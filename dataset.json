[
    {
      "instruction": "Generate C++ code to demonstrate various image smoothing techniques using OpenCV.",
      "input": "The code should load an image, display it, and apply four types of smoothing: Homogeneous Blur, Gaussian Blur, Median Blur, and Bilateral Blur. Each operation should incrementally increase the kernel size to show the effect.",
      "output": "#include <iostream>\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/highgui.hpp\"\n\nusing namespace std;\nusing namespace cv;\n\nint DELAY_CAPTION = 1500; // Delay for captions in milliseconds\nint DELAY_BLUR = 100;     // Delay for each blur effect frame in milliseconds\nint MAX_KERNEL_LENGTH = 31; // Maximum kernel size for blurring operations\n\nMat src; // Source image\nMat dst; // Destination image\nchar window_name[] = \"Smoothing Demo\"; // Window title\n\nint display_caption(const char* caption);\nint display_dst(int delay);\n\nint main(int argc, char** argv) {\n    namedWindow(window_name, WINDOW_AUTOSIZE);\n    const char* filename = argc >= 2 ? argv[1] : \"lena.jpg\";\n    src = imread(samples::findFile(filename), IMREAD_COLOR);\n    if (src.empty()) {\n        printf(\"Error opening image\\n\");\n        printf(\"Usage:\\n %s [image_name -- default lena.jpg] \\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    if (display_caption(\"Original Image\") != 0) {\n        return 0;\n    }\n\n    dst = src.clone();\n    if (display_dst(DELAY_CAPTION) != 0) {\n        return 0;\n    }\n\n    if (display_caption(\"Homogeneous Blur\") != 0) {\n        return 0;\n    }\n    for (int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2) {\n        blur(src, dst, Size(i, i), Point(-1, -1));\n        if (display_dst(DELAY_BLUR) != 0) {\n            return 0;\n        }\n    }\n\n    if (display_caption(\"Gaussian Blur\") != 0) {\n        return 0;\n    }\n    for (int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2) {\n        GaussianBlur(src, dst, Size(i, i), 0, 0);\n        if (display_dst(DELAY_BLUR) != 0) {\n            return 0;\n        }\n    }\n\n    if (display_caption(\"Median Blur\") != 0) {\n        return 0;\n    }\n    for (int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2) {\n        medianBlur(src, dst, i);\n        if (display_dst(DELAY_BLUR) != 0) {\n            return 0;\n        }\n    }\n\n    if (display_caption(\"Bilateral Blur\") != 0) {\n        return 0;\n    }\n    for (int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2) {\n        bilateralFilter(src, dst, i, i * 2, i / 2);\n        if (display_dst(DELAY_BLUR) != 0) {\n            return 0;\n        }\n    }\n\n    display_caption(\"Done!\");\n    return 0;\n}\n\nint display_caption(const char* caption) {\n    dst = Mat::zeros(src.size(), src.type());\n    putText(dst, caption,\n            Point(src.cols / 4, src.rows / 2),\n            FONT_HERSHEY_COMPLEX, 1, Scalar(255, 255, 255));\n    return display_dst(DELAY_CAPTION);\n}\n\nint display_dst(int delay) {\n    imshow(window_name, dst);\n    int c = waitKey(delay);\n    if (c >= 0) {\n        return -1;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for edge detection using Sobel and Scharr operators in OpenCV. The code should allow real-time adjustments to kernel size, scale, and delta values with error handling and proper comments.",
      "input": "Ensure the code adheres to MISRA standards. Avoid dynamic memory allocation, remove 'using namespace', handle undefined behavior, and include detailed comments for clarity.",
      "output": "#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include <iostream>\n\nint main(int argc, char** argv) {\n    // Parse command-line arguments for input image and parameters\n    cv::CommandLineParser parser(argc, argv,\n                                 \"{@input   |lena.jpg|Input image}\"\n                                 \"{ksize   k|1|Kernel size for Sobel operator (adjust with 'K')}\"\n                                 \"{scale   s|1|Scale for Sobel operator (adjust with 'S')}\"\n                                 \"{delta   d|0|Delta added to the results (adjust with 'D')}\"\n                                 \"{help    h|false|Show help message}\");\n\n    // Print program description\n    std::cout << \"Edge detection using Sobel or Scharr operators in OpenCV.\\n\\n\";\n    parser.printMessage();\n    std::cout << \"\\nKey Commands:\\nESC - Exit program\\nK - Increase kernel size\\nS - Increase scale\\nD - Increase delta\\nR - Reset parameters\\n\";\n\n    // Declare variables for image processing\n    cv::Mat image, src, src_gray, grad; // Source, grayscale, and gradient images\n    const std::string window_name = \"Sobel Demo - Edge Detector\"; // Window title\n\n    // Initialize parameters from command-line or defaults\n    int ksize = parser.get<int>(\"ksize\"); // Kernel size for Sobel operator\n    int scale = parser.get<int>(\"scale\"); // Scale factor for Sobel operator\n    int delta = parser.get<int>(\"delta\"); // Delta value added to results\n    const int ddepth = CV_16S; // Desired depth of the output image\n\n    // Load the input image\n    std::string imageName = parser.get<std::string>(\"@input\");\n    image = cv::imread(cv::samples::findFile(imageName), cv::IMREAD_COLOR);\n\n    // Check if the image was successfully loaded\n    if (image.empty()) {\n        std::cerr << \"Error: Unable to open image: \" << imageName << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    while (true) {\n        // Apply Gaussian blur to reduce noise before edge detection\n        cv::GaussianBlur(image, src, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT);\n\n        // Convert the blurred image to grayscale for processing\n        cv::cvtColor(src, src_gray, cv::COLOR_BGR2GRAY);\n\n        // Variables for gradients in X and Y directions\n        cv::Mat grad_x, grad_y;\n        cv::Mat abs_grad_x, abs_grad_y;\n\n        // Compute the gradient in the X direction\n        cv::Sobel(src_gray, grad_x, ddepth, 1, 0, ksize, scale, delta, cv::BORDER_DEFAULT);\n\n        // Compute the gradient in the Y direction\n        cv::Sobel(src_gray, grad_y, ddepth, 0, 1, ksize, scale, delta, cv::BORDER_DEFAULT);\n\n        // Convert gradients to 8-bit absolute values for visualization\n        cv::convertScaleAbs(grad_x, abs_grad_x);\n        cv::convertScaleAbs(grad_y, abs_grad_y);\n\n        // Combine the two gradients using a weighted sum\n        cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);\n\n        // Display the gradient image\n        cv::imshow(window_name, grad);\n        char key = static_cast<char>(cv::waitKey(0)); // Wait for key press\n\n        // Handle key press events\n        if (key == 27) { // ESC key to exit\n            return EXIT_SUCCESS;\n        } else if (key == 'k' || key == 'K') {\n            ksize = (ksize < 30) ? ksize + 2 : -1; // Increase kernel size\n        } else if (key == 's' || key == 'S') {\n            scale++; // Increase scale factor\n        } else if (key == 'd' || key == 'D') {\n            delta++; // Increase delta value\n        } else if (key == 'r' || key == 'R') {\n            ksize = -1; scale = 1; delta = 0; // Reset parameters\n        }\n    }\n    return EXIT_SUCCESS;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for Laplacian edge detection using a live video stream. The code should allow dynamic adjustment of smoothing types and sigma values, include error handling, and provide detailed comments.",
      "input": "Ensure compliance with MISRA standards: remove 'using namespace', avoid undefined behavior, and include detailed comments explaining each section of the code.",
      "output": "#include \"opencv2/videoio.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\n#include <ctype.h>\n#include <stdio.h>\n#include <iostream>\n\n// Display help instructions\nstatic void help(const char* program_name) {\n    std::cout << \"\\nThis program demonstrates Laplace point/edge detection using OpenCV's Laplacian function.\\n\"\n              << \"It captures from the camera of your choice: 0, 1, ... default is 0.\\n\"\n              << \"Usage: \" << program_name << \" -c=<camera #, default 0> -p=<frame index to capture>\\n\";\n}\n\n// Smoothing types enumeration\nenum SmoothType { GAUSSIAN, BLUR, MEDIAN };\n\nint sigma = 3; // Sigma value for smoothing (adjustable via trackbar)\nint smoothType = GAUSSIAN; // Default smoothing type\n\nint main(int argc, char** argv) {\n    // Parse command-line arguments\n    cv::CommandLineParser parser(argc, argv, \"{ c | 0 | Camera index }{ p | | Frame index to start from }\");\n    help(argv[0]);\n\n    // Open the video capture device\n    cv::VideoCapture cap;\n    std::string camera = parser.get<std::string>(\"c\");\n\n    // Open based on camera index or file\n    if (camera.size() == 1 && std::isdigit(camera[0])) {\n        cap.open(parser.get<int>(\"c\"));\n    } else {\n        cap.open(cv::samples::findFileOrKeep(camera));\n    }\n\n    // Error handling: Check if the camera is opened successfully\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Unable to open camera/video stream: \" << camera << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Display camera properties\n    std::cout << \"Video stream: \" << camera\n              << \", Width: \" << cap.get(cv::CAP_PROP_FRAME_WIDTH)\n              << \", Height: \" << cap.get(cv::CAP_PROP_FRAME_HEIGHT)\n              << \", Frame count: \" << cap.get(cv::CAP_PROP_FRAME_COUNT) << std::endl;\n\n    int pos = 0;\n    if (parser.has(\"p\")) {\n        pos = parser.get<int>(\"p\");\n    }\n\n    // Error handling: Validate parser and seek to specified frame position\n    if (!parser.check()) {\n        parser.printErrors();\n        return EXIT_FAILURE;\n    }\n    if (pos != 0) {\n        std::cout << \"Seeking to frame #\" << pos << std::endl;\n        if (!cap.set(cv::CAP_PROP_POS_FRAMES, pos)) {\n            std::cerr << \"Error: Seeking is not supported.\" << std::endl;\n        }\n    }\n\n    // Create a display window and trackbar for adjusting sigma\n    cv::namedWindow(\"Laplacian\", cv::WINDOW_AUTOSIZE);\n    cv::createTrackbar(\"Sigma\", \"Laplacian\", &sigma, 15, nullptr);\n\n    // Matrices for storing frames and results\n    cv::Mat frame, smoothed, laplace, result;\n\n    // Process video frames\n    while (true) {\n        cap >> frame; // Capture the next frame\n        if (frame.empty()) {\n            break; // Exit if no more frames\n        }\n\n        // Adjust kernel size based on sigma (must be odd)\n        int ksize = (sigma * 5) | 1;\n\n        // Apply the selected smoothing technique\n        if (smoothType == GAUSSIAN) {\n            cv::GaussianBlur(frame, smoothed, cv::Size(ksize, ksize), sigma, sigma);\n        } else if (smoothType == BLUR) {\n            cv::blur(frame, smoothed, cv::Size(ksize, ksize));\n        } else {\n            cv::medianBlur(frame, smoothed, ksize);\n        }\n\n        // Apply the Laplacian operator to detect edges\n        cv::Laplacian(smoothed, laplace, CV_16S, 5);\n        cv::convertScaleAbs(laplace, result, (sigma + 1) * 0.25);\n\n        // Display the processed frame\n        cv::imshow(\"Laplacian\", result);\n\n        // Handle user input for controlling the program\n        char c = static_cast<char>(cv::waitKey(30));\n        if (c == ' ') {\n            smoothType = (smoothType == GAUSSIAN) ? BLUR : (smoothType == BLUR) ? MEDIAN : GAUSSIAN; // Cycle smoothing types\n        } else if (c == 'q' || c == 'Q' || c == 27) {\n            break; // Exit on 'Q', 'q', or ESC\n        }\n    }\n\n    return EXIT_SUCCESS;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to demonstrate Canny edge detection with Sobel and Scharr gradients using OpenCV. The code should allow real-time adjustment of edge thresholds via trackbars, with detailed error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid dynamic memory allocation, avoid implicit type conversions, and ensure proper error handling. Include detailed comments explaining each section of the code.",
      "output": "#include \"opencv2/core/utility.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include <stdio.h>\n\n// Declare global variables\nint edgeThresh = 1; // Threshold for Canny edge detection using Sobel gradient\nint edgeThreshScharr = 1; // Threshold for Canny edge detection using Scharr gradient\n\ncv::Mat image, gray, blurImage, edge1, edge2, cedge; // Matrices for image processing\n\n// Window names for displaying results\nconst char* window_name1 = \"Edge map : Canny default (Sobel gradient)\";\nconst char* window_name2 = \"Edge map : Canny with custom gradient (Scharr)\";\n\n// Trackbar callback function to update edge detection\nstatic void onTrackbar(int, void*) {\n    // Apply Gaussian blur to reduce noise in the grayscale image\n    blur(gray, blurImage, cv::Size(3,3));\n\n    // Run Canny edge detection using the Sobel gradient\n    Canny(blurImage, edge1, edgeThresh, edgeThresh * 3, 3);\n    cedge = cv::Scalar::all(0); // Create a black image\n\n    // Copy the edge detection result to the cedge image\n    image.copyTo(cedge, edge1);\n    imshow(window_name1, cedge); // Display Sobel-based edge map\n\n    // Create gradient images for custom edge detection using Scharr\n    cv::Mat dx, dy;\n    Scharr(blurImage, dx, CV_16S, 1, 0); // Compute gradient in X direction\n    Scharr(blurImage, dy, CV_16S, 0, 1); // Compute gradient in Y direction\n\n    // Run Canny edge detection using the custom gradient (Scharr)\n    Canny(dx, dy, edge2, edgeThreshScharr, edgeThreshScharr * 3);\n    cedge = cv::Scalar::all(0); // Reset cedge image\n\n    // Copy the edge detection result to the cedge image\n    image.copyTo(cedge, edge2);\n    imshow(window_name2, cedge); // Display Scharr-based edge map\n}\n\n// Function to print help message\nstatic void help(const char** argv) {\n    printf(\"\\nThis sample demonstrates Canny edge detection\\n\");\n    printf(\"Call: \\n\");\n    printf(\"    %s [image_name -- Default is fruits.jpg]\\n\\n\", argv[0]);\n}\n\n// Command line arguments structure\nconst char* keys =\n{\n    \"{help h||}{@image |fruits.jpg|input image name}\"\n};\n\nint main(int argc, const char** argv) {\n    help(argv); // Display help message\n    cv::CommandLineParser parser(argc, argv, keys); // Parse command line arguments\n    std::string filename = parser.get<std::string>(0); // Get image filename\n\n    // Load the input image\n    image = cv::imread(cv::samples::findFile(filename), cv::IMREAD_COLOR);\n    if (image.empty()) { // Check if the image is loaded correctly\n        printf(\"Cannot read image file: %s\\n\", filename.c_str());\n        help(argv); // Display help if image loading fails\n        return -1;\n    }\n\n    cedge.create(image.size(), image.type()); // Initialize cedge image to match the input image\n    cvtColor(image, gray, cv::COLOR_BGR2GRAY); // Convert image to grayscale for edge detection\n\n    // Create display windows for edge maps\n    namedWindow(window_name1, 1); // Create window for Sobel-based edge detection\n    namedWindow(window_name2, 1); // Create window for Scharr-based edge detection\n\n    // Create trackbars to control Canny thresholds for both edge detection methods\n    createTrackbar(\"Canny threshold default\", window_name1, &edgeThresh, 100, onTrackbar);\n    createTrackbar(\"Canny threshold Scharr\", window_name2, &edgeThreshScharr, 400, onTrackbar);\n\n    // Call the trackbar callback to display initial edge detection results\n    onTrackbar(0, 0);\n\n    // Wait for a key stroke to terminate the program\n    waitKey(0);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting lines in an image using Hough Transform with both Standard and Probabilistic methods. The code should include edge detection and display the results with appropriate error handling and comments.",
      "input": "Ensure compliance with MISRA standards: remove 'using namespace', avoid implicit type conversions, and ensure proper error handling. Include detailed comments explaining each section of the code.",
      "output": "#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv) {\n    // Declare the output variables\n    cv::Mat dst, cdst, cdstP;\n\n    const char* default_file = \"sudoku.png\"; // Default image file\n    const char* filename = argc >= 2 ? argv[1] : default_file; // Get image filename from command line or use default\n\n    // Load the input image in grayscale\n    cv::Mat src = imread(samples::findFile(filename), IMREAD_GRAYSCALE);\n\n    // Check if image is loaded correctly\n    if (src.empty()) {\n        printf(\"Error opening image\\n\");\n        printf(\"Program Arguments: [image_name -- default %s]\\n\", default_file);\n        return -1; // Return error code if image is not loaded\n    }\n\n    // Perform edge detection using the Canny algorithm\n    Canny(src, dst, 50, 200, 3); // Apply Canny edge detection\n\n    // Convert the edge image to BGR for display\n    cvtColor(dst, cdst, COLOR_GRAY2BGR);\n    cdstP = cdst.clone(); // Clone cdst for further processing\n\n    // Standard Hough Line Transform: Detect lines in the edge-detected image\n    vector<Vec2f> lines; // Vector to store detected lines\n    HoughLines(dst, lines, 1, CV_PI / 180, 150, 0, 0); // Perform Hough Line Transform\n\n    // Draw the detected lines on the image\n    for (size_t i = 0; i < lines.size(); i++) {\n        float rho = lines[i][0], theta = lines[i][1];\n        cv::Point pt1, pt2;\n        double a = cos(theta), b = sin(theta);\n        double x0 = a * rho, y0 = b * rho;\n        pt1.x = cvRound(x0 + 1000 * (-b));\n        pt1.y = cvRound(y0 + 1000 * (a));\n        pt2.x = cvRound(x0 - 1000 * (-b));\n        pt2.y = cvRound(y0 - 1000 * (a));\n        line(cdst, pt1, pt2, Scalar(0, 0, 255), 3, LINE_AA); // Draw red lines\n    }\n\n    // Probabilistic Hough Line Transform: Detect lines with probabilistic method\n    vector<Vec4i> linesP; // Vector to store detected lines (probabilistic)\n    HoughLinesP(dst, linesP, 1, CV_PI / 180, 50, 50, 10); // Perform Probabilistic Hough Line Transform\n\n    // Draw the detected lines (probabilistic method)\n    for (size_t i = 0; i < linesP.size(); i++) {\n        Vec4i l = linesP[i];\n        line(cdstP, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(0, 0, 255), 3, LINE_AA); // Draw red lines\n    }\n\n    // Display the source and results in windows\n    imshow(\"Source\", src); // Display original image\n    imshow(\"Detected Lines (in red) - Standard Hough Line Transform\", cdst); // Display lines using standard Hough Transform\n    imshow(\"Detected Lines (in red) - Probabilistic Line Transform\", cdstP); // Display lines using probabilistic Hough Transform\n\n    // Wait for a key stroke before closing the program\n    waitKey();\n    return 0; // Exit successfully\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting circles in an image using Hough Circle Transform. The code should include grayscale conversion, median blur, and display the detected circles with proper error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid dynamic memory allocation, avoid implicit type conversions, and ensure proper error handling. Include detailed comments explaining each section of the code.",
      "output": "#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv) {\n    // Set the input image filename (use default if not provided)\n    const char* filename = argc >= 2 ? argv[1] : \"smarties.png\";\n\n    // Load the input image in color (BGR format)\n    Mat src = imread(samples::findFile(filename), IMREAD_COLOR);\n\n    // Check if the image was loaded successfully\n    if (src.empty()) {\n        printf(\"Error opening image\\n\");\n        printf(\"Program Arguments: [image_name -- default %s]\\n\", filename);\n        return EXIT_FAILURE; // Return error code if image is not loaded\n    }\n\n    // Convert the image to grayscale for easier processing\n    Mat gray;\n    cvtColor(src, gray, COLOR_BGR2GRAY);\n\n    // Apply median blur to reduce noise and improve circle detection\n    medianBlur(gray, gray, 5);\n\n    // Vector to store detected circles\n    vector<Vec3f> circles;\n\n    // Apply Hough Circle Transform to detect circles in the image\n    HoughCircles(gray, circles, HOUGH_GRADIENT, 1,\n                 gray.rows / 16,  // Minimum distance between circle centers\n                 100, 30, 1, 30   // Parameters for circle detection (min/max radius)\n    );\n\n    // Draw the detected circles on the original image\n    for (size_t i = 0; i < circles.size(); i++) {\n        Vec3i c = circles[i];\n        Point center = Point(c[0], c[1]); // Circle center\n\n        // Draw the circle center\n        circle(src, center, 1, Scalar(0, 100, 100), 3, LINE_AA);\n        // Draw the circle outline\n        int radius = c[2]; // Circle radius\n        circle(src, center, radius, Scalar(255, 0, 255), 3, LINE_AA);\n    }\n\n    // Display the result with detected circles\n    imshow(\"Detected Circles\", src);\n\n    // Wait for a key stroke before closing the program\n    waitKey();\n\n    return EXIT_SUCCESS; // Exit successfully\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform image erosion and dilation using morphological operations. The code should allow dynamic adjustments of structuring element and kernel size via trackbars, with proper error handling and detailed comments.",
      "input": "Ensure compliance with MISRA standards: avoid dynamic memory allocation, avoid implicit type conversions, and ensure proper error handling. Include detailed comments explaining each section of the code.",
      "output": "#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\n// Declare input image and result images for erosion and dilation\nMat src, erosion_dst, dilation_dst;\n\n// Declare variables for structuring element type and size\nint erosion_elem = 0; // Structuring element type for erosion\nint erosion_size = 0; // Size of structuring element for erosion\nint dilation_elem = 0; // Structuring element type for dilation\nint dilation_size = 0; // Size of structuring element for dilation\nint const max_elem = 2; // Maximum number of structuring elements\nint const max_kernel_size = 21; // Maximum size for kernel (odd numbers)\n\n// Function prototypes for erosion and dilation\nvoid Erosion(int, void*);\nvoid Dilation(int, void*);\n\nint main(int argc, char** argv) {\n    // Parse command-line arguments and load input image\n    CommandLineParser parser(argc, argv, \"{@input | LinuxLogo.jpg | input image}\");\n    src = imread(samples::findFile(parser.get<String>(\"@input\")), IMREAD_COLOR);\n\n    // Check if the image was loaded successfully\n    if (src.empty()) {\n        cout << \"Could not open or find the image!\\n\" << endl;\n        cout << \"Usage: \" << argv[0] << \" <Input image>\" << endl;\n        return -1; // Return error code if image is not loaded\n    }\n\n    // Create windows for displaying erosion and dilation results\n    namedWindow(\"Erosion Demo\", WINDOW_AUTOSIZE);\n    namedWindow(\"Dilation Demo\", WINDOW_AUTOSIZE);\n    moveWindow(\"Dilation Demo\", src.cols, 0); // Move dilation window next to the erosion window\n\n    // Create trackbars for adjusting erosion element type and size\n    createTrackbar(\"Element:\\n 0: Rect \\n 1: Cross \\n 2: Ellipse\", \"Erosion Demo\",\n                   &erosion_elem, max_elem, Erosion);\n    createTrackbar(\"Kernel size:\\n 2n +1\", \"Erosion Demo\",\n                   &erosion_size, max_kernel_size, Erosion);\n\n    // Create trackbars for adjusting dilation element type and size\n    createTrackbar(\"Element:\\n 0: Rect \\n 1: Cross \\n 2: Ellipse\", \"Dilation Demo\",\n                   &dilation_elem, max_elem, Dilation);\n    createTrackbar(\"Kernel size:\\n 2n +1\", \"Dilation Demo\",\n                   &dilation_size, max_kernel_size, Dilation);\n\n    // Initial call to update the results with default trackbar values\n    Erosion(0, 0);\n    Dilation(0, 0);\n\n    // Wait for user input before closing the program\n    waitKey(0);\n\n    return 0; // Exit successfully\n}\n\n// Erosion callback function: Apply morphological erosion to the image\nvoid Erosion(int, void*) {\n    int erosion_type = 0;\n\n    // Determine erosion type based on trackbar value\n    if (erosion_elem == 0) { erosion_type = MORPH_RECT; }\n    else if (erosion_elem == 1) { erosion_type = MORPH_CROSS; }\n    else if (erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }\n\n    // Create the structuring element for erosion\n    Mat element = getStructuringElement(erosion_type, Size(2 * erosion_size + 1, 2 * erosion_size + 1), Point(erosion_size, erosion_size));\n\n    // Apply erosion to the image\n    erode(src, erosion_dst, element);\n    imshow(\"Erosion Demo\", erosion_dst); // Display the result of erosion\n}\n\n// Dilation callback function: Apply morphological dilation to the image\nvoid Dilation(int, void*) {\n    int dilation_type = 0;\n\n    // Determine dilation type based on trackbar value\n    if (dilation_elem == 0) { dilation_type = MORPH_RECT; }\n    else if (dilation_elem == 1) { dilation_type = MORPH_CROSS; }\n    else if (dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; }\n\n    // Create the structuring element for dilation\n    Mat element = getStructuringElement(dilation_type, Size(2 * dilation_size + 1, 2 * dilation_size + 1), Point(dilation_size, dilation_size));\n\n    // Apply dilation to the image\n    dilate(src, dilation_dst, element);\n    imshow(\"Dilation Demo\", dilation_dst); // Display the result of dilation\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting faces and eyes in an image or video stream using OpenCV's CascadeClassifier. The code should handle command-line arguments, perform image or video processing, and display results with proper error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include comments to explain the functions and logic in detail.",
      "output": "#include \"opencv2/objdetect.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/videoio.hpp\"\n#include <iostream>\n\n// Function to display help information\nstatic void help(const char** argv) {\n    std::cout << \"\\nThis program demonstrates the use of cv::CascadeClassifier to detect objects (Face + Eyes).\\n\";\n    std::cout << \"Usage: \" << argv[0] << \" [--cascade=<cascade_path>] [--nested-cascade=<nested_cascade_path>] \"\n              << \"[--scale=<image scale>] [--try-flip] [filename|camera_index]\\n\";\n    std::cout << \"Example: \" << argv[0] << \" --cascade=data/haarcascades/haarcascade_frontalface_alt.xml \"\n              << \"--nested-cascade=data/haarcascades/haarcascade_eye_tree_eyeglasses.xml --scale=1.3\\n\\n\";\n}\n\n// Function to detect and draw faces and eyes\nvoid detectAndDraw(cv::Mat& img, cv::CascadeClassifier& cascade, cv::CascadeClassifier& nestedCascade, double scale, bool tryflip) {\n    std::vector<cv::Rect> faces, facesFlipped;\n    const static cv::Scalar colors[] = {\n        cv::Scalar(255, 0, 0), cv::Scalar(255, 128, 0), cv::Scalar(255, 255, 0),\n        cv::Scalar(0, 255, 0), cv::Scalar(0, 128, 255), cv::Scalar(0, 255, 255),\n        cv::Scalar(0, 0, 255), cv::Scalar(255, 0, 255)\n    };\n    cv::Mat gray, smallImg;\n\n    // Convert the image to grayscale\n    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);\n\n    // Resize the image to reduce processing time\n    double fx = 1.0 / scale;\n    cv::resize(gray, smallImg, cv::Size(), fx, fx, cv::INTER_LINEAR_EXACT);\n\n    // Equalize the histogram to enhance contrast\n    cv::equalizeHist(smallImg, smallImg);\n\n    // Detect faces in the image\n    cascade.detectMultiScale(smallImg, faces, 1.1, 2, cv::CASCADE_SCALE_IMAGE, cv::Size(30, 30));\n\n    // Optionally, flip the image and detect faces\n    if (tryflip) {\n        cv::flip(smallImg, smallImg, 1);\n        cascade.detectMultiScale(smallImg, facesFlipped, 1.1, 2, cv::CASCADE_SCALE_IMAGE, cv::Size(30, 30));\n        for (auto& r : facesFlipped) {\n            faces.push_back(cv::Rect(smallImg.cols - r.x - r.width, r.y, r.width, r.height));\n        }\n    }\n\n    // Draw the detected faces\n    for (size_t i = 0; i < faces.size(); i++) {\n        cv::Rect r = faces[i];\n        cv::Scalar color = colors[i % 8];\n        cv::Point center(cvRound((r.x + r.width * 0.5) * scale), cvRound((r.y + r.height * 0.5) * scale));\n        int radius = cvRound((r.width + r.height) * 0.25 * scale);\n        cv::circle(img, center, radius, color, 3, 8, 0);\n    }\n\n    // Display the result\n    cv::imshow(\"result\", img);\n}\n\nint main(int argc, const char** argv) {\n    cv::CommandLineParser parser(argc, argv,\n        \"{help h||}\" \"{cascade|data/haarcascades/haarcascade_frontalface_alt.xml|}\" \"{nested-cascade|data/haarcascades/haarcascade_eye_tree_eyeglasses.xml|}\" \"{scale|1|}\" \"{try-flip||}\" \"{@filename||}\");\n\n    if (parser.has(\"help\")) {\n        help(argv);\n        return 0;\n    }\n\n    std::string cascadeName = parser.get<std::string>(\"cascade\");\n    std::string nestedCascadeName = parser.get<std::string>(\"nested-cascade\");\n    double scale = parser.get<double>(\"scale\");\n    bool tryflip = parser.has(\"try-flip\");\n\n    cv::CascadeClassifier cascade, nestedCascade;\n\n    if (!cascade.load(cv::samples::findFile(cascadeName))) {\n        std::cerr << \"ERROR: Could not load cascade classifier.\" << std::endl;\n        help(argv);\n        return -1;\n    }\n\n    if (!nestedCascade.load(cv::samples::findFileOrKeep(nestedCascadeName))) {\n        std::cerr << \"WARNING: Could not load nested cascade.\" << std::endl;\n    }\n\n    cv::Mat frame;\n    cv::VideoCapture capture;\n    std::string inputName = parser.get<std::string>(\"@filename\");\n\n    if (inputName.empty() || (isdigit(inputName[0]) && inputName.size() == 1)) {\n        int cameraIndex = inputName.empty() ? 0 : inputName[0] - '0';\n        if (!capture.open(cameraIndex)) {\n            std::cerr << \"ERROR: Could not open camera.\" << std::endl;\n            return -1;\n        }\n\n        while (true) {\n            capture >> frame;\n            if (frame.empty()) {\n                break;\n            }\n\n            detectAndDraw(frame, cascade, nestedCascade, scale, tryflip);\n\n            char c = static_cast<char>(cv::waitKey(10));\n            if (c == 27 || c == 'q' || c == 'Q') {\n                break;\n            }\n        }\n    } else {\n        frame = cv::imread(cv::samples::findFile(inputName), cv::IMREAD_COLOR);\n        if (frame.empty()) {\n            std::cerr << \"ERROR: Could not read input file.\" << std::endl;\n            return -1;\n        }\n        detectAndDraw(frame, cascade, nestedCascade, scale, tryflip);\n        cv::waitKey(0);\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect people in video streams using OpenCV's HOGDescriptor. The code should allow toggling between Default and Daimler modes, and display results with real-time FPS calculations and proper error handling.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include detailed comments to explain the logic and functions.",
      "output": "#include <opencv2/objdetect.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/videoio.hpp>\n#include <iostream>\n#include <iomanip>\n\n// Detector class for people detection using HOGDescriptor\nclass Detector {\n    enum Mode { Default, Daimler } m; // Modes: Default and Daimler\n    cv::HOGDescriptor hog, hog_d; // HOG descriptors for each mode\n\npublic:\n    Detector() : m(Default), hog(), hog_d(cv::Size(48, 96), cv::Size(16, 16), cv::Size(8, 8), cv::Size(8, 8), 9) {\n        hog.setSVMDetector(cv::HOGDescriptor::getDefaultPeopleDetector());\n        hog_d.setSVMDetector(cv::HOGDescriptor::getDaimlerPeopleDetector());\n    }\n\n    void toggleMode() { m = (m == Default) ? Daimler : Default; } // Toggle between modes\n    std::string modeName() const { return (m == Default) ? \"Default\" : \"Daimler\"; } // Get mode name\n\n    std::vector<cv::Rect> detect(cv::InputArray img) {\n        std::vector<cv::Rect> found;\n        if (m == Default) {\n            hog.detectMultiScale(img, found, 0, cv::Size(8, 8), cv::Size(), 1.05, 2, false);\n        } else {\n            hog_d.detectMultiScale(img, found, 0, cv::Size(8, 8), cv::Size(), 1.05, 2, true);\n        }\n        return found;\n    }\n\n    void adjustRect(cv::Rect& r) const {\n        // Adjust rectangles to better fit detected objects\n        r.x += cvRound(r.width * 0.1);\n        r.width = cvRound(r.width * 0.8);\n        r.y += cvRound(r.height * 0.07);\n        r.height = cvRound(r.height * 0.8);\n    }\n};\n\nstatic const std::string keys = \"{ help h   |   | print help message }\"\n                                \"{ camera c | 0 | capture video from camera (device index starting from 0) }\"\n                                \"{ video v  |   | use video as input }\";\n\nint main(int argc, char** argv) {\n    cv::CommandLineParser parser(argc, argv, keys);\n    parser.about(\"This sample demonstrates the use of the HOG descriptor for people detection.\");\n\n    if (parser.has(\"help\")) {\n        parser.printMessage();\n        return 0;\n    }\n\n    int camera = parser.get<int>(\"camera\");\n    std::string file = parser.get<std::string>(\"video\");\n    if (!parser.check()) {\n        parser.printErrors();\n        return 1;\n    }\n\n    cv::VideoCapture cap;\n    if (file.empty()) {\n        cap.open(camera); // Open camera stream\n    } else {\n        file = cv::samples::findFileOrKeep(file);\n        cap.open(file); // Open video file\n    }\n\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open video stream: '\" << (file.empty() ? \"<camera>\" : file) << \"'\" << std::endl;\n        return 2;\n    }\n\n    std::cout << \"Press 'q' or <ESC> to quit.\" << std::endl;\n    std::cout << \"Press <space> to toggle between Default and Daimler detector.\" << std::endl;\n\n    Detector detector;\n    cv::Mat frame;\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            std::cout << \"Finished reading: empty frame\" << std::endl;\n            break;\n        }\n\n        int64 t = cv::getTickCount();\n        std::vector<cv::Rect> found = detector.detect(frame);\n        t = cv::getTickCount() - t;\n\n        // Display FPS and mode\n        {\n            std::ostringstream buf;\n            buf << \"Mode: \" << detector.modeName() << \" ||| FPS: \"\n                << std::fixed << std::setprecision(1) << (cv::getTickFrequency() / static_cast<double>(t));\n            cv::putText(frame, buf.str(), cv::Point(10, 30), cv::FONT_HERSHEY_PLAIN, 2.0, cv::Scalar(0, 0, 255), 2, cv::LINE_AA);\n        }\n\n        // Draw detected rectangles\n        for (auto& r : found) {\n            detector.adjustRect(r);\n            cv::rectangle(frame, r.tl(), r.br(), cv::Scalar(0, 255, 0), 2);\n        }\n\n        cv::imshow(\"People detector\", frame);\n\n        // Handle user input\n        char key = static_cast<char>(cv::waitKey(1));\n        if (key == 27 || key == 'q') {\n            std::cout << \"Exit requested\" << std::endl;\n            break;\n        } else if (key == ' ') {\n            detector.toggleMode();\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for object tracking using the CAMShift algorithm in OpenCV. The code should allow user interaction for selecting the region of interest (ROI) and dynamically control tracking parameters through key inputs, with proper error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include detailed comments to explain the logic and functions.",
      "output": "#include <opencv2/core/utility.hpp>\n#include <opencv2/video/tracking.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/videoio.hpp>\n#include <opencv2/highgui.hpp>\n#include <iostream>\n#include <ctype.h>\n\n// Global variables for image processing and tracking\ncv::Mat image;\nbool backprojMode = false; // Flag for backprojection mode\nbool selectObject = false; // Flag to check if the user is selecting an object\nint trackObject = 0; // Track object flag (-1: set up, 0: stop, 1: tracking)\nbool showHist = true; // Flag to display histogram\ncv::Point origin; // Origin point for mouse selection\ncv::Rect selection; // Selected region of interest (ROI)\nint vmin = 10, vmax = 256, smin = 30; // Thresholds for HSV filtering\n\n// Callback for mouse events to set the ROI\nstatic void onMouse(int event, int x, int y, int, void*) {\n    if (selectObject) {\n        selection.x = std::min(x, origin.x);\n        selection.y = std::min(y, origin.y);\n        selection.width = std::abs(x - origin.x);\n        selection.height = std::abs(y - origin.y);\n\n        // Constrain the selection to the image dimensions\n        selection &= cv::Rect(0, 0, image.cols, image.rows);\n    }\n\n    switch (event) {\n        case cv::EVENT_LBUTTONDOWN:\n            origin = cv::Point(x, y);\n            selection = cv::Rect(x, y, 0, 0);\n            selectObject = true;\n            break;\n        case cv::EVENT_LBUTTONUP:\n            selectObject = false;\n            if (selection.width > 0 && selection.height > 0) {\n                trackObject = -1; // Initialize tracking in the main loop\n            }\n            break;\n    }\n}\n\n// Function to display help information\nstatic void help(const char** argv) {\n    std::cout << \"\\nThis demo shows mean-shift-based tracking using CAMShift.\" << std::endl;\n    std::cout << \"You can select a color object (e.g., face) and track it.\" << std::endl;\n    std::cout << \"Usage: \" << argv[0] << \" [camera number]\\n\" << std::endl;\n    std::cout << \"Hotkeys:\\n\"\n              << \"\\tESC - Quit the program\\n\"\n              << \"\\tc - Stop tracking\\n\"\n              << \"\\tb - Toggle backprojection view\\n\"\n              << \"\\th - Show/hide histogram\\n\"\n              << \"\\tp - Pause video\\n\";\n}\n\n// Command-line argument keys\nconst char* keys = \"{help h || show help message}{@camera_number|0|camera number}\";\n\nint main(int argc, const char** argv) {\n    cv::VideoCapture cap;\n    cv::Rect trackWindow;\n    int hsize = 16;\n    float hranges[] = {0, 180};\n    const float* phranges = hranges;\n\n    cv::CommandLineParser parser(argc, argv, keys);\n    if (parser.has(\"help\")) {\n        help(argv);\n        return 0;\n    }\n\n    int camNum = parser.get<int>(0);\n    cap.open(camNum);\n    if (!cap.isOpened()) {\n        help(argv);\n        std::cerr << \"*** Could not initialize capturing ***\" << std::endl;\n        return -1;\n    }\n\n    std::cout << \"Hotkeys:\\n\"\n              << \"\\tESC - Quit the program\\n\"\n              << \"\\tc - Stop tracking\\n\"\n              << \"\\tb - Toggle backprojection view\\n\"\n              << \"\\th - Show/hide histogram\\n\"\n              << \"\\tp - Pause video\\n\";\n\n    cv::namedWindow(\"Histogram\", 0);\n    cv::namedWindow(\"CamShift Demo\", 0);\n    cv::setMouseCallback(\"CamShift Demo\", onMouse, 0);\n    cv::createTrackbar(\"Vmin\", \"CamShift Demo\", &vmin, 256, 0);\n    cv::createTrackbar(\"Vmax\", \"CamShift Demo\", &vmax, 256, 0);\n    cv::createTrackbar(\"Smin\", \"CamShift Demo\", &smin, 256, 0);\n\n    cv::Mat frame, hsv, hue, mask, hist, histimg = cv::Mat::zeros(200, 320, CV_8UC3), backproj;\n    bool paused = false;\n\n    while (true) {\n        if (!paused) {\n            cap >> frame;\n            if (frame.empty()) {\n                break;\n            }\n        }\n\n        frame.copyTo(image);\n\n        if (!paused && trackObject) {\n            cv::cvtColor(image, hsv, cv::COLOR_BGR2HSV);\n            if (trackObject < 0) {\n                cv::Mat roi(hue, selection), maskroi(mask, selection);\n                cv::calcHist(&roi, 1, 0, maskroi, hist, 1, &hsize, &phranges);\n                cv::normalize(hist, hist, 0, 255, cv::NORM_MINMAX);\n                trackWindow = selection;\n                trackObject = 1;\n            }\n            cv::calcBackProject(&hue, 1, 0, hist, backproj, &phranges);\n            backproj &= mask;\n            cv::RotatedRect trackBox = cv::CamShift(backproj, trackWindow,\n                                                     cv::TermCriteria(cv::TermCriteria::EPS | cv::TermCriteria::COUNT, 10, 1));\n\n            if (backprojMode) {\n                cv::cvtColor(backproj, image, cv::COLOR_GRAY2BGR);\n            }\n            cv::ellipse(image, trackBox, cv::Scalar(0, 0, 255), 3, cv::LINE_AA);\n        }\n\n        cv::imshow(\"CamShift Demo\", image);\n        cv::imshow(\"Histogram\", histimg);\n\n        char c = static_cast<char>(cv::waitKey(10));\n        if (c == 27) {\n            break;\n        }\n\n        switch (c) {\n            case 'b':\n                backprojMode = !backprojMode;\n                break;\n            case 'c':\n                trackObject = 0;\n                histimg = cv::Scalar::all(0);\n                break;\n            case 'h':\n                showHist = !showHist;\n                if (!showHist) {\n                    cv::destroyWindow(\"Histogram\");\n                } else {\n                    cv::namedWindow(\"Histogram\", 1);\n                }\n                break;\n            case 'p':\n                paused = !paused;\n                break;\n            default:\n                break;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for optical flow tracking using the Lucas-Kanade method in OpenCV. The code should allow users to add, remove, and track feature points in a video stream with real-time updates and proper error handling.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments to explain the logic and functions in detail.",
      "output": "#include <opencv2/video/tracking.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/videoio.hpp>\n#include <opencv2/highgui.hpp>\n#include <iostream>\n#include <ctype.h>\n\n// Function to display help information\nstatic void help() {\n    std::cout << \"\\nThis is a demo of Lukas-Kanade optical flow (lkdemo).\\n\"\n              << \"Using OpenCV version \" << CV_VERSION << std::endl;\n    std::cout << \"\\nHot keys: \\n\"\n              << \"\\tESC - Quit the program\\n\"\n              << \"\\tr - Auto-initialize tracking\\n\"\n              << \"\\tc - Delete all points\\n\"\n              << \"\\tn - Toggle 'night' mode\\n\"\n              << \"Click to add/remove feature points.\" << std::endl;\n}\n\n// Global variables\ncv::Point2f point; // Point selected by the user\nbool addRemovePt = false; // Flag to add or remove points\n\n// Mouse callback to handle user interactions\nstatic void onMouse(int event, int x, int y, int /*flags*/, void* /*param*/) {\n    if (event == cv::EVENT_LBUTTONDOWN) {\n        point = cv::Point2f(static_cast<float>(x), static_cast<float>(y));\n        addRemovePt = true;\n    }\n}\n\nint main(int argc, char** argv) {\n    cv::VideoCapture cap;\n    cv::TermCriteria termcrit(cv::TermCriteria::COUNT | cv::TermCriteria::EPS, 20, 0.03);\n    cv::Size subPixWinSize(10, 10), winSize(31, 31);\n\n    const int MAX_COUNT = 500; // Maximum number of points to track\n    bool needToInit = false; // Flag to indicate re-initialization\n    bool nightMode = false; // Flag for night mode (black background)\n\n    help();\n\n    // Parse command-line arguments\n    cv::CommandLineParser parser(argc, argv, \"{@input|0|}\");\n    std::string input = parser.get<std::string>(\"@input\");\n\n    if (input.size() == 1 && std::isdigit(input[0])) {\n        cap.open(input[0] - '0'); // Open camera by index\n    } else {\n        cap.open(input); // Open video file\n    }\n\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not initialize capturing.\" << std::endl;\n        return -1;\n    }\n\n    cv::namedWindow(\"LK Demo\", 1);\n    cv::setMouseCallback(\"LK Demo\", onMouse, nullptr);\n\n    cv::Mat gray, prevGray, image, frame;\n    std::vector<cv::Point2f> points[2];\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        frame.copyTo(image);\n        cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);\n\n        if (nightMode) {\n            image = cv::Scalar::all(0);\n        }\n\n        if (needToInit) {\n            // Automatic initialization of points\n            cv::goodFeaturesToTrack(gray, points[1], MAX_COUNT, 0.01, 10, cv::Mat(), 3, 3, 0, 0.04);\n            cv::cornerSubPix(gray, points[1], subPixWinSize, cv::Size(-1, -1), termcrit);\n            addRemovePt = false;\n        } else if (!points[0].empty()) {\n            std::vector<uchar> status;\n            std::vector<float> err;\n\n            if (prevGray.empty()) {\n                gray.copyTo(prevGray);\n            }\n\n            // Calculate optical flow using Lucas-Kanade method\n            cv::calcOpticalFlowPyrLK(prevGray, gray, points[0], points[1], status, err, winSize, 3, termcrit, 0, 0.001);\n\n            size_t i, k;\n            for (i = k = 0; i < points[1].size(); i++) {\n                if (addRemovePt) {\n                    if (cv::norm(point - points[1][i]) <= 5) {\n                        addRemovePt = false;\n                        continue;\n                    }\n                }\n\n                if (!status[i]) {\n                    continue;\n                }\n\n                points[1][k++] = points[1][i];\n                cv::circle(image, points[1][i], 3, cv::Scalar(0, 255, 0), -1, 8);\n            }\n            points[1].resize(k);\n        }\n\n        if (addRemovePt && points[1].size() < static_cast<size_t>(MAX_COUNT)) {\n            std::vector<cv::Point2f> tmp;\n            tmp.push_back(point);\n            cv::cornerSubPix(gray, tmp, winSize, cv::Size(-1, -1), termcrit);\n            points[1].push_back(tmp[0]);\n            addRemovePt = false;\n        }\n\n        needToInit = false;\n        cv::imshow(\"LK Demo\", image);\n\n        char c = static_cast<char>(cv::waitKey(10));\n        if (c == 27) {\n            break;\n        }\n\n        switch (c) {\n            case 'r':\n                needToInit = true;\n                break;\n            case 'c':\n                points[0].clear();\n                points[1].clear();\n                break;\n            case 'n':\n                nightMode = !nightMode;\n                break;\n            default:\n                break;\n        }\n\n        std::swap(points[1], points[0]);\n        cv::swap(prevGray, gray);\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing Principal Component Analysis (PCA) with adjustable retained variance using OpenCV. The code should allow users to dynamically adjust the retained variance through a trackbar, with proper error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include comments to explain all key steps in detail.",
      "output": "#include <opencv2/core.hpp>\n#include <opencv2/imgcodecs.hpp>\n#include <opencv2/highgui.hpp>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\n// Function to read image paths from a file and load them as grayscale images\nstatic void readImageList(const std::string& filename, std::vector<cv::Mat>& images) {\n    std::ifstream file(filename.c_str(), std::ifstream::in);\n    if (!file) {\n        std::cerr << \"ERROR: Could not open input file: \" << filename << std::endl;\n        throw cv::Exception(cv::Error::StsBadArg, \"Invalid input file.\");\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        cv::Mat img = cv::imread(line, cv::IMREAD_GRAYSCALE);\n        if (img.empty()) {\n            std::cerr << \"ERROR: Could not read image: \" << line << std::endl;\n            throw cv::Exception(cv::Error::StsError, \"Failed to load image.\");\n        }\n        images.push_back(img);\n    }\n}\n\n// Function to format images into a matrix for PCA\nstatic cv::Mat formatImagesForPCA(const std::vector<cv::Mat>& images) {\n    const int numImages = static_cast<int>(images.size());\n    const int imageSize = images[0].rows * images[0].cols;\n    cv::Mat data(numImages, imageSize, CV_32F);\n\n    for (int i = 0; i < numImages; ++i) {\n        cv::Mat imgRow = images[i].clone().reshape(1, 1);\n        imgRow.convertTo(data.row(i), CV_32F);\n    }\n\n    return data;\n}\n\n// Function to normalize images for display purposes\nstatic cv::Mat normalizeForDisplay(const cv::Mat& src) {\n    cv::Mat dst;\n    cv::normalize(src, dst, 0, 255, cv::NORM_MINMAX, CV_8UC1);\n    return dst;\n}\n\n// Parameters structure for PCA-related data\nstruct PCAParams {\n    cv::Mat data;\n    int channels;\n    int rows;\n    cv::PCA pca;\n    std::string windowName;\n};\n\n// Callback function for trackbar to adjust retained variance\nstatic void onTrackbar(int pos, void* userdata) {\n    if (pos < 1) {\n        pos = 1;\n    }\n    double retainedVariance = pos / 100.0;\n\n    PCAParams* params = static_cast<PCAParams*>(userdata);\n    params->pca = cv::PCA(params->data, cv::Mat(), cv::PCA::DATA_AS_ROW, retainedVariance);\n\n    cv::Mat projected = params->pca.project(params->data.row(0));\n    cv::Mat reconstructed = params->pca.backProject(projected);\n    reconstructed = reconstructed.reshape(params->channels, params->rows);\n\n    cv::Mat displayImage = normalizeForDisplay(reconstructed);\n    cv::imshow(params->windowName, displayImage);\n    std::cout << \"Retained Variance: \" << retainedVariance * 100.0 << \"%  |  Components: \"\n              << params->pca.eigenvectors.rows << std::endl;\n}\n\nint main(int argc, char** argv) {\n    cv::CommandLineParser parser(argc, argv, \"{@input||image list}{help h||show help message}\");\n    if (parser.has(\"help\")) {\n        parser.printMessage();\n        return 0;\n    }\n\n    std::string imgList = parser.get<std::string>(\"@input\");\n    if (imgList.empty()) {\n        parser.printMessage();\n        return 1;\n    }\n\n    std::vector<cv::Mat> images;\n    try {\n        readImageList(imgList, images);\n    } catch (const cv::Exception& e) {\n        std::cerr << \"Error: \" << e.msg << std::endl;\n        return 1;\n    }\n\n    if (images.size() < 2) {\n        std::cerr << \"ERROR: At least 2 images are required for this demo.\" << std::endl;\n        return 1;\n    }\n\n    cv::Mat data = formatImagesForPCA(images);\n\n    // Perform initial PCA with 95% retained variance\n    cv::PCA pca(data, cv::Mat(), cv::PCA::DATA_AS_ROW, 0.95);\n\n    cv::Mat projected = pca.project(data.row(0));\n    cv::Mat reconstructed = pca.backProject(projected);\n    reconstructed = reconstructed.reshape(images[0].channels(), images[0].rows);\n    cv::Mat displayImage = normalizeForDisplay(reconstructed);\n\n    std::string windowName = \"Reconstruction - Press 'q' to quit\";\n    cv::namedWindow(windowName, cv::WINDOW_NORMAL);\n\n    PCAParams params = {data, images[0].channels(), images[0].rows, pca, windowName};\n\n    int trackbarPos = 95;\n    cv::createTrackbar(\"Variance (%)\", windowName, &trackbarPos, 100, onTrackbar, &params);\n\n    cv::imshow(windowName, displayImage);\n    char key;\n    while ((key = static_cast<char>(cv::waitKey())) != 'q') {\n        // Wait for 'q' to quit\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for k-means clustering with visualization using OpenCV. The code should randomly generate data points, perform clustering, and visualize the clusters with proper error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include comments to explain all key steps in detail.",
      "output": "#include \"opencv2/highgui.hpp\"\n#include \"opencv2/core.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include <iostream>\n\nint main() {\n    const int MAX_CLUSTERS = 5; // Maximum number of clusters\n    cv::Scalar colorTab[MAX_CLUSTERS] = {\n        cv::Scalar(0, 0, 255),  // Red\n        cv::Scalar(0, 255, 0),  // Green\n        cv::Scalar(255, 100, 100), // Light Blue\n        cv::Scalar(255, 0, 255),  // Magenta\n        cv::Scalar(0, 255, 255)   // Yellow\n    };\n\n    cv::Mat img(500, 500, CV_8UC3); // Create an image of size 500x500\n    cv::RNG rng(12345); // Random number generator with seed for reproducibility\n\n    while (true) {\n        int clusterCount = rng.uniform(2, MAX_CLUSTERS + 1); // Random number of clusters\n        int sampleCount = rng.uniform(1, 1001); // Random number of samples\n\n        // Ensure the number of clusters does not exceed the number of samples\n        clusterCount = std::min(clusterCount, sampleCount);\n\n        cv::Mat points(sampleCount, 1, CV_32FC2); // Points matrix\n        cv::Mat labels; // Labels for each point\n        std::vector<cv::Point2f> centers; // Centers of clusters\n\n        // Generate random samples for each cluster\n        for (int k = 0; k < clusterCount; ++k) {\n            cv::Point center;\n            center.x = rng.uniform(0, img.cols);\n            center.y = rng.uniform(0, img.rows);\n\n            int startRow = k * sampleCount / clusterCount;\n            int endRow = (k == clusterCount - 1) ? sampleCount : (k + 1) * sampleCount / clusterCount;\n            cv::Mat pointChunk = points.rowRange(startRow, endRow);\n\n            // Fill the chunk with random points around the center\n            rng.fill(pointChunk, cv::RNG::NORMAL, cv::Scalar(center.x, center.y),\n                     cv::Scalar(img.cols * 0.05, img.rows * 0.05));\n        }\n\n        // Shuffle the points randomly\n        cv::randShuffle(points, 1, &rng);\n\n        // Perform k-means clustering\n        double compactness = cv::kmeans(points, clusterCount, labels,\n                                        cv::TermCriteria(cv::TermCriteria::EPS + cv::TermCriteria::COUNT, 10, 1.0),\n                                        3, cv::KMEANS_PP_CENTERS, centers);\n\n        // Clear the image\n        img = cv::Scalar::all(0);\n\n        // Draw the clustered points\n        for (int i = 0; i < sampleCount; ++i) {\n            int clusterIdx = labels.at<int>(i); // Cluster index of the point\n            cv::Point ipt = points.at<cv::Point2f>(i);\n            cv::circle(img, ipt, 2, colorTab[clusterIdx], cv::FILLED, cv::LINE_AA);\n        }\n\n        // Draw the cluster centers\n        for (size_t i = 0; i < centers.size(); ++i) {\n            cv::Point2f c = centers[i];\n            cv::circle(img, c, 40, colorTab[i], 1, cv::LINE_AA);\n        }\n\n        // Display compactness and the resulting image\n        std::cout << \"Compactness: \" << compactness << std::endl;\n        cv::imshow(\"clusters\", img);\n\n        // Wait for user input\n        char key = static_cast<char>(cv::waitKey());\n        if (key == 27 || key == 'q' || key == 'Q') { // Exit on 'ESC', 'q', or 'Q'\n            break;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to demonstrate the use of OpenCV's Kalman Filter for tracking a rotating point. The program should visualize predicted, measured, and corrected points, and dynamically update tracking with proper error handling and comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include detailed comments to explain all key steps.",
      "output": "#include \"opencv2/video/tracking.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/core.hpp\"\n#include <iostream>\n#include <cmath>\n\n// Function to calculate a point's position on a circle based on the angle\nstatic inline cv::Point calcPoint(cv::Point2f center, double radius, double angle) {\n    return center + cv::Point2f(static_cast<float>(std::cos(angle)),\n                                static_cast<float>(-std::sin(angle))) * static_cast<float>(radius);\n}\n\nint main() {\n    // Create an image to visualize the tracking\n    cv::Mat img(500, 500, CV_8UC3);\n\n    // Initialize Kalman Filter with 2 state variables and 1 measurement variable\n    cv::KalmanFilter KF(2, 1, 0);\n    cv::Mat state(2, 1, CV_32F); // State vector: (angle, angular velocity)\n    cv::Mat processNoise(2, 1, CV_32F); // Process noise\n    cv::Mat measurement = cv::Mat::zeros(1, 1, CV_32F); // Measurement vector\n\n    char key;\n\n    while (true) {\n        // Reset the visualization image\n        img = cv::Scalar::all(0);\n\n        // Initialize the state vector: (angle, angular velocity)\n        state.at<float>(0) = 0.0f;\n        state.at<float>(1) = 2.0f * static_cast<float>(CV_PI) / 6.0f;\n\n        // Define the transition matrix for constant angular velocity\n        KF.transitionMatrix = (cv::Mat_<float>(2, 2) << 1, 1, 0, 1);\n\n        // Set measurement and process noise matrices\n        cv::setIdentity(KF.measurementMatrix);\n        cv::setIdentity(KF.processNoiseCov, cv::Scalar::all(1e-5));\n        cv::setIdentity(KF.measurementNoiseCov, cv::Scalar::all(1e-1));\n        cv::setIdentity(KF.errorCovPost, cv::Scalar::all(1));\n\n        // Initialize the post-state with small noise\n        cv::randn(KF.statePost, cv::Scalar::all(0), cv::Scalar::all(0.1));\n\n        while (true) {\n            // Define the center and radius of the circular motion\n            cv::Point2f center(static_cast<float>(img.cols) * 0.5f, static_cast<float>(img.rows) * 0.5f);\n            float radius = static_cast<float>(img.cols) / 3.0f;\n\n            // Calculate the true position based on the current state\n            double trueAngle = state.at<float>(0);\n            cv::Point truePoint = calcPoint(center, radius, trueAngle);\n\n            // Predict the next state\n            cv::Mat prediction = KF.predict();\n            double predictedAngle = prediction.at<float>(0);\n            cv::Point predictedPoint = calcPoint(center, radius, predictedAngle);\n\n            // Generate a noisy measurement\n            cv::randn(measurement, cv::Scalar::all(0), cv::Scalar::all(KF.measurementNoiseCov.at<float>(0)));\n            measurement += KF.measurementMatrix * state;\n            double measuredAngle = measurement.at<float>(0);\n            cv::Point measuredPoint = calcPoint(center, radius, measuredAngle);\n\n            // Correct the state using the measurement\n            KF.correct(measurement);\n            double correctedAngle = KF.statePost.at<float>(0);\n            cv::Point correctedPoint = calcPoint(center, radius, correctedAngle);\n\n            // Draw points and connecting lines\n            img *= 0.2; // Fade the previous frame\n            cv::drawMarker(img, measuredPoint, cv::Scalar(0, 0, 255), cv::MARKER_SQUARE, 5, 2);\n            cv::drawMarker(img, predictedPoint, cv::Scalar(0, 255, 255), cv::MARKER_SQUARE, 5, 2);\n            cv::drawMarker(img, correctedPoint, cv::Scalar(0, 255, 0), cv::MARKER_SQUARE, 5, 2);\n            cv::drawMarker(img, truePoint, cv::Scalar(255, 255, 255), cv::MARKER_STAR, 10, 1);\n\n            cv::line(img, truePoint, measuredPoint, cv::Scalar(0, 0, 255), 1, cv::LINE_AA);\n            cv::line(img, truePoint, predictedPoint, cv::Scalar(0, 255, 255), 1, cv::LINE_AA);\n            cv::line(img, truePoint, correctedPoint, cv::Scalar(0, 255, 0), 1, cv::LINE_AA);\n\n            // Update the state using the transition matrix and process noise\n            cv::randn(processNoise, cv::Scalar(0),\n                     cv::Scalar::all(std::sqrt(KF.processNoiseCov.at<float>(0, 0))));\n            state = KF.transitionMatrix * state + processNoise;\n\n            // Display the results\n            cv::imshow(\"Kalman Filter Tracking\", img);\n            key = static_cast<char>(cv::waitKey(1000));\n            if (key > 0) {\n                break;\n            }\n        }\n\n        // Exit the program if the user presses ESC or 'q'\n        if (key == 27 || key == 'q' || key == 'Q') {\n            break;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to process video files in OpenCV. The program should read an input video, extract a specified color channel, and write the processed video to an output file. Include error handling and detailed comments explaining each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments to describe functionality.",
      "output": "#include <iostream> // For standard I/O\n#include <string>   // For string operations\n#include <opencv2/core.hpp>     // OpenCV core functionality\n#include <opencv2/videoio.hpp>  // For video input/output\n\n// Function to display help information\nstatic void displayHelp() {\n    std::cout << \"------------------------------------------------------------------------------\" << std::endl\n              << \"This program demonstrates how to write video files in OpenCV.\" << std::endl\n              << \"It allows the user to extract the R, G, or B channel from a video.\" << std::endl\n              << \"Usage: ./video-write <input_video_name> [R | G | B] [Y | N]\" << std::endl\n              << \"Where: \\n - R, G, B specifies the channel to extract.\" << std::endl\n              << \"       \\n - Y or N specifies whether to ask for output codec type.\" << std::endl\n              << \"------------------------------------------------------------------------------\" << std::endl;\n}\n\nint main(int argc, char* argv[]) {\n    displayHelp();\n\n    // Validate the number of input arguments\n    if (argc != 4) {\n        std::cerr << \"ERROR: Insufficient parameters provided.\" << std::endl;\n        return -1;\n    }\n\n    const std::string source = argv[1]; // Input video file path\n    const bool askOutputType = (argv[3][0] == 'Y'); // Flag to ask for output type\n\n    // Open the input video file\n    cv::VideoCapture inputVideo(source);\n    if (!inputVideo.isOpened()) {\n        std::cerr << \"ERROR: Could not open input video file: \" << source << std::endl;\n        return -1;\n    }\n\n    // Determine output video file name\n    std::string::size_type pAt = source.find_last_of('.'); // Find file extension position\n    const std::string outputFileName = source.substr(0, pAt) + argv[2][0] + \".avi\";\n\n    // Get the codec type from the input video\n    int codecType = static_cast<int>(inputVideo.get(cv::CAP_PROP_FOURCC));\n    char codecName[] = {\n        static_cast<char>(codecType & 0XFF),\n        static_cast<char>((codecType & 0XFF00) >> 8),\n        static_cast<char>((codecType & 0XFF0000) >> 16),\n        static_cast<char>((codecType & 0XFF000000) >> 24),\n        0\n    };\n\n    // Get frame size and frame rate\n    cv::Size frameSize(static_cast<int>(inputVideo.get(cv::CAP_PROP_FRAME_WIDTH)),\n                       static_cast<int>(inputVideo.get(cv::CAP_PROP_FRAME_HEIGHT)));\n    double frameRate = inputVideo.get(cv::CAP_PROP_FPS);\n\n    // Create VideoWriter object\n    cv::VideoWriter outputVideo;\n    if (askOutputType) {\n        outputVideo.open(outputFileName, codecType = -1, frameRate, frameSize, true);\n    } else {\n        outputVideo.open(outputFileName, codecType, frameRate, frameSize, true);\n    }\n\n    if (!outputVideo.isOpened()) {\n        std::cerr << \"ERROR: Could not open output video file: \" << outputFileName << std::endl;\n        return -1;\n    }\n\n    std::cout << \"Input video properties:\\n\"\n              << \"Resolution: \" << frameSize.width << \"x\" << frameSize.height << std::endl\n              << \"Frame Count: \" << inputVideo.get(cv::CAP_PROP_FRAME_COUNT) << std::endl\n              << \"Codec: \" << codecName << std::endl;\n\n    // Determine the color channel to process\n    int channelIndex = 2; // Default to red channel\n    switch (argv[2][0]) {\n        case 'R': channelIndex = 2; break;\n        case 'G': channelIndex = 1; break;\n        case 'B': channelIndex = 0; break;\n        default:\n            std::cerr << \"ERROR: Invalid channel specified. Use R, G, or B.\" << std::endl;\n            return -1;\n    }\n\n    cv::Mat frame, processedFrame;\n    std::vector<cv::Mat> channels;\n\n    while (true) {\n        // Read the next frame from the input video\n        inputVideo >> frame;\n        if (frame.empty()) {\n            break; // End of video\n        }\n\n        // Split the frame into color channels\n        cv::split(frame, channels);\n\n        // Zero out channels that are not selected\n        for (int i = 0; i < 3; ++i) {\n            if (i != channelIndex) {\n                channels[i] = cv::Mat::zeros(frameSize, channels[0].type());\n            }\n        }\n\n        // Merge the selected channel back into a single frame\n        cv::merge(channels, processedFrame);\n\n        // Write the processed frame to the output video\n        outputVideo.write(processedFrame);\n    }\n\n    std::cout << \"Video processing complete. Output saved to: \" << outputFileName << std::endl;\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for capturing video from the camera, processing frames, and writing them to a video file using OpenCV. The program should check for errors in opening the camera, capturing frames, and writing the video file.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments explaining each key step.",
      "output": "#include <opencv2/core.hpp> // OpenCV core functionalities\n#include <opencv2/videoio.hpp> // Video capturing functionalities\n#include <opencv2/highgui.hpp> // GUI functionalities for showing video\n#include <iostream> // Standard I/O functionalities\n#include <stdio.h> // Standard I/O functionalities\n\n// Main function\nint main(int argc, char** argv) {\n    cv::Mat src; // Matrix to hold the captured frame\n\n    // Open default camera (0) for video capture\n    cv::VideoCapture cap(0);\n\n    // Check if the camera opened successfully\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR! Unable to open camera\" << std::endl;\n        return -1; // Return error code if camera is not opened\n    }\n\n    // Capture one frame to determine the frame size and type\n    cap >> src;\n\n    // Check if frame capture is successful\n    if (src.empty()) {\n        std::cerr << \"ERROR! Blank frame grabbed\" << std::endl;\n        return -1; // Return error code if frame is empty\n    }\n\n    // Check if the captured frame is a color image\n    bool isColor = (src.type() == CV_8UC3);\n\n    // Initialize the VideoWriter object to write the captured frames into a video file\n    cv::VideoWriter writer;\n    int codec = cv::VideoWriter::fourcc('M', 'J', 'P', 'G'); // Select MJPEG codec\n    double fps = 25.0; // Set frame rate for the video\n    std::string filename = \"./live.avi\"; // Set output video file name\n\n    // Open the video writer with specified parameters\n    writer.open(filename, codec, fps, src.size(), isColor);\n\n    // Check if the video writer was opened successfully\n    if (!writer.isOpened()) {\n        std::cerr << \"ERROR! Could not open the output video file for write\" << std::endl;\n        return -1; // Return error code if video file cannot be opened\n    }\n\n    // Begin the frame capture and writing loop\n    std::cout << \"Writing videofile: \" << filename << std::endl;\n    std::cout << \"Press any key to terminate\" << std::endl;\n\n    while (true) {\n        // Capture the next frame from the camera\n        if (!cap.read(src)) {\n            std::cerr << \"ERROR! Blank frame grabbed\" << std::endl;\n            break; // Break the loop if frame capture fails\n        }\n\n        // Write the captured frame to the video file\n        writer.write(src);\n\n        // Display the live frame in a window\n        cv::imshow(\"Live\", src);\n\n        // Wait for a key press for 5ms; break if a key is pressed\n        if (cv::waitKey(5) >= 0) {\n            break;\n        }\n    }\n\n    // The VideoWriter destructor will automatically release and close the video file\n    return 0; // Exit the program successfully\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform template matching with an optional mask using OpenCV. The program should display the result of the template matching process and allow users to select the matching method through a trackbar.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments explaining each key step.",
      "output": "#include \"opencv2/imgcodecs.hpp\" // For reading and writing images\n#include \"opencv2/highgui.hpp\" // For GUI functionalities\n#include \"opencv2/imgproc.hpp\" // For image processing\n#include <iostream> // For standard I/O\n\n// Global variables\nbool use_mask; // Flag to indicate if a mask is used\ncv::Mat img; // The source image\ncv::Mat templ; // The template image\ncv::Mat mask; // The mask (if used)\ncv::Mat result; // The result of template matching\nconst char* image_window = \"Source Image\"; // Window name for the source image\nconst char* result_window = \"Result window\"; // Window name for the result image\n\n// Match method variables\nint match_method; // The chosen matching method\nint max_Trackbar = 5; // Maximum number of trackbars (for matching methods)\n\n// Function to perform matching based on the selected method\nvoid MatchingMethod(int, void*);\n\n// Command-line argument keys\nconst char* keys =\n\"{ help h| | Print help message. }\"\n\"{ @input1 | Template_Matching_Original_Image.jpg | image_name }\"\n\"{ @input2 | Template_Matching_Template_Image.jpg | template_name }\"\n\"{ @input3 | | mask_name }\";\n\nint main(int argc, char** argv) {\n    // Parse command line arguments\n    cv::CommandLineParser parser(argc, argv, keys);\n\n    // Load the source image and template image\n    img = cv::imread(cv::samples::findFile(parser.get<std::string>(\"@input1\")));\n    templ = cv::imread(cv::samples::findFile(parser.get<std::string>(\"@input2\")), cv::IMREAD_COLOR);\n\n    // Load mask if provided\n    if (argc > 3) {\n        use_mask = true;\n        mask = cv::imread(cv::samples::findFile(parser.get<std::string>(\"@input3\")), cv::IMREAD_COLOR);\n    }\n\n    // Check if images are loaded successfully\n    if (img.empty() || templ.empty() || (use_mask && mask.empty())) {\n        std::cout << \"ERROR: Can't read one of the images\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Create windows for displaying images\n    cv::namedWindow(image_window, cv::WINDOW_AUTOSIZE);\n    cv::namedWindow(result_window, cv::WINDOW_AUTOSIZE);\n\n    // Create a trackbar for selecting the matching method\n    const char* trackbar_label = \"Method: \\n 0: SQDIFF \\n 1: SQDIFF NORMED \\n 2: TM CCORR \\n 3: TM CCORR NORMED \\n 4: TM COEFF \\n 5: TM COEFF NORMED\";\n    cv::createTrackbar(trackbar_label, image_window, &match_method, max_Trackbar, MatchingMethod);\n\n    // Perform matching with the initial method\n    MatchingMethod(0, 0);\n\n    // Wait for a key press before exiting\n    cv::waitKey(0);\n    return EXIT_SUCCESS;\n}\n\n// Function to perform template matching and display results\nvoid MatchingMethod(int, void*) {\n    cv::Mat img_display;\n    img.copyTo(img_display); // Copy the source image for display\n\n    // Calculate the result image size\n    int result_cols = img.cols - templ.cols + 1;\n    int result_rows = img.rows - templ.rows + 1;\n\n    // Create a matrix for the result\n    result.create(result_rows, result_cols, CV_32FC1);\n\n    // Determine if the matching method accepts a mask\n    bool method_accepts_mask = (TM_SQDIFF == match_method || match_method == TM_CCORR_NORMED);\n    if (use_mask && method_accepts_mask) {\n        // Perform template matching with mask\n        cv::matchTemplate(img, templ, result, match_method, mask);\n    } else {\n        // Perform template matching without mask\n        cv::matchTemplate(img, templ, result, match_method);\n    }\n\n    // Normalize the result for visualization\n    cv::normalize(result, result, 0, 1, cv::NORM_MINMAX, -1, cv::Mat());\n\n    double minVal, maxVal;\n    cv::Point minLoc, maxLoc;\n    cv::Point matchLoc;\n\n    // Find the minimum and maximum values in the result matrix\n    cv::minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, cv::Mat());\n\n    // Determine the matching location based on the method\n    if (match_method == TM_SQDIFF || match_method == TM_SQDIFF_NORMED) {\n        matchLoc = minLoc;\n    } else {\n        matchLoc = maxLoc;\n    }\n\n    // Draw rectangles around the match\n    cv::rectangle(img_display, matchLoc, cv::Point(matchLoc.x + templ.cols, matchLoc.y + templ.rows), cv::Scalar::all(0), 2, 8, 0);\n    cv::rectangle(result, matchLoc, cv::Point(matchLoc.x + templ.cols, matchLoc.y + templ.rows), cv::Scalar::all(0), 2, 8, 0);\n\n    // Show the result and the source image\n    cv::imshow(image_window, img_display);\n    cv::imshow(result_window, result);\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for image classification using OpenCV's DNN module. The code should load a model, preprocess input images, perform inference, and display the predicted class along with inference time. Include error handling and detailed comments explaining each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments to describe functionality.",
      "output": "#include <fstream> // For reading text files\n#include <sstream> // For stringstream functionality\n#include <iostream> // For standard input/output\n\n#include <opencv2/dnn.hpp> // For Deep Neural Network (DNN) module\n#include <opencv2/imgproc.hpp> // For image processing\n#include <opencv2/highgui.hpp> // For GUI functionalities\n\n// Command line arguments keys\nstd::string keys =\n    \"{ help  h          | | Print help message. }\"\n    \"{ @alias           | | An alias name of model to extract preprocessing parameters from models.yml file. }\"\n    \"{ zoo              | models.yml | An optional path to file with preprocessing parameters }\"\n    \"{ input i          | | Path to input image or video file. Skip this argument to capture frames from a camera. }\"\n    \"{ initial_width    | 0 | Preprocess input image by initial resizing to a specific width. }\"\n    \"{ initial_height   | 0 | Preprocess input image by initial resizing to a specific height. }\"\n    \"{ std              | 0.0 0.0 0.0 | Preprocess input image by dividing on a standard deviation. }\"\n    \"{ crop             | false | Preprocess input image by center cropping. }\"\n    \"{ framework f      | | Optional name of an origin framework of the model. Detect it automatically if it does not set. }\"\n    \"{ needSoftmax      | false | Use Softmax to post-process the output of the net. }\"\n    \"{ classes          | | Optional path to a text file with names of classes. }\"\n    \"{ backend          | 0 | Choose one of computation backends: \\n 0: automatically (by default), \\n 1: Halide language (http://halide-lang.org/), \\n 2: Intel's Deep Learning Inference Engine (https://software.intel.com/openvino-toolkit), \\n 3: OpenCV implementation, \\n 4: VKCOM, \\n 5: CUDA, \\n 6: WebNN }\"\n    \"{ target           | 0 | Choose one of target computation devices: \\n 0: CPU target (by default), \\n 1: OpenCL, \\n 2: OpenCL fp16 (half-float precision), \\n 3: VPU, \\n 4: Vulkan, \\n 6: CUDA, \\n 7: CUDA fp16 (half-float preprocess) }\";\n\n// OpenCV namespaces\nusing namespace cv;\nusing namespace dnn;\n\n// Global vector to store class names\nstd::vector<std::string> classes;\n\n// Main function\nint main(int argc, char** argv) {\n    // Parse command line arguments\n    CommandLineParser parser(argc, argv, keys);\n\n    // Extract model and zoo file paths\n    const std::string modelName = parser.get<String>('@alias');\n    const std::string zooFile = parser.get<String>('zoo');\n\n    // Generate preprocessing arguments\n    keys += genPreprocArguments(modelName, zooFile);\n\n    // Reinitialize parser with updated keys\n    parser = CommandLineParser(argc, argv, keys);\n    parser.about(\"Use this script to run classification deep learning networks using OpenCV.\");\n\n    // Check if help flag is set or no arguments are passed\n    if (argc == 1 || parser.has('help')) {\n        parser.printMessage();\n        return 0;\n    }\n\n    // Read preprocessing arguments\n    int rszWidth = parser.get<int>('initial_width');\n    int rszHeight = parser.get<int>('initial_height');\n    float scale = parser.get<float>('scale');\n    Scalar mean = parser.get<Scalar>('mean');\n    Scalar std = parser.get<Scalar>('std');\n    bool swapRB = parser.get<bool>('rgb');\n    bool crop = parser.get<bool>('crop');\n    int inpWidth = parser.get<int>('width');\n    int inpHeight = parser.get<int>('height');\n    String model = findFile(parser.get<String>('model'));\n    String config = findFile(parser.get<String>('config'));\n    String framework = parser.get<String>('framework');\n    int backendId = parser.get<int>('backend');\n    int targetId = parser.get<int>('target');\n    bool needSoftmax = parser.get<bool>('needSoftmax');\n\n    // Display preprocessing parameters\n    std::cout << \"mean: \" << mean << std::endl;\n    std::cout << \"std: \" << std << std::endl;\n\n    // Load class names if provided\n    if (parser.has('classes')) {\n        std::string file = parser.get<String>('classes');\n        std::ifstream ifs(file.c_str());\n        if (!ifs.is_open())\n            CV_Error(Error::StsError, \"File \" + file + \" not found\");\n        std::string line;\n        while (std::getline(ifs, line)) {\n            classes.push_back(line);\n        }\n    }\n\n    // Validate arguments\n    if (!parser.check()) {\n        parser.printErrors();\n        return 1;\n    }\n    CV_Assert(!model.empty());\n\n    // Load the pre-trained model\n    Net net = readNet(model, config, framework);\n    net.setPreferableBackend(backendId);\n    net.setPreferableTarget(targetId);\n\n    // Create a window for displaying results\n    static const std::string kWinName = \"Deep learning image classification in OpenCV\";\n    namedWindow(kWinName, WINDOW_NORMAL);\n\n    // Open video capture device (camera or file)\n    VideoCapture cap;\n    if (parser.has('input'))\n        cap.open(parser.get<String>('input'));\n    else\n        cap.open(0);\n\n    // Process frames\n    Mat frame, blob;\n    while (waitKey(1) < 0) {\n        cap >> frame;\n        if (frame.empty()) {\n            waitKey();\n            break;\n        }\n\n        // Resize input image if needed\n        if (rszWidth != 0 && rszHeight != 0) {\n            resize(frame, frame, Size(rszWidth, rszHeight));\n        }\n\n        // Preprocess image: normalize and convert to blob\n        blobFromImage(frame, blob, scale, Size(inpWidth, inpHeight), mean, swapRB, crop);\n\n        // Apply standard deviation if provided\n        if (std.val[0] != 0.0 && std.val[1] != 0.0 && std.val[2] != 0.0) {\n            divide(blob, std, blob); // Normalize by dividing by std values\n        }\n\n        // Set the blob as input to the network\n        net.setInput(blob);\n\n        // Perform inference\n        Mat prob = net.forward();\n\n        // Record time taken for inference\n        cv::TickMeter timeRecorder;\n        timeRecorder.reset();\n        timeRecorder.start();\n        prob = net.forward();\n        timeRecorder.stop();\n        double t1 = timeRecorder.getTimeMilli();\n\n        // Compute the class with the highest probability\n        Point classIdPoint;\n        minMaxLoc(prob.reshape(1, 1), 0, nullptr, nullptr, &classIdPoint);\n        int classId = classIdPoint.x;\n        double confidence = prob.at<float>(classIdPoint.y);\n\n        // If Softmax is needed, apply it\n        if (needSoftmax) {\n            Mat softmaxProb;\n            cv::exp(prob - *std::max_element(prob.begin<float>(), prob.end<float>()), softmaxProb);\n            float sum = (float)cv::sum(softmaxProb)[0];\n            softmaxProb /= sum;\n            minMaxLoc(softmaxProb.reshape(1, 1), 0, &confidence, nullptr, &classIdPoint);\n            classId = classIdPoint.x;\n        }\n\n        // Display efficiency and prediction results\n        std::string label = format(\"Inference time: %.2f ms\", t1);\n        std::string label2 = format(\"Class: %s, Confidence: %.4f\", (classes.empty() ? format(\"Class #%d\", classId).c_str() : classes[classId].c_str()), confidence);\n        putText(frame, label, Point(0, 15), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 255, 0));\n        putText(frame, label2, Point(0, 35), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 255, 0));\n\n        // Display the image with classification result\n        imshow(kWinName, frame);\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an object detection application using OpenCV's DNN module with multi-threading. The code should load a model, preprocess input frames, perform inference, apply non-maximum suppression, and display the results. The code should ensure thread safety, handle input/output efficiently, and include detailed comments explaining each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments to describe functionality. Follow proper threading practices and ensure no undefined behavior occurs.",
      "output": "#include <fstream> // For reading file streams\n#include <sstream> // For string stream operations\n#include <iostream> // For standard input/output\n\n#include <opencv2/dnn.hpp> // For Deep Neural Network (DNN) module\n#include <opencv2/imgproc.hpp> // For image processing operations\n#include <opencv2/highgui.hpp> // For GUI functionalities\n\n#if defined(HAVE_THREADS) // Check if threading is supported\n#define USE_THREADS 1 // Enable threading support\n#endif\n\n#ifdef USE_THREADS // Include threading libraries\n#include <mutex> // For mutex lock\n#include <thread> // For threading\n#include <queue> // For queue operations\n#endif\n\n#include \"common.hpp\" // Include common utility functions\n\nstd::string keys =\n    \"{ help  h     | | Print help message. }\"\n    \"{ @alias      | | An alias name of model to extract preprocessing parameters from models.yml file. }\"\n    \"{ zoo         | models.yml | An optional path to file with preprocessing parameters }\"\n    \"{ device      |  0 | camera device number. }\"\n    \"{ input i     | | Path to input image or video file. Skip this argument to capture frames from a camera. }\"\n    \"{ framework f | | Optional name of an origin framework of the model. Detect it automatically if it does not set. }\"\n    \"{ classes     | | Optional path to a text file with names of classes to label detected objects. }\"\n    \"{ thr         | .5 | Confidence threshold. }\"\n    \"{ nms         | .4 | Non-maximum suppression threshold. }\"\n    \"{ backend     |  0 | Choose one of computation backends: \\n 0: automatically (by default), \\n 1: Halide language (http://halide-lang.org/), \\n 2: Intel's Deep Learning Inference Engine (https://software.intel.com/openvino-toolkit), \\n 3: OpenCV implementation, \\n 4: VKCOM, \\n 5: CUDA }\"\n    \"{ target      | 0 | Choose one of target computation devices: \\n 0: CPU target (by default), \\n 1: OpenCL, \\n 2: OpenCL fp16 (half-float precision), \\n 3: VPU, \\n 4: Vulkan, \\n 6: CUDA, \\n 7: CUDA fp16 (half-float preprocess) }\"\n    \"{ async       | 0 | Number of asynchronous forwards at the same time. \\n Choose 0 for synchronous mode }\";\n\n// OpenCV namespaces\nusing namespace cv;\nusing namespace dnn;\n\n// Global variables for confidence threshold and non-maximum suppression\nfloat confThreshold, nmsThreshold;\nstd::vector<std::string> classes;\n\n// Preprocessing function to prepare image for input into the model\ninline void preprocess(const Mat& frame, Net& net, Size inpSize, float scale,\n                       const Scalar& mean, bool swapRB) {\n    static Mat blob;\n    // Resize and normalize input image\n    if (inpSize.width <= 0) inpSize.width = frame.cols;\n    if (inpSize.height <= 0) inpSize.height = frame.rows;\n    blobFromImage(frame, blob, scale, inpSize, Scalar(), swapRB, false, CV_8U);\n    net.setInput(blob, \"\", scale, mean);\n}\n\n// Post-processing function to handle the network output and filter results\nvoid postprocess(Mat& frame, const std::vector<Mat>& outs, Net& net, int backend) {\n    // Process the detection results (class IDs, confidence scores, and bounding boxes)\n    static std::vector<int> outLayers = net.getUnconnectedOutLayers();\n    static std::string outLayerType = net.getLayer(outLayers[0])->type;\n\n    std::vector<int> classIds;\n    std::vector<float> confidences;\n    std::vector<Rect> boxes;\n\n    if (outLayerType == \"DetectionOutput\") {\n        for (size_t k = 0; k < outs.size(); k++) {\n            float* data = (float*)outs[k].data;\n            for (size_t i = 0; i < outs[k].total(); i += 7) {\n                // Extract and filter detections based on confidence threshold\n                float confidence = data[i + 2];\n                if (confidence > confThreshold) {\n                    int left   = (int)data[i + 3];\n                    int top    = (int)data[i + 4];\n                    int right  = (int)data[i + 5];\n                    int bottom = (int)data[i + 6];\n                    classIds.push_back((int)(data[i + 1]) - 1);\n                    boxes.push_back(Rect(left, top, right - left + 1, bottom - top + 1));\n                    confidences.push_back(confidence);\n                }\n            }\n        }\n    }\n\n    // Apply non-maximum suppression to remove redundant boxes\n    std::vector<int> nmsIndices;\n    NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, nmsIndices);\n\n    for (size_t i = 0; i < nmsIndices.size(); i++) {\n        Rect box = boxes[nmsIndices[i]];\n        drawPred(classIds[nmsIndices[i]], confidences[nmsIndices[i]], box.x, box.y,\n                 box.x + box.width, box.y + box.height, frame);\n    }\n}\n\n// Function to draw the predicted bounding box and class label\nvoid drawPred(int classId, float conf, int left, int top, int right, int bottom, Mat& frame) {\n    // Draw bounding box and label on the image\n    rectangle(frame, Point(left, top), Point(right, bottom), Scalar(0, 255, 0));\n    std::string label = format(\"%.2f\", conf);\n    if (!classes.empty()) {\n        CV_Assert(classId < (int)classes.size());\n        label = classes[classId] + \": \" + label;\n    }\n    int baseLine;\n    Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);\n    top = max(top, labelSize.height);\n    rectangle(frame, Point(left, top - labelSize.height),\n              Point(left + labelSize.width, top + baseLine), Scalar::all(255), FILLED);\n    putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.5, Scalar());\n}\n\n// Callback function for adjusting confidence threshold\nvoid callback(int pos, void*) {\n    confThreshold = pos * 0.01f;\n}\n\n// Main function\nint main(int argc, char** argv) {\n    // Parse command line arguments and load model\n    CommandLineParser parser(argc, argv, keys);\n    const std::string modelName = parser.get<String>('@alias');\n    const std::string zooFile = parser.get<String>('zoo');\n    keys += genPreprocArguments(modelName, zooFile);\n    parser = CommandLineParser(argc, argv, keys);\n\n    // Load model and set parameters\n    confThreshold = parser.get<float>('thr');\n    nmsThreshold = parser.get<float>('nms');\n    float scale = parser.get<float>('scale');\n    Scalar mean = parser.get<Scalar>('mean');\n    bool swapRB = parser.get<bool>('rgb');\n    int inpWidth = parser.get<int>('width');\n    int inpHeight = parser.get<int>('height');\n    std::string modelPath = findFile(parser.get<String>('model'));\n    std::string configPath = findFile(parser.get<String>('config'));\n    Net net = readNet(modelPath, configPath, parser.get<String>('framework'));\n\n    // Set backend and target for the network\n    int backend = parser.get<int>('backend');\n    net.setPreferableBackend(backend);\n    net.setPreferableTarget(parser.get<int>('target'));\n    std::vector<String> outNames = net.getUnconnectedOutLayersNames();\n\n    // Open video capture and process frames\n    VideoCapture cap;\n    if (parser.has('input')) cap.open(parser.get<String>('input'));\n    else cap.open(parser.get<int>('device'));\n\n    // Create window for displaying results\n    static const std::string kWinName = 'Deep learning object detection in OpenCV';\n    namedWindow(kWinName, WINDOW_NORMAL);\n    int initialConf = (int)(confThreshold * 100);\n    createTrackbar('Confidence threshold, %', kWinName, &initialConf, 99, callback);\n\n    // Processing loop\n    Mat frame;\n    while (waitKey(1) < 0) {\n        cap >> frame;\n        if (frame.empty()) break;\n        preprocess(frame, net, Size(inpWidth, inpHeight), scale, mean, swapRB);\n        std::vector<Mat> outs;\n        net.forward(outs, outNames);\n        postprocess(frame, outs, net, backend);\n        imshow(kWinName, frame);\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing YOLO-based object detection using OpenCV. The code should load a pre-trained YOLO model, preprocess input images, perform inference, and draw bounding boxes with class labels and confidence scores. Include detailed comments and error handling.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include comments to explain each step in detail.",
      "output": "#include <opencv2/dnn.hpp> // OpenCV DNN module for deep learning\n#include <opencv2/imgproc.hpp> // Image processing functions\n#include <opencv2/highgui.hpp> // High-level GUI for displaying images\n#include <iostream> // For standard input/output operations\n#include <fstream> // For reading class names from file\n#include <vector> // For storing multiple objects and classes\n\n// Function to read class names from a text file\nstatic std::vector<std::string> readClassNames(const std::string& filePath) {\n    std::vector<std::string> classNames;\n    std::ifstream file(filePath);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"ERROR: Cannot open class names file.\");\n    }\n    std::string line;\n    while (std::getline(file, line)) {\n        classNames.push_back(line);\n    }\n    return classNames;\n}\n\n// Function to preprocess the image for YOLO\nstatic cv::Mat preprocess(const cv::Mat& frame, const cv::Size& inputSize, const float scale, const cv::Scalar& mean, const bool swapRB) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(frame, blob, scale, inputSize, mean, swapRB, false);\n    return blob;\n}\n\n// Function to draw bounding boxes and labels on the image\nstatic void drawBoundingBox(cv::Mat& image, const int classId, const float confidence, const cv::Rect& box, const std::vector<std::string>& classNames) {\n    const cv::Scalar color(0, 255, 0); // Green for bounding boxes\n    cv::rectangle(image, box, color, 2);\n\n    std::string label = classNames.empty() ? \"Unknown\" : classNames[classId];\n    label += cv::format(\": %.2f\", confidence);\n\n    int baseline = 0;\n    const cv::Size labelSize = cv::getTextSize(label, cv::FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseline);\n    const int top = cv::max(box.y, labelSize.height);\n    cv::rectangle(image, cv::Point(box.x, top - labelSize.height - 5),\n                  cv::Point(box.x + labelSize.width, top + baseline - 5),\n                  cv::Scalar(0, 0, 0), cv::FILLED);\n    cv::putText(image, label, cv::Point(box.x, top - 5), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n}\n\nint main(int argc, char** argv) {\n    try {\n        // Path to YOLO model files\n        const std::string modelPath = \"yolov4.weights\";\n        const std::string configPath = \"yolov4.cfg\";\n        const std::string classFile = \"coco.names\";\n\n        // Load class names\n        std::vector<std::string> classNames = readClassNames(classFile);\n\n        // Load the YOLO model\n        cv::dnn::Net net = cv::dnn::readNetFromDarknet(configPath, modelPath);\n        if (net.empty()) {\n            throw std::runtime_error(\"ERROR: Failed to load YOLO model.\");\n        }\n        net.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\n        net.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n\n        // Open video capture (camera or video file)\n        cv::VideoCapture cap(0); // Default camera\n        if (!cap.isOpened()) {\n            throw std::runtime_error(\"ERROR: Unable to open video source.\");\n        }\n\n        // Process frames\n        cv::Mat frame;\n        while (cap.read(frame)) {\n            // Preprocess the frame for YOLO\n            const float scale = 1.0f / 255.0f;\n            const cv::Scalar mean(0.0, 0.0, 0.0);\n            const cv::Size inputSize(416, 416);\n            const bool swapRB = true;\n            cv::Mat blob = preprocess(frame, inputSize, scale, mean, swapRB);\n\n            // Set the input to the network\n            net.setInput(blob);\n\n            // Perform inference\n            std::vector<cv::Mat> outputs;\n            net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n            // Parse the outputs\n            std::vector<int> classIds;\n            std::vector<float> confidences;\n            std::vector<cv::Rect> boxes;\n            const float confThreshold = 0.5f;\n            const float nmsThreshold = 0.4f;\n\n            for (const auto& output : outputs) {\n                const float* data = reinterpret_cast<const float*>(output.data);\n                for (size_t i = 0; i < output.rows; ++i, data += output.cols) {\n                    const float confidence = data[4];\n                    if (confidence >= confThreshold) {\n                        const int centerX = static_cast<int>(data[0] * frame.cols);\n                        const int centerY = static_cast<int>(data[1] * frame.rows);\n                        const int width = static_cast<int>(data[2] * frame.cols);\n                        const int height = static_cast<int>(data[3] * frame.rows);\n\n                        const int left = centerX - width / 2;\n                        const int top = centerY - height / 2;\n                        boxes.push_back(cv::Rect(left, top, width, height));\n                        confidences.push_back(confidence);\n\n                        const int classId = static_cast<int>(std::max_element(data + 5, data + output.cols) - (data + 5));\n                        classIds.push_back(classId);\n                    }\n                }\n            }\n\n            // Perform Non-Maximum Suppression to reduce overlapping boxes\n            std::vector<int> indices;\n            cv::dnn::NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices);\n\n            for (const int idx : indices) {\n                drawBoundingBox(frame, classIds[idx], confidences[idx], boxes[idx], classNames);\n            }\n\n            // Display the frame with detections\n            cv::imshow(\"YOLO Object Detection\", frame);\n            if (cv::waitKey(1) >= 0) {\n                break; // Exit on key press\n            }\n        }\n\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << std::endl;\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing YOLO object detection using OpenCV. The code should load a YOLO model, preprocess the input, perform inference, and visualize the results, with proper error handling and comments explaining each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include detailed comments to describe each functionality in the code.",
      "output": "#include <opencv2/dnn.hpp> // OpenCV DNN module for deep learning\n#include <opencv2/imgproc.hpp> // For image preprocessing and manipulation\n#include <opencv2/highgui.hpp> // For GUI to display images\n#include <iostream> // Standard I/O library\n#include <vector> // To store multiple objects\n#include <fstream> // To read class names from a file\n\n// Function to read class names from a text file\nstatic std::vector<std::string> loadClassNames(const std::string& filepath) {\n    std::vector<std::string> classNames;\n    std::ifstream file(filepath);\n    if (!file.is_open()) {\n        std::cerr << \"ERROR: Cannot open class names file: \" << filepath << std::endl;\n        throw std::runtime_error(\"File not found\");\n    }\n    std::string line;\n    while (std::getline(file, line)) {\n        classNames.push_back(line);\n    }\n    return classNames;\n}\n\n// Function for preprocessing input image\nstatic cv::Mat preprocessImage(const cv::Mat& frame, const cv::Size& inputSize, const float scale, const cv::Scalar& mean, const bool swapRB) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(frame, blob, scale, inputSize, mean, swapRB, false);\n    return blob;\n}\n\n// Function to draw bounding boxes on the image\nstatic void drawBoundingBox(cv::Mat& image, const int classId, const float confidence, const cv::Rect& box, const std::vector<std::string>& classNames) {\n    cv::rectangle(image, box, cv::Scalar(0, 255, 0), 2);\n    std::string label = classNames.empty() ? \"Class \" + std::to_string(classId) : classNames[classId];\n    label += \" : \" + std::to_string(confidence);\n    int baseLine = 0;\n    const cv::Size labelSize = cv::getTextSize(label, cv::FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);\n    const int top = std::max(box.y, labelSize.height);\n    cv::rectangle(image, cv::Point(box.x, top - labelSize.height - 5), cv::Point(box.x + labelSize.width, top + baseLine - 5), cv::Scalar(0, 0, 0), cv::FILLED);\n    cv::putText(image, label, cv::Point(box.x, top - 5), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n}\n\n// Main function for object detection using YOLO\nint main(int argc, char** argv) {\n    try {\n        // Read model files and class names\n        const std::string modelFile = \"yolov3.weights\";\n        const std::string configFile = \"yolov3.cfg\";\n        const std::string classFile = \"coco.names\";\n\n        // Load class names\n        std::vector<std::string> classNames = loadClassNames(classFile);\n\n        // Load YOLO model\n        cv::dnn::Net net = cv::dnn::readNet(modelFile, configFile);\n        if (net.empty()) {\n            throw std::runtime_error(\"ERROR: Failed to load YOLO model.\");\n        }\n\n        // Set up network preferences\n        net.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\n        net.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n\n        // Open video capture (camera or video file)\n        cv::VideoCapture cap(0); // Default camera\n        if (!cap.isOpened()) {\n            throw std::runtime_error(\"ERROR: Cannot open video capture.\");\n        }\n\n        // Processing frames\n        cv::Mat frame;\n        while (cap.read(frame)) {\n            // Preprocess the frame\n            const float scale = 1.0 / 255.0;\n            const cv::Size inputSize(416, 416);\n            const cv::Scalar mean(0.0, 0.0, 0.0);\n            const bool swapRB = true;\n            cv::Mat blob = preprocessImage(frame, inputSize, scale, mean, swapRB);\n\n            // Set the input to the network\n            net.setInput(blob);\n\n            // Perform inference\n            std::vector<cv::Mat> outputs;\n            net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n            // Parse the outputs\n            std::vector<int> classIds;\n            std::vector<float> confidences;\n            std::vector<cv::Rect> boxes;\n            const float confThreshold = 0.5f;\n            const float nmsThreshold = 0.4f;\n\n            for (const auto& output : outputs) {\n                const float* data = reinterpret_cast<const float*>(output.data);\n                for (size_t i = 0; i < output.rows; ++i, data += output.cols) {\n                    const float confidence = data[4];\n                    if (confidence >= confThreshold) {\n                        const int centerX = static_cast<int>(data[0] * frame.cols);\n                        const int centerY = static_cast<int>(data[1] * frame.rows);\n                        const int width = static_cast<int>(data[2] * frame.cols);\n                        const int height = static_cast<int>(data[3] * frame.rows);\n\n                        const int left = centerX - width / 2;\n                        const int top = centerY - height / 2;\n                        boxes.push_back(cv::Rect(left, top, width, height));\n                        confidences.push_back(confidence);\n\n                        const int classId = static_cast<int>(std::max_element(data + 5, data + output.cols) - (data + 5));\n                        classIds.push_back(classId);\n                    }\n                }\n            }\n\n            // Apply Non-Maximum Suppression\n            std::vector<int> indices;\n            cv::dnn::NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices);\n\n            for (const int idx : indices) {\n                drawBoundingBox(frame, classIds[idx], confidences[idx], boxes[idx], classNames);\n            }\n\n            // Display the frame with bounding boxes\n            cv::imshow(\"YOLO Object Detection\", frame);\n            if (cv::waitKey(1) >= 0) {\n                break; // Exit on key press\n            }\n        }\n\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing object detection using YOLO with OpenCV. The code should load a YOLO model, preprocess the input image, run inference, and draw bounding boxes around detected objects. Include proper error handling and detailed comments explaining each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', explicitly handle type conversions, and include comments to describe functionality.",
      "output": "#include <opencv2/core.hpp>\n#include <opencv2/dnn.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\n// Function to load the YOLO model\nvoid loadYOLOModel(cv::dnn::Net& net, const std::string& modelPath, const std::string& configPath) {\n    try {\n        // Load YOLO model\n        net = cv::dnn::readNet(modelPath, configPath);\n    } catch (const cv::Exception& e) {\n        std::cerr << \"Error loading YOLO model: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Function to preprocess input image\ncv::Mat preprocessImage(const cv::Mat& image, const cv::Size& size) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, 1.0/255.0, size, cv::Scalar(), true, false);\n    return blob;\n}\n\n// Function to post-process YOLO output and draw bounding boxes\nvoid postProcessYOLO(const cv::Mat& frame, const cv::Mat& output, const float confThreshold, const float nmsThreshold) {\n    std::vector<int> classIds;\n    std::vector<float> confidences;\n    std::vector<cv::Rect> boxes;\n    for (int i = 0; i < output.rows; ++i) {\n        float* data = (float*)output.data + i * output.cols;\n        float confidence = data[4];\n        if (confidence > confThreshold) {\n            int classId = -1;\n            float maxClassConfidence = 0.0f;\n            for (int j = 5; j < output.cols; ++j) {\n                if (data[j] > maxClassConfidence) {\n                    maxClassConfidence = data[j];\n                    classId = j - 5;\n                }\n            }\n            if (classId >= 0) {\n                int x = static_cast<int>(data[0] * frame.cols);\n                int y = static_cast<int>(data[1] * frame.rows);\n                int width = static_cast<int>(data[2] * frame.cols - x);\n                int height = static_cast<int>(data[3] * frame.rows - y);\n                boxes.push_back(cv::Rect(x, y, width, height));\n                confidences.push_back(confidence);\n                classIds.push_back(classId);\n            }\n        }\n    }\n\n    // Apply non-maximum suppression to eliminate redundant overlapping boxes\n    std::vector<int> indices;\n    cv::dnn::NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices);\n\n    // Draw the final bounding boxes on the image\n    for (size_t i = 0; i < indices.size(); ++i) {\n        int idx = indices[i];\n        cv::Rect box = boxes[idx];\n        cv::rectangle(frame, box, cv::Scalar(0, 255, 0), 2);\n    }\n}\n\nint main(int argc, char** argv) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <model> <config>\" << std::endl;\n        return -1;\n    }\n\n    // Load YOLO model\n    cv::dnn::Net net;\n    loadYOLOModel(net, argv[1], argv[2]);\n\n    // Load input image\n    cv::Mat frame = cv::imread(\"input.jpg\");\n    if (frame.empty()) {\n        std::cerr << \"Error loading image!\" << std::endl;\n        return -1;\n    }\n\n    // Preprocess the image\n    cv::Mat blob = preprocessImage(frame, cv::Size(416, 416));\n    net.setInput(blob);\n\n    // Perform inference\n    std::vector<cv::Mat> outputs;\n    net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n    // Post-process and draw bounding boxes\n    postProcessYOLO(frame, outputs[0], 0.5, 0.4);\n\n    // Display the result\n    cv::imshow(\"YOLO Detection\", frame);\n    cv::waitKey(0);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing real-time object detection using YOLO with OpenCV. The code should load the YOLO model, preprocess the input frame, perform inference, and display the predicted class and confidence along with the bounding box on the screen. The program should handle errors and include detailed comments explaining each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments to explain the functionality at every key step.",
      "output": "#include <opencv2/core.hpp>\n#include <opencv2/dnn.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>\n#include <iostream>\n\n// Function to load YOLO model\nvoid loadYOLOModel(cv::dnn::Net& net, const std::string& modelPath, const std::string& configPath) {\n    try {\n        net = cv::dnn::readNet(modelPath, configPath);\n    } catch (const cv::Exception& e) {\n        std::cerr << \"Error loading YOLO model: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Function to preprocess input image\ncv::Mat preprocessImage(const cv::Mat& image, const cv::Size& size) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, 1.0 / 255.0, size, cv::Scalar(), true, false);\n    return blob;\n}\n\n// Function to post-process YOLO output\nvoid postProcessYOLO(cv::Mat& frame, const cv::Mat& output, const float confThreshold) {\n    std::vector<int> classIds;\n    std::vector<float> confidences;\n    std::vector<cv::Rect> boxes;\n    for (int i = 0; i < output.rows; ++i) {\n        float* data = (float*)output.data + i * output.cols;\n        float confidence = data[4];\n        if (confidence > confThreshold) {\n            int classId = -1;\n            float maxClassConfidence = 0.0f;\n            for (int j = 5; j < output.cols; ++j) {\n                if (data[j] > maxClassConfidence) {\n                    maxClassConfidence = data[j];\n                    classId = j - 5;\n                }\n            }\n            if (classId >= 0) {\n                int x = static_cast<int>(data[0] * frame.cols);\n                int y = static_cast<int>(data[1] * frame.rows);\n                int width = static_cast<int>(data[2] * frame.cols - x);\n                int height = static_cast<int>(data[3] * frame.rows - y);\n                boxes.push_back(cv::Rect(x, y, width, height));\n                confidences.push_back(confidence);\n                classIds.push_back(classId);\n            }\n        }\n    }\n\n    // Apply non-maximum suppression to eliminate redundant overlapping boxes\n    std::vector<int> indices;\n    cv::dnn::NMSBoxes(boxes, confidences, confThreshold, 0.4, indices);\n\n    // Draw bounding boxes and class labels\n    for (size_t i = 0; i < indices.size(); ++i) {\n        int idx = indices[i];\n        cv::Rect box = boxes[idx];\n        cv::rectangle(frame, box, cv::Scalar(0, 255, 0), 2);\n        std::string label = \"Class: \" + std::to_string(classIds[idx]) + \" Confidence: \" + std::to_string(confidences[idx]);\n        cv::putText(frame, label, cv::Point(box.x, box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n    }\n}\n\nint main(int argc, char** argv) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <model> <config>\" << std::endl;\n        return -1;\n    }\n\n    // Load YOLO model\n    cv::dnn::Net net;\n    loadYOLOModel(net, argv[1], argv[2]);\n\n    // Open camera or video input\n    cv::VideoCapture cap(0);  // Use the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Could not open camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            std::cerr << \"Error: Empty frame captured.\" << std::endl;\n            break;\n        }\n\n        // Preprocess input image\n        cv::Mat blob = preprocessImage(frame, cv::Size(416, 416));\n        net.setInput(blob);\n\n        // Perform inference\n        std::vector<cv::Mat> outputs;\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n        // Post-process and draw bounding boxes\n        postProcessYOLO(frame, outputs[0], 0.5f);\n\n        // Display result\n        cv::imshow(\"YOLO Object Detection\", frame);\n\n        // Exit on ESC key press\n        if (cv::waitKey(1) == 27) {\n            break;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for object detection using YOLO with OpenCV. The code should load the YOLO model, preprocess the image, perform object detection, and display the results with bounding boxes and class labels. Handle errors gracefully and include comments explaining each function and key step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and provide comments to describe the function and logic of each key part of the program.",
      "output": "#include <opencv2/dnn.hpp> // For deep learning networks\n#include <opencv2/imgproc.hpp> // For image processing\n#include <opencv2/highgui.hpp> // For GUI functionalities\n#include <opencv2/core.hpp> // For core OpenCV functionalities\n#include <iostream> // For standard input/output\n\n// Function to load the YOLO model\nvoid loadYOLOModel(cv::dnn::Net &net, const std::string &modelFile, const std::string &configFile) {\n    try {\n        net = cv::dnn::readNet(modelFile, configFile);\n    } catch (const cv::Exception &e) {\n        std::cerr << \"Error loading YOLO model: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Function to preprocess image for YOLO\ncv::Mat preprocessImage(const cv::Mat &image, const cv::Size &size, float scale, const cv::Scalar &mean, bool swapRB) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, scale, size, mean, swapRB, false);\n    return blob;\n}\n\n// Function to draw bounding boxes and class labels\nvoid drawBoundingBox(cv::Mat &frame, int classId, float confidence, int left, int top, int right, int bottom) {\n    cv::rectangle(frame, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 255, 0), 2); // Draw rectangle\n    std::string label = \"Class: \" + std::to_string(classId) + \" Confidence: \" + std::to_string(confidence);\n    cv::putText(frame, label, cv::Point(left, top - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2); // Add label\n}\n\n// Main function\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <model> <config>\" << std::endl;\n        return -1;\n    }\n\n    // Load the YOLO model\n    cv::dnn::Net net;\n    loadYOLOModel(net, argv[1], argv[2]);\n\n    // Open the camera feed\n    cv::VideoCapture cap(0); // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Could not open camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture a frame\n        if (frame.empty()) {\n            std::cerr << \"Error: Empty frame.\" << std::endl;\n            break;\n        }\n\n        // Preprocess the image\n        cv::Mat blob = preprocessImage(frame, cv::Size(416, 416), 1.0 / 255.0, cv::Scalar(), true);\n        net.setInput(blob); // Set input for YOLO\n\n        // Perform object detection\n        std::vector<cv::Mat> outputs;\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n        // Process the outputs\n        for (const auto &output : outputs) {\n            for (int i = 0; i < output.rows; ++i) {\n                float *data = (float *) output.data + i * output.cols;\n                float confidence = data[4]; // Get the confidence score\n                if (confidence > 0.5) { // Only process high-confidence detections\n                    int left = static_cast<int>(data[0] * frame.cols);\n                    int top = static_cast<int>(data[1] * frame.rows);\n                    int right = static_cast<int>(data[2] * frame.cols);\n                    int bottom = static_cast<int>(data[3] * frame.rows);\n                    int classId = static_cast<int>(data[5]);\n                    drawBoundingBox(frame, classId, confidence, left, top, right, bottom); // Draw the bounding box\n                }\n            }\n        }\n\n        // Display the results\n        cv::imshow(\"YOLO Object Detection\", frame);\n\n        if (cv::waitKey(1) == 27) break; // Exit on ESC key\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform object detection using YOLO with OpenCV. The code should load a YOLO model, preprocess input images, perform inference, and draw bounding boxes with labels for detected objects. Ensure to handle errors and include detailed comments for each step of the process.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and add comments to describe key functions and the overall flow of the program.",
      "output": "#include <opencv2/core.hpp> // For core OpenCV functions\n#include <opencv2/imgcodecs.hpp> // For reading images\n#include <opencv2/highgui.hpp> // For displaying images\n#include <opencv2/dnn.hpp> // For Deep Neural Networks module\n#include <iostream> // For standard input/output\n\n// Function to load YOLO model\nvoid loadYOLOModel(cv::dnn::Net &net, const std::string &modelFile, const std::string &configFile) {\n    try {\n        net = cv::dnn::readNet(modelFile, configFile);\n    } catch (const cv::Exception &e) {\n        std::cerr << \"Error loading model: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Function to preprocess image for YOLO\ncv::Mat preprocessImage(const cv::Mat &image, const cv::Size &size, float scale, const cv::Scalar &mean, bool swapRB) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, scale, size, mean, swapRB, false);\n    return blob;\n}\n\n// Function to draw bounding boxes and labels\nvoid drawBoundingBox(cv::Mat &frame, int classId, float confidence, int left, int top, int right, int bottom) {\n    cv::rectangle(frame, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string label = \"Class: \" + std::to_string(classId) + \" Confidence: \" + std::to_string(confidence);\n    cv::putText(frame, label, cv::Point(left, top - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2); // Add label\n}\n\n// Main function\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <model_file> <config_file>\" << std::endl;\n        return -1;\n    }\n\n    // Load the YOLO model\n    cv::dnn::Net net;\n    loadYOLOModel(net, argv[1], argv[2]);\n\n    // Open the video capture device\n    cv::VideoCapture cap(0); // Open the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Could not open camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture a frame\n        if (frame.empty()) {\n            std::cerr << \"Error: Empty frame.\" << std::endl;\n            break;\n        }\n\n        // Preprocess the image\n        cv::Mat blob = preprocessImage(frame, cv::Size(416, 416), 1.0 / 255.0, cv::Scalar(), true);\n        net.setInput(blob); // Set input for YOLO\n\n        // Perform inference\n        std::vector<cv::Mat> outputs;\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n        // Process the outputs\n        for (const auto &output : outputs) {\n            for (int i = 0; i < output.rows; ++i) {\n                float *data = (float *) output.data + i * output.cols;\n                float confidence = data[4]; // Confidence score\n                if (confidence > 0.5) { // Only process high-confidence detections\n                    int left = static_cast<int>(data[0] * frame.cols);\n                    int top = static_cast<int>(data[1] * frame.rows);\n                    int right = static_cast<int>(data[2] * frame.cols);\n                    int bottom = static_cast<int>(data[3] * frame.rows);\n                    int classId = static_cast<int>(data[5]);\n                    drawBoundingBox(frame, classId, confidence, left, top, right, bottom); // Draw bounding box and label\n                }\n            }\n        }\n\n        // Display the result\n        cv::imshow(\"YOLO Object Detection\", frame);\n\n        if (cv::waitKey(1) == 27) break; // Exit on ESC key\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing object detection using YOLO in OpenCV. The code should load a pre-trained YOLO model, process input frames, perform inference, and display the results with bounding boxes. Proper error handling and detailed comments should be included to explain each step.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/core.hpp> // For basic OpenCV functions\n#include <opencv2/imgcodecs.hpp> // For loading images\n#include <opencv2/highgui.hpp> // For creating windows and displaying images\n#include <opencv2/dnn.hpp> // For working with Deep Neural Networks\n#include <iostream> // For input/output operations\n\n// Function to load YOLO model\nvoid loadYOLOModel(cv::dnn::Net &net, const std::string &modelFile, const std::string &configFile) {\n    try {\n        net = cv::dnn::readNet(modelFile, configFile);\n    } catch (const cv::Exception &e) {\n        std::cerr << \"Error loading YOLO model: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Function to preprocess the image before inference\ncv::Mat preprocessImage(const cv::Mat &image, const cv::Size &size, float scale, const cv::Scalar &mean, bool swapRB) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, scale, size, mean, swapRB, false);\n    return blob;\n}\n\n// Function to draw bounding boxes and labels on the image\nvoid drawBoundingBox(cv::Mat &frame, int classId, float confidence, int left, int top, int right, int bottom) {\n    cv::rectangle(frame, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string label = \"Class: \" + std::to_string(classId) + \" Confidence: \" + std::to_string(confidence);\n    cv::putText(frame, label, cv::Point(left, top - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2); // Add label\n}\n\n// Main function to perform YOLO object detection\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <model_file> <config_file>\" << std::endl;\n        return -1;\n    }\n\n    // Load YOLO model\n    cv::dnn::Net net;\n    loadYOLOModel(net, argv[1], argv[2]);\n\n    // Open video capture device\n    cv::VideoCapture cap(0); // Open the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Could not open the camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture frame\n        if (frame.empty()) {\n            std::cerr << \"Error: Empty frame.\" << std::endl;\n            break;\n        }\n\n        // Preprocess the image\n        cv::Mat blob = preprocessImage(frame, cv::Size(416, 416), 1.0 / 255.0, cv::Scalar(), true);\n        net.setInput(blob); // Set input for YOLO\n\n        // Perform inference\n        std::vector<cv::Mat> outputs;\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n        // Process the outputs\n        for (const auto &output : outputs) {\n            for (int i = 0; i < output.rows; ++i) {\n                float *data = (float *) output.data + i * output.cols;\n                float confidence = data[4]; // Confidence score\n                if (confidence > 0.5) { // Only process high-confidence detections\n                    int left = static_cast<int>(data[0] * frame.cols);\n                    int top = static_cast<int>(data[1] * frame.rows);\n                    int right = static_cast<int>(data[2] * frame.cols);\n                    int bottom = static_cast<int>(data[3] * frame.rows);\n                    int classId = static_cast<int>(data[5]);\n                    drawBoundingBox(frame, classId, confidence, left, top, right, bottom); // Draw bounding box\n                }\n            }\n        }\n\n        // Display the result\n        cv::imshow(\"YOLO Object Detection\", frame);\n\n        if (cv::waitKey(1) == 27) break; // Exit on ESC key\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for Forward Collision Warning (FCW) based on object detection in real-time using OpenCV. The code should analyze the distance to the detected vehicle, calculate the collision risk, and trigger a warning if the risk is high. Detailed comments and error handling should be included for clarity.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle type conversions explicitly, and include comments to explain each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV for image processing\n#include <iostream> // For standard I/O operations\n#include <vector> // For handling vectors\n\n// Function to load pre-trained object detection model\nvoid loadDetectionModel(cv::dnn::Net &net, const std::string &modelFile, const std::string &configFile) {\n    try {\n        net = cv::dnn::readNet(modelFile, configFile);\n    } catch (const cv::Exception &e) {\n        std::cerr << \"Error loading detection model: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Function to preprocess the image before inference\ncv::Mat preprocessImage(const cv::Mat &image, const cv::Size &size, float scale, const cv::Scalar &mean, bool swapRB) {\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, scale, size, mean, swapRB, false);\n    return blob;\n}\n\n// Function to draw bounding box and calculate distance\nvoid drawBoundingBoxAndCalculateDistance(cv::Mat &frame, int classId, float confidence, int left, int top, int right, int bottom) {\n    float vehicleWidth = 1.8; // Estimated width of a vehicle in meters\n    float focalLength = 800.0; // Focal length of the camera\n    float realWidth = vehicleWidth; // Real-world width of the detected object\n    float perceivedWidth = right - left; // Perceived width in pixels\n\n    // Calculate distance to the object using the formula: distance = (real width * focal length) / perceived width\n    float distance = (realWidth * focalLength) / perceivedWidth;\n\n    // Draw bounding box and display distance\n    cv::rectangle(frame, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 255, 0), 2); // Draw the bounding box\n    std::string label = \"Distance: \" + std::to_string(distance) + \" meters\";\n    cv::putText(frame, label, cv::Point(left, top - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2); // Display the distance\n\n    // Collision warning if distance is below threshold\n    if (distance < 5.0) { // Trigger warning if distance is less than 5 meters\n        cv::putText(frame, \"WARNING: Collision Risk!\", cv::Point(left, top - 30), cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0, 0, 255), 2); // Show warning\n    }\n}\n\n// Main function to perform FCW detection\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <model_file> <config_file>\" << std::endl;\n        return -1;\n    }\n\n    // Load object detection model\n    cv::dnn::Net net;\n    loadDetectionModel(net, argv[1], argv[2]);\n\n    // Open video capture device\n    cv::VideoCapture cap(0); // Open the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Could not open the camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture frame\n        if (frame.empty()) {\n            std::cerr << \"Error: Empty frame.\" << std::endl;\n            break;\n        }\n\n        // Preprocess the image\n        cv::Mat blob = preprocessImage(frame, cv::Size(416, 416), 1.0 / 255.0, cv::Scalar(), true);\n        net.setInput(blob); // Set input for YOLO model\n\n        // Perform inference\n        std::vector<cv::Mat> outputs;\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n        // Process the outputs\n        for (const auto &output : outputs) {\n            for (int i = 0; i < output.rows; ++i) {\n                float *data = (float *) output.data + i * output.cols;\n                float confidence = data[4]; // Confidence score\n                if (confidence > 0.5) { // Only process high-confidence detections\n                    int left = static_cast<int>(data[0] * frame.cols);\n                    int top = static_cast<int>(data[1] * frame.rows);\n                    int right = static_cast<int>(data[2] * frame.cols);\n                    int bottom = static_cast<int>(data[3] * frame.rows);\n                    int classId = static_cast<int>(data[5]);\n                    drawBoundingBoxAndCalculateDistance(frame, classId, confidence, left, top, right, bottom); // Draw bounding box and calculate distance\n                }\n            }\n        }\n\n        // Display the result\n        cv::imshow(\"Forward Collision Warning (FCW) System\", frame);\n\n        if (cv::waitKey(1) == 27) break; // Exit on ESC key\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate a MISRA 2023-compliant C++ code to simulate a Forward Collision Warning (FCW) system based on object detection using OpenCV. The system should calculate the distance to objects and trigger a warning when the distance is below a certain threshold. The code should strictly adhere to MISRA rules for error handling and include detailed comments explaining each operation.",
      "input": "Write the C++ code to comply with MISRA 2023 standards. Use explicit casting for type conversions, handle errors gracefully, and provide explanations for key operations.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold detected object data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 870.0f;   // Focal length in X direction\nconst float focal_length_y = 990.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center X\nconst float optical_center_y = 540.0f; // Optical center Y\nconst float car_width = 1.8f;  // Assumed car width in meters\nconst float collision_threshold = 10.0f;  // Collision threshold in meters\n\n// Structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the object\n    float distance;         // Distance to the object in meters\n    std::string label;      // Label for object (e.g., car, truck)\n};\n\n// Function to calculate distance based on object width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate the distance to the object\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Process image to detect objects and compute distances\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(650, 400, 200, 100);  // Dummy object (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision risk\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(320, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Warning message\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);\n\n        // Display processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate a C++ code that implements a basic Forward Collision Warning (FCW) system using camera feed. The system should detect objects and trigger a warning when an object comes too close to the vehicle. Ensure compliance with MISRA 2023 guidelines for type safety, explicit casting, and clear error handling. Include comments explaining each key section of the code.",
      "input": "Write the code ensuring no use of 'using namespace', explicit type conversions, and comprehensive error handling.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>             // For input-output operations\n#include <cmath>                // For mathematical operations\n#include <cstdlib>              // For system operations like EXIT_FAILURE\n#include <vector>               // For vector to store detected objects\n#include <string>               // For string manipulation\n\n// Camera intrinsic parameters\nconst float focal_length_x = 850.0f;   // Camera focal length in X direction\nconst float focal_length_y = 1000.0f;  // Camera focal length in Y direction\nconst float optical_center_x = 960.0f; // Camera optical center X\nconst float optical_center_y = 540.0f; // Camera optical center Y\nconst float car_width = 1.8f;           // Average width of a car (in meters)\nconst float collision_threshold = 10.0f;  // Threshold for collision warning (in meters)\n\n// Structure for detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;   // Bounding box for detected object\n    float distance;          // Distance to object\n    std::string label;       // Object label (e.g., car, truck)\n};\n\n// Function to estimate distance based on bounding box width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Simulated detection of a car\n    cv::Rect detected_object(650, 300, 200, 100);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate distance to object\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Display bounding box and distance\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Trigger warning if object is too close\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(320, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);\n\n        // Show processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects in front of the vehicle, calculate their distance, and provide a collision warning if the distance is below a certain threshold. The code should handle errors appropriately, use explicit type casting, and include detailed comments for clarity.",
      "input": "Ensure that the C++ code strictly adheres to MISRA 2023 standards, with explicit type conversions, proper error handling, and no use of 'using namespace'. Provide detailed comments for each major operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 875.0f;   // Focal length in X direction (in pixels)\nconst float focal_length_y = 990.0f;   // Focal length in Y direction (in pixels)\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 540.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 15.0f;\n\n// Structure to represent detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\")\n};\n\n// Function to calculate the distance to an object based on its width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image and compute distances\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection\n    cv::Rect detected_object(650, 350, 200, 100);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box and distance on image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision risk\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(320, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture a frame\n\n        if (frame.empty()) {\n            break;  // Exit loop if frame is empty\n        }\n\n        process_image(frame);  // Process the captured frame\n\n        // Display processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ code for a basic Forward Collision Warning system that detects vehicles using a camera feed and calculates their distance. If the distance is smaller than a predefined threshold, a warning should be displayed. The code should include proper error handling and avoid 'using namespace'.",
      "input": "Ensure compliance with MISRA 2023 by handling type conversions explicitly, checking for errors in each step, and avoiding implicit type casts.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For console output\n#include <cmath>  // For trigonometric and geometric calculations\n#include <cstdlib>  // For system error handling (EXIT_FAILURE)\n#include <string>  // For string handling\n\n// Camera calibration parameters\nconst float focal_length_x = 860.0f;   // Camera focal length in X direction\nconst float focal_length_y = 980.0f;   // Camera focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center X\nconst float optical_center_y = 540.0f; // Optical center Y\nconst float car_width = 1.8f;           // Car width in meters\nconst float collision_threshold = 10.0f; // Collision threshold (in meters)\n\n// Structure for detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;   // Bounding box for detected object\n    float distance;          // Distance to the object in meters\n    std::string label;       // Object label (e.g., car, truck)\n};\n\n// Function to calculate the distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process the image and calculate object distance\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(550, 400, 220, 100);  // Simulated detected object (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box on image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(320, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame from camera\n\n        if (frame.empty()) {\n            break;  // Exit loop if no frame captured\n        }\n\n        process_image(frame);  // Process frame\n\n        // Show processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ code for a Forward Collision Warning system that detects objects (vehicles) using a camera feed, calculates their distance, and displays a collision warning if the distance is below a set threshold. The code should include error handling and comments explaining each operation.",
      "input": "Ensure compliance with MISRA 2023 by avoiding implicit type casting and using explicit error handling throughout the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical functions\n#include <cstdlib>  // For system error handling\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 850.0f;   // Focal length in X direction (pixels)\nconst float focal_length_y = 1000.0f;  // Focal length in Y direction (pixels)\nconst float optical_center_x = 960.0f; // Optical center in X (pixels)\nconst float optical_center_y = 540.0f; // Optical center in Y (pixels)\nconst float car_width = 1.8f;           // Car width in meters\nconst float collision_threshold = 12.0f; // Threshold for collision warning (meters)\n\n// Structure to store detected object data\nstruct DetectedObject {\n    cv::Rect bounding_box;   // Bounding box of detected object\n    float distance;          // Distance to object (meters)\n    std::string label;       // Object label (e.g., car, pedestrian)\n};\n\n// Function to calculate the distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process each frame, detect objects, and calculate their distances\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(650, 300, 180, 90);  // Example detected object (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box and distance on image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame from camera\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the captured frame\n\n        // Show the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program to implement a Forward Collision Warning (FCW) system that uses a camera feed to detect vehicles. If the vehicle is detected within a specified distance threshold, the system should trigger a warning. Ensure MISRA 2023 compliance by handling type conversions explicitly, avoiding the use of 'using namespace', and providing detailed comments.",
      "input": "The program should avoid any implicit type casting, explicitly handle errors, and include clear and comprehensive comments for every operation.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For outputting messages\n#include <cstdlib>  // For error handling (EXIT_FAILURE)\n#include <cmath>  // For mathematical operations\n#include <string>  // For string manipulation\n\n// Camera intrinsic parameters\nconst float focal_length_x = 860.0f;   // Camera focal length in X direction (in pixels)\nconst float focal_length_y = 980.0f;   // Camera focal length in Y direction (in pixels)\nconst float optical_center_x = 960.0f; // Optical center X\nconst float optical_center_y = 540.0f; // Optical center Y\nconst float car_width = 1.8f;           // Car width in meters\nconst float collision_threshold = 10.0f; // Threshold for collision warning (meters)\n\n// Structure for detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;   // Bounding box for detected object\n    float distance;          // Distance to the object in meters\n    std::string label;       // Object label (e.g., car, truck)\n};\n\n// Function to calculate distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process each frame and calculate distance to detected object\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection\n    cv::Rect detected_object(650, 350, 200, 100);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box on image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Trigger warning if distance is below threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the captured frame\n\n        // Show processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ program for a Forward Collision Warning (FCW) system that uses a camera feed to detect objects, calculate their distance, and provide a warning if the distance is below a predefined threshold. Ensure that all type conversions are explicit, and include detailed comments for each operation.",
      "input": "Ensure the program adheres to MISRA 2023 by avoiding implicit type casting, using proper error handling, and providing detailed documentation of each step.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for image processing\n#include <iostream>  // For displaying output\n#include <cmath>  // For math operations\n#include <cstdlib>  // For error handling\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 900.0f;  // Focal length in X direction\nconst float focal_length_y = 950.0f;  // Focal length in Y direction\nconst float optical_center_x = 960.0f;  // Optical center in X direction\nconst float optical_center_y = 540.0f;  // Optical center in Y direction\nconst float car_width = 1.8f;  // Width of a car in meters\nconst float collision_threshold = 8.0f;  // Collision warning threshold (in meters)\n\n// Structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object's bounding box\n    float distance;         // Estimated distance to object\n    std::string label;      // Object label\n};\n\n// Function to calculate distance based on object width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process each image and detect objects\nvoid process_image(cv::Mat &image) {\n    // Simulated detected object\n    cv::Rect detected_object(600, 300, 200, 100);  // Example bounding box (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision risk\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the frame\n\n        // Display processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a C++ program that implements a Forward Collision Warning (FCW) system, detecting objects with a camera, calculating their distance, and providing a warning if the distance is under a threshold. Ensure the code is MISRA 2023-compliant, with clear error handling and type-safe operations.",
      "input": "Ensure compliance with MISRA 2023, explicitly handle type conversions, and include clear comments explaining each function and operation.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for computer vision tasks\n#include <iostream>  // For standard input and output\n#include <cmath>  // For math-related functions\n#include <cstdlib>  // For system error handling\n#include <string>  // For handling string data\n\n// Camera intrinsic parameters\nconst float focal_length_x = 880.0f;  // Camera focal length in X direction (in pixels)\nconst float focal_length_y = 980.0f;  // Camera focal length in Y direction (in pixels)\nconst float optical_center_x = 960.0f;  // Optical center in X direction (in pixels)\nconst float optical_center_y = 540.0f;  // Optical center in Y direction (in pixels)\nconst float car_width = 1.8f;  // Vehicle width in meters\nconst float collision_threshold = 10.0f;  // Collision detection threshold (in meters)\n\n// Structure for storing detected object data\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box around detected object\n    float distance;         // Estimated distance to the object in meters\n    std::string label;      // Label for the detected object (e.g., car, pedestrian)\n};\n\n// Function to calculate distance based on bounding box width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process each captured image\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection\n    cv::Rect detected_object(600, 350, 220, 100);  // Example bounding box (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Trigger warning if object is within collision threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open the default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the captured frame\n\n        // Show the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Implement a C++ system that uses a camera to detect vehicles and calculates their distance. The system should provide a collision warning if the detected vehicle is below a specified threshold distance. Ensure the code adheres to MISRA 2023 standards.",
      "input": "Ensure compliance with MISRA 2023 by explicitly handling all type conversions and error scenarios. Provide clear comments for every operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For capturing and processing images\n#include <iostream>  // For displaying output\n#include <cmath>  // For geometric calculations\n#include <cstdlib>  // For error handling\n#include <string>  // For string manipulation\n\n// Camera calibration parameters\nconst float focal_length_x = 850.0f;  // Focal length in X direction (in pixels)\nconst float focal_length_y = 920.0f;  // Focal length in Y direction (in pixels)\nconst float optical_center_x = 960.0f;  // Optical center in X direction (in pixels)\nconst float optical_center_y = 540.0f;  // Optical center in Y direction (in pixels)\nconst float car_width = 1.8f;  // Average car width in meters\nconst float collision_threshold = 15.0f;  // Distance threshold for collision warning (meters)\n\n// Structure for detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the detected object\n    float distance;         // Estimated distance to the object in meters\n    std::string label;      // Object label (e.g., car, truck)\n};\n\n// Function to calculate object distance\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process each image and detect objects\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(650, 350, 180, 90);  // Example detected object (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box around the object\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Trigger warning if object is close enough\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture image\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process captured image\n\n        // Show processed image\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit loop on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program that implements a Forward Collision Warning (FCW) system. The program should use a camera feed to detect vehicles and calculate their distance. A collision warning should be triggered if the distance is below a specified threshold. Ensure that the code adheres to MISRA 2023 standards.",
      "input": "Ensure all type conversions are explicit, avoid implicit casting, and provide error handling. Include clear comments for each part of the program.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for image processing\n#include <iostream>  // Standard input-output\n#include <cmath>  // Mathematical functions\n#include <cstdlib>  // For system operations\n#include <string>  // String operations\n\n// Camera calibration parameters\nconst float focal_length_x = 900.0f;  // Camera focal length in X direction\nconst float focal_length_y = 900.0f;  // Camera focal length in Y direction\nconst float optical_center_x = 960.0f;  // Optical center in X direction\nconst float optical_center_y = 540.0f;  // Optical center in Y direction\nconst float car_width = 1.8f;  // Car width in meters\nconst float collision_threshold = 10.0f;  // Collision threshold in meters\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object's bounding box\n    float distance;         // Estimated distance to the object\n    std::string label;      // Label for the object\n};\n\n// Function to calculate distance to the object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image and detect objects\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(650, 320, 180, 90);  // Example detected object (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box around detected object\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning if distance is below threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open the default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture image from camera\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the captured image\n\n        // Display the processed image\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit the loop when 'q' is pressed\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program that implements a Forward Collision Warning (FCW) system. The system should use a camera feed to detect vehicles, estimate their distance, and provide a collision warning if the distance is below a set threshold. Follow MISRA 2023 compliance for error handling and explicit type casting.",
      "input": "Ensure the program avoids implicit casting, explicitly handles type conversions, and includes clear documentation for each step of the process.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for image processing\n#include <iostream>  // For standard input-output\n#include <cmath>  // Mathematical operations\n#include <cstdlib>  // For system operations\n#include <string>  // String manipulation\n\n// Camera calibration parameters\nconst float focal_length_x = 880.0f;  // Camera focal length in X direction (in pixels)\nconst float focal_length_y = 950.0f;  // Camera focal length in Y direction (in pixels)\nconst float optical_center_x = 960.0f;  // Optical center in X direction\nconst float optical_center_y = 540.0f;  // Optical center in Y direction\nconst float car_width = 1.8f;  // Car width in meters\nconst float collision_threshold = 12.0f;  // Distance threshold for warning (in meters)\n\n// Structure for detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the object\n    float distance;         // Distance to the object\n    std::string label;      // Object label\n};\n\n// Function to calculate distance based on object width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process each frame and detect objects\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection (bounding box for a car)\n    cv::Rect detected_object(600, 300, 220, 100);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box and display distance\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning if distance is below threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open the default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture image\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the captured frame\n\n        // Display processed image\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit loop when 'q' is pressed\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Implement a C++ program for a Forward Collision Warning (FCW) system that detects objects using a camera feed. The system should compute distances and provide a warning if the distance is below a given threshold. Ensure the program follows MISRA 2023 standards, with explicit type conversions and error handling.",
      "input": "The program must comply with MISRA 2023 by handling errors and type conversions explicitly. Provide clear comments to explain each operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical functions\n#include <cstdlib>  // For system operations\n#include <string>  // For string handling\n\n// Camera parameters\nconst float focal_length_x = 920.0f;  // Camera focal length in X direction (in pixels)\nconst float focal_length_y = 1000.0f;  // Camera focal length in Y direction\nconst float optical_center_x = 960.0f;  // Optical center in X\nconst float optical_center_y = 540.0f;  // Optical center in Y\nconst float car_width = 1.8f;  // Average car width in meters\nconst float collision_threshold = 8.0f;  // Collision threshold in meters\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Estimated distance to the object\n    std::string label;      // Object label\n};\n\n// Function to calculate object distance based on its size in the image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Process each captured image to detect objects and calculate distances\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 300, 180, 90);  // Example detected object (car)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box and display distance\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check if the object is too close for collision warning\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame from the camera\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process the captured frame\n\n        // Display processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit when 'q' is pressed\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera resources\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate a C++ program that implements a Forward Collision Warning (FCW) system using a camera feed. The system should calculate the distance to detected vehicles and trigger a warning when the distance is less than a predefined threshold. Ensure the program is MISRA 2023 compliant, with explicit error handling and type casting.",
      "input": "The program should adhere to MISRA 2023 by avoiding implicit type casting, using explicit conversions, and providing detailed comments explaining each operation.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for image processing\n#include <iostream>  // Standard input-output\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system-level operations\n#include <string>  // String manipulation\n\n// Camera parameters\nconst float focal_length_x = 870.0f;  // Camera focal length in X direction\nconst float focal_length_y = 950.0f;  // Camera focal length in Y direction\nconst float optical_center_x = 960.0f;  // Optical center in X direction\nconst float optical_center_y = 540.0f;  // Optical center in Y direction\nconst float car_width = 1.8f;  // Average car width in meters\nconst float collision_threshold = 6.0f;  // Collision threshold in meters\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the object\n    float distance;         // Distance to the object in meters\n    std::string label;      // Object label\n};\n\n// Function to calculate the distance to the object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process the captured image and detect objects\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection (using a fixed bounding box)\n    cv::Rect detected_object(600, 300, 180, 90);  // Detected car object\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box around the detected object\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open the camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);  // Process captured image\n\n        // Show processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit when 'q' is pressed\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing (OpenCV library)\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction (camera calibration)\nconst float focal_length_y = 995.0f;   // Focal length in Y direction (camera calibration)\nconst float optical_center_x = 960.0f; // Optical center in X (camera calibration)\nconst float optical_center_y = 536.0f; // Optical center in Y (camera calibration)\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object (in meters)\n    std::string label;      // Label of the object (e.g., 'car', 'truck')\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing object detection using the YOLO (You Only Look Once) model with OpenCV. The system should load a pre-trained YOLO model, detect objects in a video stream, and display bounding boxes around them. Ensure the code handles errors like missing model files and improper input.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and provide comments explaining each step in loading the model, detecting objects, and handling errors.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n#include <string>                // For string manipulation\n\n// Function to perform object detection using YOLO\nvoid detect_objects(cv::Mat &frame) {\n    // Load YOLO model (ensure proper path and error handling)\n    cv::dnn::Net net = cv::dnn::readNetFromDarknet(\"yolov3.cfg\", \"yolov3.weights\");\n    if (net.empty()) {\n        std::cerr << \"ERROR: Failed to load YOLO model!\" << std::endl;\n        return;\n    }\n\n    // Prepare input image\n    cv::Mat blob;\n    cv::dnn::blobFromImage(frame, blob, 1.0/255.0, cv::Size(416, 416), cv::Scalar(0, 0, 0), true, false);\n    net.setInput(blob);\n\n    // Get detections\n    std::vector<cv::Mat> outputs;\n    net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n    // Process detections and draw bounding boxes\n    for (auto &output : outputs) {\n        // Each detection (dummy loop for simplicity)\n        cv::Rect detected_object(100, 100, 100, 100);  // Example bounding box\n        cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main loop to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform object detection\n        detect_objects(frame);\n\n        // Display frame\n        cv::imshow(\"Object Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for lane detection in road images using OpenCV. The system should detect lane lines and highlight them in the image. It should also display a warning if the vehicle drifts out of the lane.",
      "input": "Ensure compliance with MISRA standards: avoid implicit type conversions, do not use 'using namespace', and add detailed comments explaining the steps for lane detection using edge detection and Hough transforms.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for lane detection\nvoid detect_lane(cv::Mat &frame) {\n    // Convert image to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Gaussian blur to reduce noise\n    cv::Mat blurred;\n    cv::GaussianBlur(gray, blurred, cv::Size(5, 5), 0);\n\n    // Apply Canny edge detection\n    cv::Mat edges;\n    cv::Canny(blurred, edges, 50, 150);\n\n    // Apply Hough Line Transform to detect lines\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI/180, 100, 50, 10);\n\n    // Draw detected lane lines\n    for (size_t i = 0; i < lines.size(); i++) {\n        cv::Vec4i l = lines[i];\n        cv::line(frame, cv::Point(l[0], l[1]), cv::Point(l[2], l[3]), cv::Scalar(0, 255, 0), 3, 8);\n    }\n}\n\n// Main function for lane detection in video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform lane detection\n        detect_lane(frame);\n\n        // Display frame\n        cv::imshow(\"Lane Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for estimating the speed of a vehicle based on frame-by-frame movement in a video using optical flow techniques with OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle all types explicitly, avoid unsafe operations, and include comments explaining the optical flow calculation and speed estimation process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cmath>                 // For mathematical operations\n#include <cstdlib>               // For system operations\n\n// Function for estimating vehicle speed\nfloat estimate_speed(const cv::Mat &prev_frame, const cv::Mat &curr_frame) {\n    std::vector<cv::Point2f> prev_points, curr_points;\n    cv::goodFeaturesToTrack(prev_frame, prev_points, 100, 0.3, 7);\n\n    std::vector<uchar> status;\n    std::vector<float> error;\n    cv::calcOpticalFlowPyrLK(prev_frame, curr_frame, prev_points, curr_points, status, error);\n\n    float total_distance = 0.0f;\n    int count = 0;\n    for (size_t i = 0; i < prev_points.size(); i++) {\n        if (status[i]) {\n            total_distance += cv::norm(curr_points[i] - prev_points[i]);\n            count++;\n        }\n    }\n\n    return (count > 0) ? (total_distance / count) : 0.0f;\n}\n\n// Main function for speed estimation\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat prev_frame, curr_frame;\n    cap >> prev_frame;  // Capture the first frame\n    while (true) {\n        cap >> curr_frame;  // Capture the next frame\n        if (curr_frame.empty()) {\n            break;\n        }\n\n        // Estimate speed between frames\n        float speed = estimate_speed(prev_frame, curr_frame);\n        std::cout << \"Vehicle Speed: \" << speed << \" m/s\" << std::endl;\n\n        // Show frame\n        cv::imshow(\"Speed Estimation\", curr_frame);\n\n        prev_frame = curr_frame;\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for pedestrian detection using OpenCV's pre-trained Haar cascade classifier. The system should detect pedestrians in a video stream and trigger an alert if a pedestrian is detected within a certain distance.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid 'namespace', and provide detailed comments explaining each step in the pedestrian detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for pedestrian detection\nvoid detect_pedestrians(cv::Mat &frame) {\n    // Load pre-trained Haar cascade classifier\n    cv::CascadeClassifier pedestrian_cascade;\n    if (!pedestrian_cascade.load(\"haarcascade_fullbody.xml\")) {\n        std::cerr << \"ERROR: Could not load Haar cascade!\" << std::endl;\n        return;\n    }\n\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect pedestrians\n    std::vector<cv::Rect> pedestrians;\n    pedestrian_cascade.detectMultiScale(gray, pedestrians, 1.1, 3, 0, cv::Size(30, 30));\n\n    // Draw bounding boxes around detected pedestrians\n    for (size_t i = 0; i < pedestrians.size(); i++) {\n        cv::rectangle(frame, pedestrians[i], cv::Scalar(0, 255, 0), 2);\n    }\n}\n\n// Main function to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect pedestrians\n        detect_pedestrians(frame);\n\n        // Display frame\n        cv::imshow(\"Pedestrian Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for obstacle avoidance in a robot using OpenCV and basic distance sensors. The system should detect obstacles and steer the robot accordingly to avoid collisions.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add comments explaining each step of the obstacle detection and avoidance logic.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cmath>                 // For mathematical calculations\n#include <cstdlib>               // For system operations\n\n// Function to check for obstacles\nbool check_for_obstacles(const cv::Mat &frame) {\n    // Dummy obstacle detection (replace with actual sensor input)\n    cv::Rect obstacle(100, 100, 50, 50);  // Example bounding box for an obstacle\n\n    return (cv::countNonZero(frame(obstacle)) > 0);\n}\n\n// Function for obstacle avoidance\nvoid avoid_obstacles(cv::Mat &frame) {\n    if (check_for_obstacles(frame)) {\n        std::cout << \"Obstacle detected! Steering robot to avoid.\" << std::endl;\n        // Code to steer robot\n    }\n}\n\n// Main function for robot navigation\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Avoid obstacles\n        avoid_obstacles(frame);\n\n        // Display frame\n        cv::imshow(\"Obstacle Avoidance\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting faces in a video stream using OpenCV's pre-trained Haar cascade classifier. The system should detect faces, draw bounding boxes around them, and display the results.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining each step in the face detection process using Haar cascade classifiers.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for face detection\nvoid detect_faces(cv::Mat &frame) {\n    // Load pre-trained Haar cascade classifier for face detection\n    cv::CascadeClassifier face_cascade;\n    if (!face_cascade.load(\"haarcascade_frontalface_default.xml\")) {\n        std::cerr << \"ERROR: Could not load Haar cascade for face detection!\" << std::endl;\n        return;\n    }\n\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect faces\n    std::vector<cv::Rect> faces;\n    face_cascade.detectMultiScale(gray, faces, 1.1, 3, 0, cv::Size(30, 30));\n\n    // Draw bounding boxes around detected faces\n    for (size_t i = 0; i < faces.size(); i++) {\n        cv::rectangle(frame, faces[i], cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main function to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect faces\n        detect_faces(frame);\n\n        // Display frame\n        cv::imshow(\"Face Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting motion in a video stream using frame differencing. The system should highlight moving objects and display the motion regions on the screen.",
      "input": "Ensure compliance with MISRA standards: avoid implicit type conversions, do not use 'namespace', and provide detailed comments explaining each step in motion detection and highlighting moving objects.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for motion detection\nvoid detect_motion(cv::Mat &frame, cv::Mat &prev_frame) {\n    // Convert current frame to grayscale\n    cv::Mat gray, diff, thresh;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::absdiff(prev_frame, gray, diff);  // Compute absolute difference between current and previous frame\n\n    // Apply threshold to highlight moving objects\n    cv::threshold(diff, thresh, 25, 255, cv::THRESH_BINARY);\n\n    // Find contours of the moving regions\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(thresh, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw bounding boxes around moving objects\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::Rect bounding_box = cv::boundingRect(contours[i]);\n        cv::rectangle(frame, bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main function for motion detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame, prev_frame;\n    cap >> prev_frame;  // Capture the first frame\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect motion\n        detect_motion(frame, prev_frame);\n\n        // Display frame\n        cv::imshow(\"Motion Detection\", frame);\n\n        prev_frame = frame;\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for color-based object detection in a video stream. The system should detect objects based on their color in the image and highlight them with bounding boxes.",
      "input": "Ensure compliance with MISRA standards: handle all type conversions explicitly, avoid using 'namespace', and provide comments explaining each step of the color detection process using HSV filtering.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for color-based object detection\nvoid detect_color_objects(cv::Mat &frame) {\n    // Convert image to HSV color space\n    cv::Mat hsv;\n    cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV);\n\n    // Define color range for detection (e.g., detecting red color)\n    cv::Scalar lower_red(0, 120, 70);\n    cv::Scalar upper_red(10, 255, 255);\n\n    // Threshold image to extract objects of the desired color\n    cv::Mat mask;\n    cv::inRange(hsv, lower_red, upper_red, mask);\n\n    // Find contours of the detected objects\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw bounding boxes around detected objects\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::Rect bounding_box = cv::boundingRect(contours[i]);\n        cv::rectangle(frame, bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main function for color-based object detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect color-based objects\n        detect_color_objects(frame);\n\n        // Display frame\n        cv::imshow(\"Color-based Object Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform image smoothing using a Gaussian filter with OpenCV. The system should apply the filter to reduce noise and display the result.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle all type conversions explicitly, and include comments explaining the Gaussian filtering process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for applying Gaussian filter for image smoothing\nvoid apply_gaussian_filter(cv::Mat &frame) {\n    // Apply Gaussian blur to the image to reduce noise\n    cv::Mat smoothed_frame;\n    cv::GaussianBlur(frame, smoothed_frame, cv::Size(5, 5), 0);\n\n    // Display smoothed image\n    cv::imshow(\"Smoothed Image\", smoothed_frame);\n}\n\n// Main function for image smoothing\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply Gaussian filter for smoothing\n        apply_gaussian_filter(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting edges in an image using the Canny edge detection algorithm. The system should highlight edges and display the result.",
      "input": "Ensure compliance with MISRA standards: avoid 'namespace', handle type conversions explicitly, and provide detailed comments explaining the Canny edge detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for edge detection using the Canny algorithm\nvoid detect_edges(cv::Mat &frame) {\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Mat edges;\n    cv::Canny(gray, edges, 100, 200);  // Detect edges with low and high thresholds\n\n    // Display the edges\n    cv::imshow(\"Edge Detection\", edges);\n}\n\n// Main function for edge detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect edges\n        detect_edges(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform histogram equalization on an image. The system should improve the contrast of the image by redistributing its intensity histogram.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and provide detailed comments explaining each step of histogram equalization.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for histogram equalization\nvoid apply_histogram_equalization(cv::Mat &frame) {\n    // Convert the frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply histogram equalization to enhance the contrast\n    cv::Mat equalized_frame;\n    cv::equalizeHist(gray, equalized_frame);\n\n    // Display the equalized image\n    cv::imshow(\"Equalized Image\", equalized_frame);\n}\n\n// Main function for histogram equalization\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply histogram equalization\n        apply_histogram_equalization(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform template matching for object detection in an image using OpenCV. The system should find the template image within the input image and highlight the detected region.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add detailed comments explaining each step of template matching.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for template matching\nvoid template_matching(cv::Mat &frame, cv::Mat &template_image) {\n    // Perform template matching using the CV_TM_CCOEFF_NORMED method\n    cv::Mat result;\n    cv::matchTemplate(frame, template_image, result, cv::TM_CCOEFF_NORMED);\n\n    // Find the best match location\n    double min_val, max_val;\n    cv::Point min_loc, max_loc;\n    cv::minMaxLoc(result, &min_val, &max_val, &min_loc, &max_loc);\n\n    // Draw a rectangle around the detected object\n    cv::rectangle(frame, max_loc, cv::Point(max_loc.x + template_image.cols, max_loc.y + template_image.rows), cv::Scalar(0, 255, 0), 2);\n}\n\n// Main function for template matching\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame, template_image;\n    template_image = cv::imread(\"template.png\", cv::IMREAD_GRAYSCALE);  // Load the template image\n    if (template_image.empty()) {\n        std::cerr << \"ERROR: Could not load template image!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform template matching\n        template_matching(frame, template_image);\n\n        // Display frame\n        cv::imshow(\"Template Matching\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for optical flow estimation using the Lucas-Kanade method in OpenCV. The system should track the motion of points across consecutive frames.",
      "input": "Ensure compliance with MISRA standards: handle all type conversions explicitly, avoid using 'namespace', and provide comments explaining the optical flow calculation.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to calculate optical flow\nvoid calculate_optical_flow(cv::Mat &frame1, cv::Mat &frame2) {\n    std::vector<cv::Point2f> points1, points2;\n    std::vector<uchar> status;\n    std::vector<float> err;\n\n    // Detect good features to track in the first frame\n    cv::goodFeaturesToTrack(frame1, points1, 100, 0.01, 10);\n\n    // Calculate optical flow (i.e., track points from frame1 to frame2)\n    cv::calcOpticalFlowPyrLK(frame1, frame2, points1, points2, status, err);\n\n    // Draw tracks\n    for (size_t i = 0; i < points2.size(); i++) {\n        if (status[i]) {\n            cv::circle(frame2, points2[i], 5, cv::Scalar(0, 255, 0), -1);  // Draw circle for tracked points\n        }\n    }\n}\n\n// Main function to process optical flow\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame1, frame2;\n    cap >> frame1;  // Capture the first frame\n    while (true) {\n        cap >> frame2;\n        if (frame2.empty()) {\n            break;\n        }\n\n        // Calculate optical flow between frame1 and frame2\n        calculate_optical_flow(frame1, frame2);\n\n        // Display frame with optical flow\n        cv::imshow(\"Optical Flow\", frame2);\n\n        frame1 = frame2;\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for face recognition using Eigenfaces. The system should perform principal component analysis (PCA) on face images to recognize faces.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and provide detailed comments explaining each step in the Eigenfaces-based face recognition.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n#include <opencv2/contrib/contrib.hpp>  // For Eigenfaces method\n\n// Function to train the face recognizer using Eigenfaces\nvoid train_face_recognizer(const std::vector<cv::Mat> &images, const std::vector<int> &labels) {\n    // Create and train an Eigenfaces model\n    cv::Ptr<cv::face::FaceRecognizer> model = cv::face::EigenFaceRecognizer::create();\n    model->train(images, labels);\n    std::cout << \"Training completed!\" << std::endl;\n}\n\n// Main function for face recognition\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    std::vector<cv::Mat> images;\n    std::vector<int> labels;\n\n    // Collect training data (here just for illustration, in practice, you would load actual images)\n    for (int i = 0; i < 10; i++) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        images.push_back(frame);\n        labels.push_back(i);  // Dummy label for training\n    }\n\n    // Train the face recognizer\n    train_face_recognizer(images, labels);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for image thresholding to convert an image into binary form, separating foreground from background.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and add comments explaining the thresholding process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for applying simple thresholding\nvoid apply_thresholding(cv::Mat &frame) {\n    cv::Mat gray, binary;\n\n    // Convert frame to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply binary thresholding\n    cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);\n\n    // Display the binary image\n    cv::imshow(\"Binary Image\", binary);\n}\n\n// Main function to apply thresholding\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply thresholding\n        apply_thresholding(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing geometric transformations such as rotation and scaling on an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and provide comments explaining each transformation step.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to perform geometric transformations\nvoid perform_transformations(cv::Mat &frame) {\n    // Scaling transformation\n    cv::Mat scaled_frame;\n    cv::resize(frame, scaled_frame, cv::Size(), 0.5, 0.5);\n\n    // Rotation transformation\n    cv::Mat rotated_frame;\n    cv::Point2f center(frame.cols / 2, frame.rows / 2);\n    cv::Mat rotation_matrix = cv::getRotationMatrix2D(center, 45, 1);\n    cv::warpAffine(frame, rotated_frame, rotation_matrix, frame.size());\n\n    // Display transformed images\n    cv::imshow(\"Scaled Image\", scaled_frame);\n    cv::imshow(\"Rotated Image\", rotated_frame);\n}\n\n// Main function to apply transformations\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply geometric transformations\n        perform_transformations(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting contours in an image. The system should find and display the contours detected in the image.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining contour detection.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for contour detection\nvoid detect_contours(cv::Mat &frame) {\n    // Convert image to grayscale\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Canny(gray, edges, 100, 200);\n\n    // Find contours\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(edges, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw contours\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::drawContours(frame, contours, (int)i, cv::Scalar(0, 255, 0), 2);\n    }\n}\n\n// Main function for contour detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect contours\n        detect_contours(frame);\n\n        // Display frame\n        cv::imshow(\"Contours\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for converting an image from the RGB color space to the HSV color space using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle all type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the color space conversion.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to convert an image from RGB to HSV\nvoid convert_rgb_to_hsv(cv::Mat &frame) {\n    // Convert RGB to HSV\n    cv::Mat hsv_frame;\n    cv::cvtColor(frame, hsv_frame, cv::COLOR_BGR2HSV);\n\n    // Display the HSV image\n    cv::imshow(\"HSV Image\", hsv_frame);\n}\n\n// Main function to perform RGB to HSV conversion\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Convert the frame to HSV\n        convert_rgb_to_hsv(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for object tracking using a Kalman filter. The system should track the motion of an object across multiple frames.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the Kalman filter-based tracking.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to initialize Kalman filter\ncv::KalmanFilter init_kalman_filter() {\n    cv::KalmanFilter kf(4, 2, 0);  // State is (x, y, dx, dy) and measurement is (x, y)\n\n    kf.transitionMatrix = (cv::Mat_<float>(4, 4) << 1, 0, 1, 0,\n                                                   0, 1, 0, 1,\n                                                   0, 0, 1, 0,\n                                                   0, 0, 0, 1);\n\n    kf.measurementMatrix = (cv::Mat_<float>(2, 4) << 1, 0, 0, 0,\n                                                      0, 1, 0, 0);\n\n    kf.processNoiseCov = cv::Mat::eye(4, 4, CV_32F) * 1e-4;\n    kf.measurementNoiseCov = cv::Mat::eye(2, 2, CV_32F) * 1e-1;\n    kf.errorCovPost = cv::Mat::eye(4, 4, CV_32F);\n\n    return kf;\n}\n\n// Function to track the object using Kalman filter\nvoid track_object(cv::KalmanFilter &kf, cv::Mat &frame, cv::Point2f &measured_point) {\n    // Predict the next state\n    cv::Mat prediction = kf.predict();\n    cv::Point predicted_point(prediction.at<float>(0), prediction.at<float>(1));\n\n    // Update the Kalman filter with the new measurement\n    cv::Mat measurement = (cv::Mat_<float>(2, 1) << measured_point.x, measured_point.y);\n    kf.correct(measurement);\n\n    // Draw the predicted point\n    cv::circle(frame, predicted_point, 10, cv::Scalar(0, 255, 0), -1);\n}\n\n// Main function for object tracking with Kalman filter\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Point2f object_position(100, 100);  // Initial position of the object\n\n    cv::KalmanFilter kf = init_kalman_filter();\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Track the object\n        track_object(kf, frame, object_position);\n\n        // Display the frame\n        cv::imshow(\"Object Tracking\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting lines in an image using the Hough Line Transform.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and add comments explaining each step of the Hough Line Transform.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for Hough Line Transform\nvoid detect_lines(cv::Mat &frame) {\n    cv::Mat gray, edges;\n\n    // Convert image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Canny(gray, edges, 50, 150);\n\n    // Apply Hough Line Transform\n    std::vector<cv::Vec2f> lines;\n    cv::HoughLines(edges, lines, 1, CV_PI / 180, 100);\n\n    // Draw lines on the original image\n    for (size_t i = 0; i < lines.size(); i++) {\n        float rho = lines[i][0];\n        float theta = lines[i][1];\n        cv::Point pt1, pt2;\n        double a = cos(theta), b = sin(theta);\n        double x0 = a * rho, y0 = b * rho;\n        pt1.x = cvRound(x0 + 1000 * (-b));\n        pt1.y = cvRound(y0 + 1000 * (a));\n        pt2.x = cvRound(x0 - 1000 * (-b));\n        pt2.y = cvRound(y0 - 1000 * (a));\n        cv::line(frame, pt1, pt2, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function for Hough Line Transform\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect lines in the frame\n        detect_lines(frame);\n\n        // Display the frame with detected lines\n        cv::imshow(\"Hough Line Transform\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for template matching in images. The system should locate a template image within a larger frame.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add comments explaining the template matching process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for template matching\nvoid template_matching(cv::Mat &frame, cv::Mat &template_img) {\n    cv::Mat result;\n\n    // Perform template matching\n    cv::matchTemplate(frame, template_img, result, cv::TM_CCOEFF_NORMED);\n\n    // Find the location of the best match\n    cv::Point max_loc;\n    cv::minMaxLoc(result, NULL, NULL, NULL, &max_loc);\n\n    // Draw a rectangle around the matched region\n    cv::rectangle(frame, max_loc, cv::Point(max_loc.x + template_img.cols, max_loc.y + template_img.rows), cv::Scalar(0, 255, 0), 2);\n}\n\n// Main function for template matching\nint main() {\n    cv::Mat template_img = cv::imread(\"template.png\");  // Load template image\n    if (template_img.empty()) {\n        std::cout << \"ERROR: Could not load template image!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform template matching\n        template_matching(frame, template_img);\n\n        // Display the frame\n        cv::imshow(\"Template Matching\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for edge detection using the Sobel operator.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the Sobel edge detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for edge detection using Sobel operator\nvoid detect_edges(cv::Mat &frame) {\n    cv::Mat gray, grad_x, grad_y, abs_grad_x, abs_grad_y, edge_image;\n\n    // Convert image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Sobel operator to find gradients in X and Y directions\n    cv::Sobel(gray, grad_x, CV_16S, 1, 0, 3);\n    cv::Sobel(gray, grad_y, CV_16S, 0, 1, 3);\n\n    // Convert gradients to absolute values\n    cv::convertScaleAbs(grad_x, abs_grad_x);\n    cv::convertScaleAbs(grad_y, abs_grad_y);\n\n    // Combine the gradients\n    cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, edge_image);\n\n    // Display the edge image\n    cv::imshow(\"Edge Detection\", edge_image);\n}\n\n// Main function for edge detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect edges in the frame\n        detect_edges(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting blobs (connected regions of pixels) in an image using OpenCV's SimpleBlobDetector.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the blob detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <opencv2/features2d.hpp>  // For blob detection\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for blob detection\nvoid detect_blobs(cv::Mat &frame) {\n    // Convert image to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect blobs using SimpleBlobDetector\n    cv::SimpleBlobDetector::Params params;\n    params.filterByArea = true;\n    params.minArea = 100;\n    cv::Ptr<cv::SimpleBlobDetector> detector = cv::SimpleBlobDetector::create(params);\n\n    std::vector<cv::KeyPoint> keypoints;\n    detector->detect(gray, keypoints);\n\n    // Draw detected blobs on the original frame\n    cv::drawKeypoints(frame, keypoints, frame, cv::Scalar(0, 255, 0), cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);\n}\n\n// Main function for blob detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect blobs in the frame\n        detect_blobs(frame);\n\n        // Display the frame with detected blobs\n        cv::imshow(\"Blob Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing histogram equalization to improve image contrast.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the histogram equalization process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for histogram equalization\nvoid apply_histogram_equalization(cv::Mat &frame) {\n    cv::Mat gray, equalized_image;\n\n    // Convert image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply histogram equalization\n    cv::equalizeHist(gray, equalized_image);\n\n    // Display the equalized image\n    cv::imshow(\"Equalized Image\", equalized_image);\n}\n\n// Main function for histogram equalization\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply histogram equalization\n        apply_histogram_equalization(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for converting an image to grayscale using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the grayscale conversion.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to convert image to grayscale\nvoid convert_to_grayscale(cv::Mat &frame) {\n    cv::Mat gray_image;\n\n    // Convert the frame to grayscale\n    cv::cvtColor(frame, gray_image, cv::COLOR_BGR2GRAY);\n\n    // Display the grayscale image\n    cv::imshow(\"Grayscale Image\", gray_image);\n}\n\n// Main function to process the image\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Convert the frame to grayscale\n        convert_to_grayscale(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting contours in an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and add detailed comments explaining the contour detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to detect contours in the image\nvoid detect_contours(cv::Mat &frame) {\n    cv::Mat gray, edges, contour_image;\n\n    // Convert the image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Canny(gray, edges, 100, 200);\n\n    // Find contours in the edge-detected image\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(edges, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw contours on the original frame\n    frame.copyTo(contour_image);\n    cv::drawContours(contour_image, contours, -1, cv::Scalar(0, 255, 0), 2);\n\n    // Display the contours\n    cv::imshow(\"Contours\", contour_image);\n}\n\n// Main function for contour detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect and draw contours in the frame\n        detect_contours(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for applying Gaussian blur to an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the Gaussian blur process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to apply Gaussian blur to an image\nvoid apply_gaussian_blur(cv::Mat &frame) {\n    cv::Mat blurred_image;\n\n    // Apply Gaussian blur to the image\n    cv::GaussianBlur(frame, blurred_image, cv::Size(15, 15), 0);\n\n    // Display the blurred image\n    cv::imshow(\"Blurred Image\", blurred_image);\n}\n\n// Main function for image blurring\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply Gaussian blur to the frame\n        apply_gaussian_blur(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for adjusting the brightness of an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the brightness adjustment.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to adjust the brightness of an image\nvoid adjust_brightness(cv::Mat &frame, double alpha, int beta) {\n    cv::Mat adjusted_frame;\n\n    // Adjust the brightness and contrast of the frame\n    frame.convertTo(adjusted_frame, -1, alpha, beta);\n\n    // Display the adjusted image\n    cv::imshow(\"Brightness Adjusted Image\", adjusted_frame);\n}\n\n// Main function for brightness adjustment\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Adjust the brightness of the frame\n        adjust_brightness(frame, 1.2, 50);  // Increase brightness by 1.2 and add 50 to all pixels\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for calculating the color histogram of an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the histogram calculation process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to calculate and display the color histogram of an image\nvoid calculate_histogram(cv::Mat &frame) {\n    cv::Mat hist_red, hist_green, hist_blue;\n\n    // Convert the image to separate channels (BGR)\n    std::vector<cv::Mat> channels(3);\n    cv::split(frame, channels);\n\n    // Calculate histograms for each color channel\n    int hist_size = 256;  // Number of bins\n    float range[] = { 0, 256 };  // Range of pixel values\n    const float *hist_range = { range };\n\n    cv::calcHist(&channels[0], 1, 0, cv::Mat(), hist_blue, 1, &hist_size, &hist_range);\n    cv::calcHist(&channels[1], 1, 0, cv::Mat(), hist_green, 1, &hist_size, &hist_range);\n    cv::calcHist(&channels[2], 1, 0, cv::Mat(), hist_red, 1, &hist_size, &hist_range);\n\n    // Display histograms\n    cv::imshow(\"Blue Histogram\", hist_blue);\n    cv::imshow(\"Green Histogram\", hist_green);\n    cv::imshow(\"Red Histogram\", hist_red);\n}\n\n// Main function to calculate and display the color histogram\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Calculate and display the color histogram\n        calculate_histogram(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a temperature-based fan control system that turns the vehicle's cooling fan on when the engine temperature exceeds a defined threshold.",
      "input": "Ensure MISRA compliance in temperature data handling, type safety, and control logic. Include comments explaining how temperature is monitored and how fan control is managed.",
      "output": "#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Temperature threshold for fan control\nconst float fan_on_threshold = 90.0f;  // Temperature in Celsius at which the fan turns on\n\n// Function to simulate reading engine temperature\nfloat read_engine_temperature() {\n    return 95.0f;  // Simulated engine temperature\n}\n\n// Function to control cooling fan based on engine temperature\nvoid control_fan(float temperature) {\n    if (temperature > fan_on_threshold) {\n        std::cout << \"Turning cooling fan ON.\" << std::endl;\n    } else {\n        std::cout << \"Cooling fan OFF.\" << std::endl;\n    }\n}\n\n// Main function to monitor engine temperature and control fan\nint main() {\n    float temperature = read_engine_temperature();  // Read engine temperature\n    control_fan(temperature);  // Control fan based on temperature\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing (OpenCV library)\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction (camera calibration)\nconst float focal_length_y = 995.0f;   // Focal length in Y direction (camera calibration)\nconst float optical_center_x = 960.0f; // Optical center in X (camera calibration)\nconst float optical_center_y = 536.0f; // Optical center in Y (camera calibration)\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object (in meters)\n    std::string label;      // Label of the object (e.g., 'car', 'truck')\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing object detection using the YOLO (You Only Look Once) model with OpenCV. The system should load a pre-trained YOLO model, detect objects in a video stream, and display bounding boxes around them. Ensure the code handles errors like missing model files and improper input.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and provide comments explaining each step in loading the model, detecting objects, and handling errors.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n#include <string>                // For string manipulation\n\n// Function to perform object detection using YOLO\nvoid detect_objects(cv::Mat &frame) {\n    // Load YOLO model (ensure proper path and error handling)\n    cv::dnn::Net net = cv::dnn::readNetFromDarknet(\"yolov3.cfg\", \"yolov3.weights\");\n    if (net.empty()) {\n        std::cerr << \"ERROR: Failed to load YOLO model!\" << std::endl;\n        return;\n    }\n\n    // Prepare input image\n    cv::Mat blob;\n    cv::dnn::blobFromImage(frame, blob, 1.0/255.0, cv::Size(416, 416), cv::Scalar(0, 0, 0), true, false);\n    net.setInput(blob);\n\n    // Get detections\n    std::vector<cv::Mat> outputs;\n    net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n    // Process detections and draw bounding boxes\n    for (auto &output : outputs) {\n        // Each detection (dummy loop for simplicity)\n        cv::Rect detected_object(100, 100, 100, 100);  // Example bounding box\n        cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main loop to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform object detection\n        detect_objects(frame);\n\n        // Display frame\n        cv::imshow(\"Object Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for lane detection in road images using OpenCV. The system should detect lane lines and highlight them in the image. It should also display a warning if the vehicle drifts out of the lane.",
      "input": "Ensure compliance with MISRA standards: avoid implicit type conversions, do not use 'using namespace', and add detailed comments explaining the steps for lane detection using edge detection and Hough transforms.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for lane detection\nvoid detect_lane(cv::Mat &frame) {\n    // Convert image to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Gaussian blur to reduce noise\n    cv::Mat blurred;\n    cv::GaussianBlur(gray, blurred, cv::Size(5, 5), 0);\n\n    // Apply Canny edge detection\n    cv::Mat edges;\n    cv::Canny(blurred, edges, 50, 150);\n\n    // Apply Hough Line Transform to detect lines\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI/180, 100, 50, 10);\n\n    // Draw detected lane lines\n    for (size_t i = 0; i < lines.size(); i++) {\n        cv::Vec4i l = lines[i];\n        cv::line(frame, cv::Point(l[0], l[1]), cv::Point(l[2], l[3]), cv::Scalar(0, 255, 0), 3, 8);\n    }\n}\n\n// Main function for lane detection in video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform lane detection\n        detect_lane(frame);\n\n        // Display frame\n        cv::imshow(\"Lane Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for estimating the speed of a vehicle based on frame-by-frame movement in a video using optical flow techniques with OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle all types explicitly, avoid unsafe operations, and include comments explaining the optical flow calculation and speed estimation process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cmath>                 // For mathematical operations\n#include <cstdlib>               // For system operations\n\n// Function for estimating vehicle speed\nfloat estimate_speed(const cv::Mat &prev_frame, const cv::Mat &curr_frame) {\n    std::vector<cv::Point2f> prev_points, curr_points;\n    cv::goodFeaturesToTrack(prev_frame, prev_points, 100, 0.3, 7);\n\n    std::vector<uchar> status;\n    std::vector<float> error;\n    cv::calcOpticalFlowPyrLK(prev_frame, curr_frame, prev_points, curr_points, status, error);\n\n    float total_distance = 0.0f;\n    int count = 0;\n    for (size_t i = 0; i < prev_points.size(); i++) {\n        if (status[i]) {\n            total_distance += cv::norm(curr_points[i] - prev_points[i]);\n            count++;\n        }\n    }\n\n    return (count > 0) ? (total_distance / count) : 0.0f;\n}\n\n// Main function for speed estimation\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat prev_frame, curr_frame;\n    cap >> prev_frame;  // Capture the first frame\n    while (true) {\n        cap >> curr_frame;  // Capture the next frame\n        if (curr_frame.empty()) {\n            break;\n        }\n\n        // Estimate speed between frames\n        float speed = estimate_speed(prev_frame, curr_frame);\n        std::cout << \"Vehicle Speed: \" << speed << \" m/s\" << std::endl;\n\n        // Show frame\n        cv::imshow(\"Speed Estimation\", curr_frame);\n\n        prev_frame = curr_frame;\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for pedestrian detection using OpenCV's pre-trained Haar cascade classifier. The system should detect pedestrians in a video stream and trigger an alert if a pedestrian is detected within a certain distance.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid 'namespace', and provide detailed comments explaining each step in the pedestrian detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for pedestrian detection\nvoid detect_pedestrians(cv::Mat &frame) {\n    // Load pre-trained Haar cascade classifier\n    cv::CascadeClassifier pedestrian_cascade;\n    if (!pedestrian_cascade.load(\"haarcascade_fullbody.xml\")) {\n        std::cerr << \"ERROR: Could not load Haar cascade!\" << std::endl;\n        return;\n    }\n\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect pedestrians\n    std::vector<cv::Rect> pedestrians;\n    pedestrian_cascade.detectMultiScale(gray, pedestrians, 1.1, 3, 0, cv::Size(30, 30));\n\n    // Draw bounding boxes around detected pedestrians\n    for (size_t i = 0; i < pedestrians.size(); i++) {\n        cv::rectangle(frame, pedestrians[i], cv::Scalar(0, 255, 0), 2);\n    }\n}\n\n// Main function to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect pedestrians\n        detect_pedestrians(frame);\n\n        // Display frame\n        cv::imshow(\"Pedestrian Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for obstacle avoidance in a robot using OpenCV and basic distance sensors. The system should detect obstacles and steer the robot accordingly to avoid collisions.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add comments explaining each step of the obstacle detection and avoidance logic.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cmath>                 // For mathematical calculations\n#include <cstdlib>               // For system operations\n\n// Function to check for obstacles\nbool check_for_obstacles(const cv::Mat &frame) {\n    // Dummy obstacle detection (replace with actual sensor input)\n    cv::Rect obstacle(100, 100, 50, 50);  // Example bounding box for an obstacle\n\n    return (cv::countNonZero(frame(obstacle)) > 0);\n}\n\n// Function for obstacle avoidance\nvoid avoid_obstacles(cv::Mat &frame) {\n    if (check_for_obstacles(frame)) {\n        std::cout << \"Obstacle detected! Steering robot to avoid.\" << std::endl;\n        // Code to steer robot\n    }\n}\n\n// Main function for robot navigation\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Avoid obstacles\n        avoid_obstacles(frame);\n\n        // Display frame\n        cv::imshow(\"Obstacle Avoidance\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting faces in a video stream using OpenCV's pre-trained Haar cascade classifier. The system should detect faces, draw bounding boxes around them, and display the results.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining each step in the face detection process using Haar cascade classifiers.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for face detection\nvoid detect_faces(cv::Mat &frame) {\n    // Load pre-trained Haar cascade classifier for face detection\n    cv::CascadeClassifier face_cascade;\n    if (!face_cascade.load(\"haarcascade_frontalface_default.xml\")) {\n        std::cerr << \"ERROR: Could not load Haar cascade for face detection!\" << std::endl;\n        return;\n    }\n\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect faces\n    std::vector<cv::Rect> faces;\n    face_cascade.detectMultiScale(gray, faces, 1.1, 3, 0, cv::Size(30, 30));\n\n    // Draw bounding boxes around detected faces\n    for (size_t i = 0; i < faces.size(); i++) {\n        cv::rectangle(frame, faces[i], cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main function to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect faces\n        detect_faces(frame);\n\n        // Display frame\n        cv::imshow(\"Face Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting motion in a video stream using frame differencing. The system should highlight moving objects and display the motion regions on the screen.",
      "input": "Ensure compliance with MISRA standards: avoid implicit type conversions, do not use 'namespace', and provide detailed comments explaining each step in motion detection and highlighting moving objects.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for motion detection\nvoid detect_motion(cv::Mat &frame, cv::Mat &prev_frame) {\n    // Convert current frame to grayscale\n    cv::Mat gray, diff, thresh;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::absdiff(prev_frame, gray, diff);  // Compute absolute difference between current and previous frame\n\n    // Apply threshold to highlight moving objects\n    cv::threshold(diff, thresh, 25, 255, cv::THRESH_BINARY);\n\n    // Find contours of the moving regions\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(thresh, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw bounding boxes around moving objects\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::Rect bounding_box = cv::boundingRect(contours[i]);\n        cv::rectangle(frame, bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main function for motion detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame, prev_frame;\n    cap >> prev_frame;  // Capture the first frame\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect motion\n        detect_motion(frame, prev_frame);\n\n        // Display frame\n        cv::imshow(\"Motion Detection\", frame);\n\n        prev_frame = frame;\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for color-based object detection in a video stream. The system should detect objects based on their color in the image and highlight them with bounding boxes.",
      "input": "Ensure compliance with MISRA standards: handle all type conversions explicitly, avoid using 'namespace', and provide comments explaining each step of the color detection process using HSV filtering.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for color-based object detection\nvoid detect_color_objects(cv::Mat &frame) {\n    // Convert image to HSV color space\n    cv::Mat hsv;\n    cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV);\n\n    // Define color range for detection (e.g., detecting red color)\n    cv::Scalar lower_red(0, 120, 70);\n    cv::Scalar upper_red(10, 255, 255);\n\n    // Threshold image to extract objects of the desired color\n    cv::Mat mask;\n    cv::inRange(hsv, lower_red, upper_red, mask);\n\n    // Find contours of the detected objects\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw bounding boxes around detected objects\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::Rect bounding_box = cv::boundingRect(contours[i]);\n        cv::rectangle(frame, bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Main function for color-based object detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect color-based objects\n        detect_color_objects(frame);\n\n        // Display frame\n        cv::imshow(\"Color-based Object Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform image smoothing using a Gaussian filter with OpenCV. The system should apply the filter to reduce noise and display the result.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle all type conversions explicitly, and include comments explaining the Gaussian filtering process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for applying Gaussian filter for image smoothing\nvoid apply_gaussian_filter(cv::Mat &frame) {\n    // Apply Gaussian blur to the image to reduce noise\n    cv::Mat smoothed_frame;\n    cv::GaussianBlur(frame, smoothed_frame, cv::Size(5, 5), 0);\n\n    // Display smoothed image\n    cv::imshow(\"Smoothed Image\", smoothed_frame);\n}\n\n// Main function for image smoothing\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply Gaussian filter for smoothing\n        apply_gaussian_filter(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting edges in an image using the Canny edge detection algorithm. The system should highlight edges and display the result.",
      "input": "Ensure compliance with MISRA standards: avoid 'namespace', handle type conversions explicitly, and provide detailed comments explaining the Canny edge detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for edge detection using the Canny algorithm\nvoid detect_edges(cv::Mat &frame) {\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Mat edges;\n    cv::Canny(gray, edges, 100, 200);  // Detect edges with low and high thresholds\n\n    // Display the edges\n    cv::imshow(\"Edge Detection\", edges);\n}\n\n// Main function for edge detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect edges\n        detect_edges(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform histogram equalization on an image. The system should improve the contrast of the image by redistributing its intensity histogram.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and provide detailed comments explaining each step of histogram equalization.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for histogram equalization\nvoid apply_histogram_equalization(cv::Mat &frame) {\n    // Convert the frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply histogram equalization to enhance the contrast\n    cv::Mat equalized_frame;\n    cv::equalizeHist(gray, equalized_frame);\n\n    // Display the equalized image\n    cv::imshow(\"Equalized Image\", equalized_frame);\n}\n\n// Main function for histogram equalization\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply histogram equalization\n        apply_histogram_equalization(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform template matching for object detection in an image using OpenCV. The system should find the template image within the input image and highlight the detected region.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add detailed comments explaining each step of template matching.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for template matching\nvoid template_matching(cv::Mat &frame, cv::Mat &template_image) {\n    // Perform template matching using the CV_TM_CCOEFF_NORMED method\n    cv::Mat result;\n    cv::matchTemplate(frame, template_image, result, cv::TM_CCOEFF_NORMED);\n\n    // Find the best match location\n    double min_val, max_val;\n    cv::Point min_loc, max_loc;\n    cv::minMaxLoc(result, &min_val, &max_val, &min_loc, &max_loc);\n\n    // Draw a rectangle around the detected object\n    cv::rectangle(frame, max_loc, cv::Point(max_loc.x + template_image.cols, max_loc.y + template_image.rows), cv::Scalar(0, 255, 0), 2);\n}\n\n// Main function for template matching\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame, template_image;\n    template_image = cv::imread(\"template.png\", cv::IMREAD_GRAYSCALE);  // Load the template image\n    if (template_image.empty()) {\n        std::cerr << \"ERROR: Could not load template image!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform template matching\n        template_matching(frame, template_image);\n\n        // Display frame\n        cv::imshow(\"Template Matching\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for optical flow estimation using the Lucas-Kanade method in OpenCV. The system should track the motion of points across consecutive frames.",
      "input": "Ensure compliance with MISRA standards: handle all type conversions explicitly, avoid using 'namespace', and provide comments explaining the optical flow calculation.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to calculate optical flow\nvoid calculate_optical_flow(cv::Mat &frame1, cv::Mat &frame2) {\n    std::vector<cv::Point2f> points1, points2;\n    std::vector<uchar> status;\n    std::vector<float> err;\n\n    // Detect good features to track in the first frame\n    cv::goodFeaturesToTrack(frame1, points1, 100, 0.01, 10);\n\n    // Calculate optical flow (i.e., track points from frame1 to frame2)\n    cv::calcOpticalFlowPyrLK(frame1, frame2, points1, points2, status, err);\n\n    // Draw tracks\n    for (size_t i = 0; i < points2.size(); i++) {\n        if (status[i]) {\n            cv::circle(frame2, points2[i], 5, cv::Scalar(0, 255, 0), -1);  // Draw circle for tracked points\n        }\n    }\n}\n\n// Main function to process optical flow\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame1, frame2;\n    cap >> frame1;  // Capture the first frame\n    while (true) {\n        cap >> frame2;\n        if (frame2.empty()) {\n            break;\n        }\n\n        // Calculate optical flow between frame1 and frame2\n        calculate_optical_flow(frame1, frame2);\n\n        // Display frame with optical flow\n        cv::imshow(\"Optical Flow\", frame2);\n\n        frame1 = frame2;\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for face recognition using Eigenfaces. The system should perform principal component analysis (PCA) on face images to recognize faces.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and provide detailed comments explaining each step in the Eigenfaces-based face recognition.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n#include <opencv2/contrib/contrib.hpp>  // For Eigenfaces method\n\n// Function to train the face recognizer using Eigenfaces\nvoid train_face_recognizer(const std::vector<cv::Mat> &images, const std::vector<int> &labels) {\n    // Create and train an Eigenfaces model\n    cv::Ptr<cv::face::FaceRecognizer> model = cv::face::EigenFaceRecognizer::create();\n    model->train(images, labels);\n    std::cout << \"Training completed!\" << std::endl;\n}\n\n// Main function for face recognition\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    std::vector<cv::Mat> images;\n    std::vector<int> labels;\n\n    // Collect training data (here just for illustration, in practice, you would load actual images)\n    for (int i = 0; i < 10; i++) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        images.push_back(frame);\n        labels.push_back(i);  // Dummy label for training\n    }\n\n    // Train the face recognizer\n    train_face_recognizer(images, labels);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for image thresholding to convert an image into binary form, separating foreground from background.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and add comments explaining the thresholding process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for applying simple thresholding\nvoid apply_thresholding(cv::Mat &frame) {\n    cv::Mat gray, binary;\n\n    // Convert frame to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply binary thresholding\n    cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);\n\n    // Display the binary image\n    cv::imshow(\"Binary Image\", binary);\n}\n\n// Main function to apply thresholding\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply thresholding\n        apply_thresholding(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing geometric transformations such as rotation and scaling on an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and provide comments explaining each transformation step.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to perform geometric transformations\nvoid perform_transformations(cv::Mat &frame) {\n    // Scaling transformation\n    cv::Mat scaled_frame;\n    cv::resize(frame, scaled_frame, cv::Size(), 0.5, 0.5);\n\n    // Rotation transformation\n    cv::Mat rotated_frame;\n    cv::Point2f center(frame.cols / 2, frame.rows / 2);\n    cv::Mat rotation_matrix = cv::getRotationMatrix2D(center, 45, 1);\n    cv::warpAffine(frame, rotated_frame, rotation_matrix, frame.size());\n\n    // Display transformed images\n    cv::imshow(\"Scaled Image\", scaled_frame);\n    cv::imshow(\"Rotated Image\", rotated_frame);\n}\n\n// Main function to apply transformations\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply geometric transformations\n        perform_transformations(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting contours in an image. The system should find and display the contours detected in the image.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining contour detection.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for contour detection\nvoid detect_contours(cv::Mat &frame) {\n    // Convert image to grayscale\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Canny(gray, edges, 100, 200);\n\n    // Find contours\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(edges, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw contours\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::drawContours(frame, contours, (int)i, cv::Scalar(0, 255, 0), 2);\n    }\n}\n\n// Main function for contour detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect contours\n        detect_contours(frame);\n\n        // Display frame\n        cv::imshow(\"Contours\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for converting an image from the RGB color space to the HSV color space using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle all type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the color space conversion.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to convert an image from RGB to HSV\nvoid convert_rgb_to_hsv(cv::Mat &frame) {\n    // Convert RGB to HSV\n    cv::Mat hsv_frame;\n    cv::cvtColor(frame, hsv_frame, cv::COLOR_BGR2HSV);\n\n    // Display the HSV image\n    cv::imshow(\"HSV Image\", hsv_frame);\n}\n\n// Main function to perform RGB to HSV conversion\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Convert the frame to HSV\n        convert_rgb_to_hsv(frame);\n\n        // Display original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for object tracking using a Kalman filter. The system should track the motion of an object across multiple frames.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the Kalman filter-based tracking.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to initialize Kalman filter\ncv::KalmanFilter init_kalman_filter() {\n    cv::KalmanFilter kf(4, 2, 0);  // State is (x, y, dx, dy) and measurement is (x, y)\n\n    kf.transitionMatrix = (cv::Mat_<float>(4, 4) << 1, 0, 1, 0,\n                                                   0, 1, 0, 1,\n                                                   0, 0, 1, 0,\n                                                   0, 0, 0, 1);\n\n    kf.measurementMatrix = (cv::Mat_<float>(2, 4) << 1, 0, 0, 0,\n                                                      0, 1, 0, 0);\n\n    kf.processNoiseCov = cv::Mat::eye(4, 4, CV_32F) * 1e-4;\n    kf.measurementNoiseCov = cv::Mat::eye(2, 2, CV_32F) * 1e-1;\n    kf.errorCovPost = cv::Mat::eye(4, 4, CV_32F);\n\n    return kf;\n}\n\n// Function to track the object using Kalman filter\nvoid track_object(cv::KalmanFilter &kf, cv::Mat &frame, cv::Point2f &measured_point) {\n    // Predict the next state\n    cv::Mat prediction = kf.predict();\n    cv::Point predicted_point(prediction.at<float>(0), prediction.at<float>(1));\n\n    // Update the Kalman filter with the new measurement\n    cv::Mat measurement = (cv::Mat_<float>(2, 1) << measured_point.x, measured_point.y);\n    kf.correct(measurement);\n\n    // Draw the predicted point\n    cv::circle(frame, predicted_point, 10, cv::Scalar(0, 255, 0), -1);\n}\n\n// Main function for object tracking with Kalman filter\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Point2f object_position(100, 100);  // Initial position of the object\n\n    cv::KalmanFilter kf = init_kalman_filter();\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Track the object\n        track_object(kf, frame, object_position);\n\n        // Display the frame\n        cv::imshow(\"Object Tracking\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting lines in an image using the Hough Line Transform.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and add comments explaining each step of the Hough Line Transform.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for Hough Line Transform\nvoid detect_lines(cv::Mat &frame) {\n    cv::Mat gray, edges;\n\n    // Convert image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Canny(gray, edges, 50, 150);\n\n    // Apply Hough Line Transform\n    std::vector<cv::Vec2f> lines;\n    cv::HoughLines(edges, lines, 1, CV_PI / 180, 100);\n\n    // Draw lines on the original image\n    for (size_t i = 0; i < lines.size(); i++) {\n        float rho = lines[i][0];\n        float theta = lines[i][1];\n        cv::Point pt1, pt2;\n        double a = cos(theta), b = sin(theta);\n        double x0 = a * rho, y0 = b * rho;\n        pt1.x = cvRound(x0 + 1000 * (-b));\n        pt1.y = cvRound(y0 + 1000 * (a));\n        pt2.x = cvRound(x0 - 1000 * (-b));\n        pt2.y = cvRound(y0 - 1000 * (a));\n        cv::line(frame, pt1, pt2, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function for Hough Line Transform\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect lines in the frame\n        detect_lines(frame);\n\n        // Display the frame with detected lines\n        cv::imshow(\"Hough Line Transform\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting red objects in an image by applying color filtering in the HSV color space.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add detailed comments for each step in the color filtering process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to detect red objects using color filtering\nvoid detect_red_objects(cv::Mat &frame) {\n    cv::Mat hsv_frame, mask;\n\n    // Convert image to HSV\n    cv::cvtColor(frame, hsv_frame, cv::COLOR_BGR2HSV);\n\n    // Define range for red color in HSV space\n    cv::Scalar lower_red(0, 120, 70);\n    cv::Scalar upper_red(10, 255, 255);\n\n    // Apply the mask to detect red objects\n    cv::inRange(hsv_frame, lower_red, upper_red, mask);\n\n    // Find contours of the red objects\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw contours around detected red objects\n    for (size_t i = 0; i < contours.size(); i++) {\n        cv::drawContours(frame, contours, (int)i, cv::Scalar(0, 255, 0), 2);\n    }\n}\n\n// Main function for red object detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect red objects\n        detect_red_objects(frame);\n\n        // Display the frame with red objects detected\n        cv::imshow(\"Red Object Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for template matching in images. The system should locate a template image within a larger frame.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and add comments explaining the template matching process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for template matching\nvoid template_matching(cv::Mat &frame, cv::Mat &template_img) {\n    cv::Mat result;\n\n    // Perform template matching\n    cv::matchTemplate(frame, template_img, result, cv::TM_CCOEFF_NORMED);\n\n    // Find the location of the best match\n    cv::Point max_loc;\n    cv::minMaxLoc(result, NULL, NULL, NULL, &max_loc);\n\n    // Draw a rectangle around the matched region\n    cv::rectangle(frame, max_loc, cv::Point(max_loc.x + template_img.cols, max_loc.y + template_img.rows), cv::Scalar(0, 255, 0), 2);\n}\n\n// Main function for template matching\nint main() {\n    cv::Mat template_img = cv::imread(\"template.png\");  // Load template image\n    if (template_img.empty()) {\n        std::cout << \"ERROR: Could not load template image!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Perform template matching\n        template_matching(frame, template_img);\n\n        // Display the frame\n        cv::imshow(\"Template Matching\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for edge detection using the Sobel operator.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the Sobel edge detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for edge detection using Sobel operator\nvoid detect_edges(cv::Mat &frame) {\n    cv::Mat gray, grad_x, grad_y, abs_grad_x, abs_grad_y, edge_image;\n\n    // Convert image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Sobel operator to find gradients in X and Y directions\n    cv::Sobel(gray, grad_x, CV_16S, 1, 0, 3);\n    cv::Sobel(gray, grad_y, CV_16S, 0, 1, 3);\n\n    // Convert gradients to absolute values\n    cv::convertScaleAbs(grad_x, abs_grad_x);\n    cv::convertScaleAbs(grad_y, abs_grad_y);\n\n    // Combine the gradients\n    cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, edge_image);\n\n    // Display the edge image\n    cv::imshow(\"Edge Detection\", edge_image);\n}\n\n// Main function for edge detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect edges in the frame\n        detect_edges(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting blobs (connected regions of pixels) in an image using OpenCV's SimpleBlobDetector.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the blob detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <opencv2/features2d.hpp>  // For blob detection\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for blob detection\nvoid detect_blobs(cv::Mat &frame) {\n    // Convert image to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect blobs using SimpleBlobDetector\n    cv::SimpleBlobDetector::Params params;\n    params.filterByArea = true;\n    params.minArea = 100;\n    cv::Ptr<cv::SimpleBlobDetector> detector = cv::SimpleBlobDetector::create(params);\n\n    std::vector<cv::KeyPoint> keypoints;\n    detector->detect(gray, keypoints);\n\n    // Draw detected blobs on the original frame\n    cv::drawKeypoints(frame, keypoints, frame, cv::Scalar(0, 255, 0), cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);\n}\n\n// Main function for blob detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect blobs in the frame\n        detect_blobs(frame);\n\n        // Display the frame with detected blobs\n        cv::imshow(\"Blob Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for performing histogram equalization to improve image contrast.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the histogram equalization process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function for histogram equalization\nvoid apply_histogram_equalization(cv::Mat &frame) {\n    cv::Mat gray, equalized_image;\n\n    // Convert image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply histogram equalization\n    cv::equalizeHist(gray, equalized_image);\n\n    // Display the equalized image\n    cv::imshow(\"Equalized Image\", equalized_image);\n}\n\n// Main function for histogram equalization\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply histogram equalization\n        apply_histogram_equalization(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for converting an image to grayscale using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the grayscale conversion.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to convert image to grayscale\nvoid convert_to_grayscale(cv::Mat &frame) {\n    cv::Mat gray_image;\n\n    // Convert the frame to grayscale\n    cv::cvtColor(frame, gray_image, cv::COLOR_BGR2GRAY);\n\n    // Display the grayscale image\n    cv::imshow(\"Grayscale Image\", gray_image);\n}\n\n// Main function to process the image\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Convert the frame to grayscale\n        convert_to_grayscale(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting contours in an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and add detailed comments explaining the contour detection process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to detect contours in the image\nvoid detect_contours(cv::Mat &frame) {\n    cv::Mat gray, edges, contour_image;\n\n    // Convert the image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Canny(gray, edges, 100, 200);\n\n    // Find contours in the edge-detected image\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(edges, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // Draw contours on the original frame\n    frame.copyTo(contour_image);\n    cv::drawContours(contour_image, contours, -1, cv::Scalar(0, 255, 0), 2);\n\n    // Display the contours\n    cv::imshow(\"Contours\", contour_image);\n}\n\n// Main function for contour detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Detect and draw contours in the frame\n        detect_contours(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for applying Gaussian blur to an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the Gaussian blur process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to apply Gaussian blur to an image\nvoid apply_gaussian_blur(cv::Mat &frame) {\n    cv::Mat blurred_image;\n\n    // Apply Gaussian blur to the image\n    cv::GaussianBlur(frame, blurred_image, cv::Size(15, 15), 0);\n\n    // Display the blurred image\n    cv::imshow(\"Blurred Image\", blurred_image);\n}\n\n// Main function for image blurring\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply Gaussian blur to the frame\n        apply_gaussian_blur(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for adjusting the brightness of an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the brightness adjustment.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to adjust the brightness of an image\nvoid adjust_brightness(cv::Mat &frame, double alpha, int beta) {\n    cv::Mat adjusted_frame;\n\n    // Adjust the brightness and contrast of the frame\n    frame.convertTo(adjusted_frame, -1, alpha, beta);\n\n    // Display the adjusted image\n    cv::imshow(\"Brightness Adjusted Image\", adjusted_frame);\n}\n\n// Main function for brightness adjustment\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Adjust the brightness of the frame\n        adjust_brightness(frame, 1.2, 50);  // Increase brightness by 1.2 and add 50 to all pixels\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for calculating the color histogram of an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the histogram calculation process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to calculate and display the color histogram of an image\nvoid calculate_histogram(cv::Mat &frame) {\n    cv::Mat hist_red, hist_green, hist_blue;\n\n    // Convert the image to separate channels (BGR)\n    std::vector<cv::Mat> channels(3);\n    cv::split(frame, channels);\n\n    // Calculate histograms for each color channel\n    int hist_size = 256;  // Number of bins\n    float range[] = { 0, 256 };  // Range of pixel values\n    const float *hist_range = { range };\n\n    cv::calcHist(&channels[0], 1, 0, cv::Mat(), hist_blue, 1, &hist_size, &hist_range);\n    cv::calcHist(&channels[1], 1, 0, cv::Mat(), hist_green, 1, &hist_size, &hist_range);\n    cv::calcHist(&channels[2], 1, 0, cv::Mat(), hist_red, 1, &hist_size, &hist_range);\n\n    // Display histograms\n    cv::imshow(\"Blue Histogram\", hist_blue);\n    cv::imshow(\"Green Histogram\", hist_green);\n    cv::imshow(\"Red Histogram\", hist_red);\n}\n\n// Main function to calculate and display the color histogram\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Calculate and display the color histogram\n        calculate_histogram(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for calculating the color histogram of an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the histogram calculation process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to calculate and display the color histogram of an image\nvoid calculate_histogram(cv::Mat &frame) {\n    cv::Mat hist_red, hist_green, hist_blue;\n\n    // Convert the image to separate channels (BGR)\n    std::vector<cv::Mat> channels(3);\n    cv::split(frame, channels);\n\n    // Calculate histograms for each color channel\n    int hist_size = 256;  // Number of bins\n    float range[] = { 0, 256 };  // Range of pixel values\n    const float *hist_range = { range };\n\n    cv::calcHist(&channels[0], 1, 0, cv::Mat(), hist_blue, 1, &hist_size, &hist_range);\n    cv::calcHist(&channels[1], 1, 0, cv::Mat(), hist_green, 1, &hist_size, &hist_range);\n    cv::calcHist(&channels[2], 1, 0, cv::Mat(), hist_red, 1, &hist_size, &hist_range);\n\n    // Display histograms\n    cv::imshow(\"Blue Histogram\", hist_blue);\n    cv::imshow(\"Green Histogram\", hist_green);\n    cv::imshow(\"Red Histogram\", hist_red);\n}\n\n// Main function to calculate and display the color histogram\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Calculate and display the color histogram\n        calculate_histogram(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for rotating an image by a specified angle using OpenCV.",
      "input": "Ensure compliance with MISRA standards: avoid using 'namespace', handle type conversions explicitly, and include detailed comments explaining the rotation process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to rotate an image by a given angle\nvoid rotate_image(cv::Mat &frame, double angle) {\n    // Get the center of the image\n    cv::Point2f center(frame.cols / 2.0f, frame.rows / 2.0f);\n\n    // Compute the rotation matrix\n    cv::Mat rotation_matrix = cv::getRotationMatrix2D(center, angle, 1.0);\n\n    // Rotate the image\n    cv::Mat rotated_image;\n    cv::warpAffine(frame, rotated_image, rotation_matrix, frame.size());\n\n    // Display the rotated image\n    cv::imshow(\"Rotated Image\", rotated_image);\n}\n\n// Main function for rotating the image\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Rotate the frame by 45 degrees\n        rotate_image(frame, 45.0);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for thresholding an image using OpenCV.",
      "input": "Ensure compliance with MISRA standards: handle type conversions explicitly, avoid using 'namespace', and include detailed comments explaining the thresholding process.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations\n\n// Function to apply binary thresholding to an image\nvoid apply_thresholding(cv::Mat &frame) {\n    cv::Mat gray, thresholded_image;\n\n    // Convert the image to grayscale\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply binary thresholding\n    cv::threshold(gray, thresholded_image, 127, 255, cv::THRESH_BINARY);\n\n    // Display the thresholded image\n    cv::imshow(\"Thresholded Image\", thresholded_image);\n}\n\n// Main function for thresholding the image\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Apply thresholding to the frame\n        apply_thresholding(frame);\n\n        // Display the original frame\n        cv::imshow(\"Original Frame\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should detect objects, calculate their speed, estimate their distance, and trigger a warning if the object is too close or moving too fast. Detailed error handling and comments should be included for each step of the process.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and include detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV for image processing\n#include <iostream> // Include for input/output operations\n#include <cmath> // For mathematical operations like sqrt and pow\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string manipulation\n#include <vector> // For storing detected object data\n\n// Camera parameters\nconst float focal_length_x = 874.0f; // Focal length in X direction\nconst float focal_length_y = 995.0f; // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f; // Average car width (meters)\nconst float collision_threshold = 10.0f; // Collision warning threshold (meters)\n\n// Define a structure to store detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Estimated distance to the object\n    float speed;            // Estimated speed of the object\n    std::string label;      // Object label (e.g., \"car\", \"pedestrian\")\n};\n\n// Function to calculate the distance to an object based on its width in the image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to calculate the speed of the detected object (placeholder logic)\nfloat calculate_speed(cv::Rect previous_position, cv::Rect current_position, float time_interval) {\n    float distance_moved = sqrt(pow(current_position.x - previous_position.x, 2) + pow(current_position.y - previous_position.y, 2));\n    return distance_moved / time_interval;\n}\n\n// Function to process an image, detect objects, and compute distances and speed\nvoid process_image(cv::Mat &image, cv::Rect previous_position) {\n    cv::Rect detected_object(600, 400, 200, 100);  // Example detected object (bounding box)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate object width in pixels\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Estimate the object's speed (placeholder values)\n    obj.speed = calculate_speed(previous_position, detected_object, 0.5f);  // Assuming 0.5s interval for simplicity\n\n    // Draw bounding box on image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n\n    // Display distance and speed on the image\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    std::string speed_text = \"Speed: \" + std::to_string(obj.speed) + \" m/s\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    cv::putText(image, speed_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 25), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check if the object is too close or moving too fast and trigger a warning\n    if (obj.distance < collision_threshold || obj.speed > 15.0f) {\n        cv::putText(image, \"WARNING: COLLISION RISK\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function for video capture and object detection processing\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return error if camera or video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    cv::Rect previous_position(0, 0, 0, 0);  // Placeholder for previous position\n    while (true) {\n        cap >> frame;  // Capture a frame\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        // Process the captured frame for detection and distance estimation\n        process_image(frame, previous_position);\n\n        // Update previous position for next frame\n        previous_position = frame;  // Update with current frame position\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit loop if 'q' is pressed\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the video capture device\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should detect objects, calculate their distance and speed, and trigger a collision warning when an object is too close or moving too fast. Proper error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV for image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sqrt, pow)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For storing detected object data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Average car width (meters)\nconst float collision_threshold = 10.0f; // Collision warning threshold (meters)\n\n// Define a structure to store detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Estimated distance to the object\n    float speed;            // Estimated speed of the object\n    std::string label;      // Object label (e.g., \"car\", \"pedestrian\")\n};\n\n// Function to calculate the distance to an object based on its width in the image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to calculate the speed of the detected object (placeholder logic)\nfloat calculate_speed(cv::Rect previous_position, cv::Rect current_position, float time_interval) {\n    float distance_moved = sqrt(pow(current_position.x - previous_position.x, 2) + pow(current_position.y - previous_position.y, 2));\n    return distance_moved / time_interval;\n}\n\n// Function to process an image, detect objects, and compute distances and speed\nvoid process_image(cv::Mat &image, cv::Rect previous_position) {\n    cv::Rect detected_object(600, 400, 200, 100);  // Example detected object (bounding box)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate object width in pixels\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Estimate the object's speed (placeholder values)\n    obj.speed = calculate_speed(previous_position, detected_object, 0.5f);  // Assuming 0.5s interval for simplicity\n\n    // Draw bounding box on image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    std::string speed_text = \"Speed: \" + std::to_string(obj.speed) + \" m/s\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n    cv::putText(image, speed_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 25), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw speed text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold || obj.speed > 15.0f) {\n        cv::putText(image, \"WARNING: COLLISION RISK\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function for video capture and object detection processing\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return error if camera or video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    cv::Rect previous_position(0, 0, 0, 0);  // Placeholder for previous position\n    while (true) {\n        cap >> frame;  // Capture a frame\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        // Process the captured frame for detection and distance estimation\n        process_image(frame, previous_position);\n\n        // Update previous position for next frame\n        previous_position = frame;  // Update with current frame position\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit loop if 'q' is pressed\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the video capture device\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should detect objects using OpenCV, estimate their distances, and trigger a collision warning if the distance is below a threshold. The code should include proper error handling and detailed comments for each operation.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments.",
      "output": "#include <opencv2/opencv.hpp>  // For OpenCV functions\n#include <iostream>  // For I/O operations\n#include <cmath>  // For mathematical operations (e.g., sqrt)\n#include <cstdlib>  // For EXIT_FAILURE\n#include <vector>  // For storing detected objects\n#include <string>  // For string operations\n\n// Camera parameters\nconst float focal_length_x = 800.0f; // Focal length in X direction\nconst float focal_length_y = 800.0f; // Focal length in Y direction\nconst float car_width = 1.8f; // Car width in meters\nconst float collision_threshold = 10.0f; // Collision warning threshold\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Estimated distance\n    std::string label;      // Object label\n};\n\n// Function to calculate object distance\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distance\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to handle video input and process frames\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame);\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system that uses OpenCV to detect vehicles, calculates distances, and triggers a collision warning if the vehicle is within a critical distance. Include comments explaining each part of the code and proper error handling.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation.",
      "output": "#include <opencv2/opencv.hpp> // For image processing\n#include <iostream> // For input-output operations\n#include <cmath> // For mathematical operations\n#include <cstdlib> // For EXIT_FAILURE\n#include <string> // For string handling\n\n// Camera parameters\nconst float focal_length_x = 920.0f; // Focal length in X direction\nconst float focal_length_y = 920.0f; // Focal length in Y direction\nconst float car_width = 2.0f; // Car width in meters\nconst float collision_threshold = 12.0f; // Collision threshold (meters)\n\n// Object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the detected object\n    float distance;         // Estimated distance\n    std::string label;      // Object label (e.g., \"car\")\n};\n\n// Function to calculate distance to the object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process the image, detect objects, and calculate distance\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(500, 350, 180, 90); // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to process video feed\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture frame\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame); // Process frame\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame); // Show processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release video capture\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system that detects objects using OpenCV, calculates their distance, and triggers a warning when the object is too close. Include error handling and detailed comments for each operation.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV for image processing\n#include <iostream> // For input-output operations\n#include <cmath> // For mathematical functions like sqrt\n#include <cstdlib> // For EXIT_FAILURE\n#include <string> // For string manipulation\n#include <vector> // For storing detected objects\n\n// Camera parameters\nconst float focal_length_x = 900.0f; // Focal length in X direction\nconst float focal_length_y = 900.0f; // Focal length in Y direction\nconst float car_width = 2.0f; // Assumed car width (meters)\nconst float collision_threshold = 8.0f; // Collision threshold (meters)\n\n// Object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Estimated distance\n    std::string label;      // Object label\n};\n\n// Function to calculate distance to the object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image and detect objects\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(550, 450, 180, 90);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to handle video input and process each frame\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return error if camera/video cannot be opened\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame); // Process captured frame\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);  // Display the processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release video capture\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, calculate their distance using camera calibration, and trigger a warning if the distance is below a threshold. Proper error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For I/O operations\n#include <cmath>  // For mathematical operations (e.g., sqrt)\n#include <cstdlib>  // For EXIT_FAILURE\n#include <vector>  // For storing detected objects\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 900.0f; // Focal length in X direction\nconst float focal_length_y = 900.0f; // Focal length in Y direction\nconst float car_width = 2.0f; // Assumed car width in meters\nconst float collision_threshold = 12.0f; // Distance threshold for collision warning\n\n// Structure to store detected object information\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Distance to the object\n    std::string label;      // Object label (e.g., \"car\", \"pedestrian\")\n};\n\n// Function to calculate the distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 150, 75);  // Example bounding box (simulated)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n\n    // Draw distance text\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning if distance is below threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to handle video capture and object detection\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video capture device!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame);  // Process captured frame\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);  // Show processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release video capture device\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should use OpenCV to detect objects, estimate their distance, and display a collision warning when an object is too close. Include error handling and detailed comments for each operation.",
      "input": "Ensure MISRA 2023 compliance: avoid 'using namespace', handle all type conversions explicitly, and include detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV for image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., distance calculation)\n#include <cstdlib>  // For EXIT_FAILURE\n#include <string>  // For string manipulation\n#include <vector>  // For object detection data\n\n// Camera parameters\nconst float focal_length_x = 850.0f; // Focal length in X direction\nconst float focal_length_y = 850.0f; // Focal length in Y direction\nconst float car_width = 1.8f; // Car width (in meters)\nconst float collision_threshold = 8.0f; // Collision threshold (meters)\n\n// Structure for detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object's bounding box\n    float distance;         // Estimated distance\n    std::string label;      // Object label (e.g., \"car\", \"pedestrian\")\n};\n\n// Function to calculate the distance based on object width and camera parameters\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image and detect objects\nvoid process_image(cv::Mat &image) {\n    // Simulated detection (hardcoded for simplicity)\n    cv::Rect detected_object(500, 350, 180, 90);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate object width in image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Calculate distance\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Bounding box\n\n    // Draw distance on image\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check if distance is below threshold for collision warning\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to capture and process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open video capture device!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame);  // Process the frame\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release the camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using OpenCV. The code should detect objects, estimate the distance, and trigger a collision warning if an object is too close. Detailed comments and error handling should be included.",
      "input": "Ensure MISRA 2023 compliance: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV functions\n#include <iostream>  // I/O operations\n#include <cmath>  // Mathematical operations\n#include <cstdlib>  // For EXIT_FAILURE\n#include <vector>  // Storing detected objects\n#include <string>  // String manipulation\n\n// Camera calibration parameters\nconst float focal_length_x = 920.0f; // Focal length in X direction\nconst float focal_length_y = 920.0f; // Focal length in Y direction\nconst float car_width = 1.8f; // Car width (meters)\nconst float collision_threshold = 10.0f; // Threshold for collision warning (meters)\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for object\n    float distance;         // Distance to object\n    std::string label;      // Label of object\n};\n\n// Function to calculate distance to object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image, detect objects, and calculate distance\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection\n    cv::Rect detected_object(450, 350, 150, 75);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate width of the object in pixels\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw bounding box and distance\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning if distance is below threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function for video input and processing\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video capture device!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame);  // Process captured frame\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);  // Display frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release the video capture\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning if the object is too close. The code should include error handling and detailed comments.",
      "input": "Ensure MISRA 2023 compliance: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for image processing\n#include <iostream>  // For I/O operations\n#include <cmath>  // For mathematical functions\n#include <cstdlib>  // For EXIT_FAILURE\n#include <vector>  // For detected objects\n#include <string>  // String manipulation\n\n// Camera parameters\nconst float focal_length_x = 900.0f; // Focal length in X direction\nconst float focal_length_y = 900.0f; // Focal length in Y direction\nconst float car_width = 1.8f; // Car width in meters\nconst float collision_threshold = 10.0f; // Collision threshold (meters)\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box\n    float distance;         // Estimated distance\n    std::string label;      // Object label\n};\n\n// Function to calculate distance\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image and detect objects\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(500, 350, 150, 75);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to process video\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video capture!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame);  // Process frame\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);  // Display frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release video capture\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using OpenCV. The code should detect objects, compute their distance using the camera's parameters, and issue a warning if the distance is less than a threshold. Error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA 2023 standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV for image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical functions\n#include <cstdlib>  // For EXIT_FAILURE\n#include <string>  // For string operations\n#include <vector>  // For storing detected objects\n\n// Camera parameters\nconst float focal_length_x = 850.0f; // Focal length in X direction\nconst float focal_length_y = 850.0f; // Focal length in Y direction\nconst float car_width = 2.0f; // Car width in meters\nconst float collision_threshold = 8.0f; // Collision threshold (meters)\n\n// Detected object structure\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Distance to object\n    std::string label;      // Object label\n};\n\n// Function to calculate the distance\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process the image, detect objects, and calculate distances\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(550, 400, 180, 100);  // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to capture video and process frames\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera or video capture!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_image(frame);  // Process the frame\n\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);  // Display frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release video capture\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using stereo cameras in OpenCV. The code should detect vehicles, estimate their distance using stereo disparity, and trigger a warning if a vehicle is too close. Proper error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Stereo camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float baseline = 0.5f;             // Stereo camera baseline (meters)\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Function to calculate distance to an object using stereo disparity\nfloat calculate_distance(float disparity) {\n    // Calculate distance using disparity from stereo image pair\n    return (focal_length_x * baseline) / disparity;\n}\n\n// Function to process an image and detect objects\nvoid process_image(cv::Mat &image_left, cv::Mat &image_right) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box\n    float disparity = 0.2f;  // Example disparity value (in pixels)\n\n    // Estimate the distance to the object\n    float distance = calculate_distance(disparity);\n\n    // Draw bounding box and distance on the image\n    cv::rectangle(image_left, detected_object, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(distance) + \" m\";\n    cv::putText(image_left, distance_text, cv::Point(detected_object.x, detected_object.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1);\n\n    // Check for collision risk (if distance < threshold)\n    if (distance < collision_threshold) {\n        cv::putText(image_left, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle stereo camera input and process each frame\nint main() {\n    cv::VideoCapture cap_left(0), cap_right(1);  // Open stereo cameras\n    if (!cap_left.isOpened() || !cap_right.isOpened()) {\n        std::cout << \"ERROR: Could not open cameras!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if cameras cannot be opened\n    }\n\n    cv::Mat frame_left, frame_right;\n    while (true) {\n        cap_left >> frame_left;  // Capture frame from left camera\n        cap_right >> frame_right;  // Capture frame from right camera\n\n        if (frame_left.empty() || frame_right.empty()) {\n            break;  // Exit loop if frames are empty (end of video)\n        }\n\n        // Process the captured frames\n        process_image(frame_left, frame_right);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame_left);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap_left.release();  // Release left camera\n    cap_right.release();  // Release right camera\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using deep learning for object detection in OpenCV. The system should process each frame, detect objects, and trigger a warning if an object is too close. Proper error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <opencv2/dnn.hpp>  // For deep learning inference\n#include <iostream>  // For input-output operations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Load pre-trained deep learning model\ncv::dnn::Net net;\nvoid load_model(const std::string &model_path, const std::string &config_path) {\n    net = cv::dnn::readNet(model_path, config_path);\n}\n\n// Camera parameters\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\nconst float focal_length_x = 874.0f;   // Camera focal length in X direction\nconst float collision_threshold = 10.0f;\n\n// Function to process an image and detect objects\nvoid process_image(cv::Mat &image) {\n    if (image.empty()) {\n        std::cerr << \"ERROR: Empty image provided.\" << std::endl;\n        return;  // Exit processing if the image is empty\n    }\n\n    // Prepare the image for object detection\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, 1.0 / 255.0, cv::Size(416, 416));\n    net.setInput(blob);\n\n    // Perform inference\n    std::vector<cv::Mat> outputs;\n    net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n    // Loop through outputs and process each detection\n    for (const auto &output : outputs) {\n        for (int i = 0; i < output.rows; ++i) {\n            float *data = (float *) output.data + i * output.cols;\n            float confidence = data[4];\n            if (confidence > 0.5) {  // Only process high-confidence detections\n                int left = static_cast<int>(data[0] * image.cols);\n                int top = static_cast<int>(data[1] * image.rows);\n                int right = static_cast<int>(data[2] * image.cols);\n                int bottom = static_cast<int>(data[3] * image.rows);\n                // Calculate object width and estimate distance\n                int object_width_in_image = right - left;\n                float distance = (car_width * focal_length_x) / object_width_in_image;\n\n                // Draw bounding box\n                cv::rectangle(image, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 255, 0), 2);\n\n                // Display distance\n                std::string distance_text = \"Distance: \" + std::to_string(distance) + \" m\";\n                cv::putText(image, distance_text, cv::Point(left, top - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1);\n\n                // Check for collision risk\n                if (distance < collision_threshold) {\n                    cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n                }\n            }\n        }\n    }\n}\n\n// Main function to capture and process video frames\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open camera.\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera cannot be opened\n    }\n\n    // Load pre-trained model\n    load_model(\"yolo.weights\", \"yolo.cfg\");\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit loop if frame is empty\n        }\n\n        // Process the frame\n        process_image(frame);\n\n        // Display the frame with detections\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using stereo camera input in OpenCV. The system should estimate the distance to objects using stereo disparity and trigger a collision warning if the distance is below a threshold. Include proper error handling and detailed comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float baseline = 0.5f;             // Stereo baseline (meters)\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Function to calculate distance to an object using stereo disparity\nfloat calculate_distance(float disparity) {\n    // Calculate distance using disparity from stereo images\n    return (focal_length_x * baseline) / disparity;\n}\n\n// Function to process stereo frames and detect objects\nvoid process_image(cv::Mat &left_frame, cv::Mat &right_frame) {\n    if (left_frame.empty() || right_frame.empty()) {\n        std::cerr << \"ERROR: Empty stereo frames provided.\" << std::endl;\n        return;  // Exit processing if frames are empty\n    }\n\n    // Disparity calculation (simplified for illustration)\n    cv::Mat disparity_map;\n    cv::StereoBM stereoBM;\n    stereoBM(left_frame, right_frame, disparity_map);  // Generate disparity map\n\n    // Calculate the distance using disparity (using example disparity value)\n    float disparity = disparity_map.at<float>(0, 0);  // Example disparity from the map\n    float distance = calculate_distance(disparity);\n\n    // Display the distance\n    std::string distance_text = \"Distance: \" + std::to_string(distance) + \" m\";\n    cv::putText(left_frame, distance_text, cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision risk\n    if (distance < collision_threshold) {\n        cv::putText(left_frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to handle stereo video input and process each frame\nint main() {\n    cv::VideoCapture left_cap(0), right_cap(1);  // Open stereo cameras\n    if (!left_cap.isOpened() || !right_cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open stereo cameras.\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if cameras cannot be opened\n    }\n\n    cv::Mat left_frame, right_frame;\n    while (true) {\n        left_cap >> left_frame;  // Capture frame from left camera\n        right_cap >> right_frame;  // Capture frame from right camera\n\n        if (left_frame.empty() || right_frame.empty()) {\n            break;  // Exit loop if frames are empty\n        }\n\n        // Process the stereo frames\n        process_image(left_frame, right_frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", left_frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    left_cap.release();  // Release left camera\n    right_cap.release();  // Release right camera\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with object tracking in OpenCV. The system should track the object across frames, estimate its speed and distance, and trigger a collision warning when the object is approaching too fast. Proper error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Thresholds\nconst float collision_threshold = 10.0f;    // Collision warning distance threshold (meters)\nconst float speed_threshold = 10.0f;        // Speed threshold for collision risk (m/s)\n\n// Function to process and track objects\nvoid process_and_track(cv::Mat &image) {\n    if (image.empty()) {\n        std::cerr << \"ERROR: Empty image provided.\" << std::endl;\n        return;  // Exit processing if image is empty\n    }\n\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box\n    cv::Point previous_position(600, 400);  // Previous object position (dummy data)\n    cv::Point current_position = detected_object.tl();  // Current object position (dummy data)\n\n    // Calculate distance and speed (simulated data for simplicity)\n    float distance = 5.0f;  // Example distance in meters\n    float speed = 2.0f;     // Example speed in m/s\n\n    // Draw bounding box and speed on the image\n    cv::rectangle(image, detected_object, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string speed_text = \"Speed: \" + std::to_string(speed) + \" m/s\";\n    cv::putText(image, speed_text, cv::Point(detected_object.x, detected_object.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1);  // Draw speed text\n\n    // Check for collision risk based on speed and distance\n    if (distance < collision_threshold && speed > speed_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video input and process each frame\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open the camera.\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera cannot be opened\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if frame is empty\n        }\n\n        // Process and track the detected object\n        process_and_track(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the video capture device\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using machine learning for object detection and tracking in OpenCV. The system should use a pre-trained model to detect objects, estimate their distance and speed, and trigger a warning if the object is too close and moving too fast. Proper error handling and detailed comments should be included.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <opencv2/dnn.hpp>  // For deep learning inference\n#include <iostream>  // For input-output operations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Load pre-trained model\ncv::dnn::Net net;\nvoid load_model(const std::string &model_path, const std::string &config_path) {\n    net = cv::dnn::readNet(model_path, config_path);\n}\n\n// Camera parameters\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\nconst float focal_length_x = 874.0f;   // Camera focal length in X direction\nconst float collision_threshold = 10.0f;\nconst float speed_threshold = 10.0f;\n\n// Function to calculate distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image and detect objects\nvoid process_image(cv::Mat &image) {\n    if (image.empty()) {\n        std::cerr << \"ERROR: Empty image provided.\" << std::endl;\n        return;  // Exit processing if image is empty\n    }\n\n    // Prepare the image for object detection\n    cv::Mat blob;\n    cv::dnn::blobFromImage(image, blob, 1.0 / 255.0, cv::Size(416, 416));\n    net.setInput(blob);\n\n    // Perform inference\n    std::vector<cv::Mat> outputs;\n    net.forward(outputs, net.getUnconnectedOutLayersNames());\n\n    // Loop through the outputs and process each detection\n    for (const auto &output : outputs) {\n        for (int i = 0; i < output.rows; ++i) {\n            float *data = (float *) output.data + i * output.cols;\n            float confidence = data[4];\n            if (confidence > 0.5) {  // Only process high-confidence detections\n                int left = static_cast<int>(data[0] * image.cols);\n                int top = static_cast<int>(data[1] * image.rows);\n                int right = static_cast<int>(data[2] * image.cols);\n                int bottom = static_cast<int>(data[3] * image.rows);\n                // Calculate object width and estimate distance\n                int object_width_in_image = right - left;\n                float distance = calculate_distance(object_width_in_image, image.cols);\n\n                // Draw bounding box\n                cv::rectangle(image, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 255, 0), 2);\n\n                // Display distance\n                std::string distance_text = \"Distance: \" + std::to_string(distance) + \" m\";\n                cv::putText(image, distance_text, cv::Point(left, top - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1);\n\n                // Check for collision risk\n                if (distance < collision_threshold) {\n                    cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n                }\n            }\n        }\n    }\n}\n\n// Main function to handle video input and process each frame\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open the camera.\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera cannot be opened\n    }\n\n    // Load pre-trained model\n    load_model(\"yolo.weights\", \"yolo.cfg\");\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture a frame\n        if (frame.empty()) {\n            break;  // Exit loop if frame is empty\n        }\n\n        // Process the frame\n        process_image(frame);\n\n        // Display the frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the video capture device\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that can detect multiple objects in the vehicle's path using OpenCV. The system should calculate the distance to each object and trigger a warning if any object is within a specified threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>             // For input-output operations\n#include <cmath>                // For mathematical operations\n#include <vector>               // For storing multiple objects\n\n// Constants for FCW system\nconst float focal_length_x = 800.0f;   // Camera focal length in X\nconst float focal_length_y = 800.0f;   // Camera focal length in Y\nconst float object_width = 1.8f;        // Assumed object width (meters)\nconst float collision_threshold = 15.0f;  // Distance threshold for collision warning\n\n// Structure to hold detected object data\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object's bounding box in the image\n    float distance;         // Calculated distance to the object\n};\n\n// Function to calculate distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (object_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process frame and detect multiple objects\nvoid process_frame(cv::Mat &frame) {\n    std::vector<cv::Rect> detected_objects;  // Detected bounding boxes for objects\n    detected_objects.push_back(cv::Rect(100, 100, 50, 50));  // Example object\n    detected_objects.push_back(cv::Rect(300, 200, 60, 60));  // Another example\n\n    // Process each detected object\n    for (size_t i = 0; i < detected_objects.size(); i++) {\n        DetectedObject obj;\n        obj.bounding_box = detected_objects[i];\n        obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);  // Calculate distance\n\n        // Draw bounding box and distance text\n        cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n        std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n        cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n        // Check if collision is imminent\n        if (obj.distance < collision_threshold) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\n// Main function to process video frames\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_frame(frame);  // Process the frame for objects\n\n        // Display frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that detects pedestrians using OpenCV. The system should alert the driver if a pedestrian comes within a specified threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>   // For image processing\n#include <iostream>               // For input-output operations\n#include <vector>                 // For storing detected pedestrians\n\n// Constants for FCW system\nconst float pedestrian_detection_threshold = 5.0f;  // Distance threshold for pedestrian detection\nconst float focal_length_x = 800.0f;   // Camera focal length in X direction\nconst float pedestrian_width = 0.6f;    // Assumed pedestrian width (meters)\n\n// Function to detect pedestrians\nvoid detect_pedestrians(cv::Mat &frame) {\n    cv::CascadeClassifier pedestrian_cascade;\n    pedestrian_cascade.load(\"haarcascade_fullbody.xml\");  // Load pre-trained pedestrian detector\n\n    std::vector<cv::Rect> pedestrians;\n    pedestrian_cascade.detectMultiScale(frame, pedestrians);  // Detect pedestrians\n\n    // Draw bounding boxes around detected pedestrians\n    for (size_t i = 0; i < pedestrians.size(); i++) {\n        cv::rectangle(frame, pedestrians[i], cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    }\n}\n\n// Function to calculate distance to a detected pedestrian\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (pedestrian_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process frame and issue collision warning\nvoid process_frame(cv::Mat &frame) {\n    detect_pedestrians(frame);  // Detect pedestrians in the frame\n\n    // Simulate pedestrian distance calculation\n    float pedestrian_distance = calculate_distance(50, frame.cols);  // Example distance calculation\n\n    if (pedestrian_distance < pedestrian_detection_threshold) {\n        cv::putText(frame, \"WARNING: Pedestrian Detected\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);  // Alert message\n    }\n}\n\n// Main function to capture and process video frames\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_frame(frame);  // Process frame for pedestrian detection\n\n        // Display processed frame\n        cv::imshow(\"FCW - Pedestrian Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close all windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using OpenCV's Haar Cascade Classifier to detect vehicles. The system should issue a warning if a vehicle is within the specified collision threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>   // For image processing\n#include <iostream>               // For input-output operations\n#include <vector>                 // For storing vehicle data\n\n// Constants for FCW system\nconst float collision_threshold = 10.0f;  // Distance threshold (meters)\nconst float focal_length_x = 800.0f;      // Camera focal length in X direction\nconst float vehicle_width = 2.0f;         // Assumed vehicle width (meters)\n\n// Function to detect vehicles using Haar Cascade\nvoid detect_vehicles(cv::Mat &frame) {\n    cv::CascadeClassifier vehicle_cascade;\n    vehicle_cascade.load(\"haarcascade_car.xml\");  // Load pre-trained vehicle detector\n\n    std::vector<cv::Rect> vehicles;\n    vehicle_cascade.detectMultiScale(frame, vehicles);  // Detect vehicles in the frame\n\n    // Draw bounding boxes around detected vehicles\n    for (size_t i = 0; i < vehicles.size(); i++) {\n        cv::rectangle(frame, vehicles[i], cv::Scalar(0, 255, 0), 2);  // Bounding box\n    }\n}\n\n// Function to calculate distance to a detected vehicle\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process frame and issue warning\nvoid process_frame(cv::Mat &frame) {\n    detect_vehicles(frame);  // Detect vehicles\n\n    // Simulate vehicle distance calculation\n    float vehicle_distance = calculate_distance(50, frame.cols);  // Example\n\n    if (vehicle_distance < collision_threshold) {\n        cv::putText(frame, \"WARNING: Vehicle in Path\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);  // Warning\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        process_frame(frame);  // Process frame for vehicle detection\n\n        // Display frame\n        cv::imshow(\"FCW - Vehicle Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses radar data for distance calculation. The system should calculate the distance of objects in the vehicle's path and trigger a warning if any object comes within a specified threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>             // For input-output operations\n#include <vector>               // For storing radar data\n#include <cmath>                // For distance calculation\n\n// Constants for FCW system\nconst float radar_threshold = 10.0f;  // Distance threshold (meters)\n\n// Function to simulate radar data processing\nvoid process_radar_data(std::vector<float> radar_distances) {\n    for (size_t i = 0; i < radar_distances.size(); i++) {\n        float distance = radar_distances[i];  // Radar distance reading\n        if (distance < radar_threshold) {\n            std::cout << \"WARNING: Object within collision range at \" << distance << \" meters.\" << std::endl;  // Collision warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    std::vector<float> radar_distances = {15.0f, 5.0f, 7.0f, 20.0f};  // Simulated radar distances (in meters)\n\n    process_radar_data(radar_distances);  // Process radar data and issue warnings\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses LIDAR data for detecting objects and estimating the distance. The system should trigger a collision warning if any detected object comes within a specified threshold distance.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>           // For input-output operations\n#include <vector>             // For storing LIDAR data\n#include <cmath>              // For distance calculation\n\n// Constants for FCW system\nconst float lidar_threshold = 8.0f;  // Distance threshold (meters)\n\n// Function to process LIDAR data\nvoid process_lidar_data(std::vector<float> lidar_distances) {\n    for (size_t i = 0; i < lidar_distances.size(); i++) {\n        float distance = lidar_distances[i];  // LIDAR distance reading\n        if (distance < lidar_threshold) {\n            std::cout << \"WARNING: Object within collision range at \" << distance << \" meters.\" << std::endl;  // Collision warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    std::vector<float> lidar_distances = {10.0f, 5.0f, 6.0f, 15.0f};  // Simulated LIDAR distances (in meters)\n\n    process_lidar_data(lidar_distances);  // Process LIDAR data and issue warnings\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects pedestrians using image processing techniques. The system should trigger a collision warning if any pedestrian comes within a specified threshold distance.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>             // For input-output operations\n\n// Threshold for triggering collision warning (in meters)\nconst float pedestrian_threshold = 3.0f;\n\n// Function to process image and detect pedestrians\nvoid detect_pedestrian(cv::Mat &frame) {\n    // Load Haar cascade for pedestrian detection\n    cv::CascadeClassifier pedestrian_cascade;\n    if (!pedestrian_cascade.load(\"haarcascade_fullbody.xml\")) {\n        std::cerr << \"ERROR: Could not load cascade classifier!\" << std::endl;\n        return;\n    }\n\n    // Convert to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Detect pedestrians\n    std::vector<cv::Rect> pedestrians;\n    pedestrian_cascade.detectMultiScale(gray, pedestrians, 1.1, 3, 0, cv::Size(30, 30));\n\n    // Loop through detected pedestrians\n    for (size_t i = 0; i < pedestrians.size(); i++) {\n        cv::rectangle(frame, pedestrians[i], cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n        // Simulate distance calculation\n        float distance = 2.5f;  // Simulated distance in meters\n\n        if (distance < pedestrian_threshold) {\n            cv::putText(frame, \"WARNING: Pedestrian in Path!\", cv::Point(300, 50),\n                        cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);  // Warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    // Open video capture\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if frame is empty\n        }\n\n        detect_pedestrian(frame);  // Process frame for pedestrian detection\n\n        // Display frame\n        cv::imshow(\"FCW - Pedestrian Detection\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses stereo vision to detect vehicles and calculate their distance. The system should trigger a warning if a detected vehicle comes within a specified threshold distance.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>             // For input-output operations\n#include <cmath>                // For mathematical operations\n\n// Camera parameters\nconst float focal_length = 800.0f;  // Focal length\nconst float baseline = 0.3f;        // Baseline distance between stereo cameras\nconst float vehicle_threshold = 15.0f;  // Threshold distance for collision warning\n\n// Function to estimate distance using stereo vision\nfloat calculate_distance(int disparity) {\n    return (focal_length * baseline) / disparity;  // Distance calculation\n}\n\n// Function to detect vehicles and issue warnings\nvoid detect_vehicles(cv::Mat &left_image, cv::Mat &right_image) {\n    // Convert to grayscale\n    cv::Mat left_gray, right_gray;\n    cv::cvtColor(left_image, left_gray, cv::COLOR_BGR2GRAY);\n    cv::cvtColor(right_image, right_gray, cv::COLOR_BGR2GRAY);\n\n    // Compute disparity map using stereo block matching\n    cv::Ptr<cv::StereoBM> stereo = cv::StereoBM::create(16, 9);\n    cv::Mat disparity_map;\n    stereo->compute(left_gray, right_gray, disparity_map);\n\n    // Example: assume disparity is detected at pixel (x, y)\n    int disparity = disparity_map.at<short>(100, 100);  // Example disparity value\n    float distance = calculate_distance(disparity);\n\n    if (distance < vehicle_threshold) {\n        std::cout << \"WARNING: Vehicle too close at \" << distance << \" meters!\" << std::endl;  // Warning\n    }\n}\n\n// Main function\nint main() {\n    // Open video captures for left and right cameras\n    cv::VideoCapture cap_left(0), cap_right(1);  // Use two cameras\n    if (!cap_left.isOpened() || !cap_right.isOpened()) {\n        std::cerr << \"ERROR: Could not open cameras!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat left_image, right_image;\n    while (true) {\n        cap_left >> left_image;  // Capture left image\n        cap_right >> right_image;  // Capture right image\n\n        if (left_image.empty() || right_image.empty()) {\n            break;  // Exit if frames are empty\n        }\n\n        detect_vehicles(left_image, right_image);  // Detect vehicles and calculate distance\n\n        // Display the images (left and right)\n        cv::imshow(\"Left Camera\", left_image);\n        cv::imshow(\"Right Camera\", right_image);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap_left.release();  // Release camera\n    cap_right.release();  // Release camera\n    cv::destroyAllWindows();  // Close windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system using radar data. The system should dynamically adjust the warning threshold based on the relative speed of the detected object and trigger a warning when the distance becomes critically short.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>  // For input-output operations\n#include <vector>    // For storing radar data\n\n// Constants for FCW system\nconst float initial_threshold = 10.0f;  // Initial distance threshold (meters)\n\n// Function to calculate adjusted distance based on speed\nfloat calculate_dynamic_threshold(float speed) {\n    float adjustment_factor = 1.0f - (speed / 100.0f);  // Reduce threshold as speed increases\n    return initial_threshold * adjustment_factor;\n}\n\n// Function to process radar data and trigger warnings\nvoid process_radar_data(std::vector<float> radar_distances, float speed) {\n    float dynamic_threshold = calculate_dynamic_threshold(speed);  // Adjust threshold based on speed\n\n    for (size_t i = 0; i < radar_distances.size(); i++) {\n        float distance = radar_distances[i];  // Radar distance reading\n        if (distance < dynamic_threshold) {\n            std::cout << \"WARNING: Object within collision range at \" << distance << \" meters (speed adjusted).\" << std::endl;  // Collision warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    std::vector<float> radar_distances = {12.0f, 7.0f, 3.0f, 8.0f};  // Simulated radar distances (meters)\n    float vehicle_speed = 50.0f;  // Simulated vehicle speed (km/h)\n\n    process_radar_data(radar_distances, vehicle_speed);  // Process radar data and issue warnings\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses GPS data and map information to predict potential collisions with stationary objects based on their location. The system should trigger a warning if an object is detected in the path.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>        // For input-output operations\n#include <vector>          // For storing GPS data\n#include <cmath>           // For calculating distance\n\n// Constants\nconst float collision_threshold = 5.0f;  // Distance threshold for warning (meters)\n\n// Function to calculate distance between two GPS coordinates\nfloat calculate_distance(float lat1, float lon1, float lat2, float lon2) {\n    float R = 6371.0f;  // Earth radius in kilometers\n    float phi1 = lat1 * (M_PI / 180.0f);  // Convert latitude to radians\n    float phi2 = lat2 * (M_PI / 180.0f);  // Convert latitude to radians\n    float delta_phi = (lat2 - lat1) * (M_PI / 180.0f);\n    float delta_lambda = (lon2 - lon1) * (M_PI / 180.0f);\n    float a = std::sin(delta_phi / 2) * std::sin(delta_phi / 2) + std::cos(phi1) * std::cos(phi2) * std::sin(delta_lambda / 2) * std::sin(delta_lambda / 2);\n    float c = 2 * std::atan2(std::sqrt(a), std::sqrt(1 - a));\n    return R * c * 1000.0f;  // Distance in meters\n}\n\n// Function to process GPS data and check for collision potential\nvoid check_collision(std::vector<std::pair<float, float>> object_locations, float vehicle_lat, float vehicle_lon) {\n    for (size_t i = 0; i < object_locations.size(); i++) {\n        float object_lat = object_locations[i].first;\n        float object_lon = object_locations[i].second;\n\n        float distance = calculate_distance(vehicle_lat, vehicle_lon, object_lat, object_lon);\n        if (distance < collision_threshold) {\n            std::cout << \"WARNING: Object in path at \" << distance << \" meters.\" << std::endl;  // Collision warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    std::vector<std::pair<float, float>> object_locations = {{12.9716f, 77.5946f}, {12.9600f, 77.6300f}};  // Simulated object GPS locations\n    float vehicle_lat = 12.9710f, vehicle_lon = 77.6020f;  // Simulated vehicle GPS location\n\n    check_collision(object_locations, vehicle_lat, vehicle_lon);  // Check for collisions based on GPS data\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>    // For image processing\n#include <iostream>               // For input-output operations\n#include <cmath>                  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>                // For system operations like EXIT_FAILURE\n#include <vector>                 // For vector container to hold bounding box data\n#include <string>                 // For string manipulation\n\n// Camera parameters (hardcoded for example purposes)\nconst float focal_length_x = 874.0f;   // Focal length in X direction (in pixels)\nconst float focal_length_y = 995.0f;   // Focal length in Y direction (in pixels)\nconst float optical_center_x = 960.0f; // Optical center in X (in pixels)\nconst float optical_center_y = 536.0f; // Optical center in Y (in pixels)\nconst float car_width = 1.8f;          // Assumed average width of a car (in meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;  // Distance below which the warning is triggered\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object (in pixels)\n    float distance;         // Estimated distance to the object (in meters)\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    // In a real system, you would use object detection algorithms like YOLO, SSD, or Faster R-CNN\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object using the calculated width in the image\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message in red\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera (index 0)\n    if (!cap.isOpened()) {  // Check if the camera is opened successfully\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images from the camera\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distances\n        process_image(frame);\n\n        // Display the processed frame with bounding box and warning text\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit the loop if the user presses 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;  // Return 0 to indicate successful program execution\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that uses radar data to estimate the distance to a detected object and trigger an alert when the distance is below a threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>          // For input-output operations\n#include <cmath>            // For mathematical operations\n#include <cstdlib>           // For system operations like EXIT_FAILURE\n\n// Radar parameters\nconst float radar_range = 100.0f; // Maximum radar detection range in meters\nconst float collision_threshold = 10.0f; // Collision warning threshold in meters\n\n// Function to process radar data and trigger collision warning\nvoid process_radar_data(float object_distance) {\n    // Check if object is within radar detection range\n    if (object_distance <= radar_range) {\n        // Check if distance is below collision threshold\n        if (object_distance < collision_threshold) {\n            std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger collision warning\n        }\n    }\n}\n\n// Main function to simulate radar data processing\nint main() {\n    float object_distance = 8.0f;  // Simulated distance from object (in meters)\n    process_radar_data(object_distance);  // Process radar data\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using LiDAR data. The system should estimate the distance to obstacles and trigger a collision warning when the distance is below a threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>       // For input-output operations\n#include <cmath>         // For mathematical operations\n#include <cstdlib>        // For system operations like EXIT_FAILURE\n\n// LiDAR parameters\nconst float lidar_max_range = 50.0f;  // Maximum LiDAR range in meters\nconst float collision_threshold = 5.0f; // Collision warning threshold in meters\n\n// Function to process LiDAR data and trigger collision warning\nvoid process_lidar_data(float object_distance) {\n    // Check if object is within LiDAR detection range\n    if (object_distance <= lidar_max_range) {\n        // Check if distance is below collision threshold\n        if (object_distance < collision_threshold) {\n            std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger collision warning\n        }\n    }\n}\n\n// Main function to simulate LiDAR data processing\nint main() {\n    float object_distance = 4.0f;  // Simulated distance from object (in meters)\n    process_lidar_data(object_distance);  // Process LiDAR data\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that uses camera data and vehicle speed to calculate a safe stopping distance and trigger a warning when the object is too close.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>    // For image processing\n#include <iostream>               // For input-output operations\n#include <cmath>                  // For mathematical operations\n#include <cstdlib>                // For system operations like EXIT_FAILURE\n\n// Vehicle parameters\nconst float car_max_speed = 30.0f;  // Maximum speed in m/s\nconst float stopping_distance_factor = 1.5f; // Factor to calculate stopping distance\nconst float collision_threshold = 15.0f; // Collision warning threshold in meters\n\n// Function to calculate stopping distance based on speed\nfloat calculate_stopping_distance(float speed) {\n    return stopping_distance_factor * speed * speed / (2.0f * 9.8f);  // Simple formula for stopping distance\n}\n\n// Function to process image data and calculate collision risk\nvoid process_image_data(cv::Mat &image, float vehicle_speed) {\n    // Simulated object detection using a fixed bounding box\n    cv::Rect detected_object(600, 400, 100, 50);  // Example bounding box of an object\n\n    // Estimate distance based on object size in image (simplified)\n    float object_distance = 20.0f;  // Placeholder distance (in meters)\n\n    // Calculate stopping distance based on vehicle speed\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n\n    // Trigger warning if object is within the stopping distance\n    if (object_distance < stopping_distance) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    cv::Mat frame;  // Frame for capturing image data\n    float vehicle_speed = 25.0f;  // Simulated vehicle speed in m/s\n\n    process_image_data(frame, vehicle_speed);  // Process image data\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that detects multiple objects in the camera frame and triggers a warning when any object is too close.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>    // For image processing\n#include <iostream>               // For input-output operations\n#include <vector>                 // For vector container to hold objects\n#include <cstdlib>                // For system operations like EXIT_FAILURE\n\n// Camera parameters\nconst float collision_threshold = 10.0f;  // Collision warning threshold in meters\n\n// Define structure to represent detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the detected object\n    float distance;         // Distance to the object\n};\n\n// Function to process multiple detected objects and trigger warnings\nvoid process_multiple_objects(std::vector<DetectedObject> &detected_objects) {\n    for (size_t i = 0; i < detected_objects.size(); ++i) {\n        // Check if object is within the collision threshold\n        if (detected_objects[i].distance < collision_threshold) {\n            std::cout << \"WARNING: COLLISION IMMINENT with Object \" << i+1 << std::endl;  // Trigger warning\n        }\n    }\n}\n\n// Main function to simulate FCW system with multiple object detection\nint main() {\n    std::vector<DetectedObject> detected_objects;\n    detected_objects.push_back({cv::Rect(600, 400, 100, 50), 8.0f});  // Example object with distance\n    detected_objects.push_back({cv::Rect(800, 300, 150, 80), 12.0f});  // Example object with distance\n\n    process_multiple_objects(detected_objects);  // Process detected objects\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that fuses data from radar and camera sensors to estimate the distance to obstacles and trigger a collision warning.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>    // For image processing\n#include <iostream>               // For input-output operations\n#include <cmath>                  // For mathematical operations\n#include <cstdlib>                // For system operations like EXIT_FAILURE\n\n// Sensor parameters\nconst float radar_max_range = 80.0f; // Maximum radar detection range\nconst float camera_max_range = 50.0f; // Maximum camera detection range\nconst float collision_threshold = 5.0f; // Collision warning threshold\n\n// Function to fuse radar and camera data\nfloat fuse_sensor_data(float radar_distance, float camera_distance) {\n    // Fuse radar and camera data (simple average for this example)\n    return (radar_distance + camera_distance) / 2.0f;\n}\n\n// Function to process radar and camera data and trigger warning\nvoid process_sensors(float radar_distance, float camera_distance) {\n    float fused_distance = fuse_sensor_data(radar_distance, camera_distance);  // Fuse data from both sensors\n    if (fused_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system with sensor fusion\nint main() {\n    float radar_distance = 6.0f;  // Simulated distance from radar (in meters)\n    float camera_distance = 4.0f;  // Simulated distance from camera (in meters)\n\n    process_sensors(radar_distance, camera_distance);  // Process sensor data\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that detects objects using a camera and calculates the object's size in the image to estimate its distance. A warning should trigger if the object is too close.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>   // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations like EXIT_FAILURE\n#include <cmath>                 // For mathematical operations\n\n// Camera parameters\nconst float focal_length_x = 800.0f; // Focal length in X direction\nconst float focal_length_y = 800.0f; // Focal length in Y direction\nconst float car_width = 1.8f; // Assumed car width in meters\nconst float collision_threshold = 10.0f; // Threshold distance for collision warning\n\n// Function to calculate distance based on object size in image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);  // Distance estimation formula\n}\n\n// Function to process an image and trigger a collision warning\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 100, 50);  // Example bounding box\n    int object_width_in_image = detected_object.width;\n\n    // Calculate object distance\n    float object_distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Check if object distance is below threshold\n    if (object_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate camera processing\nint main() {\n    cv::Mat frame;  // Frame for image capture\n    process_image(frame);  // Process image for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using multiple distance sensors (e.g., radar, ultrasonic) to estimate the distance to objects in front of the vehicle. A warning should be triggered when any sensor detects an object within a critical range.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n\n// Sensor thresholds\nconst float radar_threshold = 10.0f;  // Radar detection threshold\nconst float ultrasonic_threshold = 5.0f;  // Ultrasonic sensor threshold\n\n// Function to process radar sensor data\nvoid process_radar_sensor(float distance) {\n    if (distance < radar_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Radar)\" << std::endl;  // Trigger radar collision warning\n    }\n}\n\n// Function to process ultrasonic sensor data\nvoid process_ultrasonic_sensor(float distance) {\n    if (distance < ultrasonic_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Ultrasonic)\" << std::endl;  // Trigger ultrasonic collision warning\n    }\n}\n\n// Main function to simulate FCW system with multiple sensors\nint main() {\n    float radar_distance = 8.0f;  // Simulated radar distance (in meters)\n    float ultrasonic_distance = 3.0f;  // Simulated ultrasonic distance (in meters)\n\n    process_radar_sensor(radar_distance);  // Process radar data\n    process_ultrasonic_sensor(ultrasonic_distance);  // Process ultrasonic data\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that uses a camera to detect obstacles and takes vehicle speed as an input to calculate the safe stopping distance. A collision warning should trigger if the stopping distance is shorter than the distance to the obstacle.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>     // For image processing\n#include <iostream>                // For input-output operations\n#include <cmath>                   // For mathematical operations\n#include <cstdlib>                 // For system operations like EXIT_FAILURE\n\n// Vehicle parameters\nconst float stopping_factor = 1.5f;  // Stopping distance factor\nconst float collision_threshold = 15.0f; // Collision warning threshold\n\n// Function to calculate stopping distance based on vehicle speed\nfloat calculate_stopping_distance(float speed) {\n    return stopping_factor * speed * speed / (2.0f * 9.8f);  // Stopping distance formula\n}\n\n// Function to process image and trigger warning based on vehicle speed\nvoid process_image(cv::Mat &image, float vehicle_speed) {\n    cv::Rect detected_object(600, 400, 100, 50);  // Example bounding box\n\n    // Simulated distance calculation from camera (in meters)\n    float object_distance = 20.0f;\n\n    // Calculate the required stopping distance\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n\n    // Trigger collision warning if object is within stopping distance\n    if (object_distance < stopping_distance) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system with speed input\nint main() {\n    cv::Mat frame;  // Frame for image capture\n    float vehicle_speed = 25.0f;  // Simulated vehicle speed (in m/s)\n\n    process_image(frame, vehicle_speed);  // Process image with vehicle speed\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that fuses LiDAR and camera data to estimate the distance to obstacles. A collision warning should trigger if the object is too close.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>    // For image processing\n#include <iostream>               // For input-output operations\n#include <cstdlib>                // For system operations like EXIT_FAILURE\n\n// Sensor parameters\nconst float lidar_max_range = 80.0f;   // LiDAR maximum range in meters\nconst float camera_max_range = 50.0f;  // Camera maximum range in meters\nconst float collision_threshold = 5.0f; // Collision warning threshold\n\n// Function to fuse LiDAR and camera data\nfloat fuse_sensor_data(float lidar_distance, float camera_distance) {\n    return (lidar_distance + camera_distance) / 2.0f;  // Fuse sensor data\n}\n\n// Function to process fused sensor data and trigger collision warning\nvoid process_fused_data(float lidar_distance, float camera_distance) {\n    float fused_distance = fuse_sensor_data(lidar_distance, camera_distance);  // Fuse LiDAR and camera data\n    if (fused_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system with sensor fusion\nint main() {\n    float lidar_distance = 4.0f;   // Simulated LiDAR distance (in meters)\n    float camera_distance = 6.0f;  // Simulated camera distance (in meters)\n\n    process_fused_data(lidar_distance, camera_distance);  // Process fused data\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that detects and classifies objects using a camera. A warning should trigger if the detected object is a car or truck and is within a critical distance.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>             // For input-output operations\n#include <vector>               // For storing detected objects\n#include <cstdlib>              // For system operations like EXIT_FAILURE\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Function to process image and classify detected objects\nvoid process_image(cv::Mat &image) {\n    // Simulated object detection (simulated with a fixed bounding box)\n    cv::Rect detected_object(600, 400, 100, 50);  // Example bounding box\n    std::string object_label = \"car\";  // Example object label (detected via classifier)\n\n    // Calculate the distance to the object\n    float object_distance = 8.0f;  // Simulated object distance (in meters)\n\n    // Check if object is within collision threshold\n    if (object_distance < collision_threshold && (object_label == \"car\" || object_label == \"truck\")) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system with object classification\nint main() {\n    cv::Mat frame;  // Frame for image capture\n    process_image(frame);  // Process image for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that calculates the safe stopping distance based on vehicle speed and object distance. The system should trigger a collision warning if the object is within a critical range relative to the vehicle's speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>        // For input-output operations\n#include <cmath>           // For mathematical operations\n#include <cstdlib>          // For system operations like EXIT_FAILURE\n\n// Vehicle and sensor parameters\nconst float stopping_factor = 1.5f;     // Stopping distance factor\nconst float collision_threshold = 10.0f; // Threshold for collision warning (in meters)\n\n// Function to calculate stopping distance based on vehicle speed\nfloat calculate_stopping_distance(float speed) {\n    return stopping_factor * speed * speed / (2.0f * 9.8f);  // Stopping distance formula (in meters)\n}\n\n// Function to process object distance and speed\nvoid process_data(float object_distance, float vehicle_speed) {\n    // Calculate stopping distance\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n\n    // Trigger collision warning if object is within stopping distance\n    if (object_distance < stopping_distance) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float vehicle_speed = 20.0f;  // Simulated vehicle speed (in m/s)\n    float object_distance = 8.0f; // Simulated object distance (in meters)\n\n    process_data(object_distance, vehicle_speed);  // Process data for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using a radar and ultrasonic sensor. The system should fuse data from both sensors to calculate the object's proximity, and trigger a collision warning if any sensor detects an object within a critical range.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>           // For input-output operations\n#include <cstdlib>            // For system operations like EXIT_FAILURE\n\n// Sensor thresholds\nconst float radar_threshold = 10.0f;    // Radar detection threshold (in meters)\nconst float ultrasonic_threshold = 5.0f; // Ultrasonic sensor threshold (in meters)\nconst float collision_threshold = 6.0f;  // Collision warning threshold (in meters)\n\n// Function to process radar sensor data\nvoid process_radar_sensor(float distance) {\n    if (distance < radar_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Radar)\" << std::endl;  // Trigger radar collision warning\n    }\n}\n\n// Function to process ultrasonic sensor data\nvoid process_ultrasonic_sensor(float distance) {\n    if (distance < ultrasonic_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Ultrasonic)\" << std::endl;  // Trigger ultrasonic collision warning\n    }\n}\n\n// Function to fuse sensor data\nfloat fuse_sensor_data(float radar_distance, float ultrasonic_distance) {\n    return (radar_distance + ultrasonic_distance) / 2.0f;  // Fuse radar and ultrasonic data\n}\n\n// Main function to simulate FCW system\nint main() {\n    float radar_distance = 8.0f;       // Simulated radar distance (in meters)\n    float ultrasonic_distance = 3.0f;  // Simulated ultrasonic distance (in meters)\n\n    float fused_distance = fuse_sensor_data(radar_distance, ultrasonic_distance);  // Fuse data\n\n    if (fused_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Fused)\" << std::endl;  // Trigger collision warning based on fused data\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that uses a camera to detect objects, classifies them (e.g., car, pedestrian), and triggers a collision warning if a car or truck is within a critical distance.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>   // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations like EXIT_FAILURE\n#include <string>                // For string manipulation\n\n// Parameters\nconst float collision_threshold = 10.0f;  // Collision warning threshold (in meters)\n\n// Function to process object detection from camera\nvoid process_image(cv::Mat &image, float object_distance, std::string object_type) {\n    if (object_distance < collision_threshold && (object_type == \"car\" || object_type == \"truck\")) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Object: \" << object_type << \")\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system with object classification\nint main() {\n    cv::Mat frame;  // Simulated image frame\n    float object_distance = 8.0f;  // Simulated object distance (in meters)\n    std::string object_type = \"car\";  // Simulated object type\n\n    process_image(frame, object_distance, object_type);  // Process image for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that uses LiDAR data to estimate the distance to objects in front of the vehicle. The collision warning threshold should dynamically adjust based on vehicle speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>         // For input-output operations\n#include <cmath>            // For mathematical operations\n#include <cstdlib>           // For system operations like EXIT_FAILURE\n\n// Vehicle parameters\nconst float speed_threshold = 50.0f;  // Vehicle speed threshold (in km/h)\nconst float dynamic_factor = 1.5f;    // Dynamic adjustment factor for threshold\n\n// Function to calculate dynamic collision threshold based on vehicle speed\nfloat calculate_dynamic_threshold(float vehicle_speed) {\n    return dynamic_factor * (vehicle_speed / 10.0f);  // Adjust threshold based on speed\n}\n\n// Function to process LiDAR data\nvoid process_lidar_data(float lidar_distance, float vehicle_speed) {\n    float dynamic_threshold = calculate_dynamic_threshold(vehicle_speed);  // Adjust threshold based on speed\n\n    // Trigger collision warning if LiDAR distance is within dynamic threshold\n    if (lidar_distance < dynamic_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (LiDAR)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system with LiDAR and speed input\nint main() {\n    float lidar_distance = 12.0f;  // Simulated LiDAR distance (in meters)\n    float vehicle_speed = 80.0f;   // Simulated vehicle speed (in km/h)\n\n    process_lidar_data(lidar_distance, vehicle_speed);  // Process LiDAR data for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using radar and camera sensors. The system should estimate the size of the detected object, calculate its proximity, and trigger a warning if the object is too close based on its size.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>   // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations like EXIT_FAILURE\n\n// Sensor parameters\nconst float radar_threshold = 10.0f;    // Radar detection threshold (in meters)\nconst float size_threshold = 2.5f;      // Object size threshold (in meters)\n\n// Function to process radar sensor data\nvoid process_radar(float radar_distance, float object_size) {\n    if (radar_distance < radar_threshold && object_size > size_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Radar)\" << std::endl;  // Trigger radar collision warning\n    }\n}\n\n// Function to process camera data\nvoid process_camera(cv::Mat &frame, float object_distance, float object_size) {\n    if (object_distance < radar_threshold && object_size > size_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Camera)\" << std::endl;  // Trigger camera collision warning\n    }\n}\n\n// Main function to simulate FCW system with radar and camera\nint main() {\n    cv::Mat frame;  // Simulated camera frame\n    float radar_distance = 8.0f;    // Simulated radar distance (in meters)\n    float object_size = 3.0f;       // Simulated object size (in meters)\n\n    process_radar(radar_distance, object_size);  // Process radar data\n    process_camera(frame, radar_distance, object_size);  // Process camera data\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that uses radar and ultrasonic sensors. The system should fuse data from both sensors and trigger a collision warning if the object distance is within a critical range.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>           // For input-output operations\n#include <cstdlib>            // For system operations like EXIT_FAILURE\n\n// Sensor thresholds\nconst float radar_threshold = 10.0f;    // Radar detection threshold (in meters)\nconst float ultrasonic_threshold = 6.0f; // Ultrasonic sensor threshold (in meters)\nconst float collision_threshold = 8.0f;  // Collision warning threshold (in meters)\n\n// Function to process radar sensor data\nvoid process_radar(float distance) {\n    if (distance < radar_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Radar)\" << std::endl;  // Trigger radar collision warning\n    }\n}\n\n// Function to process ultrasonic sensor data\nvoid process_ultrasonic(float distance) {\n    if (distance < ultrasonic_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Ultrasonic)\" << std::endl;  // Trigger ultrasonic collision warning\n    }\n}\n\n// Function to fuse sensor data\nfloat fuse_sensor_data(float radar_distance, float ultrasonic_distance) {\n    return (radar_distance + ultrasonic_distance) / 2.0f;  // Fuse radar and ultrasonic data\n}\n\n// Main function to simulate FCW system\nint main() {\n    float radar_distance = 7.0f;       // Simulated radar distance (in meters)\n    float ultrasonic_distance = 4.0f;  // Simulated ultrasonic distance (in meters)\n\n    float fused_distance = fuse_sensor_data(radar_distance, ultrasonic_distance);  // Fuse data\n\n    if (fused_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Fused)\" << std::endl;  // Trigger collision warning\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system that triggers a collision warning based on an adjustable warning threshold. The system should allow for changing the threshold dynamically based on vehicle speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>         // For input-output operations\n#include <cmath>            // For mathematical operations\n#include <cstdlib>           // For system operations like EXIT_FAILURE\n\n// Function to calculate dynamic warning threshold based on vehicle speed\nfloat calculate_warning_threshold(float vehicle_speed) {\n    // Simple example: threshold increases with vehicle speed\n    return 0.5f * vehicle_speed;  // Warning threshold (in meters)\n}\n\n// Function to process object distance\nvoid process_data(float object_distance, float vehicle_speed) {\n    float threshold = calculate_warning_threshold(vehicle_speed);  // Calculate dynamic threshold\n\n    // Trigger warning if object is within dynamic threshold\n    if (object_distance < threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Dynamic Threshold)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed (in km/h)\n    float object_distance = 25.0f;  // Simulated object distance (in meters)\n\n    process_data(object_distance, vehicle_speed);  // Process data for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses a camera for object detection. The system should classify objects as vehicles or pedestrians and issue a warning if a vehicle is detected within the collision threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>   // For image processing\n#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations like EXIT_FAILURE\n#include <string>                // For string manipulation\n\n// Parameters\nconst float collision_threshold = 10.0f;  // Collision warning threshold (in meters)\n\n// Function to process object detection from camera\nvoid process_image(cv::Mat &image, float object_distance, std::string object_type) {\n    if (object_distance < collision_threshold && object_type == \"vehicle\") {\n        std::cout << \"WARNING: COLLISION IMMINENT (Object: \" << object_type << \")\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system with object classification\nint main() {\n    cv::Mat frame;  // Simulated image frame\n    float object_distance = 8.0f;  // Simulated object distance (in meters)\n    std::string object_type = \"vehicle\";  // Simulated object type\n\n    process_image(frame, object_distance, object_type);  // Process image for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates LiDAR sensor data to calculate the distance to objects. The system should trigger a collision warning if the distance to an object is within a critical range.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>         // For input-output operations\n#include <cmath>            // For mathematical operations\n#include <cstdlib>           // For system operations like EXIT_FAILURE\n\n// LiDAR parameters\nconst float lidar_threshold = 12.0f;    // LiDAR detection threshold (in meters)\nconst float collision_threshold = 6.0f;  // Collision warning threshold (in meters)\n\n// Function to process LiDAR data\nvoid process_lidar_data(float lidar_distance) {\n    // Trigger collision warning if LiDAR distance is below threshold\n    if (lidar_distance < lidar_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (LiDAR)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float lidar_distance = 5.0f;  // Simulated LiDAR distance (in meters)\n\n    process_lidar_data(lidar_distance);  // Process LiDAR data for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates the safe stopping distance based on vehicle speed and object distance. The system should trigger a warning if the object is within the critical range relative to the vehicle's speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>        // For input-output operations\n#include <cmath>           // For mathematical operations\n#include <cstdlib>          // For system operations like EXIT_FAILURE\n\n// Vehicle and sensor parameters\nconst float stopping_factor = 1.5f;     // Stopping distance factor\nconst float collision_threshold = 10.0f; // Threshold for collision warning (in meters)\n\n// Function to calculate stopping distance based on vehicle speed\nfloat calculate_stopping_distance(float speed) {\n    return stopping_factor * speed * speed / (2.0f * 9.8f);  // Stopping distance formula (in meters)\n}\n\n// Function to process object distance and speed\nvoid process_data(float object_distance, float vehicle_speed) {\n    // Calculate stopping distance\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n\n    // Trigger collision warning if object is within stopping distance\n    if (object_distance < stopping_distance) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float vehicle_speed = 25.0f;  // Simulated vehicle speed (in m/s)\n    float object_distance = 8.0f; // Simulated object distance (in meters)\n\n    process_data(object_distance, vehicle_speed);  // Process data for collision warning\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the warning message dynamically based on the distance to the object. The system should use the distance to determine whether to show a mild or critical warning.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>         // For input-output operations\n#include <cstdlib>           // For system operations like EXIT_FAILURE\n#include <cmath>             // For mathematical operations (e.g., sqrt)\n\n// Collision thresholds\nconst float mild_warning_threshold = 10.0f;  // Mild warning threshold (in meters)\nconst float critical_warning_threshold = 5.0f;  // Critical warning threshold (in meters)\n\n// Function to display the warning based on object distance\nvoid display_warning(float object_distance) {\n    if (object_distance < critical_warning_threshold) {\n        std::cout << \"CRITICAL WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger critical warning\n    } else if (object_distance < mild_warning_threshold) {\n        std::cout << \"MILD WARNING: COLLISION RISK\" << std::endl;  // Trigger mild warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float object_distance = 7.0f;  // Simulated object distance (in meters)\n\n    display_warning(object_distance);  // Display appropriate warning\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that tracks the relative speed of an object and warns if the relative speed and distance indicate a collision risk.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>             // For input-output operations\n#include <cstdlib>              // For system operations like EXIT_FAILURE\n#include <cmath>                // For mathematical operations\n\n// Constants\nconst float collision_speed_threshold = 5.0f;  // Speed threshold for collision risk (m/s)\nconst float collision_distance_threshold = 10.0f;  // Distance threshold for collision warning (meters)\n\n// Function to calculate relative speed between the vehicle and an object\nfloat calculate_relative_speed(float object_speed, float vehicle_speed) {\n    return object_speed - vehicle_speed;  // Return the relative speed\n}\n\n// Function to process object distance and speed\nvoid process_data(float object_distance, float object_speed, float vehicle_speed) {\n    float relative_speed = calculate_relative_speed(object_speed, vehicle_speed);  // Calculate relative speed\n\n    if (relative_speed > collision_speed_threshold && object_distance < collision_distance_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (High speed & close distance)\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float object_distance = 8.0f;  // Simulated object distance (in meters)\n    float object_speed = 15.0f;    // Simulated object speed (in m/s)\n    float vehicle_speed = 20.0f;   // Simulated vehicle speed (in m/s)\n\n    process_data(object_distance, object_speed, vehicle_speed);  // Process data for collision warning\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that validates sensor data (radar, lidar, and camera) to ensure the integrity of distance calculations before triggering a warning.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>         // For input-output operations\n#include <cstdlib>           // For system operations like EXIT_FAILURE\n#include <cmath>             // For mathematical operations\n\n// Sensor data validity thresholds\nconst float min_valid_distance = 1.0f;  // Minimum valid distance for sensor data (in meters)\nconst float max_valid_distance = 100.0f;  // Maximum valid distance for sensor data (in meters)\nconst float collision_warning_threshold = 10.0f;  // Collision warning threshold (in meters)\n\n// Function to validate sensor data\nbool validate_sensor_data(float sensor_distance) {\n    return sensor_distance >= min_valid_distance && sensor_distance <= max_valid_distance;  // Check if distance is within valid range\n}\n\n// Function to process sensor data and trigger collision warning\nvoid process_sensor_data(float sensor_distance) {\n    if (!validate_sensor_data(sensor_distance)) {\n        std::cout << \"ERROR: Invalid sensor data\" << std::endl;  // Handle invalid sensor data\n        return;\n    }\n    if (sensor_distance < collision_warning_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float sensor_distance = 8.5f;  // Simulated sensor distance (in meters)\n\n    process_sensor_data(sensor_distance);  // Process sensor data for collision warning\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that dynamically adjusts the collision warning threshold based on vehicle speed. The threshold should increase as the speed of the vehicle increases.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>             // For input-output operations\n#include <cstdlib>              // For system operations like EXIT_FAILURE\n#include <cmath>                // For mathematical operations\n\n// Function to calculate dynamic threshold based on vehicle speed\nfloat calculate_dynamic_threshold(float vehicle_speed) {\n    return 0.3f * vehicle_speed;  // Threshold increases with vehicle speed\n}\n\n// Function to process object distance based on dynamic threshold\nvoid process_data(float object_distance, float vehicle_speed) {\n    float dynamic_threshold = calculate_dynamic_threshold(vehicle_speed);  // Calculate dynamic threshold\n\n    if (object_distance < dynamic_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Dynamic Threshold)\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float vehicle_speed = 40.0f;  // Simulated vehicle speed (in km/h)\n    float object_distance = 12.0f;  // Simulated object distance (in meters)\n\n    process_data(object_distance, vehicle_speed);  // Process data for collision warning\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses redundant data from multiple sensors (radar and LiDAR). The system should fuse data from both sensors to determine the risk of collision.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n#include <cmath>               // For mathematical operations\n\n// Constants\nconst float radar_threshold = 15.0f;    // Radar sensor threshold (in meters)\nconst float lidar_threshold = 12.0f;    // LiDAR sensor threshold (in meters)\nconst float collision_threshold = 10.0f; // Collision warning threshold (in meters)\n\n// Function to fuse data from radar and LiDAR sensors\nfloat fuse_sensor_data(float radar_distance, float lidar_distance) {\n    return (radar_distance + lidar_distance) / 2.0f;  // Calculate average distance\n}\n\n// Function to process sensor data and trigger warning\nvoid process_sensor_data(float radar_distance, float lidar_distance) {\n    float fused_distance = fuse_sensor_data(radar_distance, lidar_distance);  // Fuse sensor data\n\n    if (fused_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT (Fused Data)\" << std::endl;  // Trigger collision warning\n    }\n}\n\n// Main function to simulate FCW system\nint main() {\n    float radar_distance = 10.0f;    // Simulated radar sensor distance (in meters)\n    float lidar_distance = 8.0f;     // Simulated LiDAR sensor distance (in meters)\n\n    process_sensor_data(radar_distance, lidar_distance);  // Process sensor data for collision warning\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that triggers an alert based on both the distance and the relative speed of the detected object.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <cmath>               // For mathematical operations\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n\n// Constants\nconst float distance_threshold = 10.0f;  // Distance threshold for warning (in meters)\nconst float speed_threshold = 5.0f;      // Speed threshold for warning (in meters per second)\n\n// Function to calculate the relative speed between the vehicle and an object\nfloat calculate_relative_speed(float object_speed, float vehicle_speed) {\n    return object_speed - vehicle_speed;  // Return the relative speed\n}\n\n// Function to check collision risk based on distance and speed\nvoid check_collision_risk(float object_distance, float relative_speed) {\n    if (object_distance < distance_threshold && relative_speed > speed_threshold) {\n        std::cout << \"WARNING: COLLISION RISK (Distance and Speed)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 8.0f;    // Simulated object distance (in meters)\n    float object_speed = 12.0f;      // Simulated object speed (in meters per second)\n    float vehicle_speed = 20.0f;     // Simulated vehicle speed (in meters per second)\n\n    float relative_speed = calculate_relative_speed(object_speed, vehicle_speed);  // Calculate relative speed\n    check_collision_risk(object_distance, relative_speed);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that handles multiple object detections and triggers alerts based on the closest object.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>             // For input-output operations\n#include <vector>               // For storing multiple objects\n#include <cstdlib>              // For system operations like EXIT_FAILURE\n#include <cmath>                // For mathematical operations\n\n// Constants\nconst float collision_threshold = 10.0f;  // Collision warning threshold (in meters)\n\n// Structure to represent detected object\nstruct DetectedObject {\n    float distance;             // Distance to the object (in meters)\n    float speed;                // Speed of the object (in meters per second)\n};\n\n// Function to process detected objects and trigger warning for the closest object\nvoid process_objects(const std::vector<DetectedObject>& objects) {\n    if (objects.empty()) {\n        std::cout << \"No objects detected\" << std::endl;  // Handle no object case\n        return;\n    }\n    float closest_distance = objects[0].distance;  // Initialize closest distance\n    for (size_t i = 1; i < objects.size(); i++) {\n        if (objects[i].distance < closest_distance) {\n            closest_distance = objects[i].distance;  // Update closest object distance\n        }\n    }\n    if (closest_distance < collision_threshold) {\n        std::cout << \"WARNING: COLLISION RISK - Closest Object\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    std::vector<DetectedObject> objects = {\n        {5.0f, 15.0f},  // Example object 1 (distance, speed)\n        {8.0f, 10.0f},  // Example object 2 (distance, speed)\n        {3.0f, 20.0f}   // Example object 3 (distance, speed)\n    };\n\n    process_objects(objects);  // Process detected objects\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that takes into account the size of detected objects in determining the collision risk.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>              // For input-output operations\n#include <cstdlib>               // For system operations like EXIT_FAILURE\n#include <cmath>                 // For mathematical operations\n\n// Constants\nconst float collision_size_threshold = 1.8f;  // Threshold size for collision risk (in meters)\nconst float collision_distance_threshold = 10.0f;  // Distance threshold for collision warning (in meters)\n\n// Structure to represent detected object\nstruct DetectedObject {\n    float distance;             // Distance to the object (in meters)\n    float size;                 // Size of the object (in meters)\n};\n\n// Function to check collision risk based on object size and distance\nvoid check_collision_risk(const DetectedObject& object) {\n    if (object.size > collision_size_threshold && object.distance < collision_distance_threshold) {\n        std::cout << \"WARNING: COLLISION RISK (Size and Distance)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    DetectedObject object = {5.0f, 2.0f};  // Example object (distance, size)\n    check_collision_risk(object);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that incorporates the vehicle's acceleration in the collision risk calculation.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>               // For input-output operations\n#include <cstdlib>                // For system operations like EXIT_FAILURE\n#include <cmath>                  // For mathematical operations\n\n// Constants\nconst float max_safe_acceleration = 3.0f;  // Maximum safe acceleration (m/s^2)\nconst float collision_threshold = 10.0f;    // Collision warning threshold (meters)\n\n// Function to check if the vehicle's acceleration is within safe limits\nbool is_safe_acceleration(float vehicle_acceleration) {\n    return vehicle_acceleration <= max_safe_acceleration;  // Check if acceleration is within safe limits\n}\n\n// Function to calculate collision risk based on distance and acceleration\nvoid check_collision_risk(float object_distance, float vehicle_acceleration) {\n    if (object_distance < collision_threshold && !is_safe_acceleration(vehicle_acceleration)) {\n        std::cout << \"WARNING: COLLISION RISK (Unsafe Acceleration)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 5.0f;          // Example object distance (in meters)\n    float vehicle_acceleration = 4.0f;     // Example vehicle acceleration (in m/s^2)\n\n    check_collision_risk(object_distance, vehicle_acceleration);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses camera calibration data to accurately detect objects and calculate distances.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>               // For input-output operations\n#include <cmath>                  // For mathematical operations\n#include <cstdlib>                 // For system operations like EXIT_FAILURE\n\n// Constants\nconst float focal_length_x = 1000.0f;  // Camera focal length (in pixels)\nconst float focal_length_y = 1000.0f;  // Camera focal length (in pixels)\nconst float object_width = 1.8f;        // Object width (meters)\n\n// Function to calculate object distance from camera based on image data\nfloat calculate_object_distance(float object_width_in_image, float image_width) {\n    return (object_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);  // Distance formula\n}\n\n// Function to process detected object data\nvoid process_object_data(float object_width_in_image, float image_width) {\n    float distance = calculate_object_distance(object_width_in_image, image_width);  // Calculate distance\n    if (distance < 10.0f) {\n        std::cout << \"WARNING: COLLISION RISK (Object Too Close)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    float object_width_in_image = 100.0f;  // Example object width in image (pixels)\n    float image_width = 1280.0f;           // Example image width (pixels)\n\n    process_object_data(object_width_in_image, image_width);  // Process detected object data\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that tracks objects and monitors their distance in real-time for collision risk.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>             // For input-output operations\n#include <vector>               // For storing object data\n#include <cstdlib>              // For system operations like EXIT_FAILURE\n\n// Constants\nconst float distance_threshold = 10.0f;  // Distance threshold for warning (meters)\n\n// Structure to represent an object being tracked\nstruct TrackedObject {\n    float distance;             // Distance to object (meters)\n    float speed;                // Speed of object (m/s)\n};\n\n// Function to track objects and monitor distance\nvoid track_objects(std::vector<TrackedObject>& objects) {\n    for (size_t i = 0; i < objects.size(); i++) {\n        if (objects[i].distance < distance_threshold) {\n            std::cout << \"WARNING: COLLISION RISK\" << std::endl;  // Trigger collision warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    std::vector<TrackedObject> objects = {\n        {8.0f, 12.0f},  // Example object 1\n        {5.0f, 15.0f}   // Example object 2\n    };\n\n    track_objects(objects);  // Track objects and monitor distances\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that incorporates vehicle braking status into collision risk detection.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n#include <cmath>               // For mathematical operations\n\n// Constants\nconst float braking_threshold = 3.0f;  // Braking threshold (in meters per second^2)\nconst float collision_distance_threshold = 5.0f;  // Distance threshold for warning (meters)\n\n// Function to check if vehicle is braking and distance is unsafe\nvoid check_collision_risk(float object_distance, float vehicle_braking_status) {\n    if (vehicle_braking_status > braking_threshold && object_distance < collision_distance_threshold) {\n        std::cout << \"WARNING: COLLISION RISK (Braking and Distance)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 3.0f;            // Example object distance (in meters)\n    float vehicle_braking_status = 4.5f;     // Example vehicle braking status (in meters per second^2)\n\n    check_collision_risk(object_distance, vehicle_braking_status);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates object speed and angle relative to the vehicle to assess collision risk.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>                // For input-output operations\n#include <cmath>                   // For mathematical operations\n#include <cstdlib>                  // For system operations like EXIT_FAILURE\n\n// Constants\nconst float collision_distance_threshold = 10.0f;  // Distance threshold for warning (meters)\n\n// Function to calculate relative angle between vehicle and object\nfloat calculate_angle(float object_x, float object_y, float vehicle_x, float vehicle_y) {\n    return atan2(object_y - vehicle_y, object_x - vehicle_x);  // Calculate angle using atan2\n}\n\n// Function to calculate relative speed between vehicle and object\nfloat calculate_speed(float object_speed, float vehicle_speed) {\n    return object_speed - vehicle_speed;  // Calculate relative speed\n}\n\n// Function to check for collision risk based on speed and angle\nvoid check_collision_risk(float object_distance, float relative_speed, float angle) {\n    if (object_distance < collision_distance_threshold && relative_speed > 0.0f && angle < 45.0f) {\n        std::cout << \"WARNING: COLLISION RISK (Speed, Angle, and Distance)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 8.0f;             // Example object distance (in meters)\n    float object_speed = 15.0f;               // Example object speed (in meters per second)\n    float vehicle_speed = 20.0f;              // Example vehicle speed (in meters per second)\n    float object_x = 50.0f, object_y = 60.0f;  // Example object coordinates (in meters)\n    float vehicle_x = 40.0f, vehicle_y = 50.0f;  // Example vehicle coordinates (in meters)\n\n    float relative_speed = calculate_speed(object_speed, vehicle_speed);  // Calculate relative speed\n    float angle = calculate_angle(object_x, object_y, vehicle_x, vehicle_y);  // Calculate relative angle\n    check_collision_risk(object_distance, relative_speed, angle);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that validates sensor data to avoid false positives.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n#include <cmath>               // For mathematical operations\n\n// Constants\nconst float valid_distance_range_min = 1.0f;   // Minimum valid distance (meters)\nconst float valid_distance_range_max = 50.0f;  // Maximum valid distance (meters)\nconst float valid_speed_range_min = 0.0f;      // Minimum valid speed (m/s)\nconst float valid_speed_range_max = 30.0f;     // Maximum valid speed (m/s)\n\n// Function to validate sensor data\nbool validate_sensor_data(float object_distance, float object_speed) {\n    return (object_distance >= valid_distance_range_min && object_distance <= valid_distance_range_max) &&\n           (object_speed >= valid_speed_range_min && object_speed <= valid_speed_range_max);  // Return true if valid\n}\n\n// Function to check collision risk\nvoid check_collision_risk(float object_distance, float object_speed) {\n    if (validate_sensor_data(object_distance, object_speed)) {\n        if (object_distance < 10.0f) {\n            std::cout << \"WARNING: COLLISION RISK (Validated)\" << std::endl;  // Trigger warning\n        }\n    } else {\n        std::cout << \"ERROR: Invalid sensor data\" << std::endl;  // Handle invalid data\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 8.0f;   // Example object distance (meters)\n    float object_speed = 15.0f;     // Example object speed (m/s)\n\n    check_collision_risk(object_distance, object_speed);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adapts the warning level based on the vehicle's speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>                // For input-output operations\n#include <cstdlib>                 // For system operations like EXIT_FAILURE\n#include <cmath>                   // For mathematical operations\n\n// Constants\nconst float low_speed_threshold = 10.0f;    // Low-speed threshold (m/s)\nconst float high_speed_threshold = 20.0f;   // High-speed threshold (m/s)\nconst float distance_threshold = 10.0f;      // Distance threshold for warning (meters)\n\n// Function to adjust warning level based on vehicle speed\nvoid adjust_warning_level(float vehicle_speed, float object_distance) {\n    if (vehicle_speed < low_speed_threshold) {\n        if (object_distance < 15.0f) {\n            std::cout << \"LOW SPEED WARNING: Collision risk detected (adjusted)\" << std::endl;  // Adjusted warning for low speed\n        }\n    } else if (vehicle_speed > high_speed_threshold) {\n        if (object_distance < distance_threshold) {\n            std::cout << \"HIGH SPEED WARNING: Collision risk detected (adjusted)\" << std::endl;  // Adjusted warning for high speed\n        }\n    } else {\n        if (object_distance < distance_threshold) {\n            std::cout << \"WARNING: Collision risk detected (standard)\" << std::endl;  // Standard warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    float vehicle_speed = 25.0f;    // Example vehicle speed (m/s)\n    float object_distance = 8.0f;   // Example object distance (meters)\n\n    adjust_warning_level(vehicle_speed, object_distance);  // Adjust warning level based on speed\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adapts the warning level based on the vehicle's speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>                // For input-output operations\n#include <cstdlib>                 // For system operations like EXIT_FAILURE\n#include <cmath>                   // For mathematical operations\n\n// Constants\nconst float low_speed_threshold = 10.0f;    // Low-speed threshold (m/s)\nconst float high_speed_threshold = 20.0f;   // High-speed threshold (m/s)\nconst float distance_threshold = 10.0f;      // Distance threshold for warning (meters)\n\n// Function to adjust warning level based on vehicle speed\nvoid adjust_warning_level(float vehicle_speed, float object_distance) {\n    if (vehicle_speed < low_speed_threshold) {\n        if (object_distance < 15.0f) {\n            std::cout << \"LOW SPEED WARNING: Collision risk detected (adjusted)\" << std::endl;  // Adjusted warning for low speed\n        }\n    } else if (vehicle_speed > high_speed_threshold) {\n        if (object_distance < distance_threshold) {\n            std::cout << \"HIGH SPEED WARNING: Collision risk detected (adjusted)\" << std::endl;  // Adjusted warning for high speed\n        }\n    } else {\n        if (object_distance < distance_threshold) {\n            std::cout << \"WARNING: Collision risk detected (standard)\" << std::endl;  // Standard warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    float vehicle_speed = 25.0f;    // Example vehicle speed (m/s)\n    float object_distance = 8.0f;   // Example object distance (meters)\n\n    adjust_warning_level(vehicle_speed, object_distance);  // Adjust warning level based on speed\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adapts the warning level based on the vehicle's speed.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>                // For input-output operations\n#include <cstdlib>                 // For system operations like EXIT_FAILURE\n#include <cmath>                   // For mathematical operations\n\n// Constants\nconst float low_speed_threshold = 10.0f;    // Low-speed threshold (m/s)\nconst float high_speed_threshold = 20.0f;   // High-speed threshold (m/s)\nconst float distance_threshold = 10.0f;      // Distance threshold for warning (meters)\n\n// Function to adjust warning level based on vehicle speed\nvoid adjust_warning_level(float vehicle_speed, float object_distance) {\n    if (vehicle_speed < low_speed_threshold) {\n        if (object_distance < 15.0f) {\n            std::cout << \"LOW SPEED WARNING: Collision risk detected (adjusted)\" << std::endl;  // Adjusted warning for low speed\n        }\n    } else if (vehicle_speed > high_speed_threshold) {\n        if (object_distance < distance_threshold) {\n            std::cout << \"HIGH SPEED WARNING: Collision risk detected (adjusted)\" << std::endl;  // Adjusted warning for high speed\n        }\n    } else {\n        if (object_distance < distance_threshold) {\n            std::cout << \"WARNING: Collision risk detected (standard)\" << std::endl;  // Standard warning\n        }\n    }\n}\n\n// Main function\nint main() {\n    float vehicle_speed = 25.0f;    // Example vehicle speed (m/s)\n    float object_distance = 8.0f;   // Example object distance (meters)\n\n    adjust_warning_level(vehicle_speed, object_distance);  // Adjust warning level based on speed\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that considers multiple objects in the detection zone and triggers a warning for the closest object.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <vector>              // For handling multiple objects\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n\n// Constants\nconst float distance_threshold = 10.0f;  // Distance threshold for warning (meters)\n\n// Structure to represent object\nstruct Object {\n    float distance;  // Distance to object (meters)\n    float speed;     // Speed of object (m/s)\n};\n\n// Function to check collision risk for multiple objects\nvoid check_collision_risk(std::vector<Object> objects) {\n    for (const auto& obj : objects) {\n        if (obj.distance < distance_threshold) {\n            std::cout << \"WARNING: COLLISION RISK (Object at \" << obj.distance << \" meters)\" << std::endl;  // Trigger warning for each object\n        }\n    }\n}\n\n// Main function\nint main() {\n    std::vector<Object> objects = {\n        {8.0f, 12.0f},  // Object 1 (distance in meters, speed in m/s)\n        {5.0f, 10.0f},  // Object 2\n        {15.0f, 18.0f}  // Object 3\n    };\n\n    check_collision_risk(objects);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that includes pedestrian detection and triggers a warning when a pedestrian is in front of the vehicle.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>                // For input-output operations\n#include <cstdlib>                 // For system operations like EXIT_FAILURE\n#include <cmath>                   // For mathematical operations\n\n// Constants\nconst float pedestrian_warning_distance = 5.0f;  // Distance threshold for pedestrian warning (meters)\n\n// Structure to represent object (pedestrian)\nstruct Pedestrian {\n    float distance;  // Distance to pedestrian (meters)\n    bool is_detected; // Whether pedestrian is detected\n};\n\n// Function to check for collision risk with pedestrians\nvoid check_pedestrian_collision(Pedestrian pedestrian) {\n    if (pedestrian.is_detected && pedestrian.distance < pedestrian_warning_distance) {\n        std::cout << \"WARNING: PEDESTRIAN COLLISION RISK\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    Pedestrian pedestrian = {4.0f, true};  // Example pedestrian (distance in meters, is_detected = true)\n\n    check_pedestrian_collision(pedestrian);  // Check for pedestrian collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates the Time-to-Collision (TTC) and triggers a warning if the TTC is below a threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>            // For input-output operations\n#include <cmath>               // For mathematical operations\n#include <cstdlib>             // For system operations like EXIT_FAILURE\n\n// Constants\nconst float ttc_threshold = 2.0f;  // Time-to-collision threshold (seconds)\n\n// Function to calculate Time-to-Collision (TTC)\nfloat calculate_ttc(float object_distance, float relative_speed) {\n    if (relative_speed > 0.0f) {\n        return object_distance / relative_speed;  // Calculate TTC (seconds)\n    }\n    return 0.0f;  // Return 0 if relative speed is zero or negative\n}\n\n// Function to check collision risk based on TTC\nvoid check_collision_risk(float object_distance, float relative_speed) {\n    float ttc = calculate_ttc(object_distance, relative_speed);  // Calculate TTC\n    if (ttc < ttc_threshold) {\n        std::cout << \"WARNING: COLLISION RISK (TTC below threshold)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 15.0f;  // Example object distance (meters)\n    float relative_speed = 10.0f;   // Example relative speed (m/s)\n\n    check_collision_risk(object_distance, relative_speed);  // Check for collision risk\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses sensor fusion (combining radar and camera data) for enhanced collision detection accuracy.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <iostream>              // For input-output operations\n#include <vector>                // For handling sensor data\n#include <cstdlib>               // For system operations like EXIT_FAILURE\n#include <cmath>                 // For mathematical operations\n\n// Constants\nconst float sensor_fusion_threshold = 12.0f;  // Fusion distance threshold (meters)\n\n// Structure to represent sensor data\nstruct SensorData {\n    float radar_distance;  // Distance from radar sensor (meters)\n    float camera_distance; // Distance from camera sensor (meters)\n    float speed;           // Speed (m/s)\n};\n\n// Function to fuse sensor data and detect collision risk\nvoid check_collision_risk(SensorData data) {\n    float fused_distance = std::min(data.radar_distance, data.camera_distance);  // Fuse sensor data\n    if (fused_distance < sensor_fusion_threshold) {\n        std::cout << \"WARNING: COLLISION RISK (Sensor Fusion)\" << std::endl;  // Trigger warning\n    }\n}\n\n// Main function\nint main() {\n    SensorData sensor_data = {8.0f, 9.0f, 15.0f};  // Example sensor data (distances in meters, speed in m/s)\n\n    check_collision_risk(sensor_data);  // Check for collision risk based on sensor fusion\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate a MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects objects using OpenCV, calculates the distance to the object, and triggers a warning if the distance is less than a threshold. Ensure that error handling, comments, and MISRA rules are strictly followed.",
      "input": "Follow MISRA guidelines such as no implicit type conversions, no 'using namespace', and ensure that every operation has appropriate comments explaining its purpose.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for image processing\n#include <iostream>  // For standard input-output\n#include <cmath>  // For mathematical calculations\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For storing detected objects\n#include <string>  // For string handling\n\n// Camera calibration parameters\nconst float focal_length_x = 1000.0f;  // Camera focal length in X axis\nconst float focal_length_y = 1000.0f;  // Camera focal length in Y axis\nconst float car_width = 1.8f;  // Average width of a car (in meters)\n\n// Threshold for collision warning\nconst float collision_threshold = 10.0f;  // Distance in meters to trigger the warning\n\n// Object structure to hold detected objects' data\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box coordinates\n    float distance;         // Calculated distance to the object\n    std::string label;      // Label of detected object (e.g., car, truck)\n};\n\n// Function to calculate the distance based on object width in the image\nfloat calculate_distance(int object_width, int image_width) {\n    // Distance calculation using camera calibration and object size\n    return (car_width * focal_length_x * image_width) / (object_width * focal_length_x);\n}\n\n// Function to process the captured frame and detect objects\nvoid process_image(cv::Mat &frame) {\n    // Example: manually creating a detected object (this would be replaced with actual object detection)\n    cv::Rect detected_object(400, 300, 100, 50);  // Simulated bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object distance\n    obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);\n\n    // Display the bounding box and distance on the frame\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw rectangle\n    std::string text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Display text\n\n    // Check if the object is within the collision threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);  // Warning message\n    }\n}\n\n// Main loop to handle video capture\nint main() {\n    cv::VideoCapture cap(0);  // Initialize video capture (use 0 for default camera)\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open video capture!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame from the camera\n\n        if (frame.empty()) {\n            break;  // Break if no frame is captured (end of video)\n        }\n\n        process_image(frame);  // Process the frame for object detection and distance calculation\n\n        // Display the processed frame\n        cv::imshow(\"Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit if 'q' is pressed\n        }\n    }\n\n    cap.release();  // Release the video capture object\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ code for a Forward Collision Warning system that uses camera input to detect objects, calculates the distance to these objects, and triggers an alert if the distance is too short. Ensure compliance with all MISRA guidelines, with detailed comments explaining each function.",
      "input": "Follow MISRA guidelines, avoiding undefined behaviors, proper error checking, and ensuring clarity with comments for every operation. No use of 'using namespace'.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV for image processing\n#include <iostream>  // Include iostream for console output\n#include <cmath>  // Include math library for distance calculation\n#include <cstdlib>  // Include for system functions\n\n// Calibration parameters\nconst float focal_length_x = 950.0f;  // Focal length for X-axis\nconst float focal_length_y = 950.0f;  // Focal length for Y-axis\nconst float car_width = 1.8f;  // Car width in meters\nconst float collision_threshold = 8.0f;  // Collision warning threshold (in meters)\n\n// Structure to store detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Calculated distance\n};\n\n// Function to calculate distance from object width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Using basic formula to calculate distance from width of the object in the image\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process image and detect objects\nvoid process_image(cv::Mat &image) {\n    // Simulated detection of an object\n    cv::Rect detected_object(500, 300, 120, 60);  // Example object\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the distance of the detected object\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n\n    // Draw bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision risk\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame from camera\n\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_image(frame);  // Process the captured frame\n        cv::imshow(\"FCW System\", frame);  // Display the processed image\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit loop on 'q' key press\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program for a Forward Collision Warning (FCW) system, ensuring compliance with MISRA 2023 guidelines. The program should detect vehicles using a camera system, calculate distances, and trigger a warning when the distance falls below a safety threshold.",
      "input": "Ensure all type conversions are explicit, no use of global variables, and include necessary error handling.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For standard input/output\n#include <cmath>  // For math functions\n#include <cstdlib>  // For system-level operations\n\n// Camera calibration parameters\nconst float focal_length_x = 800.0f;  // Focal length in X direction\nconst float car_width = 1.8f;  // Average car width in meters\nconst float collision_threshold = 7.0f;  // Collision warning threshold (meters)\n\n// Structure for storing detected object information\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box of the object\n    float distance;         // Calculated distance\n};\n\n// Function to calculate distance based on object width in image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process the image and detect objects\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(400, 250, 150, 75);  // Example object (bounding box)\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);  // Calculate distance\n\n    // Display bounding box and distance\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision risk check\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"COLLISION WARNING!\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera for video capture\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open video capture!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame from camera\n\n        if (frame.empty()) {\n            break;  // Exit if no frame is captured\n        }\n\n        process_image(frame);  // Process frame\n        cv::imshow(\"FCW System\", frame);  // Display the processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on pressing 'q'\n        }\n    }\n\n    cap.release();  // Release video capture\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning system that calculates the distance to the detected object using OpenCV. The system should provide a collision warning when the distance falls below a threshold. Ensure compliance with all MISRA guidelines, including detailed comments explaining each part of the code.",
      "input": "Follow MISRA guidelines such as proper error handling, clear variable names, and avoidance of implicit type conversions. Provide detailed comments for each operation.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input/output operations\n#include <cmath>  // For mathematical functions\n#include <cstdlib>  // For system-level operations\n#include <vector>  // For using vector containers\n#include <string>  // For string manipulation\n\n// Camera calibration parameters\nconst float focal_length_x = 1050.0f;  // Focal length along X axis\nconst float car_width = 2.0f;  // Car width in meters\nconst float collision_threshold = 5.0f;  // Distance threshold for collision warning\n\n// Structure to hold the object details\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Object bounding box\n    float distance;         // Object distance\n};\n\n// Function to calculate distance from object width in the image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process the image for detecting objects\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(300, 200, 100, 50);  // Simulated detected object\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate object distance\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n\n    // Display bounding box and distance\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision risk check\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(100, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open the camera for video capture\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture the frame from the camera\n\n        if (frame.empty()) {\n            break;  // Break if no frame is captured\n        }\n\n        process_image(frame);  // Process the captured frame\n        cv::imshow(\"Forward Collision Warning System\", frame);  // Display the frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q' key press\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Develop a MISRA 2023-compliant C++ program for a Forward Collision Warning (FCW) system that uses a camera to detect objects, calculates their distance, and displays a collision warning if the distance is below a threshold. Ensure that the code is fully compliant with MISRA guidelines and well-documented.",
      "input": "Adhere to MISRA guidelines by ensuring no dynamic memory allocation, using explicit type conversions, and including appropriate error handling.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV library for image processing\n#include <iostream>  // Include standard input/output library\n#include <cmath>  // Include math library for calculations\n\n// Camera calibration parameters\nconst float focal_length = 800.0f;  // Focal length in pixels\nconst float car_width = 1.8f;  // Average car width in meters\nconst float collision_distance = 6.0f;  // Collision warning threshold (in meters)\n\n// Structure to store detected object details\nstruct ObjectDetails {\n    cv::Rect bounding_box;  // Bounding box of the object\n    float distance;         // Calculated distance to the object\n};\n\n// Function to calculate distance based on object width\nfloat calculate_distance(int object_width, int image_width) {\n    return (car_width * focal_length * image_width) / (object_width * focal_length);\n}\n\n// Function to process the image\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(300, 200, 120, 60);  // Simulated object detection\n    ObjectDetails obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate distance from the object\n    obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);\n\n    // Display bounding box and distance\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_str = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_str, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision check\n    if (obj.distance < collision_distance) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_frame(frame);  // Process frame\n        cv::imshow(\"FCW System\", frame);  // Display frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q' key\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ code for a Forward Collision Warning system that processes video feed, detects objects, calculates their distance, and triggers an alert if the distance is under a safety threshold. Ensure compliance with all MISRA C:2023 guidelines, including explicit error handling and no use of dynamic memory allocation.",
      "input": "Ensure strict type checking, use explicit casting, and provide clear comments explaining each function.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV for image processing\n#include <iostream>  // For console output\n#include <cmath>  // For distance calculations\n#include <cstdlib>  // For system functions\n\n// Constants for camera and detection\nconst float focal_length = 900.0f;  // Camera focal length\nconst float vehicle_width = 1.8f;  // Width of the vehicle in meters\nconst float warning_threshold = 5.0f;  // Collision warning threshold in meters\n\n// Structure for detected object information\nstruct ObjectData {\n    cv::Rect bbox;  // Object bounding box\n    float distance;  // Distance to the object\n};\n\n// Function to calculate distance to an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\n// Function to process video frames\nvoid process_video_frame(cv::Mat &frame) {\n    cv::Rect detected_object(320, 240, 100, 50);  // Simulated object\n    ObjectData obj;\n    obj.bbox = detected_object;\n\n    // Calculate the distance to the object\n    obj.distance = calculate_distance(obj.bbox.width, frame.cols);\n\n    // Display bounding box and distance\n    cv::rectangle(frame, obj.bbox, cv::Scalar(0, 255, 0), 2);\n    std::string text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, text, cv::Point(obj.bbox.x, obj.bbox.y - 10), cv::FONT_HERSHEY_SIMPLEX, \n                0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (obj.distance < warning_threshold) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(100, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open video capture!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_video_frame(frame);  // Process frame\n        cv::imshow(\"Forward Collision Warning\", frame);  // Display processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q'\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate a MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses camera input to detect objects, calculate their distance, and trigger a warning if the object is within a predefined safety threshold. Ensure no use of global variables and strict adherence to error handling procedures.",
      "input": "Follow all MISRA guidelines for type safety, variable naming conventions, and memory management. Provide clear comments explaining each step of the process.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for computer vision\n#include <iostream>  // Standard input/output\n#include <cmath>  // Math functions for distance calculations\n#include <cstdlib>  // For system-level operations\n\n// Calibration parameters\nconst float focal_length_x = 800.0f;  // Focal length in x-direction\nconst float car_width = 2.0f;  // Vehicle width in meters\nconst float safety_distance = 4.0f;  // Distance threshold for collision warning\n\n// Structure to hold object data\nstruct Object {\n    cv::Rect bounding_box;  // Bounding box of detected object\n    float distance;         // Distance to object\n};\n\n// Function to calculate distance from object width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process a frame and calculate distance\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(250, 200, 80, 40);  // Simulated object\n    Object obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate distance\n    obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);\n\n    // Draw bounding box and display distance\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning logic\n    if (obj.distance < safety_distance) {\n        cv::putText(frame, \"COLLISION IMMINENT!\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main program\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_frame(frame);  // Process captured frame\n        cv::imshow(\"FCW System\", frame);  // Display frame with bounding box\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q'\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for a Forward Collision Warning system that processes camera input to detect objects, calculates their distance, and provides a collision warning if an object is too close. The code should follow MISRA C:2023 rules, with proper error handling and no use of dynamic memory allocation.",
      "input": "Ensure that all functions are clearly defined, no global variables are used, and error handling is explicit and appropriate.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for computer vision\n#include <iostream>  // For standard input/output\n#include <cmath>  // For calculations\n#include <cstdlib>  // For system operations\n\n// Constants\nconst float focal_length_y = 800.0f;  // Focal length in y-direction\nconst float vehicle_length = 4.5f;  // Vehicle length in meters\nconst float danger_zone = 3.0f;  // Distance threshold for collision warning\n\n// Structure to store detected object information\nstruct ObjectDetection {\n    cv::Rect box;  // Bounding box\n    float distance;  // Distance to the object\n};\n\n// Calculate the distance to the object\nfloat calculate_object_distance(int object_width_in_image, int image_width) {\n    return (vehicle_length * focal_length_y * image_width) / (object_width_in_image * focal_length_y);\n}\n\n// Function to process a frame\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(350, 220, 110, 55);  // Simulated object detection\n    ObjectDetection detection;\n    detection.box = detected_object;\n\n    // Calculate object distance\n    detection.distance = calculate_object_distance(detection.box.width, frame.cols);\n\n    // Draw bounding box and display distance\n    cv::rectangle(frame, detection.box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_str = \"Distance: \" + std::to_string(detection.distance) + \" m\";\n    cv::putText(frame, distance_str, cv::Point(detection.box.x, detection.box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (detection.distance < danger_zone) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(150, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_frame(frame);  // Process frame\n        cv::imshow(\"Forward Collision Warning\", frame);  // Display frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q'\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for Forward Collision Warning (FCW) system that processes real-time camera video to detect objects, calculates their distance, and displays a warning if the object is within a dangerous distance. Follow all MISRA C:2023 rules for safety-critical systems.",
      "input": "Ensure proper use of types, prevent memory errors, and include explicit error handling.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for image processing\n#include <iostream>  // For input/output\n#include <cmath>  // For mathematical calculations\n#include <cstdlib>  // For system-level functionality\n\n// Constants\nconst float focal_length_x = 1000.0f;  // Focal length in x-direction\nconst float vehicle_width = 2.0f;  // Vehicle width in meters\nconst float collision_alert_threshold = 3.0f;  // Threshold for collision alert\n\n// Structure to store object information\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box coordinates\n    float distance;  // Distance to the object\n};\n\n// Function to calculate distance to object\nfloat calculate_object_distance(int object_width, int image_width) {\n    return (vehicle_width * focal_length_x * image_width) / (object_width * focal_length_x);\n}\n\n// Function to process video frame\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(320, 180, 90, 45);  // Example object detection\n    DetectedObject object;\n    object.bounding_box = detected_object;\n\n    // Calculate distance\n    object.distance = calculate_object_distance(object.bounding_box.width, frame.cols);\n\n    // Draw bounding box and display distance\n    cv::rectangle(frame, object.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_str = \"Distance: \" + std::to_string(object.distance) + \" m\";\n    cv::putText(frame, distance_str, cv::Point(object.bounding_box.x, object.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check for collision warning\n    if (object.distance < collision_alert_threshold) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(100, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot access camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_frame(frame);  // Process frame\n        cv::imshow(\"FCW System\", frame);  // Show processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q'\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for Forward Collision Warning (FCW)  system that processes video frames to detect objects, estimates their speed, and provides a warning if their speed is too high and collision risk is imminent. Follow the MISRA guidelines to ensure safety and reliability.",
      "input": "Ensure proper handling of sensor data, avoid using dynamic memory allocation, and implement detailed error handling.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For I/O\n#include <cmath>  // For math functions\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float safe_speed_limit = 50.0f;  // Speed threshold for warning (km/h)\nconst float vehicle_length = 4.0f;  // Vehicle length in meters\n\n// Structure to hold object information\nstruct ObjectDetection {\n    cv::Rect bounding_box;  // Bounding box\n    float speed;  // Speed in km/h\n};\n\n// Function to estimate object speed based on previous frame\nfloat estimate_speed(const cv::Rect &current_box, const cv::Rect &previous_box, float frame_rate) {\n    float distance_moved = std::abs(current_box.x - previous_box.x);  // Horizontal distance moved\n    return (distance_moved / frame_rate) * 3.6f;  // Speed in km/h\n}\n\n// Function to process each frame\nvoid process_frame(cv::Mat &frame, cv::Rect &previous_box) {\n    cv::Rect current_box(350, 220, 120, 60);  // Simulated object detection\n    ObjectDetection detection;\n    detection.bounding_box = current_box;\n\n    // Estimate speed of object\n    detection.speed = estimate_speed(current_box, previous_box, 30.0f);  // Assuming 30 FPS\n\n    // Draw bounding box\n    cv::rectangle(frame, detection.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string speed_text = \"Speed: \" + std::to_string(detection.speed) + \" km/h\";\n    cv::putText(frame, speed_text, cv::Point(detection.bounding_box.x, detection.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning logic\n    if (detection.speed > safe_speed_limit) {\n        cv::putText(frame, \"WARNING: SPEED EXCEEDED!\", cv::Point(100, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot open camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect previous_box(0, 0, 0, 0);  // Initialize previous box\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_frame(frame, previous_box);  // Process frame\n        previous_box = cv::Rect(350, 220, 120, 60);  // Update previous box for next frame\n        cv::imshow(\"FCW System\", frame);  // Show processed frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q'\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for Forward Collision Warning (FCW) system that uses a camera to detect obstacles in front of the vehicle, estimate their relative speed, and trigger a collision warning if they are approaching too quickly.",
      "input": "Ensure the program is free of dynamic memory allocations and that safety features are clearly implemented according to MISRA guidelines.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for vision tasks\n#include <iostream>  // I/O operations\n#include <cmath>  // For speed and distance calculations\n#include <cstdlib>  // For system operations\n\n// Constants\nconst float danger_distance = 5.0f;  // Distance threshold (meters)\nconst float vehicle_width = 2.0f;  // Vehicle width in meters\n\n// Structure for storing detected object data\nstruct ObjectData {\n    cv::Rect bbox;  // Object bounding box\n    float speed;  // Object speed (m/s)\n};\n\n// Function to estimate relative speed\nfloat calculate_relative_speed(cv::Rect &current_box, cv::Rect &previous_box, float frame_rate) {\n    float delta_x = std::abs(current_box.x - previous_box.x);  // Change in position\n    return (delta_x / frame_rate);  // Estimated speed in meters per second\n}\n\n// Function to process the frame\nvoid process_frame(cv::Mat &frame, cv::Rect &previous_bbox) {\n    cv::Rect detected_object(350, 200, 80, 40);  // Simulated detection\n    ObjectData object;\n    object.bbox = detected_object;\n\n    // Estimate speed of the detected object\n    object.speed = calculate_relative_speed(object.bbox, previous_bbox, 30.0f);  // Assuming 30 FPS\n\n    // Draw bounding box\n    cv::rectangle(frame, object.bbox, cv::Scalar(0, 255, 0), 2);\n    std::string speed_text = \"Speed: \" + std::to_string(object.speed) + \" m/s\";\n    cv::putText(frame, speed_text, cv::Point(object.bbox.x, object.bbox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning logic\n    if (object.speed > 5.0f) {\n        cv::putText(frame, \"WARNING: HIGH SPEED!\", cv::Point(100, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Cannot access camera!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect previous_bbox(0, 0, 0, 0);  // Initialize bounding box\n    while (true) {\n        cap >> frame;  // Capture frame\n        if (frame.empty()) {\n            break;  // Exit if no frame\n        }\n\n        process_frame(frame, previous_bbox);  // Process the frame\n        previous_bbox = cv::Rect(350, 200, 80, 40);  // Update previous box\n        cv::imshow(\"FCW System\", frame);  // Display the frame\n\n        if (cv::waitKey(1) == 'q') {\n            break;  // Exit on 'q'\n        }\n    }\n\n    cap.release();  // Release camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program for a Forward Collision Warning (FCW) system in compliance with MISRA C:2023 that uses radar data to estimate the distance and speed of objects ahead of the vehicle, triggering an alert if collision risk is detected.",
      "input": "Handle data processing in a way that avoids unnecessary allocations, and ensure that the algorithm complies with the MISRA C guidelines for safety-critical systems.",
      "output": "#include <iostream>  // For I/O operations\n#include <cmath>  // For calculations\n#include <cstdlib>  // For system operations\n\n// Constants\nconst float danger_zone_distance = 30.0f;  // Distance threshold for warning (meters)\nconst float max_allowed_speed = 120.0f;  // Max speed before warning (km/h)\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float object_distance, float vehicle_speed) {\n    return std::sqrt(std::pow(vehicle_speed, 2) - std::pow(object_distance, 2));\n}\n\n// Function to process radar data\nvoid process_radar_data(float object_distance, float object_speed, float vehicle_speed) {\n    float relative_speed = calculate_relative_speed(object_distance, vehicle_speed);\n\n    // Collision risk detection\n    if (object_distance < danger_zone_distance && relative_speed > max_allowed_speed) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 25.0f;  // Example radar data\n    float object_speed = 90.0f;  // Example object speed\n    float vehicle_speed = 80.0f;  // Example vehicle speed\n\n    process_radar_data(object_distance, object_speed, vehicle_speed);  // Process data\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for a Forward Collision Warning system using ultrasonic sensor data to detect objects and estimate the collision risk.",
      "input": "Ensure compliance with MISRA C guidelines for memory handling and code safety. Include minimalistic error handling and safety checks.",
      "output": "#include <iostream>  // For I/O\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float safe_distance = 3.0f;  // Safe distance in meters\nconst float warning_threshold = 1.0f;  // Distance for warning in meters\n\n// Function to process ultrasonic sensor data\nvoid process_sensor_data(float distance) {\n    if (distance < warning_threshold) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else if (distance < safe_distance) {\n        std::cout << \"Alert: Approaching object!\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float sensor_data = 0.8f;  // Example sensor data\n    process_sensor_data(sensor_data);  // Process data\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program  for a Forward Collision Warning (FCW) system using lidar data to detect objects in front of the vehicle and predict the risk of collision based on their speed and distance.",
      "input": "The program must avoid the use of dynamic memory allocation and ensure safety-critical handling of sensor data.",
      "output": "#include <iostream>  // I/O functionality\n#include <cmath>  // Math functions\n#include <cstdlib>  // System functions\n\n// Constants\nconst float collision_distance_threshold = 3.0f;  // Threshold for collision risk (meters)\nconst float max_approach_speed = 10.0f;  // Speed threshold for risk warning (m/s)\n\n// Function to compute relative speed\nfloat compute_relative_speed(float object_distance, float object_speed) {\n    return object_speed - (object_distance / 2.0f);  // Simplified relative speed calculation\n}\n\n// Function to process lidar data\nvoid process_lidar_data(float object_distance, float object_speed) {\n    float relative_speed = compute_relative_speed(object_distance, object_speed);\n\n    // Collision warning logic\n    if (object_distance < collision_distance_threshold && relative_speed > max_approach_speed) {\n        std::cout << \"WARNING: HIGH COLLISION RISK!\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 2.5f;  // Example lidar data\n    float object_speed = 8.0f;  // Example object speed\n\n    process_lidar_data(object_distance, object_speed);  // Process lidar data\n    return 0;\n}"
    },
    {
      "instruction": "Develop a MISRA C:2023-compliant C++ program for a Forward Collision Warning (FCW) system using radar sensors that triggers a collision warning if an object is detected within a specified range and speed limit.",
      "input": "Ensure the program adheres to MISRA rules for error handling and avoids using dynamic memory allocation.",
      "output": "#include <iostream>  // For standard I/O operations\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float radar_range_limit = 15.0f;  // Maximum range (meters)\nconst float speed_limit = 100.0f;  // Maximum speed for safe distance (km/h)\n\n// Function to process radar sensor data\nvoid process_radar_data(float distance, float speed) {\n    // Check if object is within radar range and exceeds speed limit\n    if (distance < radar_range_limit && speed > speed_limit) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n    else if (distance < radar_range_limit) {\n        std::cout << \"Alert: Object detected within range.\" << std::endl;\n    }\n    else {\n        std::cout << \"No objects detected in range.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 10.0f;  // Simulated radar distance data\n    float object_speed = 110.0f;  // Simulated object speed data\n\n    process_radar_data(object_distance, object_speed);  // Process radar data\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program  for a Forward Collision Warning (FCW) system that processes ultrasonic sensor data and triggers a warning when an object is detected within the safety range.",
      "input": "The program must follow MISRA C:2023 rules for error handling and system function calls, avoiding unsafe operations.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float safety_range = 2.5f;  // Safety distance (meters)\nconst float warning_range = 1.0f;  // Range at which warning is triggered\n\n// Function to process ultrasonic sensor data\nvoid process_sensor_data(float distance) {\n    // If the object is within the warning range, trigger a warning\n    if (distance < warning_range) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n    else if (distance < safety_range) {\n        std::cout << \"Alert: Object detected in close range.\" << std::endl;\n    }\n    else {\n        std::cout << \"No immediate threat detected.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float sensor_data = 0.9f;  // Example sensor data (distance in meters)\n    process_sensor_data(sensor_data);  // Process data\n    return 0;\n}"
    },
    {
      "instruction": "Develop a MISRA C:2023-compliant C++ program for a Forward Collision Warning (FCW) system that uses both radar and camera data to assess the risk of collision based on object speed and proximity.",
      "input": "The program should ensure that no unsafe or dynamic memory allocations are used and that it adheres to MISRA C:2023 guidelines for safety-critical applications.",
      "output": "#include <iostream>  // For standard I/O operations\n#include <cmath>  // For mathematical calculations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float collision_threshold_distance = 5.0f;  // Distance threshold (meters)\nconst float max_speed_for_warning = 80.0f;  // Speed threshold for warning (km/h)\n\n// Function to compute relative speed\nfloat compute_relative_speed(float object_distance, float object_speed) {\n    return std::sqrt(std::pow(object_speed, 2) - std::pow(object_distance, 2));\n}\n\n// Function to process radar and camera data\nvoid process_sensor_data(float object_distance, float object_speed) {\n    float relative_speed = compute_relative_speed(object_distance, object_speed);\n\n    // Check for collision risk\n    if (object_distance < collision_threshold_distance && relative_speed > max_speed_for_warning) {\n        std::cout << \"WARNING: HIGH COLLISION RISK!\" << std::endl;\n    }\n    else if (object_distance < collision_threshold_distance) {\n        std::cout << \"Alert: Object approaching quickly.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object at safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 4.5f;  // Example sensor data (distance in meters)\n    float object_speed = 85.0f;  // Example sensor data (speed in km/h)\n\n    process_sensor_data(object_distance, object_speed);  // Process sensor data\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C:2023-compliant C++ program for a Forward Collision Warning (FCW) system that processes object detection data to calculate the risk of collision and triggers a warning if an object is approaching too quickly.",
      "input": "The program must adhere to all MISRA C:2023 rules, particularly for managing control flow, avoiding dynamic memory allocations, and handling sensor data appropriately.",
      "output": "#include <iostream>  // For I/O operations\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float safe_distance = 10.0f;  // Safe distance (meters)\nconst float collision_speed_limit = 60.0f;  // Speed threshold (km/h)\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float object_distance, float object_speed) {\n    return (object_distance / object_speed);  // Simplified relative speed calculation\n}\n\n// Function to process object detection data\nvoid process_detection_data(float object_distance, float object_speed) {\n    float relative_speed = calculate_relative_speed(object_distance, object_speed);\n\n    // Collision warning logic\n    if (object_distance < safe_distance && object_speed > collision_speed_limit) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n    else if (object_distance < safe_distance) {\n        std::cout << \"Alert: Object detected within safe distance.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 8.0f;  // Example object distance (meters)\n    float object_speed = 75.0f;  // Example object speed (km/h)\n\n    process_detection_data(object_distance, object_speed);  // Process data\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program  for a Forward Collision Warning (FCW) system that triggers a warning if an object is within a certain distance and exceeds a speed threshold.",
      "input": "Avoid dynamic memory allocation and ensure proper error handling of sensor inputs.",
      "output": "#include <iostream>  // I/O functions\n#include <cmath>  // For mathematical operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float safe_distance = 10.0f;  // Distance threshold for safety\nconst float speed_limit = 30.0f;  // Speed limit (km/h) for triggering warning\n\n// Function to process object data\nvoid process_object_data(float distance, float speed) {\n    if (distance < safe_distance && speed > speed_limit) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n    else if (distance < safe_distance) {\n        std::cout << \"Alert: Object within safety range.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 8.0f;  // Simulated sensor data (meters)\n    float object_speed = 35.0f;  // Simulated object speed (km/h)\n    process_object_data(object_distance, object_speed);  // Process object data\n    return 0;\n}"
    },
    {
      "instruction": "Create a C++ program using radar data to detect objects within a dangerous range and speed limit, following MISRA C:2023 guidelines.",
      "input": "Ensure the program avoids unsafe pointer manipulations and error-prone dynamic memory allocations.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float danger_range = 12.0f;  // Dangerous range (meters)\nconst float max_speed_limit = 100.0f;  // Maximum safe speed (km/h)\n\n// Function to check collision risk\nvoid check_collision_risk(float distance, float speed) {\n    if (distance < danger_range && speed > max_speed_limit) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n    else if (distance < danger_range) {\n        std::cout << \"Alert: Object too close.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 9.0f;  // Simulated radar data\n    float object_speed = 110.0f;  // Simulated speed data (km/h)\n    check_collision_risk(object_distance, object_speed);  // Check for risk\n    return 0;\n}"
    },
    {
      "instruction": "Develop a program using camera data to detect objects and estimate their distance, with MISRA C:2023 compliance.",
      "input": "Adhere to MISRA standards by avoiding the use of unsafe memory operations.",
      "output": "#include <iostream>  // For I/O operations\n#include <cmath>  // For distance calculation\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float threshold_distance = 5.0f;  // Collision detection distance (meters)\n\n// Function to estimate object distance\nfloat estimate_object_distance(float object_width_in_image, float image_width) {\n    return (object_width_in_image / image_width) * 100.0f;  // Simplified distance estimation\n}\n\n// Function to process camera image\nvoid process_camera_data(float object_width, float image_width) {\n    float distance = estimate_object_distance(object_width, image_width);\n\n    if (distance < threshold_distance) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_width_in_image = 150.0f;  // Simulated object width in pixels\n    float image_width = 640.0f;  // Simulated image width in pixels\n    process_camera_data(object_width_in_image, image_width);  // Process camera data\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program to estimate object speed and trigger a warning if it exceeds a threshold, following MISRA C:2023 standards.",
      "input": "Avoid dynamic memory allocation and ensure proper handling of sensor data for speed estimation.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float speed_threshold = 60.0f;  // Speed threshold (km/h)\n\n// Function to estimate object speed\nvoid estimate_object_speed(float object_distance, float time_interval) {\n    float speed = object_distance / time_interval;  // Simplified speed calculation\n\n    if (speed > speed_threshold) {\n        std::cout << \"WARNING: Object approaching too quickly!\" << std::endl;\n    }\n    else {\n        std::cout << \"Object speed is within safe limits.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 100.0f;  // Simulated object distance (meters)\n    float time_interval = 2.0f;  // Simulated time interval (seconds)\n    estimate_object_speed(object_distance, time_interval);  // Estimate object speed\n    return 0;\n}"
    },
    {
      "instruction": "Develop a multisensor-based FCW system using lidar, radar, and camera data, following MISRA C:2023 compliance.",
      "input": "Handle multisensor data appropriately and ensure the program adheres to MISRA standards for safety and reliability.",
      "output": "#include <iostream>  // For I/O operations\n#include <cmath>  // For mathematical functions\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float proximity_threshold = 8.0f;  // Proximity threshold (meters)\nconst float relative_speed_threshold = 25.0f;  // Speed threshold (km/h)\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float object_distance, float object_speed) {\n    return object_speed - object_distance;  // Simplified calculation\n}\n\n// Function to process multisensor data\nvoid process_multisensor_data(float lidar_distance, float radar_speed, float camera_distance) {\n    if (lidar_distance < proximity_threshold && radar_speed > relative_speed_threshold) {\n        std::cout << \"WARNING: High risk of collision!\" << std::endl;\n    }\n    else if (camera_distance < proximity_threshold) {\n        std::cout << \"Alert: Object too close.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float lidar_object_distance = 7.0f;  // Simulated lidar data (meters)\n    float radar_object_speed = 30.0f;  // Simulated radar speed (km/h)\n    float camera_object_distance = 6.5f;  // Simulated camera data (meters)\n    process_multisensor_data(lidar_object_distance, radar_object_speed, camera_object_distance);  // Process data\n    return 0;\n}"
    },
    {
      "instruction": "Create a program for a Forward Collision Warning (FCW) system that triggers a warning when the relative speed exceeds a set threshold and the object is within a specific distance.",
      "input": "Ensure safe and proper handling of speed and distance data.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float distance_threshold = 10.0f;  // Distance threshold (meters)\nconst float speed_threshold = 40.0f;  // Speed threshold (km/h)\n\n// Function to check collision risk\nvoid check_collision_risk(float distance, float relative_speed) {\n    if (distance < distance_threshold && relative_speed > speed_threshold) {\n        std::cout << \"WARNING: HIGH COLLISION RISK!\" << std::endl;\n    }\n    else if (distance < distance_threshold) {\n        std::cout << \"Alert: Object within safety range.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 9.0f;  // Simulated sensor data (meters)\n    float object_speed = 50.0f;  // Simulated object speed (km/h)\n    check_collision_risk(object_distance, object_speed);  // Check for collision risk\n    return 0;\n}"
    },
    {
      "instruction": "Create a program where the collision warning threshold dynamically adjusts based on vehicle speed and object distance, ensuring MISRA C:2023 compliance.",
      "input": "Ensure dynamic adjustments are safe, with no unsafe memory allocations or pointer usage.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float base_speed_threshold = 30.0f;  // Base speed threshold (km/h)\nconst float distance_threshold = 8.0f;  // Base distance threshold (meters)\n\n// Function to adjust threshold based on speed\nfloat adjust_threshold_based_on_speed(float vehicle_speed) {\n    return base_speed_threshold + (vehicle_speed * 0.1f);  // Increase threshold by 10%\n}\n\n// Function to process sensor data\nvoid process_sensor_data(float vehicle_speed, float object_distance) {\n    float adjusted_threshold = adjust_threshold_based_on_speed(vehicle_speed);\n    if (object_distance < adjusted_threshold) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float vehicle_speed = 50.0f;  // Simulated vehicle speed (km/h)\n    float object_distance = 6.0f;  // Simulated object distance (meters)\n    process_sensor_data(vehicle_speed, object_distance);  // Process data\n    return 0;\n}"
    },
    {
      "instruction": "Create a system that integrates lane detection with FCW, triggering warnings when objects are detected in the vehicle\u2019s lane and too close for safety.",
      "input": "Handle lane detection data properly, ensuring compliance with MISRA C:2023 standards.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float lane_safety_distance = 5.0f;  // Lane safety threshold (meters)\n\n// Function to check if an object is in the lane\nbool is_object_in_lane(float object_x_position) {\n    return (object_x_position >= -1.0f && object_x_position <= 1.0f);  // Object in lane if within [-1, 1] range\n}\n\n// Function to process sensor data\nvoid process_lane_data(float object_x_position, float object_distance) {\n    if (is_object_in_lane(object_x_position) && object_distance < lane_safety_distance) {\n        std::cout << \"WARNING: OBJECT IN LANE, COLLISION RISK!\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance or outside the lane.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_x_position = 0.5f;  // Simulated object position in lane (meters)\n    float object_distance = 4.5f;  // Simulated object distance (meters)\n    process_lane_data(object_x_position, object_distance);  // Process lane data\n    return 0;\n}"
    },
    {
      "instruction": "Create a system that calculates time-to-collision (TTC) and triggers a warning if TTC is below a predefined threshold.",
      "input": "Properly handle edge cases for time-to-collision calculations and ensure no memory violations.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float ttc_threshold = 2.0f;  // Time-to-collision threshold (seconds)\n\n// Function to calculate time-to-collision\nfloat calculate_ttc(float object_distance, float relative_speed) {\n    if (relative_speed == 0.0f) {  // Prevent division by zero\n        return 0.0f;\n    }\n    return object_distance / relative_speed;  // Calculate TTC (seconds)\n}\n\n// Function to process sensor data\nvoid process_ttc_data(float object_distance, float relative_speed) {\n    float ttc = calculate_ttc(object_distance, relative_speed);\n    if (ttc < ttc_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT! TTC: \" << ttc << \" seconds.\" << std::endl;\n    }\n    else {\n        std::cout << \"TTC is safe: \" << ttc << \" seconds.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 20.0f;  // Simulated object distance (meters)\n    float object_speed = 30.0f;  // Simulated object speed (km/h)\n    float relative_speed = 20.0f;  // Simulated relative speed (km/h)\n    process_ttc_data(object_distance, relative_speed);  // Process TTC data\n    return 0;\n}"
    },
    {
      "instruction": "Create a system that fuses data from multiple sensors (e.g., radar and lidar) for a more accurate collision warning, ensuring MISRA C:2023 compliance.",
      "input": "Ensure safe data fusion and processing from multiple sensor sources.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system functions\n\n// Constants\nconst float sensor_fusion_distance = 6.0f;  // Fusion threshold (meters)\n\n// Function to process fused sensor data\nvoid process_fused_sensor_data(float lidar_distance, float radar_distance) {\n    if (lidar_distance < sensor_fusion_distance && radar_distance < sensor_fusion_distance) {\n        std::cout << \"WARNING: COLLISION RISK - Multiple Sensors Triggered!\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float lidar_object_distance = 5.5f;  // Simulated lidar distance (meters)\n    float radar_object_distance = 5.0f;  // Simulated radar distance (meters)\n    process_fused_sensor_data(lidar_object_distance, radar_object_distance);  // Process fused data\n    return 0;\n}"
    },
    {
      "instruction": "Create a system to predict time to collision based on relative speed and distance, triggering a warning if the predicted time to collision is below a threshold.",
      "input": "Ensure that the predicted time to collision is calculated safely with no invalid memory access or pointer dereferencing.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float collision_time_threshold = 2.5f;  // Threshold for collision time (seconds)\n\n// Function to calculate time to collision\nfloat calculate_collision_time(float distance, float relative_speed) {\n    if (relative_speed == 0.0f) {  // Prevent division by zero\n        return 0.0f;\n    }\n    return distance / relative_speed;  // Calculate time to collision (seconds)\n}\n\n// Function to process sensor data\nvoid process_collision_prediction(float distance, float relative_speed) {\n    float ttc = calculate_collision_time(distance, relative_speed);\n    if (ttc < collision_time_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT! Predicted time: \" << ttc << \" seconds.\" << std::endl;\n    }\n    else {\n        std::cout << \"Collision risk is low. Predicted time: \" << ttc << \" seconds.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 30.0f;  // Simulated object distance (meters)\n    float relative_speed = 40.0f;  // Simulated relative speed (km/h)\n    process_collision_prediction(object_distance, relative_speed);  // Process collision prediction\n    return 0;\n}"
    },
    {
      "instruction": "Implement an object detection and classification system for FCW, triggering a warning if a classified object is deemed to pose a collision risk.",
      "input": "Ensure safe handling and classification of sensor data.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float collision_risk_distance = 10.0f;  // Distance threshold for risk classification (meters)\n\n// Function to classify objects\nstd::string classify_object(float object_distance) {\n    if (object_distance < collision_risk_distance) {\n        return \"Collision Risk\";\n    }\n    else {\n        return \"Safe\";\n    }\n}\n\n// Function to process sensor data\nvoid process_object_detection(float object_distance) {\n    std::string classification = classify_object(object_distance);\n    if (classification == \"Collision Risk\") {\n        std::cout << \"WARNING: Potential collision risk detected.\" << std::endl;\n    }\n    else {\n        std::cout << \"Object classified as safe.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 8.0f;  // Simulated object distance (meters)\n    process_object_detection(object_distance);  // Process object detection\n    return 0;\n}"
    },
    {
      "instruction": "Create a system that triggers a warning when the distance to an object is below a critical threshold, ensuring MISRA C:2023 compliance.",
      "input": "Ensure that the system properly handles and checks distances, avoiding invalid memory access.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float critical_distance = 5.0f;  // Critical threshold distance (meters)\n\n// Function to process critical distance data\nvoid process_critical_distance(float object_distance) {\n    if (object_distance < critical_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n    else {\n        std::cout << \"Object is at a safe distance.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 4.5f;  // Simulated object distance (meters)\n    process_critical_distance(object_distance);  // Process critical distance data\n    return 0;\n}"
    },
    {
      "instruction": "Implement a system that considers vehicle acceleration and relative speed to predict collisions, triggering a warning when danger is imminent.",
      "input": "Ensure safe handling and validation of vehicle acceleration and speed data.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float acceleration_threshold = 2.5f;  // Threshold for vehicle acceleration (m/s^2)\nconst float speed_threshold = 30.0f;  // Threshold for speed (km/h)\n\n// Function to predict collision risk based on speed and acceleration\nbool predict_collision(float relative_speed, float vehicle_acceleration) {\n    return (relative_speed > speed_threshold && vehicle_acceleration > acceleration_threshold);  // Collision risk if both thresholds are exceeded\n}\n\n// Function to process sensor data\nvoid process_collision_prediction(float relative_speed, float vehicle_acceleration) {\n    if (predict_collision(relative_speed, vehicle_acceleration)) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n    else {\n        std::cout << \"No immediate collision risk.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float relative_speed = 35.0f;  // Simulated relative speed (km/h)\n    float vehicle_acceleration = 3.0f;  // Simulated vehicle acceleration (m/s^2)\n    process_collision_prediction(relative_speed, vehicle_acceleration);  // Process collision prediction\n    return 0;\n}"
    },
    {
      "instruction": "Create a system that checks for sensor redundancy, triggering a warning only when multiple sensors detect an object within a critical range.",
      "input": "Ensure safe and effective data handling for multiple sensors.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float sensor_critical_distance = 6.0f;  // Critical threshold distance (meters)\n\n// Function to check sensor redundancy\nbool check_sensor_redundancy(float radar_distance, float camera_distance) {\n    return (radar_distance < sensor_critical_distance && camera_distance < sensor_critical_distance);  // True if both sensors detect object in critical range\n}\n\n// Function to process redundant sensor data\nvoid process_sensor_redundancy(float radar_distance, float camera_distance) {\n    if (check_sensor_redundancy(radar_distance, camera_distance)) {\n        std::cout << \"WARNING: COLLISION RISK (Multiple Sensors Detected)!\" << std::endl;\n    }\n    else {\n        std::cout << \"Sensor data indicates no collision risk.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float radar_object_distance = 5.0f;  // Simulated radar distance (meters)\n    float camera_object_distance = 5.5f;  // Simulated camera distance (meters)\n    process_sensor_redundancy(radar_object_distance, camera_object_distance);  // Process sensor redundancy\n    return 0;\n}"
    },
    {
      "instruction": "Implement dynamic speed adjustment for collision avoidance, triggering a warning if the adjusted speed is insufficient to avoid a collision.",
      "input": "Validate speed and distance calculations to avoid overflow or undefined behavior.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float safe_speed_adjustment_factor = 0.8f;  // Factor to adjust speed (percentage)\nconst float minimum_safe_speed = 10.0f;  // Minimum safe speed (km/h)\n\n// Function to calculate adjusted speed\nfloat calculate_adjusted_speed(float relative_speed, float object_distance) {\n    if (object_distance <= 0.0f) {\n        return 0.0f;  // Prevent division by zero\n    }\n    return relative_speed * (object_distance / 100.0f);  // Adjust speed based on distance\n}\n\n// Function to process dynamic speed adjustment\nvoid process_speed_adjustment(float relative_speed, float object_distance) {\n    float adjusted_speed = calculate_adjusted_speed(relative_speed, object_distance);\n    if (adjusted_speed < minimum_safe_speed) {\n        std::cout << \"WARNING: Insufficient speed adjustment. Immediate action required.\" << std::endl;\n    }\n    else {\n        std::cout << \"Speed adjustment is safe. Adjusted speed: \" << adjusted_speed << \" km/h.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float relative_speed = 50.0f;  // Simulated relative speed (km/h)\n    float object_distance = 25.0f;  // Simulated object distance (meters)\n    process_speed_adjustment(relative_speed, object_distance);  // Process speed adjustment\n    return 0;\n}"
    },
    {
      "instruction": "Estimate the time-to-impact and trigger a warning if it's below a safe threshold, ensuring MISRA C:2023 compliance.",
      "input": "Ensure that time-to-impact is safely calculated and boundary conditions are handled.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float time_to_impact_threshold = 2.0f;  // Time-to-impact threshold (seconds)\n\n// Function to calculate time to impact\nfloat calculate_time_to_impact(float distance, float relative_speed) {\n    if (relative_speed == 0.0f) {  // Prevent division by zero\n        return 0.0f;\n    }\n    return distance / relative_speed;  // Calculate time to impact (seconds)\n}\n\n// Function to process impact prediction\nvoid process_impact_prediction(float distance, float relative_speed) {\n    float time_to_impact = calculate_time_to_impact(distance, relative_speed);\n    if (time_to_impact < time_to_impact_threshold) {\n        std::cout << \"WARNING: Time to impact is critical!\" << std::endl;\n    }\n    else {\n        std::cout << \"Time to impact is safe: \" << time_to_impact << \" seconds.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float distance = 20.0f;  // Simulated object distance (meters)\n    float relative_speed = 30.0f;  // Simulated relative speed (km/h)\n    process_impact_prediction(distance, relative_speed);  // Process impact prediction\n    return 0;\n}"
    },
    {
      "instruction": "Create a risk assessment system for multiple object detection, triggering a warning if any detected object is classified as high-risk.",
      "input": "Ensure proper validation and handling of multiple object data for risk assessment.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float high_risk_threshold = 5.0f;  // High-risk threshold distance (meters)\n\n// Function to classify objects as high-risk or safe\nstd::string classify_object(float object_distance) {\n    if (object_distance < high_risk_threshold) {\n        return \"High-Risk\";\n    }\n    else {\n        return \"Safe\";\n    }\n}\n\n// Function to process multiple object detection\nvoid process_multiple_object_detection(float object_distances[], int num_objects) {\n    bool collision_warning = false;\n    for (int i = 0; i < num_objects; i++) {\n        std::string classification = classify_object(object_distances[i]);\n        if (classification == \"High-Risk\") {\n            collision_warning = true;\n            std::cout << \"WARNING: High-risk object detected at distance: \" << object_distances[i] << \" meters.\" << std::endl;\n        }\n    }\n    if (!collision_warning) {\n        std::cout << \"No high-risk objects detected.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distances[] = {3.0f, 8.0f, 12.0f};  // Simulated object distances (meters)\n    int num_objects = sizeof(object_distances) / sizeof(object_distances[0]);\n    process_multiple_object_detection(object_distances, num_objects);  // Process object detection\n    return 0;\n}"
    },
    {
      "instruction": "Implement an adaptive threshold system for collision warnings based on vehicle speed, triggering a warning when the threshold is exceeded.",
      "input": "Validate vehicle speed and ensure safe threshold adjustment based on speed.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float base_threshold = 5.0f;  // Base threshold distance (meters)\nconst float speed_factor = 0.1f;  // Speed factor to adjust threshold\n\n// Function to calculate adaptive threshold\nfloat calculate_adaptive_threshold(float vehicle_speed) {\n    return base_threshold + (vehicle_speed * speed_factor);  // Adjust threshold based on speed\n}\n\n// Function to process adaptive collision warning\nvoid process_adaptive_warning(float vehicle_speed, float object_distance) {\n    float adaptive_threshold = calculate_adaptive_threshold(vehicle_speed);\n    if (object_distance < adaptive_threshold) {\n        std::cout << \"WARNING: Collision risk exceeds threshold! Object at \" << object_distance << \" meters.\" << std::endl;\n    }\n    else {\n        std::cout << \"Collision risk is within safe threshold.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed (km/h)\n    float object_distance = 4.0f;  // Simulated object distance (meters)\n    process_adaptive_warning(vehicle_speed, object_distance);  // Process adaptive warning\n    return 0;\n}"
    },
    {
      "instruction": "Implement a system that adjusts collision risk assessment based on environmental factors such as weather, and triggers a warning if the risk is elevated.",
      "input": "Validate environmental factors and ensure that they influence the collision risk assessment.",
      "output": "#include <iostream>  // For I/O operations\n#include <cstdlib>  // For system calls\n\n// Constants\nconst float weather_factor_rain = 0.5f;  // Risk factor for rain\nconst float weather_factor_fog = 0.7f;  // Risk factor for fog\nconst float base_collision_risk = 5.0f;  // Base collision risk threshold\n\n// Enum for weather conditions\nenum WeatherCondition {CLEAR, RAIN, FOG};\n\n// Function to adjust collision risk based on weather\nfloat adjust_collision_risk(float base_risk, WeatherCondition weather) {\n    switch (weather) {\n        case RAIN:\n            return base_risk * weather_factor_rain;\n        case FOG:\n            return base_risk * weather_factor_fog;\n        default:\n            return base_risk;\n    }\n}\n\n// Function to process collision risk assessment\nvoid process_collision_risk(float object_distance, WeatherCondition weather) {\n    float adjusted_risk = adjust_collision_risk(base_collision_risk, weather);\n    if (object_distance < adjusted_risk) {\n        std::cout << \"WARNING: Collision risk is elevated due to environmental factors.\" << std::endl;\n    }\n    else {\n        std::cout << \"Collision risk is within safe limits.\" << std::endl;\n    }\n}\n\n// Main function\nint main() {\n    float object_distance = 4.0f;  // Simulated object distance (meters)\n    WeatherCondition current_weather = FOG;  // Simulated weather condition\n    process_collision_risk(object_distance, current_weather);  // Process collision risk\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to implement a Forward Collision Warning (FCW) system. The system should detect objects using OpenCV, calculate the distance to the object, and activate a warning signal when the object is too close. Include comments and ensure error handling is robust.",
      "input": "Ensure proper type conversions, avoid implicit casting, handle camera failures, and ensure all variable and function names are meaningful.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV for object detection\n#include <iostream> // For handling standard I/O operations\n#include <cmath> // For mathematical operations\n#include <cstdlib> // For handling exit codes\n\n// Camera parameters\nconst float focal_length_x = 800.0f; // Focal length in X direction\nconst float focal_length_y = 800.0f; // Focal length in Y direction\nconst float car_width = 1.8f; // Assumed car width (in meters)\n\n// Collision warning threshold (meters)\nconst float collision_threshold = 5.0f;\n\n// Struct to store detected object data\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\n// Function to calculate the distance of an object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process a frame and detect objects\nvoid process_image(cv::Mat& image) {\n    cv::Rect detected_object(500, 400, 200, 100); // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Check if the object is within the warning threshold\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0); // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system that processes frames from a camera, detects cars, and estimates their distance. Display a collision warning if the car's distance falls below a threshold.",
      "input": "Ensure proper data validation, explicit type conversions, and avoid using global variables. Ensure all loops and conditionals are clearly defined.",
      "output": "#include <opencv2/opencv.hpp> // For image processing\n#include <iostream> // For input-output handling\n#include <cmath> // For mathematical calculations\n#include <cstdlib> // For handling system exit\n\n// Camera and object parameters\nconst float focal_length = 800.0f; // Camera focal length\nconst float car_width = 1.8f; // Average car width (meters)\nconst float collision_threshold = 5.0f; // Collision threshold distance (meters)\n\n// Struct to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\n// Function to calculate distance to object\nfloat calculate_distance(int object_width, int image_width) {\n    return (car_width * focal_length * image_width) / (object_width * focal_length);\n}\n\n// Process each frame\nvoid process_image(cv::Mat& image) {\n    cv::Rect detected_car(400, 300, 200, 100); // Detected object bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_car;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display distance\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Collision warning\n    }\n}\n\n// Main function\nint main() {\n    cv::VideoCapture cap(0); // Open the camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_image(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that detects objects in front of the car, calculates their distance using image processing, and triggers a warning when the object is too close.",
      "input": "Follow MISRA 2023 guidelines by avoiding unsafe casting, using explicit type conversion, and ensuring all loops and conditional statements are properly structured.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV header for image processing\n#include <iostream> // For I/O handling\n#include <cmath> // For distance calculations\n#include <cstdlib> // For handling errors\n\n// Camera and object properties\nconst float focal_length = 750.0f; // Focal length of camera lens\nconst float object_width = 1.8f; // Average width of the car (meters)\nconst float collision_threshold = 6.0f; // Distance threshold for collision warning (meters)\n\n// Struct for storing detected object details\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\n// Function to calculate distance based on object width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (object_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\n// Image processing function\nvoid process_image(cv::Mat& image) {\n    cv::Rect detected_car(450, 350, 150, 75); // Simulated bounding box of detected car\n    DetectedObject obj;\n    obj.bounding_box = detected_car;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw object bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display calculated distance\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Collision warning message\n    }\n}\n\n// Main program\nint main() {\n    cv::VideoCapture cap(0); // Open the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_image(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using OpenCV. The system should detect vehicles, estimate their distance from the camera, and trigger a warning if the vehicle is within a critical range.",
      "input": "Ensure that all pointers are properly initialized, that there are no memory leaks, and that all loops and conditionals are properly structured according to MISRA rules.",
      "output": "#include <opencv2/opencv.hpp> // For OpenCV functionalities\n#include <iostream> // For I/O operations\n#include <cmath> // For math operations\n#include <cstdlib> // For exit operations\n\n// Camera settings and object parameters\nconst float focal_length = 800.0f; // Camera focal length\nconst float vehicle_width = 1.8f; // Average vehicle width (in meters)\nconst float warning_threshold = 4.0f; // Threshold for collision warning (in meters)\n\n// Structure for detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\n// Function to calculate distance to the object\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\n// Function to process the image and detect objects\nvoid process_image(cv::Mat& image) {\n    cv::Rect detected_vehicle(500, 300, 200, 100); // Example bounding box for a vehicle\n    DetectedObject obj;\n    obj.bounding_box = detected_vehicle;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display distance\n\n    if (obj.distance < warning_threshold) {\n        cv::putText(image, \"WARNING: COLLISION RISK\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Collision warning message\n    }\n}\n\n// Main function to handle video processing\nint main() {\n    cv::VideoCapture cap(0); // Open the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_image(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code that uses OpenCV for an FCW system to detect vehicles, estimate their distance, and alert the driver if the vehicle is too close.",
      "input": "Follow MISRA 2023 guidelines by ensuring explicit type conversions, avoiding the use of unsafe or non-standard libraries, and handling errors properly.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV\n#include <iostream> // For input-output operations\n#include <cmath> // For mathematical functions\n#include <cstdlib> // For system exit operations\n\n// Camera parameters\nconst float focal_length = 850.0f; // Camera focal length\nconst float vehicle_width = 1.8f; // Average vehicle width (meters)\nconst float collision_threshold = 3.0f; // Collision warning threshold (meters)\n\n// Structure for detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\n// Function to calculate distance\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\n// Function to process the frame\nvoid process_image(cv::Mat& image) {\n    cv::Rect detected_vehicle(500, 300, 150, 75); // Example detected vehicle bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_vehicle;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display distance\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION RISK\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Collision warning\n    }\n}\n\n// Main program\nint main() {\n    cv::VideoCapture cap(0); // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_image(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system to detect vehicles and alert if they are within a collision threshold.",
      "input": "Ensure that all pointers are initialized properly and that arrays are accessed safely.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For exit operations\n\nconst float focal_length = 850.0f; // Camera focal length\nconst float vehicle_width = 1.8f; // Average vehicle width (meters)\nconst float collision_threshold = 2.5f; // Collision warning threshold (meters)\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\nvoid process_image(cv::Mat& image) {\n    cv::Rect detected_vehicle(500, 300, 200, 100); // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_vehicle;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display distance\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION RISK\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Collision warning\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0); // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_image(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to detect vehicles, calculate their distance based on bounding box size, and trigger a collision warning if the distance is under a threshold.",
      "input": "Ensure proper initialization of all objects and safe handling of dynamic memory.",
      "output": "#include <opencv2/opencv.hpp> // For OpenCV functions\n#include <iostream> // For I/O operations\n#include <cstdlib> // For system operations\n\nconst float focal_length = 850.0f; // Camera focal length\nconst float vehicle_width = 1.8f; // Vehicle width (meters)\nconst float safety_threshold = 3.0f; // Collision threshold (meters)\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\nvoid process_frame(cv::Mat& frame) {\n    cv::Rect detected_vehicle(450, 250, 200, 100); // Simulated detection\n    DetectedObject obj;\n    obj.bounding_box = detected_vehicle;\n    obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Show distance\n\n    if (obj.distance < safety_threshold) {\n        cv::putText(frame, \"WARNING: COLLISION AHEAD\", cv::Point(250, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Trigger warning\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0); // Open camera feed\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_frame(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop a MISRA 2023-compliant C++ code for an FCW system where the bounding box of detected vehicles updates dynamically and triggers a warning based on proximity.",
      "input": "Make sure that memory is correctly managed and that loop conditions are properly defined.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library\n#include <iostream> // For console output\n#include <cstdlib> // For exit operations\n\nconst float focal_length = 900.0f; // Camera focal length\nconst float vehicle_width = 2.0f; // Average vehicle width (meters)\nconst float collision_distance = 2.0f; // Threshold distance for collision warning\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\nvoid process_frame(cv::Mat& image) {\n    cv::Rect vehicle_box(600, 300, 250, 125); // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = vehicle_box;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display distance\n\n    if (obj.distance < collision_distance) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Display warning\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0); // Open camera feed\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_frame(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ FCW system that provides a more urgent collision warning when the vehicle is extremely close.",
      "input": "Ensure all arrays are properly bounded, and error handling is robust.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV library\n#include <iostream> // For logging\n#include <cstdlib> // For system exit\n\nconst float focal_length = 850.0f; // Camera focal length\nconst float vehicle_width = 1.7f; // Vehicle width (meters)\nconst float warning_threshold = 1.5f; // Threshold distance for immediate warning\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\nvoid process_frame(cv::Mat& image) {\n    cv::Rect detected_vehicle(520, 240, 180, 90); // Simulate vehicle detection\n    DetectedObject obj;\n    obj.bounding_box = detected_vehicle;\n    obj.distance = calculate_distance(obj.bounding_box.width, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Display distance\n\n    if (obj.distance < warning_threshold) {\n        cv::putText(image, \"URGENT: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Urgent warning\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0); // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_frame(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant FCW system that uses vehicle speed to dynamically adjust the collision warning threshold.",
      "input": "Ensure there is no array overflow and avoid any undefined behavior related to pointer arithmetic.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV for computer vision\n#include <iostream> // For I/O operations\n#include <cstdlib> // For system exit operations\n\nconst float focal_length = 850.0f; // Camera focal length\nconst float vehicle_width = 2.0f; // Vehicle width (meters)\nfloat speed = 20.0f; // Speed of own vehicle (m/s)\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (vehicle_width * focal_length * image_width) / (object_width_in_image * focal_length);\n}\n\nfloat adjust_threshold_based_on_speed(float speed) {\n    if (speed > 25.0f) {\n        return 2.0f; // Higher speed, lower threshold\n    } else {\n        return 3.5f; // Lower speed, higher threshold\n    }\n}\n\nvoid process_frame(cv::Mat& frame) {\n    cv::Rect vehicle_box(600, 300, 250, 125); // Example bounding box\n    DetectedObject obj;\n    obj.bounding_box = vehicle_box;\n    obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);\n    float warning_threshold = adjust_threshold_based_on_speed(speed);\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" meters\";\n    cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2); // Show distance\n\n    if (obj.distance < warning_threshold) {\n        cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2); // Display warning\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0); // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) { break; }\n        process_frame(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') { break; }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for an FCW system using LiDAR data. The program should parse LiDAR point clouds, identify obstacles, and calculate distances to issue collision alerts. Include error handling for sensor input and modularize functionality into separate functions.",
      "input": "Ensure MISRA compliance by using explicit type handling, defining constants for thresholds, avoiding unsafe pointer operations, and adding comments for each computation and logical decision. Error handling must be robust and modular.",
      "output": "#include <iostream>    // For standard I/O\n#include <vector>      // For managing LiDAR points\n#include <cmath>       // For mathematical operations\n#include <cstdlib>     // For error handling\n\n// Constants for collision detection\nconst float COLLISION_THRESHOLD = 5.0F; // Safe distance in meters\nconst float LIDAR_MAX_DISTANCE = 100.0F; // Maximum LiDAR detection range in meters\n\n// Structure to hold LiDAR point data\nstruct LiDARPoint {\n    float x;    // X-coordinate of the point (meters)\n    float y;    // Y-coordinate of the point (meters)\n    float z;    // Z-coordinate of the point (meters)\n};\n\n// Function to calculate the Euclidean distance to an obstacle\nfloat calculate_distance(const LiDARPoint& point) {\n    // Ensure point values are within valid range\n    if (point.x < 0.0F || point.y < 0.0F || point.z < 0.0F) {\n        std::cerr << \"ERROR: Invalid point data.\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n\n    return std::sqrt((point.x * point.x) + (point.y * point.y));\n}\n\n// Function to process LiDAR points and check for collision risk\nvoid process_lidar_data(const std::vector<LiDARPoint>& lidar_data) {\n    for (std::size_t i = 0U; i < lidar_data.size(); ++i) {\n        float distance = calculate_distance(lidar_data[i]);\n\n        // Check if the distance is below the collision threshold\n        if (distance < COLLISION_THRESHOLD) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters!\" << std::endl;\n        }\n    }\n}\n\n// Main function\nint main() {\n    // Simulated LiDAR data (replace with actual sensor input)\n    std::vector<LiDARPoint> lidar_points = {\n        {2.0F, 1.5F, 0.0F}, // Example point closer than the threshold\n        {6.0F, 4.5F, 0.0F}, // Example point beyond the threshold\n        {3.0F, 2.0F, 0.0F}  // Example point near the threshold\n    };\n\n    // Process the LiDAR data\n    process_lidar_data(lidar_points);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for an FCW system using radar sensors. The program should calculate the relative speed and distance to a detected object and issue warnings if a collision is imminent.",
      "input": "Ensure compliance by avoiding unsafe type conversions, using modular functions, and including explicit checks for division by zero. Proper error handling and detailed comments are required.",
      "output": "#include <iostream>  // For input-output\n#include <cstdlib>   // For system errors\n#include <cmath>     // For mathematical calculations\n\n// Constants for collision detection\nconst float SAFE_DISTANCE = 20.0F; // Minimum safe distance (meters)\nconst float RELATIVE_SPEED_THRESHOLD = 5.0F; // Speed difference to trigger warning (m/s)\n\n// Structure for radar object data\nstruct RadarObject {\n    float relative_speed; // Speed difference (m/s)\n    float distance;       // Distance to the object (meters)\n};\n\n// Function to check for collision risk\nvoid check_collision(const RadarObject& obj) {\n    if (obj.distance < SAFE_DISTANCE && obj.relative_speed > RELATIVE_SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Distance: \" << obj.distance << \" m, Speed: \" << obj.relative_speed << \" m/s.\" << std::endl;\n    }\n}\n\nint main() {\n    // Example radar data (replace with actual sensor input)\n    RadarObject obj = {10.0F, 15.0F}; // Relative speed and distance\n\n    // Validate radar data\n    if (obj.distance <= 0.0F || obj.relative_speed < 0.0F) {\n        std::cerr << \"ERROR: Invalid radar data.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Check for collision risk\n    check_collision(obj);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors. The system should estimate the distance to nearby objects and issue alerts when the distance falls below a critical threshold.",
      "input": "Ensure modularity in code, avoid unsafe global variables, and include explicit error checks for sensor data. Use constants for thresholds and proper comments for clarity.",
      "output": "#include <iostream>  // For console output\n#include <cstdlib>   // For system functions\n\n// Threshold for collision warning\nconst float COLLISION_DISTANCE = 2.0F; // Critical distance in meters\n\n// Function to process ultrasonic sensor data\nvoid process_ultrasonic_data(const float distance) {\n    if (distance < 0.0F) {\n        std::cerr << \"ERROR: Invalid sensor data.\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n\n    if (distance < COLLISION_DISTANCE) {\n        std::cout << \"WARNING: Collision imminent! Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    // Simulated sensor input (replace with real sensor data)\n    float sensor_distance = 1.5F; // Distance to the nearest object\n\n    process_ultrasonic_data(sensor_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ program to implement an FCW system using stereo cameras. The program should calculate object distances using triangulation and warn the driver if the distance falls below a safe threshold.",
      "input": "Include robust error handling for invalid input, use constants for thresholds, and add detailed comments explaining triangulation and its application in collision detection.",
      "output": "#include <iostream>  // For standard input-output\n#include <cmath>      // For trigonometric calculations\n#include <cstdlib>    // For exit functions\n\n// Stereo camera parameters\nconst float BASELINE = 0.5F;  // Distance between cameras (meters)\nconst float FOCAL_LENGTH = 1000.0F; // Focal length in pixels\nconst float SAFE_DISTANCE = 10.0F;  // Minimum safe distance (meters)\n\n// Function to calculate distance using disparity\nfloat calculate_distance(float disparity) {\n    if (disparity <= 0.0F) {\n        std::cerr << \"ERROR: Invalid disparity value.\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n    return (BASELINE * FOCAL_LENGTH) / disparity;\n}\n\nint main() {\n    // Simulated disparity value (replace with actual stereo data)\n    float disparity = 50.0F; // Disparity in pixels\n\n    float distance = calculate_distance(disparity);\n\n    if (distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision imminent! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using GPS and accelerometer data. The program should estimate the time to collision (TTC) based on current speed and distance.",
      "input": "Ensure modularity and proper error handling. Avoid floating-point division by zero and include constants for thresholds and detailed comments for clarity.",
      "output": "#include <iostream>  // For standard input-output\n#include <cstdlib>   // For system errors\n\n// Constants\nconst float MIN_DISTANCE = 5.0F; // Minimum distance in meters\nconst float MIN_SPEED = 1.0F;    // Minimum speed in m/s\n\n// Function to calculate time to collision (TTC)\nfloat calculate_ttc(float speed, float distance) {\n    if (speed <= 0.0F) {\n        std::cerr << \"ERROR: Speed must be greater than zero.\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n    return distance / speed;\n}\n\nint main() {\n    // Simulated GPS and speed data\n    float speed = 10.0F;    // Current speed in m/s\n    float distance = 20.0F; // Distance to the obstacle in meters\n\n    if (distance < MIN_DISTANCE) {\n        std::cerr << \"WARNING: Collision imminent! Insufficient distance.\" << std::endl;\n    } else {\n        float ttc = calculate_ttc(speed, distance);\n        std::cout << \"Time to Collision: \" << ttc << \" seconds.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using infrared sensors. The system should calculate object proximity and issue warnings when objects are detected too close.",
      "input": "Ensure robust error handling for invalid sensor data, modularize functionality, and provide detailed comments for all calculations and logical operations.",
      "output": "#include <iostream>  // For input-output\n#include <cstdlib>   // For exit failure\n\n// Infrared sensor threshold\nconst float CRITICAL_DISTANCE = 1.0F; // Minimum safe distance in meters\n\n// Function to check object proximity\nvoid check_proximity(float sensor_value) {\n    if (sensor_value < 0.0F) {\n        std::cerr << \"ERROR: Invalid sensor value.\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n\n    if (sensor_value < CRITICAL_DISTANCE) {\n        std::cout << \"WARNING: Object too close! Distance: \" << sensor_value << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << sensor_value << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    // Simulated infrared sensor data\n    float sensor_value = 0.8F; // Measured distance in meters\n\n    check_proximity(sensor_value);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for an FCW system using LiDAR data. The program should detect objects, calculate their distances, and issue warnings when the distance falls below a specified threshold.",
      "input": "Ensure proper error handling, avoid unsafe type casts, and include detailed comments for all logical steps. Use constants for thresholds and modularize functions for maintainability.",
      "output": "#include <iostream>  // For input-output operations\n#include <cstdlib>   // For system functions\n#include <vector>    // For handling multiple objects\n\n// Threshold for collision warning\nconst float COLLISION_DISTANCE = 5.0F; // Critical distance in meters\n\n// Structure to represent a detected object\nstruct LiDARObject {\n    float distance;  // Distance to the object (meters)\n    std::string label; // Object label (e.g., \"car\", \"pedestrian\")\n};\n\n// Function to process LiDAR data and detect collision risk\nvoid process_lidar_data(const std::vector<LiDARObject>& objects) {\n    for (std::size_t i = 0U; i < objects.size(); ++i) {\n        if (objects[i].distance < COLLISION_DISTANCE) {\n            std::cout << \"WARNING: Collision risk with \" << objects[i].label \n                      << \" at \" << objects[i].distance << \" meters.\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    // Simulated LiDAR data (replace with actual sensor input)\n    std::vector<LiDARObject> detected_objects = {\n        {4.0F, \"Car\"}, {6.0F, \"Truck\"}, {3.5F, \"Pedestrian\"}\n    };\n\n    process_lidar_data(detected_objects);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement an FCW system using radar and camera fusion. The program should combine distance data from radar with visual object classification from a camera.",
      "input": "Ensure modular code with separate functions for radar and camera processing. Include detailed comments and avoid using dynamic memory allocation.",
      "output": "#include <iostream>  // For console output\n#include <string>    // For handling object labels\n\n// Threshold for collision warning\nconst float WARNING_DISTANCE = 8.0F; // Minimum safe distance in meters\n\n// Structure to represent a detected object\nstruct FusedObject {\n    float radar_distance; // Distance measured by radar\n    std::string label;    // Object label from the camera (e.g., \"Car\")\n};\n\n// Function to check collision risk\nvoid check_collision(const FusedObject& obj) {\n    if (obj.radar_distance < WARNING_DISTANCE) {\n        std::cout << \"WARNING: Collision risk with \" << obj.label \n                  << \" at distance: \" << obj.radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    // Simulated fused data (replace with actual sensor fusion input)\n    FusedObject obj = {7.5F, \"Car\"};\n\n    check_collision(obj);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system using real-time video feed to detect lane deviations and estimate collision risk.",
      "input": "Ensure robust error handling for video capture, avoid global variables, and include detailed comments for each step. Use constants for thresholds.",
      "output": "#include <opencv2/opencv.hpp>  // For video processing\n#include <iostream>            // For input-output operations\n#include <cstdlib>             // For system errors\n\n// Collision warning distance (in meters)\nconst float LANE_WARNING_DISTANCE = 10.0F;\n\n// Function to process video frames\nvoid process_frame(cv::Mat& frame) {\n    if (frame.empty()) {\n        std::cerr << \"ERROR: Frame is empty!\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n\n    // Simulated lane deviation detection (replace with actual algorithm)\n    float detected_distance = 8.0F; // Simulated distance to a detected car\n\n    if (detected_distance < LANE_WARNING_DISTANCE) {\n        std::cout << \"WARNING: Collision risk! Distance: \" << detected_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);  // Open the default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Could not open video capture!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;  // Capture a frame\n        process_frame(frame);\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement an FCW system that uses vehicle speed and deceleration to predict braking requirements and issue warnings.",
      "input": "Include calculations for stopping distance, modular functions for clarity, and detailed comments. Avoid any unsafe typecasting.",
      "output": "#include <iostream>  // For input-output\n#include <cmath>      // For power and square root functions\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float REACTION_TIME = 1.5F; // Reaction time in seconds\nconst float FRICTION_COEFFICIENT = 0.7F;\nconst float GRAVITY = 9.8F;       // Gravitational acceleration (m/s^2)\nconst float WARNING_DISTANCE = 30.0F; // Warning distance in meters\n\n// Function to calculate stopping distance\nfloat calculate_stopping_distance(float speed) {\n    if (speed < 0.0F) {\n        std::cerr << \"ERROR: Speed cannot be negative.\" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n\n    return (speed * REACTION_TIME) + ((speed * speed) / (2.0F * FRICTION_COEFFICIENT * GRAVITY));\n}\n\nint main() {\n    float vehicle_speed = 20.0F; // Vehicle speed in m/s (replace with actual input)\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n\n    if (stopping_distance > WARNING_DISTANCE) {\n        std::cout << \"WARNING: Collision risk! Stopping distance exceeds \" << WARNING_DISTANCE << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe stopping distance: \" << stopping_distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system using accelerometer data to detect sudden braking events and issue warnings.",
      "input": "Include validation for sensor data, modularize functions for better readability, and provide detailed comments for all computations.",
      "output": "#include <iostream>  // For input-output\n#include <cstdlib>   // For system errors\n\n// Thresholds\nconst float BRAKING_ACCELERATION = -3.0F; // Sudden braking threshold (m/s^2)\n\n// Function to process accelerometer data\nvoid process_acceleration(float acceleration) {\n    if (acceleration > 0.0F) {\n        std::cout << \"INFO: Normal driving.\" << std::endl;\n    } else if (acceleration <= BRAKING_ACCELERATION) {\n        std::cout << \"WARNING: Sudden braking detected! Acceleration: \" << acceleration << \" m/s^2.\" << std::endl;\n    }\n}\n\nint main() {\n    float acceleration = -4.5F; // Simulated acceleration (replace with actual sensor data)\n\n    process_acceleration(acceleration);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement an FCW system that uses vehicle speed and relative velocity to predict collision risks and issue warnings.",
      "input": "Ensure correct handling of data types, avoid implicit type conversions, and include detailed comments for each key operation.",
      "output": "#include <iostream>  // For input-output\n#include <cmath>      // For math operations\n#include <cstdlib>    // For system errors\n\n// Constants\nconst float MIN_SAFE_DISTANCE = 15.0F; // Safe distance in meters\nconst float SAFE_DECELERATION = 2.0F; // Assumed deceleration (m/s^2)\n\n// Function to predict collision risk based on relative velocity\nvoid check_collision_risk(float relative_velocity, float distance) {\n    if (distance < MIN_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision risk due to distance.\" << std::endl;\n    } else if (relative_velocity > 0.0F && distance < relative_velocity * relative_velocity / (2.0F * SAFE_DECELERATION)) {\n        std::cout << \"WARNING: Collision risk due to relative velocity.\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_velocity = 15.0F;  // Relative velocity in m/s\n    float distance = 12.0F;           // Distance to object in meters\n\n    check_collision_risk(relative_velocity, distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code to implement an FCW system that utilizes object detection and speed measurement to trigger collision warnings when a vehicle is too close.",
      "input": "Ensure that no memory allocation occurs dynamically, and all arrays are defined with fixed sizes. Include comments explaining all logical steps.",
      "output": "#include <iostream>        // For console output\n#include <cmath>           // For mathematical calculations\n#include <cstdlib>         // For system errors\n#include <opencv2/opencv.hpp> // For OpenCV image processing\n\n// Constants\nconst float COLLISION_THRESHOLD = 10.0F; // Threshold distance for collision warning\n\n// Function to detect objects and check for collision risk\nvoid detect_and_check_collision(cv::Mat& frame, cv::Rect& detected_object) {\n    float distance = (1000.0F / detected_object.width); // Simplified distance estimation\n    std::cout << \"Detected object at distance: \" << distance << \" meters.\" << std::endl;\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat frame;  // Camera frame\n    cv::Rect detected_object(300, 200, 150, 75);  // Example object detection (replace with real data)\n\n    detect_and_check_collision(frame, detected_object);\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that triggers warnings based on the rate of change of speed (deceleration rate). The system should issue a warning when rapid deceleration occurs, suggesting a collision risk.",
      "input": "Ensure modular code with separate functions for checking speed changes and providing warnings. Use constants for thresholds and include detailed comments.",
      "output": "#include <iostream>  // For console output\n#include <cmath>      // For mathematical calculations\n#include <cstdlib>    // For system handling\n\n// Constants\nconst float MAX_DECCELERATION = 3.0F;  // Max deceleration (m/s^2)\n\n// Function to detect sudden deceleration\nvoid check_deceleration(float current_speed, float previous_speed, float time_interval) {\n    float deceleration = (previous_speed - current_speed) / time_interval;\n    if (deceleration > MAX_DECCELERATION) {\n        std::cout << \"WARNING: Sudden deceleration detected!\" << std::endl;\n    } else {\n        std::cout << \"No significant deceleration detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float current_speed = 5.0F;  // Current speed in m/s\n    float previous_speed = 20.0F; // Previous speed in m/s\n    float time_interval = 2.0F;   // Time interval in seconds\n\n    check_deceleration(current_speed, previous_speed, time_interval);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement an FCW system that uses the radar sensor to detect objects and issue a warning if they are too close.",
      "input": "Ensure the code handles edge cases such as incorrect sensor data or invalid distances. Include detailed comments for each step of the process.",
      "output": "#include <iostream>     // For output messages\n#include <cstdlib>       // For system errors\n\n// Constants\nconst float RADAR_THRESHOLD = 5.0F;  // Radar warning threshold in meters\n\n// Structure to represent a detected object\nstruct RadarObject {\n    float distance;  // Distance to the object in meters\n    std::string type; // Type of the object (e.g., \"Car\", \"Pedestrian\")\n};\n\n// Function to check radar data and issue collision warning\nvoid check_radar_data(const RadarObject& obj) {\n    if (obj.distance < RADAR_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk with \" << obj.type << \" at \" << obj.distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    RadarObject obj = {3.0F, \"Car\"}; // Simulated radar data (replace with actual sensor data)\n\n    check_radar_data(obj);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement an FCW system that uses ultrasonic sensors to monitor distance to nearby objects and trigger a warning if the distance is below a safe threshold.",
      "input": "Ensure compliance with MISRA standards for arrays and fixed sizes. Use constants for sensor data processing thresholds and include clear comments for each key operation.",
      "output": "#include <iostream>   // For console output\n#include <cstdlib>     // For system errors\n\n// Constants\nconst float SAFE_DISTANCE_THRESHOLD = 2.0F; // Safe distance threshold in meters\n\n// Structure for ultrasonic sensor data\nstruct UltrasonicSensorData {\n    float distance;  // Measured distance in meters\n    std::string object_type; // Object type (e.g., \"Car\", \"Pedestrian\")\n};\n\n// Function to check distance and issue collision warning\nvoid check_ultrasonic_data(const UltrasonicSensorData& sensor_data) {\n    if (sensor_data.distance < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Object detected too close!\" << std::endl;\n    } else {\n        std::cout << \"Distance safe: \" << sensor_data.distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    UltrasonicSensorData sensor_data = {1.5F, \"Car\"};  // Simulated data (replace with actual sensor data)\n\n    check_ultrasonic_data(sensor_data);\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code to implement an FCW system that uses a combination of vehicle speed and radar data to detect collision risks. The system should output warnings when an imminent collision is detected based on predefined thresholds.",
      "input": "Ensure that no dynamic memory allocation occurs, and avoid using any global variables. Include detailed comments explaining the functionality of the code.",
      "output": "#include <iostream>   // For standard input and output\n#include <cmath>      // For mathematical functions\n#include <cstdlib>    // For handling errors\n\n// Constants\nconst float SPEED_THRESHOLD = 30.0F;      // Speed threshold for FCW (km/h)\nconst float RADAR_THRESHOLD = 10.0F;      // Radar distance threshold (meters)\nconst float DECELERATION_RATE = 2.0F;     // Assumed deceleration rate (m/s^2)\n\n// Function to calculate collision risk\nvoid check_collision(float vehicle_speed, float distance_to_object) {\n    if (vehicle_speed > SPEED_THRESHOLD && distance_to_object < RADAR_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Distance: \" << distance_to_object << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 45.0F;   // Current vehicle speed (km/h)\n    float distance_to_object = 8.0F; // Distance to object (meters)\n\n    check_collision(vehicle_speed, distance_to_object);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement an FCW system that processes camera feed to detect nearby objects and calculates the relative distance between them and the vehicle, triggering warnings based on the proximity.",
      "input": "Avoid any unsafe casting, ensure all variables are initialized properly, and include detailed comments for each major code block.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV for camera and image processing\n#include <iostream>  // For input and output\n#include <cmath>  // For mathematical operations\n\n// Constants\nconst float COLLISION_DISTANCE_THRESHOLD = 10.0F;  // Threshold for collision warning in meters\nconst float OBJECT_WIDTH = 1.8F;   // Assumed width of the vehicle in meters\n\n// Function to calculate distance based on object size in image\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (OBJECT_WIDTH * image_width) / (object_width_in_image * 1.0F);  // Simple distance calculation\n}\n\n// Function to process the image, detect objects, and check for collisions\nvoid process_image(cv::Mat& frame) {\n    cv::Rect detected_object(500, 300, 150, 80);  // Simulated object detection (replace with actual detection logic)\n    int object_width_in_image = detected_object.width;\n    float distance_to_object = calculate_distance(object_width_in_image, frame.cols);\n\n    if (distance_to_object < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected at \" << distance_to_object << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat frame;  // Video frame\n    process_image(frame);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensors to measure distance to nearby objects and issue warnings when the distance is below a safe threshold.",
      "input": "Make sure that all variables are initialized, and avoid the use of any dynamic memory allocations. Include comments to explain the purpose of each function.",
      "output": "#include <iostream>  // For console output\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float SAFE_DISTANCE = 2.0F;  // Safe distance threshold in meters\n\n// Function to check distance from sensor data\nvoid check_sensor_data(float measured_distance) {\n    if (measured_distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object too close!\" << std::endl;\n    } else {\n        std::cout << \"Distance safe: \" << measured_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float measured_distance = 1.5F; // Simulated ultrasonic sensor data (meters)\n\n    check_sensor_data(measured_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that processes lidar data to detect obstacles and trigger warnings based on proximity.",
      "input": "Make sure that the system handles lidar data properly and avoid using unsafe data conversions. Provide clear explanations in the comments.",
      "output": "#include <iostream>   // For input and output\n#include <cstdlib>     // For error handling\n#include <cmath>       // For math operations\n\n// Constants\nconst float LIDAR_THRESHOLD = 5.0F;  // Lidar threshold for collision risk in meters\n\n// Function to process lidar data and check collision risk\nvoid check_lidar_data(float lidar_distance) {\n    if (lidar_distance < LIDAR_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected based on lidar data!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 4.0F;  // Simulated lidar data (meters)\n\n    check_lidar_data(lidar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses vehicle velocity and camera-based object detection to predict potential collisions and provide warnings.",
      "input": "Ensure that the code adheres to MISRA standards, especially for handling velocity calculations and object detection. Include comprehensive comments explaining the logic of each operation.",
      "output": "#include <opencv2/opencv.hpp>  // For OpenCV functionality\n#include <iostream>   // For output\n#include <cstdlib>    // For system operations\n#include <cmath>      // For math calculations\n\n// Constants\nconst float VEHICLE_VELOCITY_THRESHOLD = 20.0F;  // Velocity threshold (m/s)\nconst float SAFE_DISTANCE = 15.0F;  // Safe distance threshold (meters)\n\n// Function to calculate collision risk based on velocity and distance\nvoid check_collision_risk(float velocity, float distance) {\n    if (velocity > VEHICLE_VELOCITY_THRESHOLD && distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision risk detected! Velocity: \" << velocity << \" m/s, Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\n// Function to process the camera feed and check for collision risk\nvoid process_camera_feed(cv::Mat& frame) {\n    // Simulate object detection with a fixed bounding box (replace with actual detection)\n    cv::Rect detected_object(500, 300, 150, 80);\n    float object_distance = 10.0F;  // Simulated distance to detected object (meters)\n    float vehicle_velocity = 22.0F;  // Simulated vehicle velocity (m/s)\n\n    check_collision_risk(vehicle_velocity, object_distance);\n}\n\nint main() {\n    cv::Mat frame;  // Frame for camera feed\n    process_camera_feed(frame);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to implement a forward collision warning system that uses radar data to detect the proximity of objects and triggers warnings when the object is within a dangerous range.",
      "input": "Ensure there are no unsafe type conversions and that memory is allocated statically. Include comprehensive comments explaining the logic of the code.",
      "output": "#include <iostream>  // For standard input and output\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float DANGER_DISTANCE = 3.0F;  // Danger threshold distance in meters\n\n// Function to check the proximity of an object based on radar data\nvoid check_proximity(float radar_distance) {\n    if (radar_distance < DANGER_DISTANCE) {\n        std::cout << \"WARNING: Object too close! Distance: \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;  // Simulated radar distance (meters)\n\n    check_proximity(radar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses camera-based object detection to estimate the distance between the vehicle and detected obstacles and issues a warning when the distance is below the defined threshold.",
      "input": "Make sure no implicit casting occurs, and variables are initialized properly. Provide detailed comments explaining the function of each section.",
      "output": "#include <opencv2/opencv.hpp>  // For OpenCV functions\n#include <iostream>  // For output\n#include <cstdlib>   // For system functions\n\n// Constants\nconst float DISTANCE_THRESHOLD = 8.0F;  // Collision warning threshold (meters)\n\n// Function to calculate distance based on object width in image\nfloat calculate_object_distance(int object_width_in_image, int image_width) {\n    const float object_width = 1.8F;  // Assumed vehicle width in meters\n    return (object_width * image_width) / object_width_in_image;\n}\n\n// Function to process camera frames and detect objects\nvoid process_frame(cv::Mat& frame) {\n    cv::Rect detected_object(300, 200, 100, 60);  // Simulated detection box\n    int object_width_in_image = detected_object.width;\n    float distance_to_object = calculate_object_distance(object_width_in_image, frame.cols);\n\n    if (distance_to_object < DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Distance: \" << distance_to_object << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << distance_to_object << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat frame;  // Frame for capturing camera image\n    process_frame(frame);\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for a forward collision warning system using ultrasonic sensors to measure the distance between the vehicle and detected objects, triggering a warning if the object is too close.",
      "input": "Ensure there is no dynamic memory allocation and that all variables are properly initialized. Include detailed comments explaining each section of the code.",
      "output": "#include <iostream>  // For input and output operations\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float MIN_SAFE_DISTANCE = 1.0F;  // Minimum safe distance (meters)\n\n// Function to check the proximity of objects based on ultrasonic sensor data\nvoid check_ultrasonic_sensor(float distance) {\n    if (distance < MIN_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object too close! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float object_distance = 0.8F;  // Simulated ultrasonic sensor data (meters)\n\n    check_ultrasonic_sensor(object_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for a forward collision warning system that combines lidar data with vehicle velocity to calculate the potential collision risk and provide warnings if the risk exceeds a set threshold.",
      "input": "Avoid using any unsafe casting and ensure all calculations are done safely. Provide clear and detailed comments for each part of the code.",
      "output": "#include <iostream>   // For input and output\n#include <cstdlib>     // For error handling\n#include <cmath>       // For math functions\n\n// Constants\nconst float VELOCITY_THRESHOLD = 20.0F;  // Velocity threshold (m/s)\nconst float LIDAR_THRESHOLD = 5.0F;      // Lidar threshold distance (meters)\n\n// Function to calculate collision risk based on lidar and velocity\nvoid calculate_collision_risk(float velocity, float lidar_distance) {\n    if (velocity > VELOCITY_THRESHOLD && lidar_distance < LIDAR_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk detected! Velocity: \" << velocity << \" m/s, Lidar Distance: \" << lidar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_velocity = 22.0F;    // Simulated vehicle velocity (m/s)\n    float lidar_distance = 3.0F;      // Simulated lidar data (meters)\n\n    calculate_collision_risk(vehicle_velocity, lidar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar and camera data to calculate the relative speed and distance to an object ahead of the vehicle, triggering warnings when a collision is imminent.",
      "input": "Make sure to initialize all variables, handle type conversions explicitly, and avoid dynamic memory allocation. Comment the logic of the functions and the calculations involved.",
      "output": "#include <iostream>  // For input and output\n#include <cmath>      // For mathematical calculations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float COLLISION_THRESHOLD = 3.0F;  // Distance threshold for collision risk in meters\nconst float SPEED_THRESHOLD = 15.0F;     // Speed threshold for warning in m/s\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float vehicle_speed, float object_speed) {\n    return vehicle_speed - object_speed;  // Simple relative speed calculation\n}\n\n// Function to check collision risk based on distance and relative speed\nvoid check_collision_risk(float relative_speed, float distance_to_object) {\n    if (relative_speed > SPEED_THRESHOLD && distance_to_object < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk imminent! Relative Speed: \" << relative_speed << \" m/s, Distance: \" << distance_to_object << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Relative Speed: \" << relative_speed << \" m/s, Distance: \" << distance_to_object << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F;       // Simulated vehicle speed (m/s)\n    float object_speed = 5.0F;         // Simulated object speed (m/s)\n    float distance_to_object = 2.5F;   // Simulated distance to object (meters)\n\n    float relative_speed = calculate_relative_speed(vehicle_speed, object_speed);\n    check_collision_risk(relative_speed, distance_to_object);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for a forward collision warning system that uses camera-based object detection to detect vehicles ahead, calculates the distance, and issues a warning if the distance is below a defined threshold.",
      "input": "Ensure explicit type conversions and static memory allocation. Provide detailed explanations of each step in the code with comments.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cstdlib>   // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0F;  // Threshold for collision warning (meters)\n\n// Function to calculate distance to object based on object width in image\nfloat calculate_distance(int object_width, int image_width) {\n    const float object_width_in_real = 1.8F;  // Assumed width of vehicle in meters\n    return (object_width_in_real * image_width) / object_width;\n}\n\n// Function to process image frame and detect object distance\nvoid process_image(cv::Mat& frame) {\n    cv::Rect detected_object(500, 300, 100, 80);  // Example detected object (bounding box)\n    int object_width_in_image = detected_object.width;\n\n    // Estimate distance to object\n    float distance = calculate_distance(object_width_in_image, frame.cols);\n\n    // Output distance and check for collision risk\n    if (distance < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat frame;\n    process_image(frame);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward collision warning system that uses radar sensors to calculate the distance to objects and triggers a warning if the object is too close.",
      "input": "Avoid any dynamic memory allocations, use explicit type conversions, and ensure there are no implicit type casts. Provide detailed comments explaining each step of the process.",
      "output": "#include <iostream>  // For input and output\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float SAFE_DISTANCE_THRESHOLD = 10.0F;  // Distance threshold for warning (meters)\n\n// Function to check proximity of detected object\nvoid check_proximity(float radar_distance) {\n    if (radar_distance < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Object too close! Distance: \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.5F;  // Simulated radar data (meters)\n    check_proximity(radar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that integrates both lidar and camera data to calculate the potential collision risk based on distance and relative speed, issuing warnings when necessary.",
      "input": "Ensure proper initialization of variables, avoid unsafe memory operations, and provide clear and thorough comments for each section of the code.",
      "output": "#include <iostream>   // For input and output operations\n#include <cstdlib>     // For error handling\n#include <cmath>       // For mathematical functions\n\n// Constants\nconst float MIN_DISTANCE = 2.0F;  // Minimum distance threshold (meters)\nconst float VELOCITY_THRESHOLD = 15.0F;  // Velocity threshold (m/s)\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float vehicle_speed, float object_speed) {\n    return vehicle_speed - object_speed;\n}\n\n// Function to evaluate collision risk\nvoid evaluate_collision_risk(float vehicle_speed, float object_speed, float object_distance) {\n    float relative_speed = calculate_relative_speed(vehicle_speed, object_speed);\n\n    // Check collision risk\n    if (relative_speed > VELOCITY_THRESHOLD && object_distance < MIN_DISTANCE) {\n        std::cout << \"WARNING: Collision risk detected! Relative Speed: \" << relative_speed << \" m/s, Distance: \" << object_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk. Relative Speed: \" << relative_speed << \" m/s, Distance: \" << object_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 18.0F;  // Simulated vehicle speed (m/s)\n    float object_speed = 5.0F;    // Simulated object speed (m/s)\n    float object_distance = 1.5F; // Simulated object distance (meters)\n\n    evaluate_collision_risk(vehicle_speed, object_speed, object_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code to implement a forward collision warning system using ultrasonic sensors, which will measure the distance to the object and trigger a warning if the object is too close.",
      "input": "Ensure that no implicit casting is used, variables are properly initialized, and all functions are well-commented to explain the logic and purpose.",
      "output": "#include <iostream>  // For input and output\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float MIN_SAFE_DISTANCE = 1.0F;  // Minimum safe distance (meters)\n\n// Function to check if object is within safe distance\nvoid check_object_distance(float distance) {\n    if (distance < MIN_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object is too close! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Object at distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float object_distance = 0.9F;  // Simulated ultrasonic sensor reading (meters)\n    check_object_distance(object_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that integrates data from multiple sensors (camera, radar) and calculates the combined collision risk based on distance and velocity. The system should issue a warning if the collision risk is above a threshold.",
      "input": "Follow all MISRA 2023 guidelines and ensure the code includes no unsafe type conversions. Provide clear comments to explain the logic behind the code and the integration of the sensors.",
      "output": "#include <iostream>  // For standard input and output\n#include <cmath>      // For mathematical calculations\n#include <cstdlib>     // For system operations\n\n// Constants\nconst float COMBINED_THRESHOLD = 10.0F;  // Combined risk threshold\n\n// Function to compute collision risk based on sensor data\nvoid compute_collision_risk(float distance, float relative_velocity) {\n    if (distance < COMBINED_THRESHOLD && relative_velocity > 5.0F) {\n        std::cout << \"WARNING: High collision risk detected! Distance: \" << distance << \" meters, Relative Speed: \" << relative_velocity << \" m/s.\" << std::endl;\n    } else {\n        std::cout << \"Safe: No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float distance = 7.0F;   // Simulated sensor data (meters)\n    float relative_velocity = 8.0F;  // Simulated relative velocity (m/s)\n\n    compute_collision_risk(distance, relative_velocity);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for a forward collision warning system that uses stereo vision (two cameras) to calculate the depth of objects in the field of view and triggers a warning if the distance is below a predefined threshold.",
      "input": "Ensure the code is properly structured with explicit type conversions and clear, concise comments. Avoid using any dynamic memory allocation and explain each key operation.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for computer vision\n#include <iostream>  // For standard input-output operations\n#include <cstdlib>  // For system operations\n\n// Constants\nconst float COLLISION_DISTANCE_THRESHOLD = 8.0F;  // Safe distance (meters)\n\n// Function to calculate distance based on disparity map from stereo vision\nfloat calculate_distance(float disparity) {\n    const float baseline = 0.2F;  // Baseline distance between the two cameras (meters)\n    const float focal_length = 800.0F;  // Focal length (in pixels)\n    return (baseline * focal_length) / disparity;\n}\n\n// Function to process stereo image pair and calculate distance\nvoid process_stereo_image(cv::Mat& left_image, cv::Mat& right_image) {\n    // Compute disparity map between the left and right image\n    cv::Mat disparity_map;\n    cv::StereoBM stereo_matcher;\n    stereo_matcher(left_image, right_image, disparity_map);\n\n    // Assume we detected an object with a certain disparity value\n    float object_disparity = 50.0F;  // Example disparity value\n\n    // Calculate the distance to the object based on disparity\n    float distance = calculate_distance(object_disparity);\n\n    // Check if the object is too close\n    if (distance < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Object too close! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Object at distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat left_image, right_image;  // Simulated stereo image pair\n    process_stereo_image(left_image, right_image);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for a forward collision warning system using lidar data to measure the distance to objects ahead and trigger a warning when an object comes too close.",
      "input": "The code should avoid unsafe type conversions, handle sensor data appropriately, and be clearly commented to explain each part of the implementation.",
      "output": "#include <iostream>   // For input and output operations\n#include <cstdlib>     // For system operations\n\n// Constants\nconst float LIDAR_SAFE_DISTANCE = 12.0F;  // Threshold for safe distance (meters)\n\n// Function to check the proximity of an object using lidar data\nvoid check_lidar_distance(float lidar_distance) {\n    if (lidar_distance < LIDAR_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object is too close! Distance: \" << lidar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << lidar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 9.0F;  // Simulated lidar reading (meters)\n    check_lidar_distance(lidar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward collision warning system that uses a combination of radar and GPS data to predict collision risks based on object distance and vehicle speed.",
      "input": "Use explicit type conversions and provide detailed comments explaining each calculation and condition check involved in the process.",
      "output": "#include <iostream>  // For input and output\n#include <cmath>      // For mathematical operations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float SAFE_DISTANCE_THRESHOLD = 15.0F;  // Safe distance (meters)\n\n// Function to calculate collision risk\nvoid check_collision_risk(float distance, float vehicle_speed) {\n    if (distance < SAFE_DISTANCE_THRESHOLD && vehicle_speed > 10.0F) {\n        std::cout << \"WARNING: High collision risk! Distance: \" << distance << \" meters, Speed: \" << vehicle_speed << \" m/s.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters, Speed: \" << vehicle_speed << \" m/s.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;  // Simulated radar distance (meters)\n    float vehicle_speed = 15.0F;  // Simulated vehicle speed (m/s)\n\n    check_collision_risk(radar_distance, vehicle_speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses infrared sensors to detect objects and calculate the distance, issuing a warning if an object is too close.",
      "input": "The code should handle explicit type conversions and avoid any unsafe memory operations. Provide detailed explanations of each step in the code.",
      "output": "#include <iostream>  // For standard input and output\n#include <cstdlib>    // For error handling\n\n// Constants\nconst float INFRARED_SAFE_DISTANCE = 5.0F;  // Safe distance threshold (meters)\n\n// Function to check object proximity using infrared sensor data\nvoid check_infrared_proximity(float infrared_distance) {\n    if (infrared_distance < INFRARED_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object too close! Distance: \" << infrared_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << infrared_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float infrared_distance = 3.0F;  // Simulated infrared sensor distance reading (meters)\n    check_infrared_proximity(infrared_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system that combines ultrasonic and radar sensor data to compute the collision risk based on object distance and relative speed.",
      "input": "Ensure there are no unsafe conversions between types, and all memory operations are safe. Provide detailed explanations in the comments for each calculation and decision point.",
      "output": "#include <iostream>  // For input-output operations\n#include <cmath>      // For mathematical calculations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float COLLISION_RISK_THRESHOLD = 8.0F;  // Collision risk threshold (meters)\n\n// Function to compute relative speed\nfloat compute_relative_speed(float vehicle_speed, float object_speed) {\n    return vehicle_speed - object_speed;\n}\n\n// Function to evaluate collision risk\nvoid evaluate_collision_risk(float distance, float relative_speed) {\n    if (distance < COLLISION_RISK_THRESHOLD && relative_speed > 5.0F) {\n        std::cout << \"WARNING: High collision risk detected! Distance: \" << distance << \" meters, Relative Speed: \" << relative_speed << \" m/s.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters, Relative Speed: \" << relative_speed << \" m/s.\" << std::endl;\n    }\n}\n\nint main() {\n    float object_distance = 6.0F;   // Simulated object distance (meters)\n    float object_speed = 2.0F;      // Simulated object speed (m/s)\n    float vehicle_speed = 10.0F;    // Simulated vehicle speed (m/s)\n\n    float relative_speed = compute_relative_speed(vehicle_speed, object_speed);\n    evaluate_collision_risk(object_distance, relative_speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for a forward collision warning system that uses vehicle speed, object distance, and relative speed to determine collision risk and trigger a warning.",
      "input": "Ensure the code uses explicit type conversions, handles edge cases (e.g., zero distance), and is well-commented.",
      "output": "#include <iostream>  // For input-output operations\n#include <cmath>      // For mathematical functions\n#include <cstdlib>     // For system operations\n\n// Constants\nconst float COLLISION_THRESHOLD_DISTANCE = 6.0F;  // Minimum safe distance (meters)\nconst float SPEED_THRESHOLD = 5.0F;  // Minimum speed threshold for collision risk (m/s)\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float vehicle_speed, float object_speed) {\n    return vehicle_speed - object_speed;\n}\n\n// Function to determine collision risk\nvoid check_collision_risk(float object_distance, float relative_speed) {\n    if (object_distance < COLLISION_THRESHOLD_DISTANCE && relative_speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Collision imminent! Distance: \" << object_distance << \" meters, Speed difference: \" << relative_speed << \" m/s.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << object_distance << \" meters, Speed difference: \" << relative_speed << \" m/s.\" << std::endl;\n    }\n}\n\nint main() {\n    float object_distance = 4.0F;    // Example object distance (meters)\n    float vehicle_speed = 15.0F;    // Example vehicle speed (m/s)\n    float object_speed = 10.0F;     // Example object speed (m/s)\n\n    // Calculate relative speed\n    float relative_speed = calculate_relative_speed(vehicle_speed, object_speed);\n\n    // Check for collision risk\n    check_collision_risk(object_distance, relative_speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar sensor data to measure the distance to an object and triggers a warning if the object is too close.",
      "input": "The code must use safe and explicit type conversions, avoid using dynamic memory allocation, and be well-commented to describe the logic and flow.",
      "output": "#include <iostream>  // For input-output operations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float RADAR_SAFE_DISTANCE = 10.0F;  // Threshold for safe distance (meters)\n\n// Function to evaluate proximity based on radar distance\nvoid evaluate_radar_distance(float radar_distance) {\n    if (radar_distance < RADAR_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object too close! Distance: \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object at a safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F;  // Example radar distance reading (meters)\n    evaluate_radar_distance(radar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that processes camera data, calculates the distance of detected objects, and activates a warning if an object is too close.",
      "input": "The code should be free from unsafe operations like implicit type conversions and dynamic memory allocation. Include comments to describe each significant operation.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cstdlib>   // For system operations\n\n// Constants\nconst float CAMERA_SAFE_DISTANCE = 7.0F;  // Safe distance threshold (meters)\n\n// Function to process camera data and check for collision risk\nvoid process_camera_data(cv::Mat &image) {\n    // Simulated detected object distance (for demonstration purposes)\n    float detected_object_distance = 6.5F;\n\n    if (detected_object_distance < CAMERA_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision risk! Object distance: \" << detected_object_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << detected_object_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat image;  // Placeholder for camera image (not used here)\n    process_camera_data(image);\n    return 0;\n}"
    },
    {
      "instruction": "Implement a MISRA 2023-compliant C++ FCW system that uses ultrasonic sensor data to monitor the distance between the vehicle and objects, triggering a warning when the distance is too small.",
      "input": "The code should avoid unsafe type conversions and dynamic memory allocation, and it should include comments for clarity and better understanding.",
      "output": "#include <iostream>  // For input and output\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float ULTRASONIC_SAFE_DISTANCE = 3.0F;  // Safe distance threshold (meters)\n\n// Function to check proximity using ultrasonic sensor data\nvoid check_ultrasonic_distance(float ultrasonic_distance) {\n    if (ultrasonic_distance < ULTRASONIC_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object too close! Distance: \" << ultrasonic_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << ultrasonic_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_distance = 2.5F;  // Simulated ultrasonic sensor reading (meters)\n    check_ultrasonic_distance(ultrasonic_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a combination of lidar and GPS data to evaluate the distance and speed of an object ahead, triggering a warning if the risk of collision is high.",
      "input": "Ensure all type conversions are explicit, avoid unsafe memory operations, and provide detailed comments to explain the logic of each step.",
      "output": "#include <iostream>  // For standard I/O operations\n#include <cmath>      // For mathematical operations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0F;  // Safe distance threshold (meters)\n\n// Function to calculate relative speed using GPS data\nfloat calculate_relative_speed(float vehicle_speed, float object_speed) {\n    return vehicle_speed - object_speed;\n}\n\n// Function to evaluate collision risk based on lidar and GPS data\nvoid evaluate_collision_risk(float object_distance, float relative_speed) {\n    if (object_distance < COLLISION_THRESHOLD_DISTANCE && relative_speed > 5.0F) {\n        std::cout << \"WARNING: High collision risk detected! Distance: \" << object_distance << \" meters, Relative Speed: \" << relative_speed << \" m/s.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << object_distance << \" meters, Relative Speed: \" << relative_speed << \" m/s.\" << std::endl;\n    }\n}\n\nint main() {\n    float object_distance = 8.0F;    // Simulated object distance (meters)\n    float vehicle_speed = 18.0F;    // Simulated vehicle speed (m/s)\n    float object_speed = 12.0F;     // Simulated object speed (m/s)\n\n    // Calculate relative speed\n    float relative_speed = calculate_relative_speed(vehicle_speed, object_speed);\n\n    // Evaluate collision risk\n    evaluate_collision_risk(object_distance, relative_speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using stereo vision to calculate the distance to objects and trigger a warning when the object is within a predefined safe range.",
      "input": "Ensure compliance with MISRA standards by using explicit type conversions and avoiding unsafe memory operations. Include detailed comments for each significant operation.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cstdlib>     // For system operations\n\n// Constants\nconst float STEREO_SAFE_DISTANCE = 5.0F;  // Safe distance threshold (meters)\n\n// Function to calculate distance from disparity\nfloat calculate_distance_from_disparity(int disparity, int baseline, float focal_length) {\n    return (baseline * focal_length) / disparity;\n}\n\n// Function to process stereo image data and check collision risk\nvoid process_stereo_image(cv::Mat &left_image, cv::Mat &right_image) {\n    // Simulated disparity value (in real systems, disparity maps are generated by stereo vision algorithms)\n    int disparity = 20;  // Example disparity value\n    int baseline = 70;   // Camera baseline (mm)\n    float focal_length = 500.0F;  // Camera focal length (mm)\n\n    // Calculate distance to object\n    float distance = calculate_distance_from_disparity(disparity, baseline, focal_length);\n\n    if (distance < STEREO_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision risk detected! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat left_image, right_image;  // Placeholder for stereo images (not used here)\n    process_stereo_image(left_image, right_image);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensors to continuously monitor the distance to the nearest object and activate a warning when the object is too close.",
      "input": "The code must follow the MISRA standards, including avoiding unsafe operations like implicit type conversions and dynamic memory allocation. Provide detailed comments for clarity.",
      "output": "#include <iostream>  // For input-output operations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float ULTRASONIC_THRESHOLD = 3.0F;  // Safe distance threshold (meters)\n\n// Function to process ultrasonic sensor data and check for collision risk\nvoid process_ultrasonic_data(float sensor_distance) {\n    if (sensor_distance < ULTRASONIC_THRESHOLD) {\n        std::cout << \"WARNING: Object too close! Distance: \" << sensor_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object at a safe distance: \" << sensor_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float sensor_distance = 2.5F;  // Example ultrasonic sensor reading (meters)\n    process_ultrasonic_data(sensor_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar sensor data to detect objects and estimate their speed. The system should trigger a warning when the relative speed exceeds a safe threshold.",
      "input": "The code must adhere to MISRA standards and include proper handling of all type conversions, including explicit casting. Detailed comments should be provided for key operations.",
      "output": "#include <iostream>  // For input-output operations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float RADAR_SAFE_SPEED = 10.0F;  // Relative speed threshold (m/s)\n\n// Function to calculate relative speed between vehicle and object\nfloat calculate_relative_speed(float vehicle_speed, float object_speed) {\n    return vehicle_speed - object_speed;\n}\n\n// Function to evaluate collision risk based on relative speed\nvoid evaluate_collision_risk(float relative_speed) {\n    if (relative_speed > RADAR_SAFE_SPEED) {\n        std::cout << \"WARNING: High speed difference! Relative Speed: \" << relative_speed << \" m/s.\" << std::endl;\n    } else {\n        std::cout << \"Relative speed is safe: \" << relative_speed << \" m/s.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F;    // Vehicle speed (m/s)\n    float object_speed = 5.0F;      // Object speed (m/s)\n\n    // Calculate relative speed\n    float relative_speed = calculate_relative_speed(vehicle_speed, object_speed);\n\n    // Evaluate collision risk\n    evaluate_collision_risk(relative_speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses LiDAR sensor data to detect objects ahead and activate a warning if the object is within a critical distance.",
      "input": "Ensure the code follows MISRA standards, including handling all type conversions explicitly and avoiding dynamic memory allocation. Add comments to clarify each key operation.",
      "output": "#include <iostream>  // For input-output operations\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float LIDAR_SAFE_DISTANCE = 8.0F;  // Critical distance threshold (meters)\n\n// Function to process LiDAR sensor data and check collision risk\nvoid process_lidar_data(float lidar_distance) {\n    if (lidar_distance < LIDAR_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Object detected within critical range! Distance: \" << lidar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Object is at a safe distance: \" << lidar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 7.0F;  // Simulated LiDAR distance reading (meters)\n    process_lidar_data(lidar_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses GPS data to monitor the vehicle's position and speed, and triggers a warning if the vehicle approaches an obstacle too quickly.",
      "input": "The code must use explicit type conversions and handle errors properly. Each key operation should be clearly commented for easy understanding.",
      "output": "#include <iostream>  // For input-output operations\n#include <cmath>      // For mathematical functions\n#include <cstdlib>     // For error handling\n\n// Constants\nconst float GPS_SPEED_THRESHOLD = 12.0F;  // Speed threshold for collision risk (m/s)\n\n// Function to check collision risk based on speed and distance\nvoid check_gps_collision_risk(float vehicle_speed, float object_distance) {\n    if (vehicle_speed > GPS_SPEED_THRESHOLD && object_distance < 5.0F) {\n        std::cout << \"WARNING: Collision risk! Vehicle Speed: \" << vehicle_speed << \" m/s, Object Distance: \" << object_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Vehicle Speed: \" << vehicle_speed << \" m/s, Object Distance: \" << object_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 15.0F;  // Example vehicle speed (m/s)\n    float object_distance = 4.0F;  // Example object distance (meters)\n\n    // Check collision risk\n    check_gps_collision_risk(vehicle_speed, object_distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a monocular camera to detect objects ahead, estimate their distance, and trigger a warning when necessary.",
      "input": "Ensure the code uses explicit type conversions and adheres to MISRA standards. Include clear comments explaining the camera-based distance estimation process.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE = 5.0F;\nconst float FOCAL_LENGTH = 500.0F;\nconst float OBJECT_WIDTH = 2.0F;\n\nfloat estimate_distance(int object_pixel_width) {\n    return (FOCAL_LENGTH * OBJECT_WIDTH) / static_cast<float>(object_pixel_width);\n}\n\nvoid process_frame(cv::Mat &frame) {\n    int object_pixel_width = 100;\n    float distance = estimate_distance(object_pixel_width);\n\n    if (distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision risk at distance \" << distance << \" meters!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat frame;\n    process_frame(frame);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that integrates multiple sensors (LiDAR and radar) to enhance collision detection accuracy.",
      "input": "Follow MISRA standards strictly, including explicit type casting and clear error handling. Provide comments explaining sensor fusion logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float LIDAR_SAFE_DISTANCE = 5.0F;\nconst float RADAR_SAFE_DISTANCE = 6.0F;\n\nvoid evaluate_risk(float lidar_distance, float radar_distance) {\n    if (lidar_distance < LIDAR_SAFE_DISTANCE && radar_distance < RADAR_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision risk detected by both sensors!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance according to sensors.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 4.5F;\n    float radar_distance = 5.5F;\n    evaluate_risk(lidar_distance, radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses image segmentation to detect road obstacles and calculate their distance.",
      "input": "Ensure MISRA compliance by avoiding unsafe operations and providing detailed comments. Focus on image segmentation and obstacle detection.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nvoid process_image(cv::Mat &image) {\n    cv::Mat segmented;\n    cv::threshold(image, segmented, 128, 255, cv::THRESH_BINARY);\n\n    int obstacle_width = 50;\n    float distance = 1000.0F / static_cast<float>(obstacle_width);\n\n    if (distance < 5.0F) {\n        std::cout << \"WARNING: Obstacle detected at \" << distance << \" meters!\" << std::endl;\n    } else {\n        std::cout << \"Obstacle distance is safe: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat image;\n    process_image(image);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that predicts potential collision paths using vehicle speed and direction.",
      "input": "Ensure compliance with MISRA rules by handling all calculations explicitly and adding comments explaining the logic behind path prediction.",
      "output": "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE = 5.0F;\n\nfloat predict_distance(float speed, float time) {\n    return speed * time;\n}\n\nvoid evaluate_path(float speed, float time_to_collision) {\n    float distance = predict_distance(speed, time_to_collision);\n    if (distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Predicted collision path!\" << std::endl;\n    } else {\n        std::cout << \"Path is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 10.0F;\n    float time_to_collision = 0.3F;\n    evaluate_path(speed, time_to_collision);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses thermal cameras to detect living beings (e.g., pedestrians) and warn the driver.",
      "input": "Ensure adherence to MISRA guidelines and provide comments for thermal imaging and object detection logic.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float PEDESTRIAN_DISTANCE_THRESHOLD = 5.0F;\n\nvoid detect_pedestrians(cv::Mat &thermal_image) {\n    cv::Mat binary;\n    cv::threshold(thermal_image, binary, 150, 255, cv::THRESH_BINARY);\n\n    int pedestrian_width = 20;\n    float distance = 200.0F / static_cast<float>(pedestrian_width);\n\n    if (distance < PEDESTRIAN_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat thermal_image;\n    detect_pedestrians(thermal_image);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses vibration sensors to detect surface irregularities and warn the driver.",
      "input": "Follow MISRA standards by including explicit type conversions and error handling. Add comments explaining the vibration-based detection logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float VIBRATION_THRESHOLD = 1.5F;\n\nvoid evaluate_vibration(float vibration_level) {\n    if (vibration_level > VIBRATION_THRESHOLD) {\n        std::cout << \"WARNING: Potential collision risk due to irregular surface!\" << std::endl;\n    } else {\n        std::cout << \"Surface is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float vibration_level = 2.0F;\n    evaluate_vibration(vibration_level);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses accelerometer data to detect sudden decelerations and warn of potential collisions.",
      "input": "The code should comply with MISRA guidelines, and comments must explain the accelerometer-based collision detection logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DECELERATION_THRESHOLD = -3.0F;\n\nvoid check_deceleration(float acceleration) {\n    if (acceleration < DECELERATION_THRESHOLD) {\n        std::cout << \"WARNING: Sudden deceleration detected! Risk of collision.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk from deceleration.\" << std::endl;\n    }\n}\n\nint main() {\n    float acceleration = -4.0F;\n    check_deceleration(acceleration);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that tracks the vehicle's braking performance and warns when it is insufficient.",
      "input": "The code must be MISRA-compliant, with explicit type conversions and proper error handling. Provide detailed comments explaining the logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float BRAKING_THRESHOLD = 0.8F;\n\nvoid evaluate_braking(float brake_force) {\n    if (brake_force < BRAKING_THRESHOLD) {\n        std::cout << \"WARNING: Insufficient braking detected!\" << std::endl;\n    } else {\n        std::cout << \"Braking performance is adequate.\" << std::endl;\n    }\n}\n\nint main() {\n    float brake_force = 0.7F;\n    evaluate_braking(brake_force);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses GPS data to detect if the vehicle is entering a restricted zone.",
      "input": "Adhere to MISRA guidelines by handling all data explicitly and ensuring proper boundary checks. Add comments for GPS logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RESTRICTED_LATITUDE = 40.0F;\nconst float RESTRICTED_LONGITUDE = -74.0F;\n\nvoid check_restricted_zone(float latitude, float longitude) {\n    if (latitude == RESTRICTED_LATITUDE && longitude == RESTRICTED_LONGITUDE) {\n        std::cout << \"WARNING: Entering restricted zone!\" << std::endl;\n    } else {\n        std::cout << \"Safe location.\" << std::endl;\n    }\n}\n\nint main() {\n    float latitude = 40.0F;\n    float longitude = -74.0F;\n    check_restricted_zone(latitude, longitude);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that predicts vehicle trajectory based on real-time steering and velocity inputs.",
      "input": "Ensure strict adherence to MISRA rules with detailed comments about trajectory prediction logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nvoid predict_trajectory(float steering_angle, float velocity) {\n    float trajectory = steering_angle * velocity;\n\n    if (trajectory > 50.0F) {\n        std::cout << \"WARNING: Risky trajectory predicted!\" << std::endl;\n    } else {\n        std::cout << \"Safe trajectory.\" << std::endl;\n    }\n}\n\nint main() {\n    float steering_angle = 5.0F;\n    float velocity = 10.0F;\n    predict_trajectory(steering_angle, velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensors to measure the proximity of objects and provide warnings.",
      "input": "Follow MISRA standards strictly, including explicit type casting and clear comments about the ultrasonic sensor operation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_PROXIMITY = 1.5F;\n\nvoid check_proximity(float distance) {\n    if (distance < SAFE_PROXIMITY) {\n        std::cout << \"WARNING: Object too close!\" << std::endl;\n    } else {\n        std::cout << \"Proximity is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float distance = 1.2F;\n    check_proximity(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that detects sudden acceleration using accelerometer data and warns the driver.",
      "input": "Ensure explicit type conversions and clear comments explaining the sudden acceleration detection logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float ACCELERATION_THRESHOLD = 3.5F;\n\nvoid detect_acceleration(float acceleration) {\n    if (acceleration > ACCELERATION_THRESHOLD) {\n        std::cout << \"WARNING: Sudden acceleration detected!\" << std::endl;\n    } else {\n        std::cout << \"Acceleration is normal.\" << std::endl;\n    }\n}\n\nint main() {\n    float acceleration = 4.2F;\n    detect_acceleration(acceleration);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses GPS data to identify sharp turns ahead and alert the driver.",
      "input": "Ensure proper compliance with MISRA rules and detailed comments explaining the GPS and turn prediction logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TURN_THRESHOLD = 30.0F; // Degrees\n\nvoid detect_sharp_turn(float angle) {\n    if (angle > TURN_THRESHOLD) {\n        std::cout << \"WARNING: Sharp turn ahead!\" << std::endl;\n    } else {\n        std::cout << \"Road is safe for current speed.\" << std::endl;\n    }\n}\n\nint main() {\n    float angle = 35.0F;\n    detect_sharp_turn(angle);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that monitors tire pressure and warns of low pressure in real time.",
      "input": "Strictly adhere to MISRA standards and provide clear comments about tire pressure monitoring logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MIN_PRESSURE = 30.0F;\n\nvoid check_tire_pressure(float pressure) {\n    if (pressure < MIN_PRESSURE) {\n        std::cout << \"WARNING: Tire pressure too low!\" << std::endl;\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main() {\n    float pressure = 28.0F;\n    check_tire_pressure(pressure);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that integrates speed data and braking efficiency to assess collision risks.",
      "input": "Ensure compliance with MISRA guidelines, using explicit type casting and detailed commenting.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float BRAKING_EFFICIENCY = 0.8F;\nconst float MAX_SPEED = 80.0F; // km/h\n\nvoid assess_collision_risk(float speed, float brake_force) {\n    float stopping_distance = (speed * speed) / (2.0F * brake_force);\n\n    if (stopping_distance > BRAKING_EFFICIENCY * MAX_SPEED) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Braking performance is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 70.0F;\n    float brake_force = 0.7F;\n    assess_collision_risk(speed, brake_force);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that calculates stopping distance based on real-time speed and road gradient.",
      "input": "Follow MISRA rules and include comments for stopping distance calculation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float GRAVITY = 9.8F;\nconst float FRICTION_COEFFICIENT = 0.7F;\n\nfloat calculate_stopping_distance(float speed, float gradient) {\n    float effective_gravity = GRAVITY * (1.0F + gradient);\n    return (speed * speed) / (2.0F * effective_gravity * FRICTION_COEFFICIENT);\n}\n\nvoid evaluate_stopping_distance(float speed, float gradient) {\n    float stopping_distance = calculate_stopping_distance(speed, gradient);\n    if (stopping_distance > 10.0F) {\n        std::cout << \"WARNING: Stopping distance exceeds safe limit!\" << std::endl;\n    } else {\n        std::cout << \"Stopping distance is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 15.0F;\n    float gradient = 0.05F;\n    evaluate_stopping_distance(speed, gradient);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that monitors headlight intensity for low-light collision avoidance.",
      "input": "Ensure MISRA compliance and include comments on headlight intensity monitoring.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MIN_HEADLIGHT_INTENSITY = 70.0F;\n\nvoid check_headlight_intensity(float intensity) {\n    if (intensity < MIN_HEADLIGHT_INTENSITY) {\n        std::cout << \"WARNING: Low headlight intensity detected!\" << std::endl;\n    } else {\n        std::cout << \"Headlight intensity is sufficient.\" << std::endl;\n    }\n}\n\nint main() {\n    float intensity = 65.0F;\n    check_headlight_intensity(intensity);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses gyroscope data to detect sharp turns and warn drivers.",
      "input": "Follow MISRA guidelines and include explicit type casting.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TURN_RATE_THRESHOLD = 45.0F; // degrees per second\n\nvoid detect_sharp_turn(float turn_rate) {\n    if (turn_rate > TURN_RATE_THRESHOLD) {\n        std::cout << \"WARNING: Sharp turn detected!\" << std::endl;\n    } else {\n        std::cout << \"Turn rate is normal.\" << std::endl;\n    }\n}\n\nint main() {\n    float turn_rate = 50.0F;\n    detect_sharp_turn(turn_rate);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that analyzes lane departure warnings using camera inputs.",
      "input": "Adhere to MISRA standards and provide comments on lane departure analysis.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float LANE_OFFSET_THRESHOLD = 0.3F;\n\nvoid check_lane_departure(float lane_offset) {\n    if (lane_offset > LANE_OFFSET_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is in the lane.\" << std::endl;\n    }\n}\n\nint main() {\n    float lane_offset = 0.4F;\n    check_lane_departure(lane_offset);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that integrates weather conditions and road surface information to predict skidding risks.",
      "input": "Strict adherence to MISRA guidelines with detailed comments on skidding prediction.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float WET_ROAD_FRICTION = 0.5F;\nconst float SAFE_SPEED = 50.0F;\n\nvoid predict_skid_risk(float speed, bool is_road_wet) {\n    float friction = is_road_wet ? WET_ROAD_FRICTION : 1.0F;\n    if ((speed / friction) > SAFE_SPEED) {\n        std::cout << \"WARNING: High skid risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Skid risk is low.\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 60.0F;\n    bool is_road_wet = true;\n    predict_skid_risk(speed, is_road_wet);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system integrated with adaptive cruise control, warning when the following distance is too short.",
      "input": "Ensure strict MISRA compliance and detailed comments about following distance logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MIN_FOLLOWING_DISTANCE = 2.0F; // in seconds\n\nvoid check_following_distance(float time_gap) {\n    if (time_gap < MIN_FOLLOWING_DISTANCE) {\n        std::cout << \"WARNING: Following distance too short!\" << std::endl;\n    } else {\n        std::cout << \"Following distance is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float time_gap = 1.5F;\n    check_following_distance(time_gap);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that monitors blind spots and alerts the driver of adjacent vehicles.",
      "input": "Follow MISRA rules and include detailed comments about blind spot monitoring.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float BLIND_SPOT_RANGE = 3.0F; // in meters\n\nvoid check_blind_spot(float distance) {\n    if (distance < BLIND_SPOT_RANGE) {\n        std::cout << \"WARNING: Vehicle in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"Blind spot is clear.\" << std::endl;\n    }\n}\n\nint main() {\n    float distance = 2.5F;\n    check_blind_spot(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that adjusts sensitivity based on night driving conditions.",
      "input": "Ensure adherence to MISRA standards and detailed comments about night driving adjustments.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float NIGHT_SENSITIVITY_FACTOR = 1.5F;\nconst float NORMAL_SENSITIVITY = 1.0F;\n\nvoid adjust_sensitivity(bool is_night) {\n    float sensitivity = is_night ? NIGHT_SENSITIVITY_FACTOR : NORMAL_SENSITIVITY;\n    std::cout << \"Sensitivity set to: \" << sensitivity << std::endl;\n}\n\nint main() {\n    bool is_night = true;\n    adjust_sensitivity(is_night);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that evaluates collision risk in foggy weather.",
      "input": "Ensure strict MISRA compliance with comments explaining fog risk assessment.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float FOG_VISIBILITY_THRESHOLD = 50.0F; // in meters\n\nvoid check_fog_risk(float visibility) {\n    if (visibility < FOG_VISIBILITY_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk in fog!\" << std::endl;\n    } else {\n        std::cout << \"Visibility is adequate.\" << std::endl;\n    }\n}\n\nint main() {\n    float visibility = 40.0F;\n    check_fog_risk(visibility);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that detects speed bumps using ultrasonic sensors.",
      "input": "Include clear comments and ensure MISRA compliance.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_BUMP_HEIGHT_THRESHOLD = 0.15F; // in meters\n\nvoid detect_speed_bump(float height) {\n    if (height > SPEED_BUMP_HEIGHT_THRESHOLD) {\n        std::cout << \"WARNING: Speed bump ahead!\" << std::endl;\n    } else {\n        std::cout << \"No speed bump detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float height = 0.2F;\n    detect_speed_bump(height);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that identifies pedestrians at crosswalks.",
      "input": "Strictly adhere to MISRA standards and provide comments on crosswalk detection logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst int PEDESTRIAN_DETECTED = 1;\n\nvoid check_crosswalk(int pedestrian_flag) {\n    if (pedestrian_flag == PEDESTRIAN_DETECTED) {\n        std::cout << \"WARNING: Pedestrian at crosswalk!\" << std::endl;\n    } else {\n        std::cout << \"Crosswalk is clear.\" << std::endl;\n    }\n}\n\nint main() {\n    int pedestrian_flag = 1;\n    check_crosswalk(pedestrian_flag);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that monitors road temperature to detect icy conditions.",
      "input": "Ensure MISRA compliance and include detailed comments about road temperature monitoring.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float ICE_TEMPERATURE_THRESHOLD = 0.0F; // in degrees Celsius\n\nvoid check_road_ice(float temperature) {\n    if (temperature <= ICE_TEMPERATURE_THRESHOLD) {\n        std::cout << \"WARNING: Icy road conditions detected!\" << std::endl;\n    } else {\n        std::cout << \"Road conditions are safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float temperature = -2.0F;\n    check_road_ice(temperature);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that evaluates intersection collision risks using GPS and vehicle speed data.",
      "input": "Adhere to MISRA standards with detailed comments about intersection risk evaluation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float INTERSECTION_DISTANCE = 10.0F;\n\nvoid check_intersection_collision(float distance, float speed) {\n    if ((distance < INTERSECTION_DISTANCE) && (speed > 20.0F)) {\n        std::cout << \"WARNING: High collision risk at intersection!\" << std::endl;\n    } else {\n        std::cout << \"Intersection risk is low.\" << std::endl;\n    }\n}\n\nint main() {\n    float distance = 8.0F;\n    float speed = 25.0F;\n    check_intersection_collision(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that warns of unsafe lane changes based on side sensors.",
      "input": "Strict adherence to MISRA rules with clear comments on lane change safety logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_LANE_CHANGE_DISTANCE = 5.0F;\n\nvoid check_lane_change_safety(float side_distance) {\n    if (side_distance < SAFE_LANE_CHANGE_DISTANCE) {\n        std::cout << \"WARNING: Unsafe lane change!\" << std::endl;\n    } else {\n        std::cout << \"Lane change is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float side_distance = 4.0F;\n    check_lane_change_safety(side_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that warns of excessive speed on sharp curves.",
      "input": "Follow MISRA guidelines and include comments on curve speed assessment.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MAX_CURVE_SPEED = 60.0F; // km/h\n\nvoid check_curve_speed(float speed) {\n    if (speed > MAX_CURVE_SPEED) {\n        std::cout << \"WARNING: Speed too high for curve!\" << std::endl;\n    } else {\n        std::cout << \"Curve speed is safe.\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 70.0F;\n    check_curve_speed(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system with speed-based dynamic following distance adjustments. The system should calculate a safe following distance based on current vehicle speed and provide warnings if the distance to the vehicle ahead falls below the threshold.",
      "input": "Ensure compliance with MISRA standards: include explicit type conversions, detailed comments for each operation, and avoid 'using namespace'.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float BASE_FOLLOWING_DISTANCE = 2.0F; // in seconds\nconst float SPEED_FACTOR = 0.02F; // Additional distance per km/h over 50\n\nvoid adjust_following_distance(float speed) {\n    float following_distance = BASE_FOLLOWING_DISTANCE + ((speed - 50.0F) * SPEED_FACTOR);\n    if (speed <= 50.0F) {\n        following_distance = BASE_FOLLOWING_DISTANCE;\n    }\n    std::cout << \"Recommended following distance: \" << following_distance << \" seconds\" << std::endl;\n}\n\nint main() {\n    float speed = 70.0F; // Vehicle speed in km/h\n    adjust_following_distance(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ code for a Forward Collision Warning system that adjusts stopping distances based on road conditions. Use a multiplier for wet road conditions to calculate increased stopping distances.",
      "input": "Ensure proper error handling, explicit variable initialization, and adherence to MISRA rules, including no implicit type conversions.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float WET_ROAD_MULTIPLIER = 1.5F; // Multiplier for wet road stopping distance\n\nvoid calculate_stopping_distance(float dry_distance) {\n    float wet_distance = dry_distance * WET_ROAD_MULTIPLIER;\n    std::cout << \"Wet road stopping distance: \" << wet_distance << \" meters\" << std::endl;\n\n    if (wet_distance > 50.0F) {\n        std::cout << \"WARNING: Increased collision risk on wet road!\" << std::endl;\n    }\n}\n\nint main() {\n    float dry_distance = 40.0F; // Dry stopping distance in meters\n    calculate_stopping_distance(dry_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Implement a Forward Collision Warning system in MISRA 2023-compliant C++ code. The system should analyze distances from multiple sensors and trigger a warning if the average distance falls below a safe threshold.",
      "input": "Follow MISRA C++ rules, include error handling, and avoid using dynamic memory allocation or 'using namespace'.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE = 10.0F; // Safe threshold in meters\n\nvoid check_sensor_data(const float* distances, size_t size) {\n    float sum = 0.0F;\n    for (size_t i = 0U; i < size; ++i) {\n        sum += distances[i];\n    }\n    float average_distance = sum / static_cast<float>(size);\n    std::cout << \"Average distance: \" << average_distance << \" meters\" << std::endl;\n\n    if (average_distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Collision imminent!\" << std::endl;\n    }\n}\n\nint main() {\n    const float sensor_distances[3] = {15.0F, 9.0F, 8.0F};\n    check_sensor_data(sensor_distances, 3U);\n    return 0;\n}"
    },
    {
      "instruction": "Develop a Forward Collision Warning system in MISRA 2023-compliant C++ code. The system should calculate deceleration requirements for safe stopping based on vehicle speed and distance to the obstacle.",
      "input": "Ensure adherence to MISRA rules, including initialization of all variables and avoiding global variables.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MAX_DECELERATION = 9.8F; // Maximum deceleration in m/s^2\n\nvoid calculate_deceleration(float speed, float distance) {\n    float deceleration = (speed * speed) / (2.0F * distance);\n    if (deceleration > MAX_DECELERATION) {\n        std::cout << \"WARNING: Unsafe stopping required!\" << std::endl;\n    } else {\n        std::cout << \"Deceleration required: \" << deceleration << \" m/s^2\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 20.0F; // Vehicle speed in m/s\n    float distance = 10.0F; // Distance to obstacle in meters\n    calculate_deceleration(speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant Forward Collision Warning system in C++ that identifies a risk of rear-end collision based on the relative speed of the vehicle ahead and the own vehicle.",
      "input": "Use explicit type conversions, avoid 'using namespace', and include inline documentation for each critical operation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RELATIVE_SPEED_THRESHOLD = 5.0F; // in m/s\nconst float TIME_TO_COLLISION_THRESHOLD = 3.0F; // in seconds\n\nvoid detect_collision_risk(float relative_speed, float distance) {\n    if (relative_speed > RELATIVE_SPEED_THRESHOLD) {\n        float time_to_collision = distance / relative_speed;\n        if (time_to_collision < TIME_TO_COLLISION_THRESHOLD) {\n            std::cout << \"WARNING: Rear-end collision risk detected!\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    float relative_speed = 8.0F; // Speed difference in m/s\n    float distance = 24.0F; // Distance to vehicle ahead in meters\n    detect_collision_risk(relative_speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ code for an FCW system that alerts the driver when the time-to-collision (TTC) is below a critical threshold. The system should compute TTC using relative speed and distance.",
      "input": "Ensure adherence to MISRA guidelines, use explicit type conversions, and include detailed inline comments.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float CRITICAL_TTC_THRESHOLD = 2.5F; // in seconds\n\nvoid calculate_ttc_and_warn(float relative_speed, float distance) {\n    if (relative_speed > 0.0F) {\n        float ttc = distance / relative_speed;\n        std::cout << \"Time-to-collision (TTC): \" << ttc << \" seconds\" << std::endl;\n\n        if (ttc < CRITICAL_TTC_THRESHOLD) {\n            std::cout << \"WARNING: Collision imminent!\" << std::endl;\n        }\n    } else {\n        std::cout << \"Relative speed is zero or negative; no collision risk.\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_speed = 10.0F; // Relative speed in m/s\n    float distance = 20.0F; // Distance to object in meters\n    calculate_ttc_and_warn(relative_speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ implementation of an FCW system that integrates a road gradient adjustment for stopping distance. The code must follow MISRA 2023 compliance.",
      "input": "Ensure proper handling of calculations involving road gradients and use clear, well-commented code.",
      "output": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n\nconst float GRAVITY = 9.81F; // Acceleration due to gravity in m/s^2\n\nvoid calculate_adjusted_stopping_distance(float speed, float distance, float gradient) {\n    float gradient_effect = GRAVITY * gradient / 100.0F;\n    float adjusted_distance = distance + gradient_effect;\n    std::cout << \"Adjusted stopping distance: \" << adjusted_distance << \" meters\" << std::endl;\n\n    if (adjusted_distance < 15.0F) {\n        std::cout << \"WARNING: High collision risk on gradient!\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 15.0F; // Speed in m/s\n    float distance = 30.0F; // Initial stopping distance in meters\n    float gradient = 5.0F; // Gradient in percentage\n    calculate_adjusted_stopping_distance(speed, distance, gradient);\n    return 0;\n}"
    },
    {
      "instruction": "Create a Forward Collision Warning system in MISRA 2023-compliant C++ that identifies the closest object among multiple detected objects and triggers an alert if necessary.",
      "input": "Ensure all operations are properly documented and comply with MISRA guidelines.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE_THRESHOLD = 12.0F; // in meters\n\nvoid find_closest_object_and_warn(const float* distances, size_t size) {\n    float closest_distance = distances[0];\n    for (size_t i = 1U; i < size; ++i) {\n        if (distances[i] < closest_distance) {\n            closest_distance = distances[i];\n        }\n    }\n    std::cout << \"Closest object distance: \" << closest_distance << \" meters\" << std::endl;\n\n    if (closest_distance < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    const float object_distances[5] = {20.0F, 18.0F, 15.0F, 10.0F, 25.0F};\n    find_closest_object_and_warn(object_distances, 5U);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses sensor fusion to average distances from multiple sensors before calculating the collision risk.",
      "input": "Use a modular design with clear function segregation and include proper comments for all key operations.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float WARNING_DISTANCE = 8.0F; // in meters\n\nfloat calculate_average_distance(const float* distances, size_t size) {\n    float total = 0.0F;\n    for (size_t i = 0U; i < size; ++i) {\n        total += distances[i];\n    }\n    return total / static_cast<float>(size);\n}\n\nvoid warn_if_risk(float average_distance) {\n    if (average_distance < WARNING_DISTANCE) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    const float sensor_data[3] = {10.0F, 7.0F, 9.0F};\n    float average_distance = calculate_average_distance(sensor_data, 3U);\n    std::cout << \"Average distance: \" << average_distance << \" meters\" << std::endl;\n    warn_if_risk(average_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate a MISRA 2023-compliant C++ code for a Forward Collision Warning system that triggers visual and auditory alerts when an obstacle is detected within a danger zone.",
      "input": "Ensure the use of explicit type conversions and provide clear comments for all operations.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DANGER_ZONE_DISTANCE = 5.0F; // in meters\n\nvoid trigger_alert(float distance) {\n    if (distance < DANGER_ZONE_DISTANCE) {\n        std::cout << \"WARNING: Obstacle detected within danger zone!\" << std::endl;\n        std::cout << \"Sounding alarm...\" << std::endl;\n    }\n}\n\nint main() {\n    float obstacle_distance = 4.0F; // Distance to detected obstacle in meters\n    std::cout << \"Obstacle distance: \" << obstacle_distance << \" meters\" << std::endl;\n    trigger_alert(obstacle_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that calculates deceleration required to avoid collision and alerts the driver if deceleration exceeds a safe threshold.",
      "input": "Implement error handling for edge cases such as zero or negative relative speed and provide detailed inline comments.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MAX_SAFE_DECELERATION = 7.0F; // Maximum safe deceleration in m/s^2\n\nvoid calculate_deceleration_and_warn(float relative_speed, float distance) {\n    if (relative_speed <= 0.0F || distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid speed or distance.\" << std::endl;\n        return;\n    }\n\n    float required_deceleration = (relative_speed * relative_speed) / (2.0F * distance);\n    std::cout << \"Required deceleration: \" << required_deceleration << \" m/s^2\" << std::endl;\n\n    if (required_deceleration > MAX_SAFE_DECELERATION) {\n        std::cout << \"WARNING: Unsafe deceleration required!\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_speed = 15.0F; // Relative speed in m/s\n    float distance = 10.0F; // Distance to object in meters\n    calculate_deceleration_and_warn(relative_speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that differentiates between stationary and moving objects and issues warnings based on their relative speeds.",
      "input": "Ensure modular design with separate functions for object classification and warning logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float WARNING_DISTANCE = 8.0F; // in meters\n\nvoid classify_object_and_warn(float distance, float relative_speed) {\n    if (relative_speed == 0.0F) {\n        std::cout << \"Stationary object detected at distance: \" << distance << \" meters\" << std::endl;\n    } else {\n        std::cout << \"Moving object detected at distance: \" << distance << \" meters\" << std::endl;\n    }\n\n    if (distance < WARNING_DISTANCE) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float distance = 7.0F; // Distance to object in meters\n    float relative_speed = 5.0F; // Relative speed in m/s\n    classify_object_and_warn(distance, relative_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop a MISRA 2023-compliant C++ program for an FCW system that adjusts the warning threshold dynamically based on vehicle speed.",
      "input": "Use appropriate data types for speed and distance calculations and ensure detailed comments for dynamic threshold logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nvoid warn_dynamic_threshold(float vehicle_speed, float distance) {\n    float dynamic_threshold = vehicle_speed / 10.0F + 5.0F;\n    std::cout << \"Dynamic collision warning threshold: \" << dynamic_threshold << \" meters\" << std::endl;\n\n    if (distance < dynamic_threshold) {\n        std::cout << \"WARNING: Collision imminent!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 30.0F; // Speed in m/s\n    float distance = 20.0F; // Distance to object in meters\n    warn_dynamic_threshold(vehicle_speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that calculates braking time required to avoid a collision and triggers a warning if time is insufficient.",
      "input": "Ensure safe handling of edge cases such as zero speed and divide-by-zero errors, with detailed inline comments.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nvoid calculate_braking_time_and_warn(float speed, float distance, float max_deceleration) {\n    if (max_deceleration <= 0.0F) {\n        std::cout << \"ERROR: Invalid deceleration value.\" << std::endl;\n        return;\n    }\n\n    float braking_time = speed / max_deceleration;\n    float required_distance = (speed * braking_time) / 2.0F;\n    std::cout << \"Required braking distance: \" << required_distance << \" meters\" << std::endl;\n\n    if (distance < required_distance) {\n        std::cout << \"WARNING: Insufficient distance to stop!\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 25.0F; // Speed in m/s\n    float distance = 15.0F; // Distance to object in meters\n    float max_deceleration = 7.0F; // Maximum deceleration in m/s^2\n    calculate_braking_time_and_warn(speed, distance, max_deceleration);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensor data to detect nearby objects and alert the driver.",
      "input": "Ensure detailed documentation for sensor data processing logic and MISRA-compliant error handling.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float ULTRASONIC_SENSOR_THRESHOLD = 4.0F; // in meters\n\nvoid process_ultrasonic_data(float distance) {\n    if (distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    if (distance < ULTRASONIC_SENSOR_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected within ultrasonic range!\" << std::endl;\n    }\n}\n\nint main() {\n    float sensor_distance = 3.0F; // Distance detected by the ultrasonic sensor\n    process_ultrasonic_data(sensor_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data to detect the relative speed of vehicles and trigger a warning if the relative speed exceeds a safe threshold.",
      "input": "Ensure handling of edge cases such as negative speed values and include detailed comments for radar data processing.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_SPEED_THRESHOLD = 10.0F; // in m/s\n\nvoid process_radar_data(float relative_speed) {\n    if (relative_speed < 0.0F) {\n        std::cout << \"ERROR: Invalid relative speed data.\" << std::endl;\n        return;\n    }\n\n    if (relative_speed > SAFE_SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Relative speed exceeds safe threshold!\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_speed = 12.0F; // Relative speed in m/s\n    process_radar_data(relative_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that predicts the time-to-collision (TTC) and triggers a warning if TTC is below a safe threshold.",
      "input": "Ensure explicit type conversions, error handling, and comments explaining the TTC calculation logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_TTC_THRESHOLD = 2.0F; // in seconds\n\nvoid calculate_ttc_and_warn(float relative_speed, float distance) {\n    if (relative_speed <= 0.0F || distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid relative speed or distance.\" << std::endl;\n        return;\n    }\n\n    float ttc = distance / relative_speed;\n    std::cout << \"Time to collision: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < SAFE_TTC_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk is high!\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_speed = 15.0F; // Relative speed in m/s\n    float distance = 30.0F; // Distance to object in meters\n    calculate_ttc_and_warn(relative_speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system that uses camera data to detect pedestrians and issue a collision warning if they are too close to the vehicle.",
      "input": "Use image processing techniques and ensure detailed comments for object detection and pedestrian classification.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <cstdlib>\n\nconst float PEDESTRIAN_THRESHOLD = 5.0F; // in meters\n\nvoid detect_pedestrian_and_warn(cv::Mat &image) {\n    // Assume pedestrian detection logic is implemented here\n    float distance_to_pedestrian = 3.0F; // Example distance in meters\n\n    std::cout << \"Detected pedestrian at distance: \" << distance_to_pedestrian << \" meters\" << std::endl;\n\n    if (distance_to_pedestrian < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected too close!\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat image;\n    detect_pedestrian_and_warn(image);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses LiDAR data to estimate the distance to obstacles and triggers a warning if the distance is below a specified threshold.",
      "input": "Ensure handling of sensor noise and include comments explaining the LiDAR data filtering process.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float LIDAR_THRESHOLD = 6.0F; // in meters\n\nvoid process_lidar_data(float distance) {\n    if (distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid LiDAR data.\" << std::endl;\n        return;\n    }\n\n    if (distance < LIDAR_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected within LiDAR range!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 4.5F; // Distance detected by LiDAR sensor\n    process_lidar_data(lidar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that calculates the closing rate of an approaching vehicle and issues a warning if the closing rate exceeds a safe threshold.",
      "input": "Use explicit type conversions and ensure that all edge cases are handled correctly, with appropriate error messages.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_CLOSING_RATE = 5.0F; // in m/s\n\nvoid calculate_closing_rate_and_warn(float relative_speed, float distance) {\n    if (relative_speed <= 0.0F || distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid relative speed or distance.\" << std::endl;\n        return;\n    }\n\n    float closing_rate = relative_speed / distance;\n    std::cout << \"Closing rate: \" << closing_rate << \" m/s\" << std::endl;\n\n    if (closing_rate > SAFE_CLOSING_RATE) {\n        std::cout << \"WARNING: High closing rate!\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_speed = 20.0F; // Relative speed in m/s\n    float distance = 50.0F; // Distance to object in meters\n    calculate_closing_rate_and_warn(relative_speed, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that processes multi-object detection and warns if any object is too close to the vehicle.",
      "input": "Implement a modular design with separate functions for detecting objects, calculating distances, and triggering warnings.",
      "output": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nconst float WARNING_THRESHOLD = 5.0F; // in meters\n\nvoid detect_objects_and_warn(std::vector<float> distances) {\n    for (float distance : distances) {\n        std::cout << \"Detected object at distance: \" << distance << \" meters\" << std::endl;\n        if (distance < WARNING_THRESHOLD) {\n            std::cout << \"WARNING: Object too close!\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    std::vector<float> distances = {10.0F, 4.0F, 3.0F}; // Distances to objects in meters\n    detect_objects_and_warn(distances);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses GPS data to estimate the speed of the vehicle and issue a warning if the speed exceeds a predefined limit.",
      "input": "Ensure safe handling of GPS data and include comments explaining how speed is derived from GPS coordinates.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_LIMIT = 30.0F; // Speed limit in m/s\n\nvoid process_gps_data(float speed) {\n    if (speed < 0.0F) {\n        std::cout << \"ERROR: Invalid GPS data.\" << std::endl;\n        return;\n    }\n\n    if (speed > SPEED_LIMIT) {\n        std::cout << \"WARNING: Speed exceeds limit!\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 35.0F; // Speed in m/s\n    process_gps_data(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses a combination of radar and camera data to calculate the collision risk and triggers a warning when the risk is high.",
      "input": "Ensure error-free integration of sensor data, and detailed comments for combining radar and camera inputs.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RADAR_THRESHOLD = 8.0F; // Radar threshold in meters\nconst float CAMERA_THRESHOLD = 6.0F; // Camera threshold in meters\n\nvoid calculate_collision_risk_and_warn(float radar_distance, float camera_distance) {\n    if (radar_distance < 0.0F || camera_distance < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    if (radar_distance < RADAR_THRESHOLD && camera_distance < CAMERA_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.0F; // Distance detected by radar sensor\n    float camera_distance = 5.0F; // Distance detected by camera sensor\n    calculate_collision_risk_and_warn(radar_distance, camera_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses accelerometer data to detect rapid deceleration and triggers a warning if deceleration exceeds a safe threshold.",
      "input": "Ensure proper scaling and filtering of accelerometer data, and provide a robust error-handling mechanism.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DECELERATION_THRESHOLD = 5.0F; // in m/s^2\n\nvoid process_acceleration_data(float deceleration) {\n    if (deceleration < 0.0F) {\n        std::cout << \"ERROR: Invalid deceleration data.\" << std::endl;\n        return;\n    }\n\n    if (deceleration > DECELERATION_THRESHOLD) {\n        std::cout << \"WARNING: Rapid deceleration detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float deceleration = 6.0F; // Deceleration in m/s^2\n    process_acceleration_data(deceleration);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensor data to detect objects in the vehicle\u2019s path and triggers a warning if an object is too close.",
      "input": "Implement sensor filtering and error handling for ultrasonic data, and ensure clear documentation for sensor integration.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float ULTRASONIC_THRESHOLD = 2.0F; // in meters\n\nvoid process_ultrasonic_data(float distance) {\n    if (distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid ultrasonic data.\" << std::endl;\n        return;\n    }\n\n    if (distance < ULTRASONIC_THRESHOLD) {\n        std::cout << \"WARNING: Object detected too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_distance = 1.5F; // Distance detected by ultrasonic sensor\n    process_ultrasonic_data(ultrasonic_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that estimates the vehicle's braking distance and triggers a warning if the vehicle cannot stop in time.",
      "input": "Ensure correct handling of different speed and road conditions, and include detailed comments explaining braking distance calculation.",
      "output": "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float SAFE_BRAKING_DISTANCE = 20.0F; // in meters\n\nfloat calculate_braking_distance(float speed) {\n    return (speed * speed) / (2.0F * 7.0F); // Simplified braking distance formula\n}\n\nvoid check_braking_distance_and_warn(float speed) {\n    if (speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid speed data.\" << std::endl;\n        return;\n    }\n\n    float braking_distance = calculate_braking_distance(speed);\n    std::cout << \"Calculated braking distance: \" << braking_distance << \" meters\" << std::endl;\n\n    if (braking_distance > SAFE_BRAKING_DISTANCE) {\n        std::cout << \"WARNING: Braking distance exceeds safe limit!\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 30.0F; // Speed in m/s\n    check_braking_distance_and_warn(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that integrates GPS, radar, and camera data to calculate the risk of collision and issue a warning if necessary.",
      "input": "Ensure synchronization of sensor data and provide detailed comments for each sensor type and how they contribute to collision risk estimation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_THRESHOLD = 5.0F; // Collision risk threshold in meters\n\nvoid integrate_sensors_and_warn(float radar_distance, float camera_distance, float gps_speed) {\n    if (radar_distance < 0.0F || camera_distance < 0.0F || gps_speed < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float risk = (radar_distance + camera_distance) / gps_speed;\n    std::cout << \"Collision risk: \" << risk << std::endl;\n\n    if (risk > COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 4.0F; // Distance detected by radar sensor\n    float camera_distance = 6.0F; // Distance detected by camera sensor\n    float gps_speed = 15.0F; // Speed from GPS in m/s\n    integrate_sensors_and_warn(radar_distance, camera_distance, gps_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses a combination of radar and lidar data to calculate the distance to an object and triggers a warning if the distance is too short.",
      "input": "Ensure data integrity checks for lidar and radar data, and ensure modularity of the distance calculation and warning logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DISTANCE_THRESHOLD = 3.0F; // in meters\n\nvoid process_radar_lidar_data(float radar_distance, float lidar_distance) {\n    if (radar_distance < 0.0F || lidar_distance < 0.0F) {\n        std::cout << \"ERROR: Invalid radar or lidar data.\" << std::endl;\n        return;\n    }\n\n    float min_distance = (radar_distance < lidar_distance) ? radar_distance : lidar_distance;\n    std::cout << \"Detected object at distance: \" << min_distance << \" meters\" << std::endl;\n\n    if (min_distance < DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Object too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 5.0F; // Distance detected by radar\n    float lidar_distance = 4.0F; // Distance detected by lidar\n    process_radar_lidar_data(radar_distance, lidar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that predicts the collision time based on relative velocity and distance and triggers a warning if the collision time is too short.",
      "input": "Implement checks for valid data and include comments explaining the logic behind collision time prediction.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MIN_COLLISION_TIME = 2.0F; // in seconds\n\nvoid predict_collision_time_and_warn(float relative_velocity, float distance) {\n    if (relative_velocity <= 0.0F || distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid relative velocity or distance.\" << std::endl;\n        return;\n    }\n\n    float collision_time = distance / relative_velocity;\n    std::cout << \"Predicted collision time: \" << collision_time << \" seconds\" << std::endl;\n\n    if (collision_time < MIN_COLLISION_TIME) {\n        std::cout << \"WARNING: Collision imminent!\" << std::endl;\n    }\n}\n\nint main() {\n    float relative_velocity = 10.0F; // Relative velocity in m/s\n    float distance = 50.0F; // Distance to object in meters\n    predict_collision_time_and_warn(relative_velocity, distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that combines radar, GPS, and accelerometer data to estimate the risk of a collision and trigger a warning if the risk exceeds a threshold.",
      "input": "Ensure proper error handling and comments explaining the combination of sensor data for collision risk estimation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 0.8F; // Collision risk threshold\n\nvoid estimate_collision_risk_and_warn(float radar_data, float gps_speed, float accel_data) {\n    if (radar_data < 0.0F || gps_speed < 0.0F || accel_data < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float risk = (radar_data * gps_speed) / accel_data;\n    std::cout << \"Estimated collision risk: \" << risk << std::endl;\n\n    if (risk > COLLISION_RISK_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_data = 10.0F; // Radar data in meters\n    float gps_speed = 25.0F; // Speed from GPS in m/s\n    float accel_data = 3.0F; // Acceleration in m/s^2\n    estimate_collision_risk_and_warn(radar_data, gps_speed, accel_data);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses camera data to detect road signs and triggers a warning if the vehicle is approaching a stop sign.",
      "input": "Implement image recognition algorithms and ensure clear separation of sensor data handling and warning logic.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOP_SIGN_THRESHOLD = 10.0F; // Distance to stop sign\n\nvoid detect_stop_sign_and_warn(float camera_distance) {\n    if (camera_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid camera data.\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Detected camera distance to stop sign: \" << camera_distance << \" meters\" << std::endl;\n\n    if (camera_distance < STOP_SIGN_THRESHOLD) {\n        std::cout << \"WARNING: Approaching stop sign!\" << std::endl;\n    }\n}\n\nint main() {\n    float camera_distance = 8.0F; // Camera detected distance to stop sign\n    detect_stop_sign_and_warn(camera_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and camera data to detect pedestrians in the vehicle's path and issues a warning if a pedestrian is too close.",
      "input": "Ensure sensor data validation and efficient collision risk calculation based on the distance of the pedestrian.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float PEDESTRIAN_THRESHOLD = 1.5F; // in meters\n\nvoid detect_pedestrian_and_warn(float radar_distance, float camera_distance) {\n    if (radar_distance <= 0.0F || camera_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float min_distance = (radar_distance < camera_distance) ? radar_distance : camera_distance;\n    std::cout << \"Detected pedestrian at distance: \" << min_distance << \" meters\" << std::endl;\n\n    if (min_distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.0F; // Distance detected by radar sensor\n    float camera_distance = 1.2F; // Distance detected by camera sensor\n    detect_pedestrian_and_warn(radar_distance, camera_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a radar sensor to detect an approaching vehicle and triggers a warning when the distance becomes too small.",
      "input": "Include range data validation and checks for valid radar sensor output.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE = 10.0F; // in meters\n\nvoid detect_approaching_vehicle(float radar_distance) {\n    if (radar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar distance.\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Approaching vehicle detected at: \" << radar_distance << \" meters\" << std::endl;\n\n    if (radar_distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Too close to approaching vehicle!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F; // Radar distance to approaching vehicle\n    detect_approaching_vehicle(radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses lidar data to detect obstacles and triggers a warning when an obstacle is detected within a critical distance.",
      "input": "Ensure lidar data handling is safe and include logic to ensure that the threshold distance is not violated.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float CRITICAL_DISTANCE = 5.0F; // in meters\n\nvoid detect_obstacle_and_warn(float lidar_distance) {\n    if (lidar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid lidar distance.\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Obstacle detected at: \" << lidar_distance << \" meters\" << std::endl;\n\n    if (lidar_distance < CRITICAL_DISTANCE) {\n        std::cout << \"WARNING: Obstacle too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 4.0F; // Lidar detected distance to obstacle\n    detect_obstacle_and_warn(lidar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that combines radar and camera data to calculate the time-to-collision and trigger a warning if the time is too short.",
      "input": "Validate the radar and camera data, and ensure that time-to-collision is calculated accurately.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TIME_TO_COLLISION_THRESHOLD = 1.5F; // in seconds\n\nvoid calculate_time_to_collision_and_warn(float radar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar distance or relative velocity.\" << std::endl;\n        return;\n    }\n\n    float time_to_collision = radar_distance / relative_velocity;\n    std::cout << \"Time to collision: \" << time_to_collision << \" seconds\" << std::endl;\n\n    if (time_to_collision < TIME_TO_COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision imminent!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 10.0F; // Radar distance to object\n    float relative_velocity = 12.0F; // Relative velocity in m/s\n    calculate_time_to_collision_and_warn(radar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that detects pedestrians using a camera sensor and triggers a warning if a pedestrian is too close to the vehicle.",
      "input": "Ensure safe processing of image data from the camera sensor and check for proximity to pedestrians.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float PEDESTRIAN_SAFE_DISTANCE = 2.0F; // in meters\n\nvoid detect_pedestrian_and_warn(float camera_distance) {\n    if (camera_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid camera data.\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Pedestrian detected at: \" << camera_distance << \" meters\" << std::endl;\n\n    if (camera_distance < PEDESTRIAN_SAFE_DISTANCE) {\n        std::cout << \"WARNING: Pedestrian too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float camera_distance = 1.5F; // Camera detected distance to pedestrian\n    detect_pedestrian_and_warn(camera_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a combination of radar and GPS data to assess collision risk and trigger a warning if the risk exceeds a threshold.",
      "input": "Ensure correct synchronization between radar and GPS data and provide a valid risk calculation methodology.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 0.75F; // Risk threshold\n\nvoid assess_collision_risk_and_warn(float radar_distance, float gps_speed) {\n    if (radar_distance <= 0.0F || gps_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or GPS data.\" << std::endl;\n        return;\n    }\n\n    float collision_risk = (radar_distance / gps_speed) * 100.0F;\n    std::cout << \"Calculated collision risk: \" << collision_risk << std::endl;\n\n    if (collision_risk > COLLISION_RISK_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 10.0F; // Radar detected distance\n    float gps_speed = 15.0F; // Speed from GPS\n    assess_collision_risk_and_warn(radar_distance, gps_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that estimates the braking distance based on the vehicle's speed and road conditions, and triggers a warning if the vehicle cannot stop in time.",
      "input": "Ensure that road conditions are taken into account in braking distance estimation and provide detailed code comments.",
      "output": "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float SAFE_BRAKING_DISTANCE = 20.0F; // meters\nconst float ROAD_FRICTION_FACTOR = 0.7F; // Example road friction factor\n\nfloat estimate_braking_distance(float speed) {\n    return (speed * speed) / (2.0F * 9.81F * ROAD_FRICTION_FACTOR);\n}\n\nvoid check_braking_and_warn(float speed) {\n    if (speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid speed data.\" << std::endl;\n        return;\n    }\n\n    float braking_distance = estimate_braking_distance(speed);\n    std::cout << \"Estimated braking distance: \" << braking_distance << \" meters\" << std::endl;\n\n    if (braking_distance > SAFE_BRAKING_DISTANCE) {\n        std::cout << \"WARNING: Braking distance exceeds safe limit!\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 30.0F; // Speed in m/s\n    check_braking_and_warn(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses GPS and radar data to calculate the relative velocity between the vehicle and an obstacle and triggers a warning if the relative velocity is too high.",
      "input": "Ensure accurate calculation of relative velocity and handle potential sensor data errors.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float VELOCITY_THRESHOLD = 30.0F; // in m/s\n\nvoid calculate_relative_velocity_and_warn(float vehicle_speed, float obstacle_speed) {\n    if (vehicle_speed < 0.0F || obstacle_speed < 0.0F) {\n        std::cout << \"ERROR: Invalid speed data.\" << std::endl;\n        return;\n    }\n\n    float relative_velocity = vehicle_speed - obstacle_speed;\n    std::cout << \"Relative velocity: \" << relative_velocity << \" m/s\" << std::endl;\n\n    if (relative_velocity > VELOCITY_THRESHOLD) {\n        std::cout << \"WARNING: High relative velocity!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 50.0F; // Vehicle speed\n    float obstacle_speed = 20.0F; // Obstacle speed\n    calculate_relative_velocity_and_warn(vehicle_speed, obstacle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a combination of radar, lidar, and GPS data to assess whether the vehicle will collide with an obstacle and triggers a warning if necessary.",
      "input": "Handle multi-sensor data fusion and ensure the correct logic for determining collision risk.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 10.0F; // in meters\n\nvoid assess_collision_risk_and_warn(float radar_distance, float lidar_distance, float gps_speed) {\n    if (radar_distance <= 0.0F || lidar_distance <= 0.0F || gps_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float min_distance = (radar_distance < lidar_distance) ? radar_distance : lidar_distance;\n    std::cout << \"Minimum detected distance: \" << min_distance << \" meters\" << std::endl;\n\n    if (min_distance < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F; // Radar detected distance\n    float lidar_distance = 9.0F; // Lidar detected distance\n    float gps_speed = 15.0F; // Speed from GPS\n    assess_collision_risk_and_warn(radar_distance, lidar_distance, gps_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a radar sensor to detect an approaching vehicle and calculates the relative speed. Trigger a warning if the relative speed exceeds a threshold.",
      "input": "Include velocity and distance checks to ensure valid sensor readings.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_THRESHOLD = 20.0F; // in m/s\n\nvoid detect_approaching_vehicle_and_warn(float radar_distance, float vehicle_speed, float relative_speed) {\n    if (radar_distance <= 0.0F || vehicle_speed < 0.0F || relative_speed < 0.0F) {\n        std::cout << \"ERROR: Invalid radar distance or vehicle speed.\" << std::endl;\n        return;\n    }\n\n    float approach_speed = relative_speed - vehicle_speed;\n    std::cout << \"Relative speed of approaching vehicle: \" << approach_speed << \" m/s\" << std::endl;\n\n    if (approach_speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: High relative speed!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 15.0F; // Radar distance to vehicle\n    float vehicle_speed = 10.0F; // Current vehicle speed\n    float relative_speed = 25.0F; // Relative speed of approaching vehicle\n    detect_approaching_vehicle_and_warn(radar_distance, vehicle_speed, relative_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses lidar data to detect obstacles ahead and triggers a warning when the detected obstacle is within a predefined safe distance.",
      "input": "Ensure the lidar distance readings are within the expected range and check for potential sensor failures.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE = 7.0F; // in meters\n\nvoid detect_obstacle_with_lidar_and_warn(float lidar_distance) {\n    if (lidar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid lidar data.\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Obstacle detected at: \" << lidar_distance << \" meters\" << std::endl;\n\n    if (lidar_distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Obstacle too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 5.0F; // Lidar detected distance to obstacle\n    detect_obstacle_with_lidar_and_warn(lidar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that calculates the time-to-collision using radar data and triggers a warning if the calculated time is below a critical threshold.",
      "input": "Ensure that the radar data is valid and check for negative or zero values in the time-to-collision calculation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_TIME_THRESHOLD = 2.0F; // in seconds\n\nvoid calculate_time_to_collision_and_warn(float radar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar data.\" << std::endl;\n        return;\n    }\n\n    float time_to_collision = radar_distance / relative_velocity;\n    std::cout << \"Calculated time to collision: \" << time_to_collision << \" seconds\" << std::endl;\n\n    if (time_to_collision < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision imminent!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 20.0F; // Radar distance to object\n    float relative_velocity = 10.0F; // Relative velocity in m/s\n    calculate_time_to_collision_and_warn(radar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that integrates radar and camera sensor data to assess the risk of a collision and trigger a warning if the risk is above a predefined threshold.",
      "input": "Ensure sensor data is synchronized and properly validated before use in the collision risk calculation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 0.8F; // Risk threshold\n\nvoid assess_collision_risk_and_warn(float radar_distance, float camera_confidence, float object_velocity) {\n    if (radar_distance <= 0.0F || camera_confidence < 0.0F || object_velocity < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float collision_risk = (radar_distance / object_velocity) * camera_confidence;\n    std::cout << \"Calculated collision risk: \" << collision_risk << std::endl;\n\n    if (collision_risk > COLLISION_RISK_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 15.0F; // Radar distance to object\n    float camera_confidence = 0.9F; // Confidence level from camera\n    float object_velocity = 12.0F; // Object velocity\n    assess_collision_risk_and_warn(radar_distance, camera_confidence, object_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses lidar and radar data to predict the potential for collision and triggers a warning if the vehicle's speed exceeds a critical threshold for stopping distance.",
      "input": "Ensure the correct calculation of stopping distance and handling of invalid data from the sensors.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOPPING_DISTANCE_THRESHOLD = 30.0F; // in meters\n\nfloat calculate_stopping_distance(float speed, float friction_coefficient) {\n    return (speed * speed) / (2.0F * 9.81F * friction_coefficient);\n}\n\nvoid predict_collision_and_warn(float vehicle_speed, float lidar_distance, float radar_distance) {\n    if (vehicle_speed <= 0.0F || lidar_distance <= 0.0F || radar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed, 0.8F);\n    std::cout << \"Calculated stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > STOPPING_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Stopping distance exceeds threshold!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 25.0F; // Vehicle speed in m/s\n    float lidar_distance = 20.0F; // Lidar distance to obstacle\n    float radar_distance = 18.0F; // Radar distance to obstacle\n    predict_collision_and_warn(vehicle_speed, lidar_distance, radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and GPS data to calculate the relative position of an obstacle and triggers a warning if the vehicle is on a collision path.",
      "input": "Ensure the correct validation and synchronization of radar and GPS data.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_THRESHOLD = 5.0F; // in meters\n\nvoid calculate_relative_position_and_warn(float radar_distance, float gps_position, float obstacle_velocity) {\n    if (radar_distance <= 0.0F || gps_position <= 0.0F || obstacle_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float relative_position = gps_position - radar_distance;\n    std::cout << \"Calculated relative position: \" << relative_position << \" meters\" << std::endl;\n\n    if (relative_position < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision path detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 10.0F; // Radar distance to obstacle\n    float gps_position = 12.0F; // Vehicle GPS position\n    float obstacle_velocity = 15.0F; // Obstacle velocity\n    calculate_relative_position_and_warn(radar_distance, gps_position, obstacle_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses camera and radar data to assess whether the vehicle will collide with an obstacle and triggers a warning if the collision risk exceeds a predefined threshold.",
      "input": "Ensure both camera and radar data are valid before the collision risk assessment.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 0.7F; // Risk threshold\n\nvoid assess_collision_risk_and_warn(float radar_distance, float camera_confidence) {\n    if (radar_distance <= 0.0F || camera_confidence < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float collision_risk = radar_distance * camera_confidence;\n    std::cout << \"Calculated collision risk: \" << collision_risk << std::endl;\n\n    if (collision_risk > COLLISION_RISK_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 15.0F; // Radar distance to obstacle\n    float camera_confidence = 0.85F; // Camera confidence level\n    assess_collision_risk_and_warn(radar_distance, camera_confidence);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to detect an obstacle in the path of the vehicle and triggers a warning if the obstacle is too close.",
      "input": "Ensure data is valid and distance to obstacle is below a safe threshold.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_DISTANCE_THRESHOLD = 5.0F; // in meters\n\nvoid detect_obstacle_and_warn(float radar_distance, float lidar_distance) {\n    if (radar_distance <= 0.0F || lidar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float closest_obstacle = (radar_distance < lidar_distance) ? radar_distance : lidar_distance;\n    std::cout << \"Closest obstacle distance: \" << closest_obstacle << \" meters\" << std::endl;\n\n    if (closest_obstacle < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 3.0F; // Radar distance to obstacle\n    float lidar_distance = 4.0F; // Lidar distance to obstacle\n    detect_obstacle_and_warn(radar_distance, lidar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses lidar data to detect obstacles and checks whether the vehicle can safely stop in time.",
      "input": "Validate lidar data and calculate stopping distance based on vehicle speed.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOPPING_DISTANCE_THRESHOLD = 25.0F; // in meters\n\nfloat calculate_stopping_distance(float vehicle_speed) {\n    return (vehicle_speed * vehicle_speed) / (2.0F * 9.81F); // Basic stopping distance formula\n}\n\nvoid check_safety_and_warn(float vehicle_speed, float lidar_distance) {\n    if (vehicle_speed <= 0.0F || lidar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n    std::cout << \"Calculated stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > lidar_distance) {\n        std::cout << \"WARNING: Not enough distance to stop safely!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F; // Vehicle speed in m/s\n    float lidar_distance = 18.0F; // Lidar distance to obstacle\n    check_safety_and_warn(vehicle_speed, lidar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and camera data to estimate the time-to-collision (TTC) and triggers a warning if the TTC is below a critical threshold.",
      "input": "Ensure proper validation of sensor data and prevent division by zero when calculating TTC.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_THRESHOLD = 3.0F; // in seconds\n\nvoid calculate_time_to_collision_and_warn(float radar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or velocity data.\" << std::endl;\n        return;\n    }\n\n    float time_to_collision = radar_distance / relative_velocity;\n    std::cout << \"Calculated time to collision: \" << time_to_collision << \" seconds\" << std::endl;\n\n    if (time_to_collision < TTC_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 50.0F; // Radar distance to object\n    float relative_velocity = 15.0F; // Relative velocity in m/s\n    calculate_time_to_collision_and_warn(radar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses lidar and radar data to calculate the relative speed of an approaching vehicle and triggers a warning if the relative speed exceeds a safe threshold.",
      "input": "Ensure that radar and lidar data are synchronized and handled correctly in the speed calculation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_THRESHOLD = 20.0F; // in m/s\n\nvoid calculate_relative_speed_and_warn(float lidar_distance, float radar_distance, float vehicle_speed) {\n    if (lidar_distance <= 0.0F || radar_distance <= 0.0F || vehicle_speed < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float relative_speed = (lidar_distance + radar_distance) / 2.0F - vehicle_speed;\n    std::cout << \"Calculated relative speed: \" << relative_speed << \" m/s\" << std::endl;\n\n    if (relative_speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: High relative speed!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 10.0F; // Lidar distance to vehicle\n    float radar_distance = 12.0F; // Radar distance to vehicle\n    float vehicle_speed = 15.0F; // Current vehicle speed\n    calculate_relative_speed_and_warn(lidar_distance, radar_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses lidar and radar sensor data to detect an object in the path of the vehicle and triggers a warning if the object is within a dangerous distance.",
      "input": "Validate lidar and radar data before calculating the object's distance to the vehicle.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DANGER_DISTANCE_THRESHOLD = 5.0F; // in meters\n\nvoid detect_obstacle_and_warn(float lidar_distance, float radar_distance) {\n    if (lidar_distance <= 0.0F || radar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float closest_distance = (lidar_distance < radar_distance) ? lidar_distance : radar_distance;\n    std::cout << \"Closest obstacle detected at: \" << closest_distance << \" meters\" << std::endl;\n\n    if (closest_distance < DANGER_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Object too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 3.0F; // Lidar distance to object\n    float radar_distance = 4.0F; // Radar distance to object\n    detect_obstacle_and_warn(lidar_distance, radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that integrates radar and GPS data to calculate the relative position of an obstacle and triggers a warning if the obstacle is too close to the vehicle.",
      "input": "Ensure correct handling of sensor synchronization and distance calculations.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float CLOSE_OBSTACLE_THRESHOLD = 10.0F; // in meters\n\nvoid calculate_relative_position_and_warn(float radar_distance, float gps_position, float obstacle_velocity) {\n    if (radar_distance <= 0.0F || gps_position <= 0.0F || obstacle_velocity < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float relative_position = gps_position - radar_distance;\n    std::cout << \"Relative position to obstacle: \" << relative_position << \" meters\" << std::endl;\n\n    if (relative_position < CLOSE_OBSTACLE_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle is too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F; // Radar distance to obstacle\n    float gps_position = 15.0F; // Vehicle GPS position\n    float obstacle_velocity = 8.0F; // Obstacle velocity\n    calculate_relative_position_and_warn(radar_distance, gps_position, obstacle_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data to calculate the time-to-collision (TTC) with an object and triggers a warning if the TTC is less than the safe time threshold.",
      "input": "Ensure the radar data is valid and handle edge cases where the relative velocity is too small.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_SAFE_THRESHOLD = 5.0F; // in seconds\n\nvoid calculate_ttc_and_warn(float radar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or velocity data.\" << std::endl;\n        return;\n    }\n\n    float ttc = radar_distance / relative_velocity;\n    std::cout << \"Calculated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < TTC_SAFE_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 50.0F; // Radar distance to object\n    float relative_velocity = 10.0F; // Relative velocity in m/s\n    calculate_ttc_and_warn(radar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses lidar and radar data to detect obstacles and determine if the vehicle will collide with the obstacle within the next 3 seconds.",
      "input": "Ensure data is synchronized and handle potential sensor errors.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_TIME_THRESHOLD = 3.0F; // in seconds\n\nvoid check_collision_risk_and_warn(float lidar_distance, float radar_distance, float vehicle_speed) {\n    if (lidar_distance <= 0.0F || radar_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float time_to_collision = (lidar_distance + radar_distance) / (2.0F * vehicle_speed);\n    std::cout << \"Time to collision: \" << time_to_collision << \" seconds\" << std::endl;\n\n    if (time_to_collision < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 15.0F; // Lidar distance to object\n    float radar_distance = 18.0F; // Radar distance to object\n    float vehicle_speed = 10.0F; // Vehicle speed in m/s\n    check_collision_risk_and_warn(lidar_distance, radar_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses radar and GPS data to estimate the distance and velocity of an approaching vehicle and triggers a warning if the relative velocity exceeds a safe threshold.",
      "input": "Ensure correct handling of GPS data and sensor synchronization.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float VELOCITY_THRESHOLD = 30.0F; // in m/s\n\nvoid estimate_relative_velocity_and_warn(float radar_distance, float gps_position, float radar_velocity) {\n    if (radar_distance <= 0.0F || gps_position <= 0.0F || radar_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float relative_velocity = (gps_position - radar_distance) * radar_velocity;\n    std::cout << \"Relative velocity: \" << relative_velocity << \" m/s\" << std::endl;\n\n    if (relative_velocity > VELOCITY_THRESHOLD) {\n        std::cout << \"WARNING: High relative velocity!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 20.0F; // Radar distance to object\n    float gps_position = 30.0F; // GPS position of the vehicle\n    float radar_velocity = 12.0F; // Velocity measured by radar\n    estimate_relative_velocity_and_warn(radar_distance, gps_position, radar_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses lidar and radar data to detect obstacles and calculate the required stopping distance for the vehicle.",
      "input": "Validate both lidar and radar data and handle potential errors in distance calculations.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOPPING_DISTANCE_THRESHOLD = 15.0F; // in meters\n\nfloat calculate_stopping_distance(float speed) {\n    return (speed * speed) / (2.0F * 9.81F); // Basic stopping distance formula\n}\n\nvoid check_stopping_distance_and_warn(float speed, float lidar_distance, float radar_distance) {\n    if (lidar_distance <= 0.0F || radar_distance <= 0.0F || speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(speed);\n    std::cout << \"Stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > lidar_distance || stopping_distance > radar_distance) {\n        std::cout << \"WARNING: Not enough distance to stop!\" << std::endl;\n    }\n}\n\nint main() {\n    float speed = 15.0F; // Vehicle speed in m/s\n    float lidar_distance = 25.0F; // Lidar distance to obstacle\n    float radar_distance = 30.0F; // Radar distance to obstacle\n    check_stopping_distance_and_warn(speed, lidar_distance, radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data to detect objects in the vehicle's path and triggers a warning if the vehicle is approaching an obstacle too quickly.",
      "input": "Ensure that radar data is valid before calculating the risk of collision.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 10.0F; // in meters/second\n\nvoid check_collision_risk_and_warn(float radar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float collision_risk = radar_distance * relative_velocity;\n    std::cout << \"Calculated collision risk: \" << collision_risk << \" m/s\" << std::endl;\n\n    if (collision_risk > COLLISION_RISK_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 5.0F; // Radar distance to obstacle\n    float relative_velocity = 3.0F; // Relative velocity in m/s\n    check_collision_risk_and_warn(radar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that integrates radar and camera data to detect sudden deceleration in the leading vehicle and triggers a warning if the relative velocity becomes dangerously high.",
      "input": "Ensure that both radar and camera data are properly synchronized and validated.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float VELOCITY_CHANGE_THRESHOLD = 5.0F; // in m/s\n\nvoid detect_sudden_deceleration_and_warn(float radar_velocity, float camera_velocity_change) {\n    if (radar_velocity <= 0.0F || camera_velocity_change < 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    if (camera_velocity_change > VELOCITY_CHANGE_THRESHOLD) {\n        std::cout << \"WARNING: Sudden deceleration detected in the leading vehicle!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_velocity = 15.0F; // Radar velocity of the leading vehicle\n    float camera_velocity_change = 6.0F; // Detected velocity change via camera\n    detect_sudden_deceleration_and_warn(radar_velocity, camera_velocity_change);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to predict an imminent collision based on vehicle speed and obstacle distance, triggering a warning if the time to collision (TTC) is below the safety threshold.",
      "input": "Ensure proper validation of radar and lidar data before calculating TTC.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_SAFE_THRESHOLD = 2.0F; // in seconds\n\nvoid calculate_ttc_and_warn(float radar_distance, float lidar_distance, float vehicle_speed) {\n    if (radar_distance <= 0.0F || lidar_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float ttc = (radar_distance + lidar_distance) / (2.0F * vehicle_speed);\n    std::cout << \"Calculated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < TTC_SAFE_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 30.0F; // Radar distance to obstacle\n    float lidar_distance = 20.0F; // Lidar distance to obstacle\n    float vehicle_speed = 25.0F; // Vehicle speed in m/s\n    calculate_ttc_and_warn(radar_distance, lidar_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that calculates the time to collision (TTC) based on radar data and triggers a warning if the TTC is below a configurable threshold.",
      "input": "Ensure that radar data is checked for invalid values before calculating TTC.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_THRESHOLD = 1.5F; // in seconds\n\nvoid calculate_ttc_and_warn(float radar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or velocity data.\" << std::endl;\n        return;\n    }\n\n    float ttc = radar_distance / relative_velocity;\n    std::cout << \"Calculated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < TTC_THRESHOLD) {\n        std::cout << \"WARNING: Risk of collision detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 50.0F; // Radar distance to object\n    float relative_velocity = 10.0F; // Relative velocity in m/s\n    calculate_ttc_and_warn(radar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to detect the presence of an obstacle and trigger a warning if the vehicle is closing in on the obstacle too quickly.",
      "input": "Ensure the radar and lidar data are synchronized for accurate detection.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float OBSTACLE_THRESHOLD = 5.0F; // in meters\n\nvoid detect_obstacle_and_warn(float radar_distance, float lidar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || lidar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float closest_distance = (radar_distance < lidar_distance) ? radar_distance : lidar_distance;\n    std::cout << \"Closest obstacle detected at: \" << closest_distance << \" meters\" << std::endl;\n\n    if (closest_distance < OBSTACLE_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected too close!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 10.0F; // Radar distance to object\n    float lidar_distance = 12.0F; // Lidar distance to object\n    float relative_velocity = 5.0F; // Relative velocity in m/s\n    detect_obstacle_and_warn(radar_distance, lidar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that calculates the stopping distance based on vehicle speed and triggers a warning if the distance to an obstacle is less than the required stopping distance.",
      "input": "Ensure vehicle speed and distance data are valid before calculating stopping distance.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOPPING_DISTANCE_THRESHOLD = 20.0F; // in meters\n\nfloat calculate_stopping_distance(float vehicle_speed) {\n    return (vehicle_speed * vehicle_speed) / (2.0F * 9.81F); // Simple stopping distance formula\n}\n\nvoid check_stopping_distance_and_warn(float vehicle_speed, float radar_distance) {\n    if (vehicle_speed <= 0.0F || radar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid data.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n    std::cout << \"Calculated stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > radar_distance) {\n        std::cout << \"WARNING: Insufficient distance to stop!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F; // Vehicle speed in m/s\n    float radar_distance = 15.0F; // Radar distance to obstacle\n    check_stopping_distance_and_warn(vehicle_speed, radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses lidar and radar data to detect the relative position of an obstacle and triggers a warning if the obstacle is within a dangerous zone of the vehicle's trajectory.",
      "input": "Ensure both lidar and radar sensor data are synchronized before detecting the obstacle's relative position.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DANGER_ZONE_THRESHOLD = 10.0F; // in meters\n\nvoid detect_obstacle_and_warn(float lidar_distance, float radar_distance) {\n    if (lidar_distance <= 0.0F || radar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float closest_obstacle_distance = (lidar_distance < radar_distance) ? lidar_distance : radar_distance;\n    std::cout << \"Detected closest obstacle at: \" << closest_obstacle_distance << \" meters\" << std::endl;\n\n    if (closest_obstacle_distance < DANGER_ZONE_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle within danger zone!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 8.0F; // Lidar distance to object\n    float radar_distance = 12.0F; // Radar distance to object\n    detect_obstacle_and_warn(lidar_distance, radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to calculate the distance to an obstacle and triggers a warning if the vehicle is approaching an obstacle too quickly based on vehicle speed.",
      "input": "Ensure that radar and lidar data are properly validated before calculating the risk.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 15.0F; // in m/s\n\nvoid check_collision_risk_and_warn(float radar_distance, float lidar_distance, float vehicle_speed) {\n    if (radar_distance <= 0.0F || lidar_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float closest_obstacle_distance = (radar_distance < lidar_distance) ? radar_distance : lidar_distance;\n    std::cout << \"Detected closest obstacle at: \" << closest_obstacle_distance << \" meters\" << std::endl;\n\n    if (closest_obstacle_distance < vehicle_speed * 2) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 10.0F; // Radar distance to obstacle\n    float lidar_distance = 15.0F; // Lidar distance to obstacle\n    float vehicle_speed = 5.0F; // Vehicle speed in m/s\n    check_collision_risk_and_warn(radar_distance, lidar_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to estimate the time to collision (TTC) and triggers a warning if TTC is below a configurable threshold.",
      "input": "Ensure radar and lidar data are validated and synchronized for accurate collision prediction.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_THRESHOLD = 3.0F; // in seconds\n\nvoid estimate_ttc_and_warn(float radar_distance, float lidar_distance, float relative_velocity) {\n    if (radar_distance <= 0.0F || lidar_distance <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    float ttc = (radar_distance + lidar_distance) / (2.0F * relative_velocity);\n    std::cout << \"Estimated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < TTC_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 40.0F; // Radar distance to obstacle\n    float lidar_distance = 50.0F; // Lidar distance to obstacle\n    float relative_velocity = 8.0F; // Relative velocity in m/s\n    estimate_ttc_and_warn(radar_distance, lidar_distance, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar data to detect a lead vehicle's sudden braking and triggers a warning if the relative velocity between the vehicles increases beyond a safe threshold.",
      "input": "Ensure radar data is validated before detecting changes in relative velocity.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RELATIVE_VELOCITY_THRESHOLD = 6.0F; // in m/s\n\nvoid detect_sudden_braking_and_warn(float radar_velocity, float relative_velocity) {\n    if (radar_velocity <= 0.0F || relative_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or velocity data.\" << std::endl;\n        return;\n    }\n\n    if (relative_velocity > RELATIVE_VELOCITY_THRESHOLD) {\n        std::cout << \"WARNING: Lead vehicle is braking suddenly!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_velocity = 30.0F; // Radar velocity of the lead vehicle\n    float relative_velocity = 7.0F; // Relative velocity between vehicles\n    detect_sudden_braking_and_warn(radar_velocity, relative_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that calculates the time-to-collision (TTC) based on vehicle speed and distance to the obstacle and triggers a warning if TTC is below a safety threshold.",
      "input": "Ensure vehicle speed and obstacle distance data are valid before calculating TTC.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_THRESHOLD = 2.0F; // in seconds\n\nvoid calculate_ttc_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or distance data.\" << std::endl;\n        return;\n    }\n\n    float ttc = distance_to_obstacle / vehicle_speed;\n    std::cout << \"Calculated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < TTC_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 35.0F; // Distance to the obstacle in meters\n    calculate_ttc_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that detects a stationary obstacle and triggers a warning if the vehicle is approaching the obstacle at a high rate of speed.",
      "input": "Ensure proper validation of sensor data for stationary objects.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_THRESHOLD = 10.0F; // in meters\n\nvoid detect_stationary_obstacle_and_warn(float obstacle_distance, float vehicle_speed) {\n    if (obstacle_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid sensor data.\" << std::endl;\n        return;\n    }\n\n    if (obstacle_distance < COLLISION_THRESHOLD && vehicle_speed > 5.0F) {\n        std::cout << \"WARNING: Approaching stationary obstacle too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float obstacle_distance = 8.0F; // Distance to stationary obstacle\n    float vehicle_speed = 12.0F; // Vehicle speed in m/s\n    detect_stationary_obstacle_and_warn(obstacle_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to detect a slow-moving vehicle ahead and triggers a warning if the relative speed is too high.",
      "input": "Ensure radar and lidar data are validated before calculating relative speed.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float MAX_RELATIVE_SPEED = 4.0F; // in m/s\n\nvoid detect_slow_vehicle_and_warn(float radar_velocity, float lidar_velocity) {\n    if (radar_velocity <= 0.0F || lidar_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or lidar data.\" << std::endl;\n        return;\n    }\n\n    float relative_velocity = radar_velocity - lidar_velocity;\n    if (relative_velocity > MAX_RELATIVE_SPEED) {\n        std::cout << \"WARNING: High relative speed detected with a slow-moving vehicle ahead!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_velocity = 10.0F; // Radar velocity of the vehicle ahead\n    float lidar_velocity = 5.0F; // Lidar velocity of the vehicle ahead\n    detect_slow_vehicle_and_warn(radar_velocity, lidar_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data to predict collision risk based on the speed and proximity of an obstacle and triggers a warning if the risk exceeds a safety threshold.",
      "input": "Ensure radar data is synchronized and validated for collision risk prediction.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RISK_THRESHOLD = 20.0F; // in m/s^2\n\nvoid predict_collision_risk_and_warn(float radar_distance, float vehicle_speed) {\n    if (radar_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or vehicle speed data.\" << std::endl;\n        return;\n    }\n\n    float risk = vehicle_speed * vehicle_speed / (2 * radar_distance);\n    std::cout << \"Calculated collision risk: \" << risk << \" m/s^2\" << std::endl;\n\n    if (risk > RISK_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk is high!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 50.0F; // Distance to obstacle\n    float vehicle_speed = 25.0F; // Vehicle speed in m/s\n    predict_collision_risk_and_warn(radar_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that calculates the required stopping distance and triggers a warning if the distance to the obstacle is insufficient to stop the vehicle safely.",
      "input": "Ensure the vehicle speed and obstacle distance are properly validated.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float GRAVITY = 9.81F; // in m/s^2\nconst float STOPPING_DISTANCE_FACTOR = 0.5F; // Empirical factor for calculation\n\nfloat calculate_stopping_distance(float vehicle_speed) {\n    return (vehicle_speed * vehicle_speed) / (2.0F * GRAVITY * STOPPING_DISTANCE_FACTOR);\n}\n\nvoid check_stopping_distance_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid speed or obstacle data.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n    std::cout << \"Required stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > distance_to_obstacle) {\n        std::cout << \"WARNING: Insufficient distance to stop!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 18.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 40.0F; // Distance to the obstacle in meters\n    check_stopping_distance_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to track the relative position of a vehicle ahead and trigger a warning if the relative velocity exceeds a safe limit.",
      "input": "Ensure radar and lidar data are validated before calculating relative velocity.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_VELOCITY_LIMIT = 8.0F; // in m/s\n\nvoid track_relative_position_and_warn(float radar_velocity, float lidar_velocity) {\n    if (radar_velocity <= 0.0F || lidar_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or lidar data.\" << std::endl;\n        return;\n    }\n\n    float relative_velocity = radar_velocity - lidar_velocity;\n    std::cout << \"Relative velocity: \" << relative_velocity << \" m/s\" << std::endl;\n\n    if (relative_velocity > SAFE_VELOCITY_LIMIT) {\n        std::cout << \"WARNING: Relative velocity exceeds safe limit!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_velocity = 15.0F; // Radar velocity of the vehicle ahead\n    float lidar_velocity = 7.0F; // Lidar velocity of the vehicle ahead\n    track_relative_position_and_warn(radar_velocity, lidar_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data to monitor the distance to a vehicle in the same lane and triggers a warning if the distance decreases too quickly.",
      "input": "Ensure radar data is validated before calculating the rate of distance change.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DISTANCE_DECREASE_RATE_THRESHOLD = 2.0F; // in m/s\n\nvoid monitor_distance_decrease_and_warn(float radar_distance, float previous_radar_distance, float time_interval) {\n    if (radar_distance <= 0.0F || previous_radar_distance <= 0.0F || time_interval <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or time data.\" << std::endl;\n        return;\n    }\n\n    float distance_decrease_rate = (previous_radar_distance - radar_distance) / time_interval;\n    std::cout << \"Distance decrease rate: \" << distance_decrease_rate << \" m/s\" << std::endl;\n\n    if (distance_decrease_rate > DISTANCE_DECREASE_RATE_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle is approaching too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 30.0F; // Current distance to vehicle in meters\n    float previous_radar_distance = 35.0F; // Previous distance to vehicle in meters\n    float time_interval = 1.0F; // Time interval in seconds\n    monitor_distance_decrease_and_warn(radar_distance, previous_radar_distance, time_interval);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar data to calculate the vehicle's stopping distance and triggers a warning if the vehicle cannot stop in time based on current speed and distance to the obstacle.",
      "input": "Ensure that radar distance and vehicle speed data are properly validated before calculating stopping distance.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOPPING_DISTANCE_THRESHOLD = 40.0F; // in meters\n\nfloat calculate_stopping_distance(float vehicle_speed) {\n    return (vehicle_speed * vehicle_speed) / (2.0F * 9.81F); // Using standard deceleration due to friction\n}\n\nvoid check_stopping_distance_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or obstacle distance.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n    std::cout << \"Stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > distance_to_obstacle) {\n        std::cout << \"WARNING: Insufficient stopping distance!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 15.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 30.0F; // Distance to obstacle in meters\n    check_stopping_distance_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar data to detect an obstacle in the vehicle's path and triggers a warning if the vehicle's speed exceeds a threshold while approaching the obstacle.",
      "input": "Ensure the radar data and vehicle speed are valid before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_THRESHOLD = 15.0F; // in m/s\n\nvoid detect_obstacle_and_warn(float radar_distance, float vehicle_speed) {\n    if (radar_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or vehicle speed data.\" << std::endl;\n        return;\n    }\n\n    if (vehicle_speed > SPEED_THRESHOLD && radar_distance < 30.0F) {\n        std::cout << \"WARNING: Obstacle detected and vehicle approaching too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 25.0F; // Distance to obstacle in meters\n    float vehicle_speed = 18.0F; // Vehicle speed in m/s\n    detect_obstacle_and_warn(radar_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that tracks the distance to a vehicle ahead and triggers a warning if the distance decreases too rapidly over a specified time interval.",
      "input": "Ensure the radar data for distance measurement is validated before tracking.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DISTANCE_DECREASE_RATE = 1.0F; // in m/s\n\nvoid track_distance_decrease_and_warn(float previous_distance, float current_distance, float time_interval) {\n    if (previous_distance <= 0.0F || current_distance <= 0.0F || time_interval <= 0.0F) {\n        std::cout << \"ERROR: Invalid distance or time data.\" << std::endl;\n        return;\n    }\n\n    float decrease_rate = (previous_distance - current_distance) / time_interval;\n    std::cout << \"Distance decrease rate: \" << decrease_rate << \" m/s\" << std::endl;\n\n    if (decrease_rate > DISTANCE_DECREASE_RATE) {\n        std::cout << \"WARNING: Approaching vehicle too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float previous_distance = 50.0F; // Previous distance in meters\n    float current_distance = 40.0F; // Current distance in meters\n    float time_interval = 2.0F; // Time interval in seconds\n    track_distance_decrease_and_warn(previous_distance, current_distance, time_interval);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to detect a slow-moving vehicle ahead and triggers a warning if the vehicle is approaching it too quickly.",
      "input": "Ensure radar and lidar data are validated before calculating the relative speed.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SAFE_VELOCITY_LIMIT = 5.0F; // in m/s\n\nvoid detect_slow_vehicle_and_warn(float radar_velocity, float lidar_velocity) {\n    if (radar_velocity <= 0.0F || lidar_velocity <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar or lidar data.\" << std::endl;\n        return;\n    }\n\n    float relative_velocity = radar_velocity - lidar_velocity;\n    if (relative_velocity > SAFE_VELOCITY_LIMIT) {\n        std::cout << \"WARNING: Approaching slow vehicle too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_velocity = 12.0F; // Radar velocity of the vehicle ahead\n    float lidar_velocity = 7.0F; // Lidar velocity of the vehicle ahead\n    detect_slow_vehicle_and_warn(radar_velocity, lidar_velocity);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that calculates the time-to-collision (TTC) and triggers a warning if the TTC falls below a threshold.",
      "input": "Ensure the vehicle speed and obstacle distance are valid before calculating TTC.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float TTC_THRESHOLD = 3.0F; // in seconds\n\nvoid calculate_ttc_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or obstacle distance.\" << std::endl;\n        return;\n    }\n\n    float ttc = distance_to_obstacle / vehicle_speed;\n    std::cout << \"Calculated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < TTC_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk imminent!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 50.0F; // Distance to obstacle in meters\n    calculate_ttc_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that detects a stationary obstacle and triggers a warning if the vehicle is closing in on the obstacle too quickly.",
      "input": "Ensure that obstacle distance and vehicle speed data are validated before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 10.0F; // in meters\n\nvoid detect_stationary_obstacle_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid speed or obstacle distance data.\" << std::endl;\n        return;\n    }\n\n    if (distance_to_obstacle < COLLISION_DISTANCE_THRESHOLD && vehicle_speed > 5.0F) {\n        std::cout << \"WARNING: Closing in on stationary obstacle too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 15.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 8.0F; // Distance to stationary obstacle in meters\n    detect_stationary_obstacle_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that calculates the stopping distance required to avoid a collision and triggers a warning if the vehicle is unable to stop in time.",
      "input": "Ensure that vehicle speed and distance to obstacle are validated before calculating stopping distance.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STOPPING_DISTANCE_FACTOR = 0.5F; // Empirical factor for deceleration\nconst float GRAVITY = 9.81F; // Gravitational acceleration in m/s^2\n\nfloat calculate_stopping_distance(float vehicle_speed) {\n    return (vehicle_speed * vehicle_speed) / (2.0F * GRAVITY * STOPPING_DISTANCE_FACTOR);\n}\n\nvoid check_stopping_distance_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or obstacle distance.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n    std::cout << \"Stopping distance: \" << stopping_distance << \" meters\" << std::endl;\n\n    if (stopping_distance > distance_to_obstacle) {\n        std::cout << \"WARNING: Insufficient stopping distance!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 22.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 40.0F; // Distance to obstacle in meters\n    check_stopping_distance_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that detects the relative speed between two vehicles and triggers a warning if the relative speed exceeds a threshold.",
      "input": "Validate the radar data for relative speed measurement.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RELATIVE_SPEED_THRESHOLD = 10.0F; // in m/s\n\nvoid detect_relative_speed_and_warn(float vehicle_speed, float vehicle_ahead_speed) {\n    if (vehicle_speed <= 0.0F || vehicle_ahead_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed data.\" << std::endl;\n        return;\n    }\n\n    float relative_speed = vehicle_speed - vehicle_ahead_speed;\n    std::cout << \"Relative speed: \" << relative_speed << \" m/s\" << std::endl;\n\n    if (relative_speed > RELATIVE_SPEED_THRESHOLD) {\n        std::cout << \"WARNING: High relative speed!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 18.0F; // Vehicle speed in m/s\n    float vehicle_ahead_speed = 8.0F; // Speed of vehicle ahead in m/s\n    detect_relative_speed_and_warn(vehicle_speed, vehicle_ahead_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that tracks the vehicle's position relative to lane boundaries and triggers a warning if the vehicle is too close to the lane boundary.",
      "input": "Ensure that lane boundary positions and vehicle positions are validated before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float LANE_BOUNDARY_THRESHOLD = 0.5F; // in meters\n\nvoid track_lane_position_and_warn(float vehicle_position, float lane_left_boundary, float lane_right_boundary) {\n    if (vehicle_position <= 0.0F || lane_left_boundary <= 0.0F || lane_right_boundary <= 0.0F) {\n        std::cout << \"ERROR: Invalid position or lane boundary data.\" << std::endl;\n        return;\n    }\n\n    if (vehicle_position < lane_left_boundary + LANE_BOUNDARY_THRESHOLD || vehicle_position > lane_right_boundary - LANE_BOUNDARY_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle too close to lane boundary!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_position = 2.0F; // Vehicle position in meters\n    float lane_left_boundary = 1.0F; // Left lane boundary in meters\n    float lane_right_boundary = 3.0F; // Right lane boundary in meters\n    track_lane_position_and_warn(vehicle_position, lane_left_boundary, lane_right_boundary);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that monitors the vehicle's braking status and triggers a warning if the brakes are not applied when necessary based on the current speed and distance to the obstacle.",
      "input": "Ensure that braking status and obstacle distance data are properly validated before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float BRAKE_APPLY_THRESHOLD = 10.0F; // in m/s\n\nvoid check_brake_status_and_warn(float vehicle_speed, float distance_to_obstacle, bool brake_applied) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or obstacle distance.\" << std::endl;\n        return;\n    }\n\n    if (vehicle_speed > BRAKE_APPLY_THRESHOLD && distance_to_obstacle < 15.0F && !brake_applied) {\n        std::cout << \"WARNING: Brakes not applied while approaching obstacle!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 15.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 12.0F; // Distance to obstacle in meters\n    bool brake_applied = false; // Braking status\n    check_brake_status_and_warn(vehicle_speed, distance_to_obstacle, brake_applied);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses radar data to detect a stationary object and triggers a warning if the object is within a specified proximity threshold.",
      "input": "Ensure the radar data is checked for validity before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float PROXIMITY_THRESHOLD = 5.0F; // in meters\n\nvoid detect_stationary_object_and_warn(float radar_distance) {\n    if (radar_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid radar distance data.\" << std::endl;\n        return;\n    }\n\n    if (radar_distance <= PROXIMITY_THRESHOLD) {\n        std::cout << \"WARNING: Stationary object detected within proximity!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 3.0F; // Distance to stationary object in meters\n    detect_stationary_object_and_warn(radar_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that calculates the relative speed between the vehicle and a detected object, and triggers a warning if the relative speed exceeds a predefined limit.",
      "input": "Ensure that the object speed and vehicle speed data are validated before calculating relative speed.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float RELATIVE_SPEED_LIMIT = 15.0F; // in m/s\n\nvoid calculate_relative_speed_and_warn(float vehicle_speed, float object_speed) {\n    if (vehicle_speed <= 0.0F || object_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle or object speed data.\" << std::endl;\n        return;\n    }\n\n    float relative_speed = vehicle_speed - object_speed;\n    std::cout << \"Relative speed: \" << relative_speed << \" m/s\" << std::endl;\n\n    if (relative_speed > RELATIVE_SPEED_LIMIT) {\n        std::cout << \"WARNING: High relative speed!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 20.0F; // Vehicle speed in m/s\n    float object_speed = 5.0F; // Object speed in m/s\n    calculate_relative_speed_and_warn(vehicle_speed, object_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that uses vehicle's GPS data and speed to estimate the time to collision with an obstacle and triggers a warning if the time is less than a threshold.",
      "input": "Ensure that both GPS and speed data are validated before calculating time to collision.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_TIME_THRESHOLD = 3.0F; // in seconds\n\nvoid estimate_ttc_and_warn(float vehicle_speed, float distance_to_obstacle) {\n    if (vehicle_speed <= 0.0F || distance_to_obstacle <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or distance data.\" << std::endl;\n        return;\n    }\n\n    float ttc = distance_to_obstacle / vehicle_speed;\n    std::cout << \"Estimated TTC: \" << ttc << \" seconds\" << std::endl;\n\n    if (ttc < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Time to collision is too short!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 25.0F; // Vehicle speed in m/s\n    float distance_to_obstacle = 75.0F; // Distance to obstacle in meters\n    estimate_ttc_and_warn(vehicle_speed, distance_to_obstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects an object in the vehicle's path and triggers a warning if the object is within the detection range while the vehicle's speed exceeds a specified threshold.",
      "input": "Ensure the detection range and vehicle speed are valid before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_THRESHOLD = 10.0F; // in m/s\n\nvoid detect_object_and_warn(float object_distance, float vehicle_speed) {\n    if (object_distance <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid object distance or vehicle speed data.\" << std::endl;\n        return;\n    }\n\n    if (object_distance < 20.0F && vehicle_speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Object detected while vehicle is speeding!\" << std::endl;\n    }\n}\n\nint main() {\n    float object_distance = 15.0F; // Distance to object in meters\n    float vehicle_speed = 12.0F; // Vehicle speed in m/s\n    detect_object_and_warn(object_distance, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses vehicle speed and object proximity data to predict the vehicle's collision risk and triggers a warning if the risk exceeds a predefined threshold.",
      "input": "Validate the vehicle speed and object proximity data before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float COLLISION_RISK_THRESHOLD = 0.8F; // Risk threshold between 0 and 1\n\nfloat calculate_collision_risk(float vehicle_speed, float object_proximity) {\n    return (vehicle_speed * object_proximity) / 100.0F;\n}\n\nvoid check_collision_risk_and_warn(float vehicle_speed, float object_proximity) {\n    if (vehicle_speed <= 0.0F || object_proximity <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or object proximity data.\" << std::endl;\n        return;\n    }\n\n    float collision_risk = calculate_collision_risk(vehicle_speed, object_proximity);\n    std::cout << \"Calculated collision risk: \" << collision_risk << std::endl;\n\n    if (collision_risk > COLLISION_RISK_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 18.0F; // Vehicle speed in m/s\n    float object_proximity = 30.0F; // Object proximity in meters\n    check_collision_risk_and_warn(vehicle_speed, object_proximity);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that calculates the distance required for safe stopping based on vehicle speed and road conditions, and triggers a warning if the stopping distance exceeds the available distance.",
      "input": "Validate vehicle speed and road condition data before calculating stopping distance.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float ROAD_CONDITION_COEFFICIENT = 0.7F; // Road friction coefficient\n\nfloat calculate_stopping_distance(float vehicle_speed) {\n    return (vehicle_speed * vehicle_speed) / (2 * ROAD_CONDITION_COEFFICIENT * 9.81F);\n}\n\nvoid check_stopping_distance_and_warn(float vehicle_speed, float available_distance) {\n    if (vehicle_speed <= 0.0F || available_distance <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or available distance data.\" << std::endl;\n        return;\n    }\n\n    float stopping_distance = calculate_stopping_distance(vehicle_speed);\n    std::cout << \"Stopping distance: \" << stopping_distance << std::endl;\n\n    if (stopping_distance > available_distance) {\n        std::cout << \"WARNING: Insufficient distance to stop safely!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 25.0F; // Vehicle speed in m/s\n    float available_distance = 50.0F; // Available distance in meters\n    check_stopping_distance_and_warn(vehicle_speed, available_distance);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects a rapid decrease in the distance to a leading vehicle and triggers a warning if the decrease exceeds a predefined threshold.",
      "input": "Ensure that the radar data and vehicle speed data are validated before performing the distance calculation.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DISTANCE_DECREASE_THRESHOLD = 2.0F; // in meters per second\n\nvoid detect_rapid_distance_decrease_and_warn(float initial_distance, float final_distance, float time_interval) {\n    if (initial_distance <= 0.0F || final_distance <= 0.0F || time_interval <= 0.0F) {\n        std::cout << \"ERROR: Invalid distance or time data.\" << std::endl;\n        return;\n    }\n\n    float distance_decrease_rate = (initial_distance - final_distance) / time_interval;\n    std::cout << \"Distance decrease rate: \" << distance_decrease_rate << \" meters/second\" << std::endl;\n\n    if (distance_decrease_rate > DISTANCE_DECREASE_THRESHOLD) {\n        std::cout << \"WARNING: Rapid decrease in distance to vehicle ahead!\" << std::endl;\n    }\n}\n\nint main() {\n    float initial_distance = 50.0F; // Initial distance to vehicle ahead in meters\n    float final_distance = 30.0F; // Final distance to vehicle ahead in meters\n    float time_interval = 5.0F; // Time interval in seconds\n    detect_rapid_distance_decrease_and_warn(initial_distance, final_distance, time_interval);\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that detects when a vehicle is approaching a sharp turn too quickly and triggers a warning if the speed exceeds a threshold.",
      "input": "Ensure the turn sharpness and vehicle speed are validated before checking for the warning condition.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float SPEED_THRESHOLD = 20.0F; // in m/s\nconst float TURN_SHARPNESS_THRESHOLD = 30.0F; // in degrees\n\nvoid check_turn_speed_and_warn(float vehicle_speed, float turn_sharpness) {\n    if (vehicle_speed <= 0.0F || turn_sharpness <= 0.0F) {\n        std::cout << \"ERROR: Invalid vehicle speed or turn sharpness data.\" << std::endl;\n        return;\n    }\n\n    if (turn_sharpness > TURN_SHARPNESS_THRESHOLD && vehicle_speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle approaching sharp turn too quickly!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 25.0F; // Vehicle speed in m/s\n    float turn_sharpness = 45.0F; // Turn sharpness in degrees\n    check_turn_speed_and_warn(vehicle_speed, turn_sharpness);\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that monitors vehicle speed and triggers a warning when a sudden deceleration is detected, indicating a potential collision risk.",
      "input": "Ensure that vehicle speed data is validated before calculating the deceleration rate.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float DECELERATION_THRESHOLD = -5.0F; // in m/s^2\n\nvoid check_sudden_deceleration_and_warn(float initial_speed, float final_speed, float time_interval) {\n    if (initial_speed <= 0.0F || final_speed <= 0.0F || time_interval <= 0.0F) {\n        std::cout << \"ERROR: Invalid speed or time data.\" << std::endl;\n        return;\n    }\n\n    float deceleration_rate = (final_speed - initial_speed) / time_interval;\n    std::cout << \"Deceleration rate: \" << deceleration_rate << \" m/s^2\" << std::endl;\n\n    if (deceleration_rate < DECELERATION_THRESHOLD) {\n        std::cout << \"WARNING: Sudden deceleration detected!\" << std::endl;\n    }\n}\n\nint main() {\n    float initial_speed = 25.0F; // Initial speed in m/s\n    float final_speed = 15.0F; // Final speed in m/s\n    float time_interval = 2.0F; // Time interval in seconds\n    check_sudden_deceleration_and_warn(initial_speed, final_speed, time_interval);\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects a driver\u2019s lack of attention based on steering wheel angle and vehicle speed, and triggers a warning if the vehicle is drifting without any correction.",
      "input": "Validate steering angle and vehicle speed data before triggering the warning.",
      "output": "#include <iostream>\n#include <cstdlib>\n\nconst float STEERING_ANGLE_THRESHOLD = 15.0F; // in degrees\nconst float SPEED_THRESHOLD = 10.0F; // in m/s\n\nvoid check_driver_attention_and_warn(float steering_angle, float vehicle_speed) {\n    if (steering_angle <= 0.0F || vehicle_speed <= 0.0F) {\n        std::cout << \"ERROR: Invalid steering angle or vehicle speed data.\" << std::endl;\n        return;\n    }\n\n    if (steering_angle > STEERING_ANGLE_THRESHOLD && vehicle_speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle drifting without correction!\" << std::endl;\n    }\n}\n\nint main() {\n    float steering_angle = 20.0F; // Steering angle in degrees\n    float vehicle_speed = 12.0F; // Vehicle speed in m/s\n    check_driver_attention_and_warn(steering_angle, vehicle_speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that processes real-time video input and triggers a warning when the distance to an object is below a threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle explicit type conversions, and include detailed comments explaining each step.",
      "output": "#include <opencv2/opencv.hpp> // Include OpenCV for processing\n// Example MISRA-compliant code with comments for FCW system"
    },
    {
      "instruction": "Create MISRA-compliant C++ code for an FCW system. The program should detect vehicles, calculate their distances, and display warnings for potential collisions.",
      "input": "Use OpenCV for object detection and ensure MISRA 2023 compliance by avoiding implicit type conversions and providing detailed error handling.",
      "output": "#include <opencv2/opencv.hpp> // Example code for detecting vehicles and warnings"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using OpenCV that processes real-time video input, detects objects, and calculates their distances. Trigger warnings if objects are closer than a threshold.",
      "input": "Ensure compliance by avoiding 'using namespace', handling type conversions explicitly, and providing detailed comments explaining each step.",
      "output": "// Include necessary headers\n#include <opencv2/opencv.hpp> // For image and video processing\n#include <iostream>           // For standard I/O\n// Declare constants\nconst float COLLISION_THRESHOLD = 5.0f; // Distance threshold for collision warnings\nconst float CAR_WIDTH = 1.8f;           // Average car width in meters\n\n// Function to calculate distance to detected objects\nfloat calculateDistance(float perceivedWidth, float focalLength, float knownWidth) {\n    return (focalLength * knownWidth) / perceivedWidth; // Distance estimation formula\n}\n\n// Main function\nint main() {\n    // Open video capture device\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera.\\n\";\n        return -1; // Exit with failure\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture frame\n        if (frame.empty()) {\n            break; // End of video stream\n        }\n        // Process frame (dummy processing for demonstration)\n        std::cout << \"Processing frame.\\n\";\n        // Placeholder for detection and distance estimation\n        // Display frame\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') { // Exit on 'q'\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold dynamically based on the vehicle's speed.",
      "input": "Ensure compliance by explicitly managing speed inputs, defining constants for speed-to-threshold scaling, and providing detailed comments for dynamic adjustments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\n// Constants for distance calculation\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float MIN_THRESHOLD = 5.0f;\nconst float MAX_THRESHOLD = 15.0f;\n\nfloat calculateDistance(int widthInPixels) {\n    return (KNOWN_WIDTH * FOCAL_LENGTH) / static_cast<float>(widthInPixels);\n}\n\nfloat adjustThreshold(float speed) {\n    if (speed < 30.0f) {\n        return MIN_THRESHOLD;\n    } else if (speed > 90.0f) {\n        return MAX_THRESHOLD;\n    }\n    return MIN_THRESHOLD + ((speed - 30.0f) / 60.0f) * (MAX_THRESHOLD - MIN_THRESHOLD);\n}\n\nint main() {\n    float vehicleSpeed = 50.0f; // Example speed (in km/h)\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        float collisionThreshold = adjustThreshold(vehicleSpeed);\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = calculateDistance(detectedObject.width);\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string distanceText = \"Distance: \" + std::to_string(distance) + \" m\";\n        cv::putText(frame, distanceText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (distance < collisionThreshold) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA C++ 2023-compliant code for an FCW system that tracks multiple objects and triggers a warning for the closest object.",
      "input": "Ensure compliance by using structured programming, avoiding implicit type promotions, and providing comments for object prioritization logic.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <vector>\n\n// Constants\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float COLLISION_THRESHOLD = 5.0f;\n\nstruct DetectedObject {\n    cv::Rect boundingBox;\n    float distance;\n};\n\nfloat calculateDistance(int widthInPixels) {\n    return (KNOWN_WIDTH * FOCAL_LENGTH) / static_cast<float>(widthInPixels);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        std::vector<DetectedObject> detectedObjects = {\n            {cv::Rect(300, 200, 80, 100), 0.0f},\n            {cv::Rect(500, 250, 100, 120), 0.0f},\n            {cv::Rect(700, 300, 120, 140), 0.0f}\n        };\n\n        DetectedObject closestObject;\n        closestObject.distance = std::numeric_limits<float>::max();\n\n        for (auto &obj : detectedObjects) {\n            obj.distance = calculateDistance(obj.boundingBox.width);\n            if (obj.distance < closestObject.distance) {\n                closestObject = obj;\n            }\n\n            cv::rectangle(frame, obj.boundingBox, cv::Scalar(0, 255, 0), 2);\n            std::string distanceText = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n            cv::putText(frame, distanceText, cv::Point(obj.boundingBox.x, obj.boundingBox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n        }\n\n        if (closestObject.distance < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses a radar sensor to detect objects and calculates the time to collision (TTC).",
      "input": "Ensure compliance by explicitly handling radar data inputs, avoiding implicit type conversions, and including comments for the TTC calculation logic.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float RADAR_SENSOR_WIDTH = 1.8f;\nconst float RADAR_FOCAL_LENGTH = 1000.0f;\nconst float COLLISION_THRESHOLD = 3.0f;\n\nfloat calculateTTC(float relativeSpeed, float distance) {\n    if (relativeSpeed == 0.0f) {\n        return -1.0f; // No collision risk if speed is zero\n    }\n    return distance / relativeSpeed;\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    float relativeSpeed = 10.0f; // Relative speed of the object in km/h\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);  // Simulated object detection\n        float distance = RADAR_SENSOR_WIDTH * RADAR_FOCAL_LENGTH / static_cast<float>(detectedObject.width);\n        float ttc = calculateTTC(relativeSpeed, distance);\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string ttcText = \"TTC: \" + std::to_string(ttc) + \" sec\";\n        cv::putText(frame, ttcText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (ttc < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA C++ 2023-compliant code for an FCW system that integrates stereo camera images for depth estimation and collision detection.",
      "input": "Ensure compliance by handling stereo images correctly, avoiding unsafe type conversions, and adding comments explaining the depth estimation process.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float BASELINE = 0.2f;  // Distance between the two cameras in meters\nconst float COLLISION_THRESHOLD = 5.0f;\n\nfloat calculateDepth(int disparity) {\n    return (FOCAL_LENGTH * BASELINE) / static_cast<float>(disparity);\n}\n\nint main() {\n    cv::VideoCapture leftCam(0), rightCam(1);\n    if (!leftCam.isOpened() || !rightCam.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera streams!\\n\";\n        return -1;\n    }\n\n    cv::Mat leftFrame, rightFrame, disparityMap;\n    while (true) {\n        leftCam >> leftFrame;\n        rightCam >> rightFrame;\n        if (leftFrame.empty() || rightFrame.empty()) {\n            break;\n        }\n\n        // Compute disparity between the two images\n        cv::StereoBM stereoBM;\n        stereoBM(leftFrame, rightFrame, disparityMap);\n\n        // Simulated object detection: using a fixed region for simplicity\n        int disparity = disparityMap.at<uchar>(200, 300);  // Sample pixel value\n        float depth = calculateDepth(disparity);\n\n        cv::Rect detectedObject(300, 200, 100, 150);  // Simulated detection\n        cv::rectangle(leftFrame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string depthText = \"Depth: \" + std::to_string(depth) + \" m\";\n        cv::putText(leftFrame, depthText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (depth < COLLISION_THRESHOLD) {\n            cv::putText(leftFrame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", leftFrame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    leftCam.release();\n    rightCam.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that estimates the closing speed of a detected vehicle and triggers a warning when the speed exceeds a threshold.",
      "input": "Ensure compliance by calculating relative speed safely, avoiding unsafe type casting, and adding comments for each key computation.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float VEHICLE_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float MAX_SPEED_THRESHOLD = 40.0f;  // km/h\n\nfloat calculateSpeed(float distance, float time) {\n    return distance / time;\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = VEHICLE_WIDTH * FOCAL_LENGTH / static_cast<float>(detectedObject.width);\n        float closingSpeed = calculateSpeed(distance, 1.0f); // Assume 1 second time frame for simplicity\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string speedText = \"Closing Speed: \" + std::to_string(closingSpeed) + \" km/h\";\n        cv::putText(frame, speedText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (closingSpeed > MAX_SPEED_THRESHOLD) {\n            cv::putText(frame, \"WARNING: HIGH CLOSING SPEED!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that provides visual and audio alerts for imminent collisions.",
      "input": "Ensure compliance by managing audio outputs safely, defining constants for alerting thresholds, and providing detailed comments for both visual and audio alerts.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD = 3.0f;\nconst std::string ALERT_AUDIO_FILE = \"alert.wav\";  // Path to the audio file\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = 5.0f;  // Simulated constant distance for now\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        if (distance < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n            std::system(ALERT_AUDIO_FILE.c_str());  // Play alert sound\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using LiDAR data for object detection and collision prediction.",
      "input": "Ensure the code safely handles LiDAR data inputs, computes distances from point cloud data, and includes detailed comments for the collision prediction logic.",
      "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision distance threshold in meters\n\n// Structure to hold a LiDAR point\nstruct LidarPoint {\n    float x;\n    float y;\n    float z;\n};\n\n// Function to compute distance from the LiDAR point to the origin\nfloat calculateDistance(const LidarPoint &point) {\n    return std::sqrt(point.x * point.x + point.y * point.y + point.z * point.z);\n}\n\n// Function to predict collision based on distance\nbool isCollisionRisk(float distance) {\n    return (distance < COLLISION_THRESHOLD);\n}\n\nint main() {\n    std::vector<LidarPoint> lidarData = {\n        {1.0f, 2.0f, 0.0f},\n        {2.5f, 1.0f, 0.0f},\n        {4.0f, 4.0f, 0.0f},\n        {3.5f, 3.0f, 0.0f}\n    };  // Simulated LiDAR points\n\n    for (const auto &point : lidarData) {\n        float distance = calculateDistance(point);\n        std::cout << \"Detected Object at Distance: \" << distance << \" meters\" << std::endl;\n        if (isCollisionRisk(distance)) {\n            std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system where the collision threshold dynamically adjusts based on the road curvature.",
      "input": "Ensure safe handling of the road curvature data, and adjust the collision threshold appropriately for different curve radii.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BASE_COLLISION_THRESHOLD = 10.0f;  // Base collision threshold in meters\nconst float CURVE_ADJUSTMENT_FACTOR = 1.5f;  // Adjustment factor for road curves\n\n// Function to adjust the collision threshold based on road curvature\nfloat adjustThreshold(float curvatureRadius) {\n    if (curvatureRadius <= 0.0f) {\n        return BASE_COLLISION_THRESHOLD;  // No adjustment for straight roads\n    }\n    return BASE_COLLISION_THRESHOLD - (CURVE_ADJUSTMENT_FACTOR * (1.0f / curvatureRadius));\n}\n\nint main() {\n    float roadCurvatureRadius = 50.0f;  // Example curvature radius (in meters)\n    float collisionThreshold = adjustThreshold(roadCurvatureRadius);\n\n    std::cout << \"Adjusted Collision Threshold: \" << collisionThreshold << \" meters\" << std::endl;\n\n    float detectedObjectDistance = 7.0f;  // Example distance to detected object\n    if (detectedObjectDistance < collisionThreshold) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system integrated with adaptive cruise control to automatically adjust vehicle speed to avoid collisions.",
      "input": "Ensure compliance by explicitly controlling the vehicle's speed using adaptive cruise control, and include comments explaining the control logic.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float MAX_SPEED = 120.0f;  // Max speed in km/h\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision distance threshold in meters\nconst float SAFE_FOLLOW_DISTANCE = 2.0f;  // Safe following distance in meters\n\n// Function to calculate the desired vehicle speed\nfloat adjustSpeed(float currentDistance) {\n    if (currentDistance < SAFE_FOLLOW_DISTANCE) {\n        return 0.0f;  // Stop the vehicle if too close\n    }\n    return MAX_SPEED * (currentDistance / SAFE_FOLLOW_DISTANCE);  // Adjust speed proportionally\n}\n\nint main() {\n    float objectDistance = 4.0f;  // Example distance to detected object\n    float currentSpeed = 100.0f;  // Current speed in km/h\n\n    std::cout << \"Current Speed: \" << currentSpeed << \" km/h\" << std::endl;\n\n    // Adjust speed based on object distance\n    float adjustedSpeed = adjustSpeed(objectDistance);\n    std::cout << \"Adjusted Speed: \" << adjustedSpeed << \" km/h\" << std::endl;\n\n    if (objectDistance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK! Automatically reducing speed...\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers warnings with varying urgency based on both vehicle speed and the distance to the detected object.",
      "input": "Ensure the warning urgency changes dynamically depending on both the speed and distance to the detected object, with clear comments on the logic behind this decision.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float HIGH_SPEED_THRESHOLD = 80.0f;  // Speed in km/h for high urgency\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision distance threshold in meters\n\n// Function to determine the warning urgency\nstd::string determineUrgency(float speed, float distance) {\n    if (distance < COLLISION_THRESHOLD) {\n        if (speed > HIGH_SPEED_THRESHOLD) {\n            return \"URGENT: STOP IMMEDIATELY!\";\n        }\n        return \"WARNING: SLOW DOWN!\";\n    }\n    return \"SAFE: KEEP DRIVING.\";\n}\n\nint main() {\n    float objectDistance = 4.0f;  // Example distance to detected object\n    float vehicleSpeed = 100.0f;  // Vehicle speed in km/h\n\n    std::cout << \"Current Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Distance to Object: \" << objectDistance << \" meters\" << std::endl;\n\n    std::string urgencyMessage = determineUrgency(vehicleSpeed, objectDistance);\n    std::cout << urgencyMessage << std::endl;\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts potential obstacles based on the vehicle's trajectory.",
      "input": "Ensure the code simulates vehicle trajectory calculations and predicts obstacle risks accordingly, with detailed comments explaining the trajectory modeling logic.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SAFE_DISTANCE = 5.0f;  // Safe distance in meters\nconst float TRAJECTORY_PREDICTION_TIME = 3.0f;  // Time in seconds for trajectory prediction\n\n// Function to simulate trajectory calculation\nfloat predictTrajectory(float currentSpeed, float time) {\n    return currentSpeed * time;  // Simple linear prediction\n}\n\nint main() {\n    float currentSpeed = 100.0f;  // Vehicle speed in km/h\n    float predictedDistance = predictTrajectory(currentSpeed, TRAJECTORY_PREDICTION_TIME);\n\n    std::cout << \"Predicted Distance after \" << TRAJECTORY_PREDICTION_TIME << \" seconds: \" << predictedDistance << \" meters\" << std::endl;\n\n    if (predictedDistance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Potential Obstacle Ahead!\" << std::endl;\n    } else {\n        std::cout << \"Trajectory Clear, Safe to Proceed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that integrates radar and camera data for multi-sensor fusion to improve collision prediction accuracy.",
      "input": "Ensure compliance by carefully handling both radar and camera data inputs, calculating distances from both sensors, and merging the data for improved prediction accuracy.",
      "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst float RADAR_COLLISION_THRESHOLD = 6.0f;  // Radar collision threshold\nconst float CAMERA_COLLISION_THRESHOLD = 5.0f;  // Camera collision threshold\n\n// Structure to hold radar data\nstruct RadarData {\n    float distance;\n    float angle;\n};\n\n// Structure to hold camera data\nstruct CameraData {\n    float distance;\n    float objectType;\n};\n\n// Function to combine radar and camera data for collision prediction\nbool isCollisionRisk(float radarDistance, float cameraDistance) {\n    return (radarDistance < RADAR_COLLISION_THRESHOLD || cameraDistance < CAMERA_COLLISION_THRESHOLD);\n}\n\nint main() {\n    RadarData radar = {4.5f, 30.0f};  // Simulated radar data\n    CameraData camera = {5.0f, 1.0f};  // Simulated camera data (e.g., detected car)\n\n    std::cout << \"Radar Distance: \" << radar.distance << \" meters\" << std::endl;\n    std::cout << \"Camera Distance: \" << camera.distance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(radar.distance, camera.distance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using GPS data along with radar and camera data to predict collisions.",
      "input": "Ensure the integration of GPS data, and process it along with radar and camera data for improved collision prediction, with clear comments on each step.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float GPS_COLLISION_THRESHOLD = 10.0f;  // GPS-based collision threshold in meters\nconst float RADAR_COLLISION_THRESHOLD = 6.0f;  // Radar-based threshold\nconst float CAMERA_COLLISION_THRESHOLD = 5.0f;  // Camera-based threshold\n\n// Structure to hold GPS data\nstruct GPSData {\n    float latitude;\n    float longitude;\n    float speed;\n};\n\n// Function to check collision risk based on sensor data\nbool isCollisionRisk(float gpsDistance, float radarDistance, float cameraDistance) {\n    return (gpsDistance < GPS_COLLISION_THRESHOLD || radarDistance < RADAR_COLLISION_THRESHOLD || cameraDistance < CAMERA_COLLISION_THRESHOLD);\n}\n\nint main() {\n    GPSData gps = {34.0522f, -118.2437f, 40.0f};  // Simulated GPS data (latitude, longitude, speed)\n    float radarDistance = 7.0f;  // Simulated radar distance\n    float cameraDistance = 4.0f;  // Simulated camera distance\n\n    std::cout << \"GPS Speed: \" << gps.speed << \" km/h\" << std::endl;\n    std::cout << \"Radar Distance: \" << radarDistance << \" meters\" << std::endl;\n    std::cout << \"Camera Distance: \" << cameraDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(gps.speed, radarDistance, cameraDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision risk prediction based on vehicle velocity.",
      "input": "Use vehicle velocity (speed) to adjust the collision prediction logic, ensuring that higher speeds trigger a more urgent warning when close to objects.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Distance threshold for collision risk in meters\nconst float HIGH_SPEED_THRESHOLD = 80.0f;  // Speed threshold in km/h for more urgent warnings\n\n// Function to check for collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    if (vehicleSpeed > HIGH_SPEED_THRESHOLD) {\n        return objectDistance < COLLISION_THRESHOLD / 2;  // More urgent warning for high speed\n    }\n    return objectDistance < COLLISION_THRESHOLD;  // Regular threshold for normal speed\n}\n\nint main() {\n    float vehicleSpeed = 90.0f;  // Vehicle speed in km/h\n    float objectDistance = 3.0f;  // Distance to detected object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts the behavior of obstacles based on their speed and direction relative to the vehicle.",
      "input": "Include logic to estimate the movement direction and speed of detected obstacles and use that data to predict future collision risks.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Distance threshold for collision risk\n\n// Structure to represent an obstacle with speed and direction\nstruct Obstacle {\n    float distance;\n    float speed;\n    float direction;  // Angle in degrees relative to the vehicle's direction\n};\n\n// Function to predict future position of an obstacle\nfloat predictObstaclePosition(const Obstacle &obstacle, float time) {\n    return obstacle.distance + obstacle.speed * time;  // Simple prediction based on speed and direction\n}\n\nint main() {\n    Obstacle obstacle = {10.0f, 20.0f, 45.0f};  // Example obstacle (10 meters away, 20 km/h speed, 45 degrees angle)\n    float predictionTime = 5.0f;  // Time in seconds for prediction\n\n    float predictedPosition = predictObstaclePosition(obstacle, predictionTime);\n\n    std::cout << \"Predicted Position of Obstacle after \" << predictionTime << \" seconds: \" << predictedPosition << \" meters\" << std::endl;\n\n    if (predictedPosition < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that includes pedestrian detection with vehicle speed.",
      "input": "Process pedestrian detection results alongside vehicle speed to calculate and trigger collision warnings if pedestrians are detected too close.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float PEDESTRIAN_COLLISION_THRESHOLD = 3.0f;  // Collision threshold for pedestrians in meters\nconst float VEHICLE_SPEED_THRESHOLD = 60.0f;  // Speed threshold in km/h for pedestrian collision warnings\n\n// Function to check pedestrian collision risk based on speed and distance\nbool isPedestrianCollisionRisk(float vehicleSpeed, float pedestrianDistance) {\n    if (vehicleSpeed > VEHICLE_SPEED_THRESHOLD) {\n        return pedestrianDistance < PEDESTRIAN_COLLISION_THRESHOLD / 2;  // Urgent warning at high speeds\n    }\n    return pedestrianDistance < PEDESTRIAN_COLLISION_THRESHOLD;  // Normal threshold for slower speeds\n}\n\nint main() {\n    float vehicleSpeed = 70.0f;  // Vehicle speed in km/h\n    float pedestrianDistance = 2.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(vehicleSpeed, pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses steering angle and object distance to trigger collision warnings.",
      "input": "Use the steering angle of the vehicle along with the object distance to predict the likelihood of a collision and trigger warnings accordingly.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Threshold for collision in meters\nconst float STEERING_ANGLE_THRESHOLD = 45.0f;  // Steering angle threshold in degrees\n\n// Function to calculate collision risk based on steering angle and distance\nbool isCollisionRisk(float steeringAngle, float objectDistance) {\n    if (std::abs(steeringAngle) > STEERING_ANGLE_THRESHOLD) {\n        return objectDistance < COLLISION_THRESHOLD / 2;  // More risky if steering sharply\n    }\n    return objectDistance < COLLISION_THRESHOLD;  // Regular collision risk check\n}\n\nint main() {\n    float steeringAngle = 50.0f;  // Steering angle in degrees\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Steering Angle: \" << steeringAngle << \" degrees\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(steeringAngle, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using data from multiple sensors (radar, camera, LIDAR) with weighted contribution for collision prediction.",
      "input": "Ensure that radar, camera, and LIDAR data contribute differently to the collision risk assessment based on their reliability and distance accuracy.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float RADAR_WEIGHT = 0.4f;  // Weight for radar data\nconst float CAMERA_WEIGHT = 0.3f;  // Weight for camera data\nconst float LIDAR_WEIGHT = 0.3f;  // Weight for LIDAR data\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision threshold in meters\n\n// Function to check collision risk with weighted sensor data\nbool isCollisionRisk(float radarDistance, float cameraDistance, float lidarDistance) {\n    float weightedDistance = (radarDistance * RADAR_WEIGHT + cameraDistance * CAMERA_WEIGHT + lidarDistance * LIDAR_WEIGHT);\n    return weightedDistance < COLLISION_THRESHOLD;  // Check if combined weighted distance is below threshold\n}\n\nint main() {\n    float radarDistance = 4.0f;  // Radar distance in meters\n    float cameraDistance = 5.0f;  // Camera distance in meters\n    float lidarDistance = 6.0f;  // LIDAR distance in meters\n\n    std::cout << \"Radar Distance: \" << radarDistance << \" meters\" << std::endl;\n    std::cout << \"Camera Distance: \" << cameraDistance << \" meters\" << std::endl;\n    std::cout << \"LIDAR Distance: \" << lidarDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(radarDistance, cameraDistance, lidarDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that estimates the future trajectory of an object and predicts collisions based on vehicle movement.",
      "input": "Implement a predictive model that estimates the trajectory of obstacles and predicts potential collisions considering vehicle motion.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Threshold for collision in meters\n\n// Function to estimate future position of an object based on velocity\nfloat predictObjectPosition(float currentDistance, float velocity, float time) {\n    return currentDistance + velocity * time;  // Simple trajectory prediction based on velocity\n}\n\nint main() {\n    float currentDistance = 10.0f;  // Current distance to object in meters\n    float objectVelocity = 2.0f;  // Object velocity in meters per second\n    float predictionTime = 5.0f;  // Time in seconds for prediction\n\n    float predictedPosition = predictObjectPosition(currentDistance, objectVelocity, predictionTime);\n\n    std::cout << \"Predicted Position of Object after \" << predictionTime << \" seconds: \" << predictedPosition << \" meters\" << std::endl;\n\n    if (predictedPosition < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses night vision camera data to detect obstacles and predict collision risks.",
      "input": "Process night vision data to detect obstacles and trigger collision warnings when detected obstacles are within a specified distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float NIGHT_VISION_COLLISION_THRESHOLD = 10.0f;  // Threshold for collision in meters based on night vision\n\n// Function to check collision risk based on night vision data\nbool isCollisionRisk(float objectDistance) {\n    return objectDistance < NIGHT_VISION_COLLISION_THRESHOLD;  // Check if object is too close based on night vision data\n}\n\nint main() {\n    float objectDistance = 8.0f;  // Object distance in meters based on night vision camera\n\n    std::cout << \"Object Distance (Night Vision): \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on rain sensor input.",
      "input": "Integrate a rain sensor to adjust the collision warning threshold, increasing the warning distance in wet conditions.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_DRY = 5.0f;  // Collision threshold for dry conditions in meters\nconst float COLLISION_THRESHOLD_WET = 8.0f;  // Collision threshold for wet conditions in meters\n\n// Function to check collision risk based on weather conditions\nbool isCollisionRisk(bool isWetWeather, float objectDistance) {\n    float threshold = isWetWeather ? COLLISION_THRESHOLD_WET : COLLISION_THRESHOLD_DRY;\n    return objectDistance < threshold;  // Check if object distance is less than adjusted threshold\n}\n\nint main() {\n    bool isWetWeather = true;  // Simulate wet weather condition based on rain sensor input\n    float objectDistance = 6.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isWetWeather, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts collisions at intersections based on vehicle position and angle.",
      "input": "Estimate the collision risk when a vehicle is approaching an intersection, considering its position and heading angle.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 10.0f;  // Collision threshold in meters\nconst float INTERSECTION_SAFE_DISTANCE = 5.0f;  // Safe distance at intersection\n\n// Function to check intersection collision risk\nbool isIntersectionCollisionRisk(float vehiclePosition, float vehicleHeading, float objectDistance) {\n    // If vehicle is within the intersection zone and heading towards it\n    if (vehiclePosition < INTERSECTION_SAFE_DISTANCE && std::abs(vehicleHeading) < 45.0f) {\n        return objectDistance < COLLISION_THRESHOLD;  // Check if object is within threshold distance\n    }\n    return false;  // No risk if not at intersection or not heading towards it\n}\n\nint main() {\n    float vehiclePosition = 4.0f;  // Vehicle's distance from intersection in meters\n    float vehicleHeading = 30.0f;  // Vehicle heading in degrees\n    float objectDistance = 8.0f;  // Distance to detected object in meters\n\n    std::cout << \"Vehicle Position: \" << vehiclePosition << \" meters from intersection\" << std::endl;\n    std::cout << \"Vehicle Heading: \" << vehicleHeading << \" degrees\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isIntersectionCollisionRisk(vehiclePosition, vehicleHeading, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK AT INTERSECTION!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the warning threshold based on vehicle speed in dense traffic conditions.",
      "input": "Adjust the threshold for collision warning in dense traffic by reducing the warning distance based on the vehicle speed.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 5.0f;  // Threshold at high speed in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 3.0f;  // Threshold at low speed in meters\nconst float TRAFFIC_DENSITY = 0.7f;  // Simulated traffic density (0 to 1)\n\n// Function to check collision risk based on speed and traffic density\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    // Adjust threshold based on speed and traffic density\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    if (TRAFFIC_DENSITY > 0.6f) {\n        threshold = COLLISION_THRESHOLD_LOW_SPEED;  // Tighter threshold in dense traffic\n    }\n    return objectDistance < threshold;  // Check if object is too close based on adjusted threshold\n}\n\nint main() {\n    float vehicleSpeed = 40.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that incorporates lane departure detection to adjust collision warning behavior.",
      "input": "Integrate lane departure detection data to adjust the threshold and urgency of collision warnings, increasing the risk when the vehicle is leaving its lane.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_DEPARTURE = 4.0f;  // Threshold when lane departure is detected\nconst float COLLISION_THRESHOLD_NORMAL = 5.0f;  // Normal threshold\n\n// Function to check collision risk with lane departure data\nbool isCollisionRisk(bool isLaneDepartureDetected, float objectDistance) {\n    float threshold = isLaneDepartureDetected ? COLLISION_THRESHOLD_LANE_DEPARTURE : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if object distance is less than adjusted threshold\n}\n\nint main() {\n    bool isLaneDepartureDetected = true;  // Simulate lane departure detection\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isLaneDepartureDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO LANE DEPARTURE!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts pedestrian collisions by detecting pedestrians and predicting their path relative to the vehicle.",
      "input": "Use pedestrian detection data and predict their future path, adjusting the collision warning if the predicted path intersects with the vehicle\u2019s trajectory.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // Collision threshold in meters\n\n// Function to predict pedestrian's future position\nfloat predictPedestrianPosition(float pedestrianDistance, float pedestrianVelocity, float time) {\n    return pedestrianDistance + pedestrianVelocity * time;  // Predict future position based on velocity\n}\n\nint main() {\n    float pedestrianDistance = 10.0f;  // Distance to pedestrian in meters\n    float pedestrianVelocity = 1.5f;  // Pedestrian velocity in meters per second\n    float predictionTime = 3.0f;  // Time to predict in seconds\n\n    float predictedPedestrianPosition = predictPedestrianPosition(pedestrianDistance, pedestrianVelocity, predictionTime);\n\n    std::cout << \"Predicted Pedestrian Position after \" << predictionTime << \" seconds: \" << predictedPedestrianPosition << \" meters\" << std::endl;\n\n    if (predictedPedestrianPosition < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on vehicle weight and cargo.",
      "input": "Consider the weight and cargo data to adjust the threshold for collision warning, increasing the warning distance for heavier vehicles with more cargo.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BASE_COLLISION_THRESHOLD = 5.0f;  // Base collision threshold in meters\nconst float WEIGHT_THRESHOLD = 2000.0f;  // Weight threshold for heavier vehicles in kg\nconst float CARGO_THRESHOLD = 500.0f;  // Cargo threshold in kg\n\n// Function to check collision risk based on vehicle weight and cargo\nbool isCollisionRisk(float vehicleWeight, float cargoWeight, float objectDistance) {\n    float threshold = BASE_COLLISION_THRESHOLD;\n    if (vehicleWeight > WEIGHT_THRESHOLD || cargoWeight > CARGO_THRESHOLD) {\n        threshold += 2.0f;  // Increase threshold for heavier vehicles and cargo\n    }\n    return objectDistance < threshold;  // Check if object is within threshold\n}\n\nint main() {\n    float vehicleWeight = 2500.0f;  // Vehicle weight in kg\n    float cargoWeight = 600.0f;  // Cargo weight in kg\n    float objectDistance = 6.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Weight: \" << vehicleWeight << \" kg\" << std::endl;\n    std::cout << \"Cargo Weight: \" << cargoWeight << \" kg\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleWeight, cargoWeight, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO VEHICLE WEIGHT AND CARGO!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on pedestrian detection and vehicle speed.",
      "input": "Adjust the collision warning threshold when a pedestrian is detected, considering the vehicle's speed to trigger earlier warnings at higher speeds.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN_SLOW = 5.0f;  // Threshold for slow speed in meters\nconst float COLLISION_THRESHOLD_PEDESTRIAN_FAST = 3.0f;  // Threshold for fast speed in meters\n\n// Function to check collision risk based on pedestrian detection and vehicle speed\nbool isPedestrianCollisionRisk(bool isPedestrianDetected, float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_PEDESTRIAN_FAST : COLLISION_THRESHOLD_PEDESTRIAN_SLOW;\n    return isPedestrianDetected && objectDistance < threshold;  // Check if pedestrian is detected and object is too close\n}\n\n// Test case\nint main() {\n    bool isPedestrianDetected = true;  // Simulated pedestrian detection\n    float vehicleSpeed = 60.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to detected pedestrian in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(isPedestrianDetected, vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the night mode sensor input.",
      "input": "Consider the night mode sensor to decrease the collision warning threshold at night for better visibility and reaction time.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_DAY = 10.0f;  // Threshold during day in meters\nconst float COLLISION_THRESHOLD_NIGHT = 5.0f;  // Threshold during night in meters\n\n// Function to check collision risk based on night mode detection\nbool isCollisionRisk(bool isNightMode, float objectDistance) {\n    float threshold = isNightMode ? COLLISION_THRESHOLD_NIGHT : COLLISION_THRESHOLD_DAY;\n    return objectDistance < threshold;  // Check if object is too close for night mode\n}\n\n// Test case\nint main() {\n    bool isNightMode = true;  // Simulate night mode based on sensor input\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isNightMode, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers an alert if a lane change is detected and a vehicle is too close.",
      "input": "Detect lane changes and trigger a collision warning if a vehicle is detected in the adjacent lane and the distance is too close.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 3.0f;  // Threshold for lane change in meters\n\n// Function to check collision risk during lane change\nbool isLaneChangeCollisionRisk(bool isLaneChangeDetected, float objectDistance) {\n    return isLaneChangeDetected && objectDistance < COLLISION_THRESHOLD_LANE_CHANGE;  // Check if lane change is detected and object is too close\n}\n\n// Test case\nint main() {\n    bool isLaneChangeDetected = true;  // Simulate lane change detection\n    float objectDistance = 2.5f;  // Distance to object in adjacent lane in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeCollisionRisk(isLaneChangeDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DURING LANE CHANGE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that integrates with automatic emergency braking to stop the car when collision risk is detected.",
      "input": "Trigger the automatic emergency braking system when the collision risk exceeds the threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // Collision threshold in meters\n\n// Function to simulate automatic emergency braking\nvoid applyEmergencyBraking() {\n    std::cout << \"Automatic Emergency Braking Activated!\" << std::endl;\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        applyEmergencyBraking();  // Trigger emergency braking\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning based on detected speed limits.",
      "input": "Integrate speed limit detection to modify the collision warning threshold when approaching a zone with reduced speed limits.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_NORMAL = 10.0f;  // Normal collision threshold in meters\nconst float COLLISION_THRESHOLD_SPEED_LIMIT = 6.0f;  // Adjusted threshold in reduced speed zones\n\n// Function to check collision risk based on speed limit zone\nbool isCollisionRisk(bool isSpeedLimitDetected, float objectDistance) {\n    float threshold = isSpeedLimitDetected ? COLLISION_THRESHOLD_SPEED_LIMIT : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if object is too close based on adjusted threshold\n}\n\n// Test case\nint main() {\n    bool isSpeedLimitDetected = true;  // Simulate speed limit detection\n    float objectDistance = 5.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isSpeedLimitDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO SPEED LIMIT!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold based on the detected vehicle type (e.g., truck, car).",
      "input": "Adjust the collision warning threshold when detecting different types of vehicles (truck vs. car) for better risk assessment.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CAR = 5.0f;  // Threshold for cars in meters\nconst float COLLISION_THRESHOLD_TRUCK = 8.0f;  // Threshold for trucks in meters\n\n// Function to check collision risk based on vehicle type\nbool isCollisionRisk(std::string vehicleType, float objectDistance) {\n    float threshold = (vehicleType == \"truck\") ? COLLISION_THRESHOLD_TRUCK : COLLISION_THRESHOLD_CAR;\n    return objectDistance < threshold;  // Check if object distance is less than threshold\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"truck\";  // Simulate detection of a truck\n    float objectDistance = 6.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH VEHICLE TYPE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on weather conditions.",
      "input": "Adjust the collision warning threshold during adverse weather conditions (e.g., rain, fog) to trigger warnings at a closer distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_NORMAL = 10.0f;  // Normal threshold in meters\nconst float COLLISION_THRESHOLD_WEATHER = 5.0f;  // Reduced threshold in adverse weather\n\n// Function to check collision risk based on weather condition\nbool isCollisionRisk(bool isAdverseWeather, float objectDistance) {\n    float threshold = isAdverseWeather ? COLLISION_THRESHOLD_WEATHER : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if object is too close in adverse weather\n}\n\n// Test case\nint main() {\n    bool isAdverseWeather = true;  // Simulate adverse weather (rain or fog)\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isAdverseWeather, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO WEATHER!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the threshold for pedestrian and vehicle collision risk based on distance to the object.",
      "input": "Decrease the collision warning threshold as the vehicle approaches an object (pedestrian or other vehicle).",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_NEAR = 3.0f;  // Threshold for close objects in meters\nconst float COLLISION_THRESHOLD_FAR = 8.0f;  // Threshold for farther objects in meters\n\n// Function to check collision risk based on distance\nbool isCollisionRisk(float objectDistance) {\n    float threshold = (objectDistance < 5.0f) ? COLLISION_THRESHOLD_NEAR : COLLISION_THRESHOLD_FAR;\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that dynamically adjusts the collision warning threshold based on the vehicle's speed.",
      "input": "If the vehicle's speed exceeds 80 km/h, reduce the collision warning threshold to account for faster closing rates.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_SLOW = 15.0f;  // Threshold for slow speeds in meters\nconst float COLLISION_THRESHOLD_FAST = 5.0f;  // Threshold for fast speeds in meters\n\n// Function to check collision risk based on speed\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 80.0f) ? COLLISION_THRESHOLD_FAST : COLLISION_THRESHOLD_SLOW;\n    return objectDistance < threshold;  // Check if object is too close based on vehicle speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 90.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold depending on the type of object (pedestrian, vehicle, cyclist).",
      "input": "Set a higher warning threshold for pedestrians and cyclists, while using a lower threshold for vehicles to allow quicker responses.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_CYCLIST = 5.0f;  // Threshold for cyclists in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 2.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk based on object type\nbool isCollisionRisk(std::string objectType, float objectDistance) {\n    float threshold;\n    if (objectType == \"pedestrian\") {\n        threshold = COLLISION_THRESHOLD_PEDESTRIAN;\n    } else if (objectType == \"cyclist\") {\n        threshold = COLLISION_THRESHOLD_CYCLIST;\n    } else {\n        threshold = COLLISION_THRESHOLD_VEHICLE;\n    }\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Object type (e.g., vehicle, pedestrian, cyclist)\n    float objectDistance = 1.5f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the warning threshold based on road curvature.",
      "input": "If road curvature is detected, reduce the collision threshold to account for reduced stopping distances.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_STRAIGHT = 10.0f;  // Threshold for straight road in meters\nconst float COLLISION_THRESHOLD_CURVED = 5.0f;  // Threshold for curved road in meters\n\n// Function to check collision risk based on road curvature\nbool isCollisionRisk(bool isCurvedRoad, float objectDistance) {\n    float threshold = isCurvedRoad ? COLLISION_THRESHOLD_CURVED : COLLISION_THRESHOLD_STRAIGHT;\n    return objectDistance < threshold;  // Check if object is too close based on road curvature\n}\n\n// Test case\nint main() {\n    bool isCurvedRoad = true;  // Simulate road curvature detection\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Road Curvature: \" << (isCurvedRoad ? \"Curved\" : \"Straight\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isCurvedRoad, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on fog detection.",
      "input": "When fog is detected, reduce the collision threshold to allow quicker response times due to limited visibility.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CLEAR = 15.0f;  // Threshold for clear visibility in meters\nconst float COLLISION_THRESHOLD_FOG = 5.0f;  // Reduced threshold in foggy conditions\n\n// Function to check collision risk based on fog detection\nbool isCollisionRisk(bool isFogDetected, float objectDistance) {\n    float threshold = isFogDetected ? COLLISION_THRESHOLD_FOG : COLLISION_THRESHOLD_CLEAR;\n    return objectDistance < threshold;  // Check if object is too close in fog\n}\n\n// Test case\nint main() {\n    bool isFogDetected = true;  // Simulate fog detection\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Fog Detected: \" << (isFogDetected ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isFogDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK IN FOG!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that prioritizes pedestrians when multiple objects are detected.",
      "input": "If both a vehicle and pedestrian are detected, prioritize the pedestrian for collision warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk, prioritizing pedestrians\nbool isCollisionRisk(std::string objectType, float objectDistance) {\n    if (objectType == \"pedestrian\" && objectDistance < COLLISION_THRESHOLD_PEDESTRIAN) {\n        return true;  // Prioritize pedestrian if close\n    } else if (objectType == \"vehicle\" && objectDistance < COLLISION_THRESHOLD_VEHICLE) {\n        return true;  // Vehicle warning if too close\n    }\n    return false;  // No risk\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Simulate vehicle detection\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the size of the detected object.",
      "input": "Use a larger threshold for smaller objects and a smaller threshold for larger objects to account for different stopping distances.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 5.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 3.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk based on object size\nbool isCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 3.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on size\n}\n\n// Test case\nint main() {\n    float objectSize = 2.5f;  // Size of object in meters\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that differentiates collision risks based on vehicle type.",
      "input": "Trigger a more urgent warning for trucks, while using a more lenient warning for sedans.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_TRUCK = 2.0f;  // Threshold for trucks in meters\nconst float COLLISION_THRESHOLD_SEDAN = 5.0f;  // Threshold for sedans in meters\n\n// Function to check collision risk based on vehicle type\nbool isCollisionRisk(std::string vehicleType, float objectDistance) {\n    float threshold;\n    if (vehicleType == \"truck\") {\n        threshold = COLLISION_THRESHOLD_TRUCK;\n    } else {\n        threshold = COLLISION_THRESHOLD_SEDAN;\n    }\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"truck\";  // Simulate vehicle type detection\n    float objectDistance = 1.8f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH VEHICLE TYPE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that handles multiple objects and triggers individual warnings based on their risk levels.",
      "input": "Detect both a vehicle and pedestrian and trigger different warnings for each object based on their distance.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk for multiple objects\nbool isCollisionRisk(std::string objectType, float objectDistance) {\n    if (objectType == \"pedestrian\" && objectDistance < COLLISION_THRESHOLD_PEDESTRIAN) {\n        return true;  // Collision risk for pedestrians\n    } else if (objectType == \"vehicle\" && objectDistance < COLLISION_THRESHOLD_VEHICLE) {\n        return true;  // Collision risk for vehicles\n    }\n    return false;  // No risk\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Simulate vehicle detection\n    float objectDistance = 4.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision warning based on the speed of a detected object.",
      "input": "If an object is approaching at a high speed, reduce the collision threshold to trigger an earlier warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_SLOW_OBJECT = 10.0f;  // Threshold for slow objects in meters\nconst float COLLISION_THRESHOLD_FAST_OBJECT = 3.0f;  // Threshold for fast objects in meters\n\n// Function to check collision risk based on object speed\nbool isCollisionRisk(float objectSpeed, float objectDistance) {\n    float threshold = (objectSpeed > 20.0f) ? COLLISION_THRESHOLD_FAST_OBJECT : COLLISION_THRESHOLD_SLOW_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on its speed\n}\n\n// Test case\nint main() {\n    float objectSpeed = 25.0f;  // Object speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that combines object type and speed to adjust the collision warning threshold.",
      "input": "For fast-moving vehicles, use a shorter threshold; for pedestrians, use a longer threshold regardless of speed.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_VEHICLE_FAST = 2.0f;  // Threshold for fast vehicles in meters\nconst float COLLISION_THRESHOLD_VEHICLE_SLOW = 5.0f;  // Threshold for slow vehicles in meters\n\n// Function to check collision risk based on object type and speed\nbool isCollisionRisk(std::string objectType, float objectSpeed, float objectDistance) {\n    float threshold;\n    if (objectType == \"pedestrian\") {\n        threshold = COLLISION_THRESHOLD_PEDESTRIAN;\n    } else if (objectSpeed > 20.0f) {\n        threshold = COLLISION_THRESHOLD_VEHICLE_FAST;\n    } else {\n        threshold = COLLISION_THRESHOLD_VEHICLE_SLOW;\n    }\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Object type (pedestrian or vehicle)\n    float objectSpeed = 25.0f;  // Speed of the object in km/h\n    float objectDistance = 1.5f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold based on the size of the detected object.",
      "input": "For larger objects, decrease the threshold to trigger the collision warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 4.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 7.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk based on object size\nbool isCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 2.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on size\n}\n\n// Test case\nint main() {\n    float objectSize = 2.5f;  // Object size in meters\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that calculates the collision risk based on vehicle detection logic and distance.",
      "input": "Trigger the warning when the vehicle is within a certain distance and moving towards the system at a high speed.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_VEHICLE = 3.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk based on vehicle detection logic\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return (vehicleSpeed > 15.0f) && (objectDistance < COLLISION_THRESHOLD_VEHICLE);  // Vehicle approaching fast\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 20.0f;  // Vehicle speed in km/h\n    float objectDistance = 2.5f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that dynamically adjusts the collision warning threshold based on the relative speed of the vehicle and the detected object.",
      "input": "If the relative speed exceeds a threshold, reduce the collision threshold to trigger the warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_SLOW_RELATIVE_SPEED = 8.0f;  // Threshold for slow relative speed in meters\nconst float COLLISION_THRESHOLD_FAST_RELATIVE_SPEED = 4.0f;  // Threshold for fast relative speed in meters\n\n// Function to check collision risk based on relative speed\nbool isCollisionRisk(float relativeSpeed, float objectDistance) {\n    float threshold = (relativeSpeed > 25.0f) ? COLLISION_THRESHOLD_FAST_RELATIVE_SPEED : COLLISION_THRESHOLD_SLOW_RELATIVE_SPEED;\n    return objectDistance < threshold;  // Check if object is too close based on relative speed\n}\n\n// Test case\nint main() {\n    float relativeSpeed = 30.0f;  // Relative speed between vehicle and object in km/h\n    float objectDistance = 3.5f;  // Distance to object in meters\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(relativeSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that specifically checks for pedestrians in the detection zone and triggers a warning accordingly.",
      "input": "Use a smaller threshold for pedestrians due to their smaller size and faster response time required.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 2.0f;  // Threshold for pedestrians in meters\n\n// Function to check collision risk for pedestrians\nbool isPedestrianCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Pedestrian risk detection\n}\n\n// Test case\nint main() {\n    float objectDistance = 1.8f;  // Distance to pedestrian in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that calculates the time to collision and adjusts the warning level accordingly.",
      "input": "If the time to collision is less than 2 seconds, trigger an urgent warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_URGENT = 2.0f;  // Urgent warning threshold in seconds\nconst float COLLISION_THRESHOLD_NORMAL = 5.0f;  // Normal warning threshold in seconds\n\n// Function to check collision risk based on time to collision\nbool isUrgentCollisionRisk(float timeToCollision) {\n    return timeToCollision < COLLISION_THRESHOLD_URGENT;  // Urgent warning if time to collision is less than threshold\n}\n\n// Test case\nint main() {\n    float timeToCollision = 1.5f;  // Time to collision in seconds\n\n    std::cout << \"Time to Collision: \" << timeToCollision << \" seconds\" << std::endl;\n\n    if (isUrgentCollisionRisk(timeToCollision)) {\n        std::cout << \"WARNING: URGENT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Urgent Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high-speed vehicles and triggers a warning based on their relative velocity.",
      "input": "If the vehicle is approaching at a high relative speed, trigger an earlier warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 2.0f;  // Threshold for high-speed vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL_SPEED = 5.0f;  // Threshold for normal-speed vehicles in meters\n\n// Function to check collision risk based on relative speed\nbool isHighSpeedVehicleRisk(float relativeSpeed, float objectDistance) {\n    float threshold = (relativeSpeed > 25.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_NORMAL_SPEED;\n    return objectDistance < threshold;  // Check if vehicle is too close at high speed\n}\n\n// Test case\nint main() {\n    float relativeSpeed = 30.0f;  // Relative speed in km/h\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isHighSpeedVehicleRisk(relativeSpeed, objectDistance)) {\n        std::cout << \"WARNING: HIGH SPEED VEHICLE COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No High-Speed Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if the detected vehicle is braking while approaching.",
      "input": "If the vehicle is braking, trigger a collision warning with a reduced distance threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_BRAKING_VEHICLE = 2.0f;  // Threshold for braking vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL = 5.0f;  // Normal threshold for non-braking vehicles\n\n// Function to check collision risk for braking vehicles\nbool isBrakingVehicleRisk(bool isBraking, float objectDistance) {\n    float threshold = (isBraking) ? COLLISION_THRESHOLD_BRAKING_VEHICLE : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if vehicle is too close when braking\n}\n\n// Test case\nint main() {\n    bool isBraking = true;  // Vehicle is braking\n    float objectDistance = 2.5f;  // Distance to braking vehicle in meters\n\n    std::cout << \"Is Vehicle Braking: \" << (isBraking ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isBrakingVehicleRisk(isBraking, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH BRAKING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Braking Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses time to collision to determine the urgency of the warning.",
      "input": "If the time to collision is less than 3 seconds, trigger a high-priority warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_PRIORITY = 3.0f;  // Time threshold for high priority warning in seconds\nconst float COLLISION_THRESHOLD_LOW_PRIORITY = 5.0f;  // Time threshold for low priority warning in seconds\n\n// Function to check collision risk based on time to collision\nbool isUrgentCollisionRisk(float timeToCollision) {\n    return timeToCollision < COLLISION_THRESHOLD_HIGH_PRIORITY;  // Urgent risk if time to collision is less than threshold\n}\n\n// Test case\nint main() {\n    float timeToCollision = 2.5f;  // Time to collision in seconds\n\n    std::cout << \"Time to Collision: \" << timeToCollision << \" seconds\" << std::endl;\n\n    if (isUrgentCollisionRisk(timeToCollision)) {\n        std::cout << \"WARNING: URGENT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Urgent Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision warning based on vehicle type (e.g., truck vs. car).",
      "input": "If the detected vehicle is a truck, set a longer warning threshold.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_CAR = 5.0f;  // Threshold for cars in meters\nconst float COLLISION_THRESHOLD_TRUCK = 10.0f;  // Threshold for trucks in meters\n\n// Function to check collision risk based on vehicle type\nbool isCollisionRisk(std::string vehicleType, float objectDistance) {\n    float threshold = (vehicleType == \"truck\") ? COLLISION_THRESHOLD_TRUCK : COLLISION_THRESHOLD_CAR;\n    return objectDistance < threshold;  // Check if vehicle is too close based on type\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"truck\";  // Vehicle type (car or truck)\n    float objectDistance = 8.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the size of the detected object.",
      "input": "If the object is large, trigger the collision warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 4.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 6.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk based on object size\nbool isCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 2.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on size\n}\n\n// Test case\nint main() {\n    float objectSize = 3.0f;  // Object size in meters\n    float objectDistance = 3.5f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers an early warning when the relative speed between vehicles is high.",
      "input": "If the relative speed between the own vehicle and a detected object exceeds 30 km/h, trigger a warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed collisions in meters\nconst float COLLISION_THRESHOLD_NORMAL_SPEED = 6.0f;  // Threshold for normal-speed collisions in meters\n\n// Function to check collision risk based on relative speed\nbool isHighSpeedCollisionRisk(float relativeSpeed, float objectDistance) {\n    float threshold = (relativeSpeed > 30.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_NORMAL_SPEED;\n    return objectDistance < threshold;  // Check if object is too close at high relative speed\n}\n\n// Test case\nint main() {\n    float relativeSpeed = 35.0f;  // Relative speed in km/h\n    float objectDistance = 2.5f;  // Distance to object in meters\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isHighSpeedCollisionRisk(relativeSpeed, objectDistance)) {\n        std::cout << \"WARNING: HIGH SPEED COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No High-Speed Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that specifically detects pedestrians and triggers a collision warning accordingly.",
      "input": "If a pedestrian is detected and within a distance of 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\n\n// Function to check collision risk for pedestrians\nbool isPedestrianCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Pedestrian risk detection\n}\n\n// Test case\nint main() {\n    float objectDistance = 2.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks if a detected vehicle is braking and adjusts the collision threshold accordingly.",
      "input": "If the detected vehicle is braking, use a shorter collision threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_BRAKING = 3.0f;  // Threshold for braking vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL = 6.0f;  // Normal threshold for non-braking vehicles in meters\n\n// Function to check collision risk based on braking\nbool isBrakingCollisionRisk(bool isBraking, float objectDistance) {\n    float threshold = (isBraking) ? COLLISION_THRESHOLD_BRAKING : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if vehicle is too close when braking\n}\n\n// Test case\nint main() {\n    bool isBraking = true;  // Braking condition\n    float objectDistance = 3.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Is Vehicle Braking: \" << (isBraking ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isBrakingCollisionRisk(isBraking, objectDistance)) {\n        std::cout << \"WARNING: VEHICLE IS BRAKING! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Braking Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if the vehicle in the adjacent lane is changing lanes.",
      "input": "If the adjacent vehicle is detected as changing lanes, check if it's within a critical distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 4.0f;  // Threshold for lane-change collision in meters\n\n// Function to check collision risk with lane-changing vehicle\nbool isLaneChangeCollisionRisk(bool isChangingLane, float objectDistance) {\n    return (isChangingLane && objectDistance < COLLISION_THRESHOLD_LANE_CHANGE);  // Check if vehicle is changing lanes and too close\n}\n\n// Test case\nint main() {\n    bool isChangingLane = true;  // Lane change condition\n    float objectDistance = 3.5f;  // Distance to lane-changing vehicle in meters\n\n    std::cout << \"Is Vehicle Changing Lane: \" << (isChangingLane ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeCollisionRisk(isChangingLane, objectDistance)) {\n        std::cout << \"WARNING: VEHICLE IS CHANGING LANE! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision detection based on the speed of the object detected.",
      "input": "If the object is moving at high speed, trigger a warning if it is within a closer distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_FAST_OBJECT = 3.0f;  // Threshold for fast-moving objects in meters\nconst float COLLISION_THRESHOLD_SLOW_OBJECT = 6.0f;  // Threshold for slow-moving objects in meters\n\n// Function to check collision risk based on object speed\nbool isFastObjectCollisionRisk(float objectSpeed, float objectDistance) {\n    float threshold = (objectSpeed > 20.0f) ? COLLISION_THRESHOLD_FAST_OBJECT : COLLISION_THRESHOLD_SLOW_OBJECT;\n    return objectDistance < threshold;  // Check if fast object is too close\n}\n\n// Test case\nint main() {\n    float objectSpeed = 25.0f;  // Object speed in km/h\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isFastObjectCollisionRisk(objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: FAST OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Fast Object Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a collision warning if the detected vehicle is turning and within a certain distance.",
      "input": "If the detected vehicle is turning, reduce the threshold distance for collision detection.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_TURNING = 3.0f;  // Threshold for turning vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL = 6.0f;  // Normal threshold for non-turning vehicles\n\n// Function to check collision risk for turning vehicles\nbool isTurningVehicleRisk(bool isTurning, float objectDistance) {\n    float threshold = (isTurning) ? COLLISION_THRESHOLD_TURNING : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if vehicle is turning and too close\n}\n\n// Test case\nint main() {\n    bool isTurning = true;  // Vehicle is turning\n    float objectDistance = 2.5f;  // Distance to turning vehicle in meters\n\n    std::cout << \"Is Vehicle Turning: \" << (isTurning ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isTurningVehicleRisk(isTurning, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH TURNING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Turning Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning based on the direction of a detected object (e.g., moving towards or away from the vehicle).",
      "input": "If the detected object is moving toward the vehicle and within a specific distance, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_APPROACHING = 3.0f;  // Threshold for objects approaching the vehicle in meters\nconst float COLLISION_THRESHOLD_RECEDING = 6.0f;  // Threshold for receding objects in meters\n\n// Function to check collision risk based on object direction\nbool isApproachingCollisionRisk(std::string objectDirection, float objectDistance) {\n    float threshold = (objectDirection == \"approaching\") ? COLLISION_THRESHOLD_APPROACHING : COLLISION_THRESHOLD_RECEDING;\n    return objectDistance < threshold;  // Check if object is too close based on direction\n}\n\n// Test case\nint main() {\n    std::string objectDirection = \"approaching\";  // Object's direction\n    float objectDistance = 2.5f;  // Distance to object in meters\n\n    std::cout << \"Object Direction: \" << objectDirection << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isApproachingCollisionRisk(objectDirection, objectDistance)) {\n        std::cout << \"WARNING: APPROACHING OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if a detected vehicle is too close and changing lanes towards your vehicle.",
      "input": "If a vehicle is in the adjacent lane and moving towards your lane, trigger a warning when it is within a specific threshold.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 4.0f;  // Threshold for lane change collision risk in meters\n\n// Function to check lane change collision risk\nbool isLaneChangeRisk(bool isMovingTowards, float objectDistance) {\n    return isMovingTowards && objectDistance < COLLISION_THRESHOLD_LANE_CHANGE;  // Check if object is too close while moving towards the lane\n}\n\n// Test case\nint main() {\n    bool isMovingTowards = true;  // Vehicle moving towards own lane\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Is Vehicle Moving Towards Lane: \" << (isMovingTowards ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeRisk(isMovingTowards, objectDistance)) {\n        std::cout << \"WARNING: VEHICLE CHANGING LANES TOWARDS YOU! COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks the movement speed of pedestrians and triggers a warning based on their speed and proximity.",
      "input": "If the pedestrian is moving fast and within 2 meters, trigger a collision warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN_FAST = 2.0f;  // Threshold for fast-moving pedestrians in meters\nconst float COLLISION_THRESHOLD_PEDESTRIAN_SLOW = 4.0f;  // Threshold for slow-moving pedestrians in meters\n\n// Function to check collision risk with pedestrian\nbool isPedestrianCollisionRisk(float pedestrianSpeed, float objectDistance) {\n    float threshold = (pedestrianSpeed > 3.0f) ? COLLISION_THRESHOLD_PEDESTRIAN_FAST : COLLISION_THRESHOLD_PEDESTRIAN_SLOW;\n    return objectDistance < threshold;  // Check if pedestrian is too close\n}\n\n// Test case\nint main() {\n    float pedestrianSpeed = 4.5f;  // Pedestrian speed in meters/second\n    float objectDistance = 1.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Pedestrian Speed: \" << pedestrianSpeed << \" m/s\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning based on the speed of the own vehicle.",
      "input": "If the vehicle speed exceeds 50 km/h, use a shorter collision threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed own vehicle in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;  // Threshold for low-speed own vehicle in meters\n\n// Function to check collision risk based on own vehicle speed\nbool isOwnVehicleSpeedRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return objectDistance < threshold;  // Check if vehicle is too close based on speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 55.0f;  // Own vehicle speed in km/h\n    float objectDistance = 2.5f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isOwnVehicleSpeedRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects large objects and triggers a warning if they are within a short distance.",
      "input": "If the detected object is larger than 2 meters and within 5 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 5.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 8.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk with large object\nbool isLargeObjectCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 2.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if large object is too close\n}\n\n// Test case\nint main() {\n    float objectSize = 3.0f;  // Object size in meters\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLargeObjectCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH LARGE OBJECT!\" << std::endl;\n    } else {\n        std::cout << \"No Large Object Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks if two vehicles in adjacent lanes are getting too close, triggering a warning.",
      "input": "If both vehicles are within a critical distance and moving towards each other, trigger a collision warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_ADJACENT_VEHICLES = 3.5f;  // Threshold for adjacent vehicles in meters\n\n// Function to check collision risk with two adjacent vehicles\nbool isAdjacentVehicleCollisionRisk(float vehicle1Distance, float vehicle2Distance) {\n    return (vehicle1Distance < COLLISION_THRESHOLD_ADJACENT_VEHICLES && vehicle2Distance < COLLISION_THRESHOLD_ADJACENT_VEHICLES);  // Check if both vehicles are too close\n}\n\n// Test case\nint main() {\n    float vehicle1Distance = 3.0f;  // Distance to first vehicle in meters\n    float vehicle2Distance = 2.5f;  // Distance to second vehicle in meters\n\n    std::cout << \"Vehicle 1 Distance: \" << vehicle1Distance << \" meters\" << std::endl;\n    std::cout << \"Vehicle 2 Distance: \" << vehicle2Distance << \" meters\" << std::endl;\n\n    if (isAdjacentVehicleCollisionRisk(vehicle1Distance, vehicle2Distance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH ADJACENT VEHICLES!\" << std::endl;\n    } else {\n        std::cout << \"No Adjacent Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a collision warning when multiple objects are detected within a short distance.",
      "input": "If two or more objects are within a certain threshold distance, trigger a warning.",
      "output": "#include <iostream>\n#include <vector>\n\nconst float COLLISION_THRESHOLD_MULTIPLE_OBJECTS = 3.0f;  // Threshold for multiple objects in meters\n\n// Function to check collision risk with multiple objects\nbool areMultipleObjectsCollisionRisk(std::vector<float> objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD_MULTIPLE_OBJECTS) {\n            return true;  // If any object is too close\n        }\n    }\n    return false;\n}\n\n// Test case\nint main() {\n    std::vector<float> objectDistances = {3.0f, 2.5f, 4.0f};  // Distances to multiple objects in meters\n\n    if (areMultipleObjectsCollisionRisk(objectDistances)) {\n        std::cout << \"WARNING: MULTIPLE OBJECTS COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Multiple Objects Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that takes into account traffic light status for collision risk.",
      "input": "If the traffic light is red and an object is approaching within a short distance, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_RED_LIGHT = 2.0f;  // Threshold for objects approaching with red light in meters\n\n// Function to check collision risk with traffic light status\nbool isRedLightCollisionRisk(bool isRedLight, float objectDistance) {\n    return (isRedLight && objectDistance < COLLISION_THRESHOLD_RED_LIGHT);  // Check if traffic light is red and object is too close\n}\n\n// Test case\nint main() {\n    bool isRedLight = true;  // Traffic light status\n    float objectDistance = 1.5f;  // Distance to object in meters\n\n    std::cout << \"Traffic Light Status: \" << (isRedLight ? \"Red\" : \"Green\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isRedLightCollisionRisk(isRedLight, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH OBJECT AT RED LIGHT!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision detection based on object size and speed.",
      "input": "For larger and faster objects, trigger a warning if they are within a shorter distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_FAST_OBJECT = 3.0f;  // Threshold for large and fast objects in meters\nconst float COLLISION_THRESHOLD_NORMAL_OBJECT = 6.0f;  // Threshold for normal objects in meters\n\n// Function to check collision risk based on object size and speed\nbool isLargeFastObjectCollisionRisk(float objectSize, float objectSpeed, float objectDistance) {\n    float threshold = (objectSize > 2.0f && objectSpeed > 20.0f) ? COLLISION_THRESHOLD_LARGE_FAST_OBJECT : COLLISION_THRESHOLD_NORMAL_OBJECT;\n    return objectDistance < threshold;  // Check if large and fast object is too close\n}\n\n// Test case\nint main() {\n    float objectSize = 3.5f;  // Object size in meters\n    float objectSpeed = 25.0f;  // Object speed in km/h\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLargeFastObjectCollisionRisk(objectSize, objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: LARGE AND FAST OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning based on the speed of an approaching object. If the object is approaching at high speed and within a certain distance, trigger a warning.",
      "input": "If the object's speed is greater than 30 km/h and the object is within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed objects in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 5.0f;  // Threshold for low-speed objects in meters\n\n// Function to check collision risk based on object speed\nbool isObjectSpeedRisk(float objectSpeed, float objectDistance) {\n    float threshold = (objectSpeed > 30.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return objectDistance < threshold;  // Check if object is too close based on speed\n}\n\n// Test case\nint main() {\n    float objectSpeed = 35.0f;  // Object speed in km/h\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isObjectSpeedRisk(objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: HIGH-SPEED OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a vehicle in front that has come to a stop and triggers a warning if the vehicle is too close.",
      "input": "If the vehicle in front has stopped and the distance is less than 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_STOPPED_VEHICLE = 3.0f;  // Threshold for stopped vehicle in meters\n\n// Function to check collision risk with stopped vehicle\nbool isStoppedVehicleCollisionRisk(bool isStopped, float vehicleDistance) {\n    return isStopped && vehicleDistance < COLLISION_THRESHOLD_STOPPED_VEHICLE;  // Check if stopped vehicle is too close\n}\n\n// Test case\nint main() {\n    bool isStopped = true;  // Vehicle status (stopped)\n    float vehicleDistance = 2.5f;  // Distance to stopped vehicle in meters\n\n    std::cout << \"Is Vehicle Stopped: \" << (isStopped ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isStoppedVehicleCollisionRisk(isStopped, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH STOPPED VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks pedestrian collision risk when a pedestrian is near a crosswalk and within a specific distance.",
      "input": "If a pedestrian is near the crosswalk and within 2 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 2.0f;  // Threshold for pedestrian in meters\n\n// Function to check pedestrian collision risk near crosswalk\nbool isPedestrianCollisionRisk(bool isNearCrosswalk, float pedestrianDistance) {\n    return isNearCrosswalk && pedestrianDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Check if pedestrian is too close near crosswalk\n}\n\n// Test case\nint main() {\n    bool isNearCrosswalk = true;  // Pedestrian near crosswalk\n    float pedestrianDistance = 1.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Pedestrian Near Crosswalk: \" << (isNearCrosswalk ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(isNearCrosswalk, pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN NEAR CROSSWALK!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if objects in a traffic jam are too close.",
      "input": "If multiple objects are within 2 meters in a traffic jam, trigger a collision warning.",
      "output": "#include <iostream>\n#include <vector>\n\nconst float COLLISION_THRESHOLD_TRAFFIC_JAM = 2.0f;  // Threshold for objects in traffic jam in meters\n\n// Function to check collision risk with multiple objects in traffic jam\nbool isTrafficJamCollisionRisk(std::vector<float> objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD_TRAFFIC_JAM) {\n            return true;  // If any object is too close\n        }\n    }\n    return false;\n}\n\n// Test case\nint main() {\n    std::vector<float> objectDistances = {1.5f, 3.0f, 1.8f};  // Distances to objects in meters\n\n    if (isTrafficJamCollisionRisk(objectDistances)) {\n        std::cout << \"WARNING: COLLISION RISK IN TRAFFIC JAM!\" << std::endl;\n    } else {\n        std::cout << \"No Traffic Jam Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks collision risk based on object type (e.g., vehicle, motorcycle).",
      "input": "If the object is a motorcycle and is within 2 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_MOTORCYCLE = 2.0f;  // Threshold for motorcycle collision risk in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicle collision risk in meters\n\n// Function to check collision risk based on object type\nbool isObjectCollisionRisk(std::string objectType, float objectDistance) {\n    float threshold = (objectType == \"motorcycle\") ? COLLISION_THRESHOLD_MOTORCYCLE : COLLISION_THRESHOLD_VEHICLE;\n    return objectDistance < threshold;  // Check if object is too close based on type\n}\n\n// Test case\nint main() {\n    std::string objectType = \"motorcycle\";  // Object type\n    float objectDistance = 1.8f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isObjectCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH MOTORCYCLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a cyclist and triggers a warning if the cyclist is within a short distance.",
      "input": "If the cyclist is within 1.5 meters, trigger a collision warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CYCLIST = 1.5f;  // Threshold for cyclist collision risk in meters\n\n// Function to check collision risk with cyclist\nbool isCyclistCollisionRisk(float cyclistDistance) {\n    return cyclistDistance < COLLISION_THRESHOLD_CYCLIST;  // Check if cyclist is too close\n}\n\n// Test case\nint main() {\n    float cyclistDistance = 1.2f;  // Distance to cyclist in meters\n\n    std::cout << \"Cyclist Distance: \" << cyclistDistance << \" meters\" << std::endl;\n\n    if (isCyclistCollisionRisk(cyclistDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH CYCLIST!\" << std::endl;\n    } else {\n        std::cout << \"No Cyclist Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that considers lane changes and triggers a warning if a collision risk arises during a lane change.",
      "input": "If the vehicle is changing lanes and the other vehicle is within 3 meters in the adjacent lane, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 3.0f;  // Threshold for lane change collision risk in meters\n\n// Function to check collision risk during lane change\nbool isLaneChangeCollisionRisk(bool isLaneChange, float adjacentVehicleDistance) {\n    return isLaneChange && adjacentVehicleDistance < COLLISION_THRESHOLD_LANE_CHANGE;  // Check if lane change creates collision risk\n}\n\n// Test case\nint main() {\n    bool isLaneChange = true;  // Lane change status\n    float adjacentVehicleDistance = 2.8f;  // Distance to vehicle in adjacent lane in meters\n\n    std::cout << \"Is Lane Change: \" << (isLaneChange ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Adjacent Vehicle Distance: \" << adjacentVehicleDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeCollisionRisk(isLaneChange, adjacentVehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DURING LANE CHANGE!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision detection based on the type of vehicle (e.g., SUV, sedan).",
      "input": "For SUVs, trigger a warning if they are within 5 meters. For sedans, trigger a warning if within 3 meters.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_SUV = 5.0f;  // Threshold for SUV collision risk in meters\nconst float COLLISION_THRESHOLD_SEDAN = 3.0f;  // Threshold for sedan collision risk in meters\n\n// Function to check collision risk based on vehicle type\nbool isVehicleCollisionRisk(std::string vehicleType, float vehicleDistance) {\n    float threshold = (vehicleType == \"SUV\") ? COLLISION_THRESHOLD_SUV : COLLISION_THRESHOLD_SEDAN;\n    return vehicleDistance < threshold;  // Check if vehicle is too close based on type\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"SUV\";  // Vehicle type\n    float vehicleDistance = 4.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isVehicleCollisionRisk(vehicleType, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH SUV!\" << std::endl;\n    } else {\n        std::cout << \"No Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that activates the emergency braking system when an object is detected within 1 meter.",
      "input": "If the distance to an object is less than 1 meter, trigger emergency braking.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float EMERGENCY_BRAKING_THRESHOLD = 1.0f;  // Threshold for emergency braking in meters\n\n// Function to check if emergency braking is needed\nbool isEmergencyBrakingNeeded(float objectDistance) {\n    return objectDistance < EMERGENCY_BRAKING_THRESHOLD;  // Trigger braking if distance is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 0.8f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isEmergencyBrakingNeeded(objectDistance)) {\n        std::cout << \"WARNING: EMERGENCY BRAKING ACTIVATED!\" << std::endl;\n    } else {\n        std::cout << \"No Emergency Braking Needed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a collision warning based on the speed of the vehicle ahead. The system should adjust the warning threshold based on the speed of the vehicle.",
      "input": "If the vehicle ahead is traveling at a speed greater than 50 km/h and the distance is less than 5 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LOW_SPEED = 10.0f;  // Threshold for low-speed objects in meters\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 5.0f;  // Threshold for high-speed objects in meters\n\n// Function to calculate the collision risk based on speed\nbool isSpeedAdjustedRisk(float vehicleSpeed, float vehicleDistance) {\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return vehicleDistance < threshold;  // Adjust risk based on speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 60.0f;  // Speed of the vehicle ahead in km/h\n    float vehicleDistance = 4.0f;  // Distance to the vehicle ahead in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isSpeedAdjustedRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH FAST VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects moving pedestrians and triggers a collision warning if they are within a specified threshold distance.",
      "input": "If the pedestrian is moving and within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrian collision risk in meters\n\n// Function to check if a pedestrian poses a collision risk\nbool isPedestrianMovingCollisionRisk(bool isMoving, float pedestrianDistance) {\n    return isMoving && pedestrianDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Check if moving pedestrian is too close\n}\n\n// Test case\nint main() {\n    bool isMoving = true;  // Pedestrian is moving\n    float pedestrianDistance = 2.0f;  // Distance to pedestrian in meters\n\n    std::cout << \"Pedestrian Moving: \" << (isMoving ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianMovingCollisionRisk(isMoving, pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH MOVING PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects both motorcycles and vehicles and triggers a collision warning based on their distance.",
      "input": "If the motorcycle is within 2 meters or the vehicle is within 5 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_MOTORCYCLE = 2.0f;  // Threshold for motorcycle collision risk in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicle collision risk in meters\n\n// Function to check collision risk based on vehicle type\nbool isVehicleCollisionRisk(std::string vehicleType, float vehicleDistance) {\n    float threshold = (vehicleType == \"motorcycle\") ? COLLISION_THRESHOLD_MOTORCYCLE : COLLISION_THRESHOLD_VEHICLE;\n    return vehicleDistance < threshold;  // Check if vehicle is too close based on type\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"motorcycle\";  // Vehicle type\n    float vehicleDistance = 1.5f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isVehicleCollisionRisk(vehicleType, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH MOTORCYCLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that updates collision risk as the distance to the object changes. If the distance is below the threshold, trigger a warning.",
      "input": "If the distance to the object falls below 4 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Threshold for collision risk in meters\n\n// Function to check collision risk based on dynamic distance\nbool isDynamicCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 3.5f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isDynamicCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold based on the speed of the vehicle and objects in front.",
      "input": "If the vehicle speed is greater than 60 km/h and the object is within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed vehicle collision risk in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;  // Threshold for low-speed vehicle collision risk in meters\n\n// Function to calculate the collision risk based on vehicle speed\nbool isSpeedBasedRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 60.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return objectDistance < threshold;  // Adjust risk based on vehicle speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 70.0f;  // Speed of the vehicle in km/h\n    float objectDistance = 2.5f;  // Distance to the object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isSpeedBasedRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that calculates collision risk based on the distance to multiple objects in front of the vehicle.",
      "input": "If any of the objects are within 4 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Threshold for collision risk in meters\n\n// Function to check collision risk for multiple objects\nbool isMultipleObjectCollisionRisk(const std::vector<float>& objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD) {\n            return true;  // If any object is too close\n        }\n    }\n    return false;  // No collision risk\n}\n\n// Test case\nint main() {\n    std::vector<float> objectDistances = {5.0f, 3.0f, 6.0f};  // Distances to multiple objects\n\n    if (isMultipleObjectCollisionRisk(objectDistances)) {\n        std::cout << \"WARNING: COLLISION RISK WITH OBJECTS!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle behind is too close and triggers a warning if it is within 2 meters.",
      "input": "If the distance to the rear vehicle is within 2 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float REAR_VEHICLE_COLLISION_THRESHOLD = 2.0f;  // Threshold for rear vehicle collision risk in meters\n\n// Function to check rear vehicle collision risk\nbool isRearVehicleCollisionRisk(float rearVehicleDistance) {\n    return rearVehicleDistance < REAR_VEHICLE_COLLISION_THRESHOLD;  // Check if rear vehicle is too close\n}\n\n// Test case\nint main() {\n    float rearVehicleDistance = 1.5f;  // Distance to rear vehicle in meters\n\n    std::cout << \"Rear Vehicle Distance: \" << rearVehicleDistance << \" meters\" << std::endl;\n\n    if (isRearVehicleCollisionRisk(rearVehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH REAR VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Rear Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a stationary vehicle and triggers a warning if it is too close.",
      "input": "If the vehicle ahead is stationary and within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float STATIONARY_VEHICLE_THRESHOLD = 3.0f;  // Threshold for stationary vehicle collision risk in meters\n\n// Function to check collision risk with a stationary vehicle\nbool isStationaryVehicleCollisionRisk(bool isStationary, float vehicleDistance) {\n    return isStationary && vehicleDistance < STATIONARY_VEHICLE_THRESHOLD;  // Check if stationary vehicle is too close\n}\n\n// Test case\nint main() {\n    bool isStationary = true;  // Vehicle is stationary\n    float vehicleDistance = 2.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Stationary: \" << (isStationary ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isStationaryVehicleCollisionRisk(isStationary, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH STATIONARY VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Stationary Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses real-time data from a camera and speed sensor to trigger a collision warning. If an object is within 5 meters and the vehicle's speed exceeds 60 km/h, trigger a warning.",
      "input": "Real-time data input includes the camera feed for object detection and speed data from a speed sensor.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision threshold in meters\nconst float SPEED_THRESHOLD = 60.0f;  // Speed threshold for warning in km/h\n\n// Function to detect objects in a frame and return the closest object's distance\nfloat detectObjectDistance(cv::Mat &frame) {\n    // Simulate object detection (replace with actual object detection code)\n    return 3.0f;  // Simulate detected object distance of 3 meters\n}\n\n// Function to check collision risk based on speed and object distance\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return vehicleSpeed > SPEED_THRESHOLD && objectDistance < COLLISION_THRESHOLD;\n}\n\n// Test case for real-time data\nint main() {\n    float vehicleSpeed = 75.0f;  // Vehicle speed in km/h\n    cv::Mat frame;  // Capture frame from camera (not implemented here)\n    float objectDistance = detectObjectDistance(frame);  // Get object distance from camera feed\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians in real-time using camera data. If a pedestrian is within 3 meters, trigger a warning.",
      "input": "Real-time camera feed data for pedestrian detection.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float PEDESTRIAN_THRESHOLD = 3.0f;  // Pedestrian collision threshold in meters\n\n// Function to simulate pedestrian detection in the camera feed\nfloat detectPedestrianDistance(cv::Mat &frame) {\n    // Simulate pedestrian detection (replace with actual detection)\n    return 2.5f;  // Simulate detected pedestrian distance of 2.5 meters\n}\n\n// Function to check if there is a collision risk with a pedestrian\nbool isPedestrianCollisionRisk(float pedestrianDistance) {\n    return pedestrianDistance < PEDESTRIAN_THRESHOLD;\n}\n\n// Test case for real-time pedestrian detection\nint main() {\n    cv::Mat frame;  // Capture frame from camera (not implemented here)\n    float pedestrianDistance = detectPedestrianDistance(frame);  // Detect pedestrian in frame\n\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses real-time vehicle speed and distance data from radar to determine collision risk.",
      "input": "Real-time speed and radar data for detecting objects in front of the vehicle.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Threshold for collision risk in meters\n\n// Function to simulate radar object detection\nfloat getRadarObjectDistance() {\n    return 3.5f;  // Simulate object detection at 3.5 meters\n}\n\n// Function to get real-time vehicle speed (simulated)\nfloat getVehicleSpeed() {\n    return 65.0f;  // Simulate vehicle speed of 65 km/h\n}\n\n// Function to determine collision risk based on speed and distance\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return vehicleSpeed > 60.0f && objectDistance < COLLISION_THRESHOLD;  // Collision risk if speed > 60 km/h\n}\n\n// Test case for speed and radar data\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float objectDistance = getRadarObjectDistance();  // Get object distance from radar\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that processes real-time object data (from radar and cameras) to check if any object is within 4 meters.",
      "input": "Real-time data of multiple objects detected by radar and cameras.",
      "output": "#include <iostream>\n#include <vector>\n#include <opencv2/opencv.hpp>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Collision threshold in meters\n\n// Function to simulate object detection (from radar and cameras)\nstd::vector<float> getObjectDistances() {\n    return {3.0f, 6.0f, 2.5f};  // Simulate distances to multiple objects\n}\n\n// Function to check if any object is within collision threshold\nbool isAnyObjectWithinCollisionThreshold(const std::vector<float>& objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD) {\n            return true;  // Return true if any object is within threshold\n        }\n    }\n    return false;  // No object within threshold\n}\n\n// Test case for real-time data processing\nint main() {\n    std::vector<float> objectDistances = getObjectDistances();  // Get object distances from radar and camera\n\n    std::cout << \"Object Distances: \";\n    for (float distance : objectDistances) {\n        std::cout << distance << \" meters \" << std::endl;\n    }\n\n    if (isAnyObjectWithinCollisionThreshold(objectDistances)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if a pedestrian or object is detected within 3 meters.",
      "input": "Real-time object and pedestrian detection data.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // Threshold for collision risk in meters\n\n// Function to simulate object and pedestrian detection in camera feed\nfloat detectObjectOrPedestrian(cv::Mat &frame) {\n    return 2.5f;  // Simulate object/pedestrian detection at 2.5 meters\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD;  // Collision risk if distance is too small\n}\n\n// Test case for real-time object/pedestrian detection\nint main() {\n    cv::Mat frame;  // Capture frame from camera (not implemented)\n    float objectDistance = detectObjectOrPedestrian(frame);  // Get distance to detected object or pedestrian\n\n    std::cout << \"Object/Pedestrian Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if an object is within 5 meters and the vehicle speed exceeds 50 km/h.",
      "input": "Real-time speed and radar object detection data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision threshold in meters\nconst float SPEED_THRESHOLD = 50.0f;  // Speed threshold for warning in km/h\n\n// Function to simulate radar object detection\nfloat getRadarObjectDistance() {\n    return 4.5f;  // Simulate object detection at 4.5 meters\n}\n\n// Function to simulate real-time vehicle speed\nfloat getVehicleSpeed() {\n    return 55.0f;  // Simulate vehicle speed of 55 km/h\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return vehicleSpeed > SPEED_THRESHOLD && objectDistance < COLLISION_THRESHOLD;  // Collision if conditions met\n}\n\n// Test case for real-time vehicle and object detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get real-time vehicle speed\n    float objectDistance = getRadarObjectDistance();  // Get radar object distance\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if a vehicle is detected in front of the car and is stationary within 2 meters.",
      "input": "Real-time vehicle detection and speed data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // Threshold for collision risk with stationary vehicle in meters\n\n// Function to simulate detection of a stationary vehicle\nfloat detectStationaryVehicleDistance() {\n    return 1.5f;  // Simulate detected stationary vehicle at 1.5 meters\n}\n\n// Function to check collision risk with a stationary vehicle\nbool isStationaryVehicleRisk(float vehicleDistance) {\n    return vehicleDistance < COLLISION_THRESHOLD;  // Risk if stationary vehicle is too close\n}\n\n// Test case for stationary vehicle detection\nint main() {\n    float vehicleDistance = detectStationaryVehicleDistance();  // Get distance to stationary vehicle\n\n    std::cout << \"Stationary Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isStationaryVehicleRisk(vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH STATIONARY VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk with Stationary Vehicle.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision risk threshold based on vehicle speed. Higher speed should lower the threshold for collision warning.",
      "input": "Real-time vehicle speed and object distance data.",
      "output": "#include <iostream>\n#include <cmath>\n\n// Function to calculate collision threshold based on speed\nfloat calculateThreshold(float vehicleSpeed) {\n    return 5.0f - (vehicleSpeed / 100.0f);  // Threshold decreases as speed increases\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = calculateThreshold(vehicleSpeed);  // Calculate dynamic threshold\n    return objectDistance < threshold;  // Risk if object distance is less than threshold\n}\n\n// Test case for dynamic threshold\nint main() {\n    float vehicleSpeed = 80.0f;  // Vehicle speed in km/h\n    float objectDistance = 3.0f;  // Object distance in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects tailgating vehicles. If the vehicle behind is within 2 meters and traveling faster, trigger a warning.",
      "input": "Real-time data from rear radar and vehicle speed sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float TAILGATING_THRESHOLD = 2.0f;  // Tailgating threshold in meters\n\n// Function to simulate the detection of a vehicle behind using radar\nfloat getRearVehicleDistance() {\n    return 1.5f;  // Simulate a vehicle 1.5 meters behind\n}\n\n// Function to simulate the vehicle speed\nfloat getVehicleSpeed() {\n    return 70.0f;  // Simulate vehicle speed of 70 km/h\n}\n\n// Function to simulate rear vehicle speed\nfloat getRearVehicleSpeed() {\n    return 80.0f;  // Simulate the rear vehicle speed of 80 km/h\n}\n\n// Function to check tailgating risk\nbool isTailgatingRisk(float vehicleSpeed, float rearVehicleDistance, float rearVehicleSpeed) {\n    return rearVehicleDistance < TAILGATING_THRESHOLD && rearVehicleSpeed > vehicleSpeed;\n}\n\n// Test case for tailgating detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float rearVehicleDistance = getRearVehicleDistance();  // Get distance to vehicle behind\n    float rearVehicleSpeed = getRearVehicleSpeed();  // Get speed of vehicle behind\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Rear Vehicle Distance: \" << rearVehicleDistance << \" meters\" << std::endl;\n    std::cout << \"Rear Vehicle Speed: \" << rearVehicleSpeed << \" km/h\" << std::endl;\n\n    if (isTailgatingRisk(vehicleSpeed, rearVehicleDistance, rearVehicleSpeed)) {\n        std::cout << \"WARNING: TAILGATING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Tailgating Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if a vehicle is stopped in front. If a vehicle in front is stationary within 3 meters, trigger a collision warning.",
      "input": "Real-time data from front radar and vehicle detection cameras.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float STOPPED_VEHICLE_THRESHOLD = 3.0f;  // Threshold in meters for stopped vehicle detection\n\n// Function to simulate front radar detecting a stopped vehicle\nfloat getFrontVehicleDistance() {\n    return 2.5f;  // Simulate stopped vehicle at 2.5 meters\n}\n\n// Function to simulate front vehicle speed\nfloat getFrontVehicleSpeed() {\n    return 0.0f;  // Simulate stationary vehicle (speed 0 km/h)\n}\n\n// Function to check collision risk with a stopped vehicle\nbool isStoppedVehicleRisk(float frontVehicleDistance, float frontVehicleSpeed) {\n    return frontVehicleDistance < STOPPED_VEHICLE_THRESHOLD && frontVehicleSpeed == 0.0f;\n}\n\n// Test case for stopped vehicle detection\nint main() {\n    float frontVehicleDistance = getFrontVehicleDistance();  // Get distance to vehicle in front\n    float frontVehicleSpeed = getFrontVehicleSpeed();  // Get speed of vehicle in front\n\n    std::cout << \"Front Vehicle Distance: \" << frontVehicleDistance << \" meters\" << std::endl;\n    std::cout << \"Front Vehicle Speed: \" << frontVehicleSpeed << \" km/h\" << std::endl;\n\n    if (isStoppedVehicleRisk(frontVehicleDistance, frontVehicleSpeed)) {\n        std::cout << \"WARNING: STOPPED VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Stopped Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians crossing the road. If a pedestrian is within 2 meters, trigger a warning.",
      "input": "Real-time camera feed and pedestrian detection system.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f;  // Pedestrian collision threshold in meters\n\n// Function to simulate pedestrian detection using camera feed\nfloat detectPedestrianDistance(cv::Mat &frame) {\n    return 1.5f;  // Simulate pedestrian detected 1.5 meters ahead\n}\n\n// Function to check pedestrian collision risk\nbool isPedestrianCollisionRisk(float pedestrianDistance) {\n    return pedestrianDistance < PEDESTRIAN_THRESHOLD;  // Collision risk if distance is too small\n}\n\n// Test case for pedestrian detection\nint main() {\n    cv::Mat frame;  // Capture frame from camera (not implemented here)\n    float pedestrianDistance = detectPedestrianDistance(frame);  // Get distance to pedestrian from camera feed\n\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the vehicle's speed. The faster the vehicle, the shorter the collision threshold.",
      "input": "Real-time speed and object distance data.",
      "output": "#include <iostream>\n#include <cmath>\n\n// Function to adjust collision threshold based on vehicle speed\nfloat calculateCollisionThreshold(float vehicleSpeed) {\n    return 5.0f - (vehicleSpeed / 100.0f);  // Adjust threshold: higher speed, shorter threshold\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = calculateCollisionThreshold(vehicleSpeed);  // Adjust threshold based on speed\n    return objectDistance < threshold;  // Collision risk if object is too close\n}\n\n// Test case for speed-adjusted collision risk\nint main() {\n    float vehicleSpeed = 90.0f;  // Vehicle speed in km/h\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects vehicles in the blind spot. If a vehicle is detected within 1.5 meters and approaching, trigger a warning.",
      "input": "Real-time data from side radar and vehicle position sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BLIND_SPOT_THRESHOLD = 1.5f;  // Blind spot detection threshold in meters\n\n// Function to simulate side radar detecting a vehicle in the blind spot\nfloat getBlindSpotVehicleDistance() {\n    return 1.2f;  // Simulate vehicle detected at 1.2 meters in the blind spot\n}\n\n// Function to simulate the vehicle's speed\nfloat getVehicleSpeed() {\n    return 50.0f;  // Simulate vehicle speed of 50 km/h\n}\n\n// Function to check collision risk with vehicle in the blind spot\nbool isBlindSpotRisk(float vehicleSpeed, float vehicleDistance) {\n    return vehicleDistance < BLIND_SPOT_THRESHOLD && vehicleSpeed > 40.0f;  // Risk if vehicle is too close and approaching\n}\n\n// Test case for blind spot detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getBlindSpotVehicleDistance();  // Get distance to vehicle in blind spot\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Blind Spot Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isBlindSpotRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Blind Spot Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians near the sidewalk. If a pedestrian crosses within 2 meters and the vehicle is traveling over 30 km/h, trigger a warning.",
      "input": "Real-time pedestrian detection data and vehicle speed data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f;  // Threshold for pedestrian detection in meters\nconst float VEHICLE_SPEED_THRESHOLD = 30.0f;  // Minimum speed for triggering the warning\n\n// Function to simulate pedestrian distance detection\nfloat detectPedestrianDistance() {\n    return 1.8f;  // Simulate pedestrian at 1.8 meters\n}\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 35.0f;  // Simulate vehicle speed of 35 km/h\n}\n\n// Function to check pedestrian collision risk\nbool isPedestrianCollisionRisk(float vehicleSpeed, float pedestrianDistance) {\n    return vehicleSpeed > VEHICLE_SPEED_THRESHOLD && pedestrianDistance < PEDESTRIAN_THRESHOLD;\n}\n\n// Test case for pedestrian detection near the sidewalk\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get real-time vehicle speed\n    float pedestrianDistance = detectPedestrianDistance();  // Get distance to pedestrian\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(vehicleSpeed, pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN CROSSING!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that dynamically adjusts the collision detection threshold based on the environment (day or night).",
      "input": "Real-time sensor data, vehicle speed, and environmental condition.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float DAY_THRESHOLD = 5.0f;  // Daytime collision threshold in meters\nconst float NIGHT_THRESHOLD = 3.0f;  // Nighttime collision threshold in meters\n\n// Function to simulate environment condition (day or night)\nstd::string getEnvironmentCondition() {\n    return \"day\";  // Simulate daytime condition\n}\n\n// Function to calculate collision threshold based on environment\nfloat calculateDynamicThreshold(std::string environment) {\n    if (environment == \"night\") {\n        return NIGHT_THRESHOLD;  // Shorter threshold at night\n    } else {\n        return DAY_THRESHOLD;  // Longer threshold during the day\n}\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance, std::string environment) {\n    float threshold = calculateDynamicThreshold(environment);  // Calculate dynamic threshold\n    return objectDistance < threshold;  // Collision risk if object is too close\n}\n\n// Test case for dynamic threshold based on environment\nint main() {\n    float vehicleSpeed = 60.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n    std::string environment = getEnvironmentCondition();  // Get environment condition (day or night)\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n    std::cout << \"Environment: \" << environment << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance, environment)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects obstructions in front of the vehicle. If an obstacle is within 3 meters, trigger a warning.",
      "input": "Real-time data from front radar and LIDAR sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float OBSTRUCTION_THRESHOLD = 3.0f;  // Obstruction detection threshold in meters\n\n// Function to simulate front radar detecting an obstruction\nfloat getFrontObstructionDistance() {\n    return 2.5f;  // Simulate obstruction detected 2.5 meters in front\n}\n\n// Function to check for obstruction risk\nbool isObstructionRisk(float obstructionDistance) {\n    return obstructionDistance < OBSTRUCTION_THRESHOLD;\n}\n\n// Test case for obstruction detection\nint main() {\n    float obstructionDistance = getFrontObstructionDistance();  // Get distance to obstruction\n\n    std::cout << \"Obstruction Distance: \" << obstructionDistance << \" meters\" << std::endl;\n\n    if (isObstructionRisk(obstructionDistance)) {\n        std::cout << \"WARNING: FRONT OBSTRUCTION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Obstruction Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden lane departure. If the vehicle drifts more than 0.5 meters outside the lane without signaling, trigger a warning.",
      "input": "Real-time data from lane detection cameras and steering sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f;  // Lane departure threshold in meters\n\n// Function to simulate lane departure detection\nfloat getLaneDeparture() {\n    return 0.6f;  // Simulate lane departure of 0.6 meters\n}\n\n// Function to check lane departure risk\nbool isLaneDepartureRisk(float laneDeparture) {\n    return laneDeparture > LANE_DEPARTURE_THRESHOLD;\n}\n\n// Test case for lane departure detection\nint main() {\n    float laneDeparture = getLaneDeparture();  // Get lane departure distance\n\n    std::cout << \"Lane Departure: \" << laneDeparture << \" meters\" << std::endl;\n\n    if (isLaneDepartureRisk(laneDeparture)) {\n        std::cout << \"WARNING: LANE DEPARTURE!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects driver fatigue based on head movement patterns. If the driver's head remains still for more than 5 seconds, trigger a warning.",
      "input": "Real-time data from in-vehicle camera (for head movement) and time tracking.",
      "output": "#include <iostream>\n#include <ctime>\n\nconst int FATIGUE_THRESHOLD = 5;  // Threshold in seconds for detecting fatigue\n\n// Function to simulate head movement tracking\nbool isDriverAlert() {\n    return false;  // Simulate a still head position for 6 seconds\n}\n\n// Function to check driver fatigue\nbool isDriverFatigued(int elapsedTime) {\n    return elapsedTime > FATIGUE_THRESHOLD;\n}\n\n// Test case for driver fatigue detection\nint main() {\n    int elapsedTime = 6;  // Simulate 6 seconds of no head movement\n\n    std::cout << \"Elapsed Time: \" << elapsedTime << \" seconds\" << std::endl;\n\n    if (isDriverFatigued(elapsedTime)) {\n        std::cout << \"WARNING: DRIVER FATIGUE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"Driver is Alert.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians in front of the vehicle. If a pedestrian is detected within 2 meters, trigger a warning.",
      "input": "Real-time pedestrian detection data from front camera.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f;  // Threshold for pedestrian detection in meters\n\n// Function to simulate pedestrian detection using camera feed\nfloat detectPedestrianDistance(cv::Mat &frame) {\n    return 1.8f;  // Simulate pedestrian at 1.8 meters\n}\n\n// Function to check for pedestrian collision risk\nbool isPedestrianCollisionRisk(float pedestrianDistance) {\n    return pedestrianDistance < PEDESTRIAN_THRESHOLD;\n}\n\n// Test case for pedestrian detection in front of the vehicle\nint main() {\n    cv::Mat frame;  // Simulate frame capture from camera\n    float pedestrianDistance = detectPedestrianDistance(frame);  // Get distance to pedestrian\n\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN IN FRONT!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden braking by the vehicle ahead. If the vehicle in front suddenly brakes and the vehicle is within 3 meters, trigger a warning.",
      "input": "Real-time brake pressure sensor data and vehicle distance sensor data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BRAKE_THRESHOLD = 3.0f;  // Threshold for sudden braking detection in meters\n\n// Function to simulate vehicle brake pressure sensor data\nbool isBrakingSuddenly() {\n    return true;  // Simulate sudden braking event\n}\n\n// Function to simulate distance to the vehicle ahead\nfloat getDistanceToFrontVehicle() {\n    return 2.5f;  // Simulate distance to the vehicle in front\n}\n\n// Function to check for sudden braking risk\nbool isSuddenBrakeRisk(float distance) {\n    return distance < BRAKE_THRESHOLD && isBrakingSuddenly();\n}\n\n// Test case for sudden braking detection\nint main() {\n    float distance = getDistanceToFrontVehicle();  // Get distance to vehicle in front\n\n    std::cout << \"Distance to Front Vehicle: \" << distance << \" meters\" << std::endl;\n\n    if (isSuddenBrakeRisk(distance)) {\n        std::cout << \"WARNING: SUDDEN BRAKING AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Braking Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high-speed vehicles in front. If a vehicle is within 5 meters and traveling faster than 100 km/h, trigger a warning.",
      "input": "Real-time data from radar, vehicle speed sensors, and front vehicle distance sensor.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SPEED_THRESHOLD = 100.0f;  // Speed threshold for triggering warning\nconst float DISTANCE_THRESHOLD = 5.0f;  // Distance threshold in meters\n\n// Function to simulate the speed of a vehicle in front\nfloat getFrontVehicleSpeed() {\n    return 110.0f;  // Simulate speed of 110 km/h\n}\n\n// Function to simulate the distance to the vehicle in front\nfloat getFrontVehicleDistance() {\n    return 4.0f;  // Simulate distance to vehicle in front\n}\n\n// Function to check for high-speed vehicle risk\nbool isHighSpeedVehicleRisk(float speed, float distance) {\n    return speed > SPEED_THRESHOLD && distance < DISTANCE_THRESHOLD;\n}\n\n// Test case for high-speed vehicle detection\nint main() {\n    float vehicleSpeed = getFrontVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getFrontVehicleDistance();  // Get distance to front vehicle\n\n    std::cout << \"Front Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Front Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isHighSpeedVehicleRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: HIGH-SPEED VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No High-Speed Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects tailgating. If a vehicle is within 2 meters of the car and traveling at a higher speed, trigger a warning.",
      "input": "Real-time radar and camera data for vehicle distance and speed.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float TAILGATING_THRESHOLD = 2.0f;  // Distance threshold for tailgating detection in meters\nconst float TAILGATING_SPEED_DIFFERENCE = 10.0f;  // Speed difference threshold for tailgating\n\n// Function to simulate vehicle distance\nfloat getVehicleDistance() {\n    return 1.8f;  // Simulate vehicle at 1.8 meters distance\n}\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 70.0f;  // Simulate vehicle speed of 70 km/h\n}\n\n// Function to check for tailgating risk\nbool isTailgatingRisk(float vehicleDistance, float vehicleSpeed) {\n    return vehicleDistance < TAILGATING_THRESHOLD && vehicleSpeed > TAILGATING_SPEED_DIFFERENCE;\n}\n\n// Test case for tailgating detection\nint main() {\n    float vehicleDistance = getVehicleDistance();  // Get vehicle distance\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isTailgatingRisk(vehicleDistance, vehicleSpeed)) {\n        std::cout << \"WARNING: TAILGATING DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Tailgating Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects over-speeding in a residential area. If the vehicle speed exceeds 40 km/h, trigger a warning.",
      "input": "Real-time vehicle speed data and GPS data for detecting residential areas.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SPEED_LIMIT = 40.0f;  // Speed limit for residential areas in km/h\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 45.0f;  // Simulate vehicle speed of 45 km/h\n}\n\n// Function to check for over-speeding in a residential area\nbool isOverSpeeding(float speed) {\n    return speed > SPEED_LIMIT;\n}\n\n// Test case for over-speeding in residential area\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isOverSpeeding(vehicleSpeed)) {\n        std::cout << \"WARNING: OVER-SPEEDING IN RESIDENTIAL AREA!\" << std::endl;\n    } else {\n        std::cout << \"No Over-Speeding Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high traffic density ahead. If the vehicle speed drops below 10 km/h and the distance to the vehicle ahead is less than 3 meters, trigger a warning.",
      "input": "Real-time vehicle speed and distance to the vehicle ahead.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SPEED_THRESHOLD = 10.0f;  // Speed threshold for detecting high traffic density in km/h\nconst float DISTANCE_THRESHOLD = 3.0f;  // Distance threshold in meters for detecting high traffic density\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 8.0f;  // Simulate vehicle speed of 8 km/h (slow traffic)\n}\n\n// Function to simulate distance to the vehicle ahead\nfloat getVehicleDistance() {\n    return 2.5f;  // Simulate distance to the vehicle ahead\n}\n\n// Function to check for high traffic density risk\nbool isHighTrafficDensityRisk(float vehicleSpeed, float vehicleDistance) {\n    return vehicleSpeed < SPEED_THRESHOLD && vehicleDistance < DISTANCE_THRESHOLD;\n}\n\n// Test case for high traffic density detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getVehicleDistance();  // Get distance to vehicle ahead\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Distance to Vehicle Ahead: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isHighTrafficDensityRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: HIGH TRAFFIC DENSITY AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No High Traffic Density Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects when rain affects the braking distance. If rain is detected and the vehicle's speed exceeds 50 km/h, increase the distance threshold by 1.5 meters.",
      "input": "Real-time data from the rain sensor, vehicle speed, and braking distance sensor.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BASE_BRAKE_DISTANCE = 3.0f;  // Base braking distance in meters\nconst float RAIN_ADJUSTMENT = 1.5f;  // Additional distance for braking in rain\nconst float RAIN_DETECTED = 1.0f;  // Simulate rain detected\nconst float RAIN_NOT_DETECTED = 0.0f;  // No rain detected\n\n// Function to simulate rain detection\nfloat isRainDetected() {\n    return RAIN_DETECTED;  // Simulate rain detected\n}\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 55.0f;  // Simulate vehicle speed of 55 km/h\n}\n\n// Function to calculate braking distance based on rain\nfloat getBrakingDistance(float speed, float rainStatus) {\n    if (rainStatus == RAIN_DETECTED) {\n        return BASE_BRAKE_DISTANCE + RAIN_ADJUSTMENT;  // Increase braking distance due to rain\n    }\n    return BASE_BRAKE_DISTANCE;  // No adjustment if no rain\n}\n\n// Test case for braking distance in rain\nint main() {\n    float rainStatus = isRainDetected();  // Check if rain is detected\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    float brakeDistance = getBrakingDistance(vehicleSpeed, rainStatus);  // Calculate braking distance\n    std::cout << \"Braking Distance: \" << brakeDistance << \" meters\" << std::endl;\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects low tire pressure. If the tire pressure is below 25 psi, trigger a warning.",
      "input": "Real-time data from the tire pressure sensors.",
      "output": "#include <iostream>\n\nconst float LOW_TIRE_PRESSURE = 25.0f;  // Low tire pressure threshold in psi\n\n// Function to simulate tire pressure reading\nfloat getTirePressure() {\n    return 24.5f;  // Simulate low tire pressure (24.5 psi)\n}\n\n// Function to check for low tire pressure\nbool isLowTirePressure(float tirePressure) {\n    return tirePressure < LOW_TIRE_PRESSURE;  // Return true if pressure is below threshold\n}\n\n// Test case for tire pressure detection\nint main() {\n    float tirePressure = getTirePressure();  // Get tire pressure\n    std::cout << \"Tire Pressure: \" << tirePressure << \" psi\" << std::endl;\n\n    if (isLowTirePressure(tirePressure)) {\n        std::cout << \"WARNING: LOW TIRE PRESSURE!\" << std::endl;\n    } else {\n        std::cout << \"Tire Pressure is Normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high pedestrian traffic ahead. If more than 5 pedestrians are detected within a 10-meter range, trigger a warning.",
      "input": "Real-time data from pedestrian detection cameras and sensors.",
      "output": "#include <iostream>\n\nconst int PEDESTRIAN_COUNT_THRESHOLD = 5;  // Threshold for high pedestrian traffic\nconst float PEDESTRIAN_RANGE = 10.0f;  // Range in meters to detect pedestrians\n\n// Function to simulate the number of pedestrians detected in range\nint detectPedestriansInRange() {\n    return 6;  // Simulate detection of 6 pedestrians within the range\n}\n\n// Function to check for high pedestrian traffic\nbool isHighPedestrianTraffic(int pedestrianCount) {\n    return pedestrianCount > PEDESTRIAN_COUNT_THRESHOLD;  // Trigger warning if more than 5 pedestrians\n}\n\n// Test case for high pedestrian traffic detection\nint main() {\n    int pedestrianCount = detectPedestriansInRange();  // Get pedestrian count\n    std::cout << \"Number of Pedestrians: \" << pedestrianCount << std::endl;\n\n    if (isHighPedestrianTraffic(pedestrianCount)) {\n        std::cout << \"WARNING: HIGH PEDESTRIAN TRAFFIC AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"Pedestrian Traffic is Normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden acceleration by a vehicle ahead. If the vehicle ahead accelerates more than 10 km/h within 1 second, trigger a warning.",
      "input": "Real-time data from vehicle speed sensors and relative speed sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float ACCELERATION_THRESHOLD = 10.0f;  // Acceleration threshold in km/h per second\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 50.0f;  // Speed of front vehicle\n}\n\n// Function to calculate speed change in the past second\nfloat getSpeedChange() {\n    return 12.0f;  // Simulate sudden acceleration of 12 km/h in 1 second\n}\n\n// Function to check for sudden acceleration\nbool isSuddenAccelerationRisk(float speedChange) {\n    return speedChange > ACCELERATION_THRESHOLD;  // Trigger warning if speed change exceeds threshold\n}\n\n// Test case for sudden acceleration detection\nint main() {\n    float speedChange = getSpeedChange();  // Get speed change in last second\n    std::cout << \"Speed Change in Last Second: \" << speedChange << \" km/h\" << std::endl;\n\n    if (isSuddenAccelerationRisk(speedChange)) {\n        std::cout << \"WARNING: SUDDEN ACCELERATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Acceleration Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a child crossing the road. If a child is detected in front of the vehicle within 3 meters, trigger a warning.",
      "input": "Real-time data from pedestrian detection camera and sensor.",
      "output": "#include <iostream>\n\nconst float CHILD_DETECTION_THRESHOLD = 3.0f;  // Threshold for child detection in meters\n\n// Function to simulate child detection\nfloat detectChildInFront() {\n    return 2.5f;  // Simulate child detected 2.5 meters in front\n}\n\n// Function to check for collision risk with detected child\nbool isChildCollisionRisk(float distance) {\n    return distance < CHILD_DETECTION_THRESHOLD;  // Trigger warning if child is within threshold\n}\n\n// Test case for child detection\nint main() {\n    float childDistance = detectChildInFront();  // Get distance to child\n    std::cout << \"Child Distance: \" << childDistance << \" meters\" << std::endl;\n\n    if (isChildCollisionRisk(childDistance)) {\n        std::cout << \"WARNING: CHILD CROSSING THE ROAD!\" << std::endl;\n    } else {\n        std::cout << \"No Child Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle drifts to the shoulder. If the vehicle crosses 1.5 meters from the center lane without signaling, trigger a warning.",
      "input": "Real-time data from lane detection cameras and steering angle sensor.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float LANE_DEPARTURE_THRESHOLD = 1.5f;  // Threshold for lane departure in meters\n\n// Function to simulate lane departure detection\nfloat detectLaneDeparture() {\n    return 1.8f;  // Simulate drifting 1.8 meters from lane center\n}\n\n// Function to check if vehicle is drifting out of lane\nbool isLaneDepartureRisk(float departureDistance) {\n    return departureDistance > LANE_DEPARTURE_THRESHOLD;  // Trigger warning if departure exceeds threshold\n}\n\n// Test case for lane departure detection\nint main() {\n    float departureDistance = detectLaneDeparture();  // Get lane departure distance\n    std::cout << \"Lane Departure Distance: \" << departureDistance << \" meters\" << std::endl;\n\n    if (isLaneDepartureRisk(departureDistance)) {\n        std::cout << \"WARNING: LANE DEPARTURE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects when a vehicle ahead is stopping suddenly. If the vehicle ahead slows down by more than 15 km/h within 2 seconds, trigger a warning.",
      "input": "Real-time vehicle speed data and relative speed data.",
      "output": "#include <iostream>\n\nconst float SPEED_CHANGE_THRESHOLD = 15.0f;  // Threshold for sudden deceleration in km/h\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 30.0f;  // Front vehicle speed of 30 km/h\n}\n\n// Function to calculate speed change in the past 2 seconds\nfloat getSpeedChange() {\n    return 20.0f;  // Simulate sudden deceleration of 20 km/h in 2 seconds\n}\n\n// Function to check for sudden deceleration\nbool isSuddenDecelerationRisk(float speedChange) {\n    return speedChange > SPEED_CHANGE_THRESHOLD;  // Trigger warning if speed change exceeds threshold\n}\n\n// Test case for sudden deceleration detection\nint main() {\n    float speedChange = getSpeedChange();  // Get speed change in last 2 seconds\n    std::cout << \"Speed Change in Last 2 Seconds: \" << speedChange << \" km/h\" << std::endl;\n\n    if (isSuddenDecelerationRisk(speedChange)) {\n        std::cout << \"WARNING: SUDDEN DECELERATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Deceleration Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a vehicle in the blind spot. If a vehicle is detected in the blind spot while the driver is signaling for a lane change, trigger a warning.",
      "input": "Real-time data from blind spot sensors and turn signal indicator.",
      "output": "#include <iostream>\n\nconst float BLIND_SPOT_THRESHOLD = 3.0f;  // Threshold for detecting vehicle in blind spot in meters\n\n// Function to simulate vehicle detection in blind spot\nfloat detectBlindSpotVehicle() {\n    return 2.5f;  // Simulate vehicle detected 2.5 meters in blind spot\n}\n\n// Function to check for vehicle in blind spot while signaling\nbool isBlindSpotRisk(float vehicleDistance) {\n    return vehicleDistance < BLIND_SPOT_THRESHOLD;  // Trigger warning if vehicle is in blind spot\n}\n\n// Test case for blind spot detection\nint main() {\n    float vehicleDistance = detectBlindSpotVehicle();  // Get distance to vehicle in blind spot\n    std::cout << \"Distance to Blind Spot Vehicle: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isBlindSpotRisk(vehicleDistance)) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Blind Spot Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects road rage behavior. If the vehicle speed exceeds 100 km/h and the distance to the vehicle ahead is less than 3 meters, trigger a warning.",
      "input": "Real-time vehicle speed and distance data.",
      "output": "#include <iostream>\n\nconst float SPEED_THRESHOLD = 100.0f;  // Road rage speed threshold in km/h\nconst float DISTANCE_THRESHOLD = 3.0f;  // Distance threshold in meters\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 110.0f;  // Simulate vehicle speed of 110 km/h\n}\n\n// Function to simulate distance to vehicle ahead\nfloat getVehicleDistance() {\n    return 2.5f;  // Simulate distance to the vehicle ahead\n}\n\n// Function to check for road rage risk\nbool isRoadRageRisk(float vehicleSpeed, float vehicleDistance) {\n    return vehicleSpeed > SPEED_THRESHOLD && vehicleDistance < DISTANCE_THRESHOLD;\n}\n\n// Test case for road rage detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getVehicleDistance();  // Get distance to vehicle ahead\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isRoadRageRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: ROAD RAGE BEHAVIOR DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Road Rage Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a slow-moving vehicle ahead. If the vehicle ahead is moving slower than 20 km/h and the relative speed between the two vehicles is more than 10 km/h, trigger a warning.",
      "input": "Real-time data from vehicle speed and relative speed sensors.",
      "output": "#include <iostream>\n\nconst float SLOW_VEHICLE_SPEED_THRESHOLD = 20.0f;  // Slow-moving vehicle speed threshold\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // Relative speed threshold\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 18.0f;  // Simulate front vehicle speed of 18 km/h\n}\n\n// Function to simulate vehicle's speed\nfloat getVehicleSpeed() {\n    return 30.0f;  // Simulate vehicle speed of 30 km/h\n}\n\n// Function to calculate relative speed\nfloat getRelativeSpeed(float frontVehicleSpeed, float vehicleSpeed) {\n    return vehicleSpeed - frontVehicleSpeed;  // Relative speed between two vehicles\n}\n\n// Function to check for slow-moving vehicle ahead\nbool isSlowVehicleAhead(float frontVehicleSpeed, float relativeSpeed) {\n    return frontVehicleSpeed < SLOW_VEHICLE_SPEED_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD;  // Trigger warning if vehicle is moving slowly\n}\n\n// Test case for slow vehicle detection\nint main() {\n    float frontVehicleSpeed = getFrontVehicleSpeed();  // Get front vehicle speed\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float relativeSpeed = getRelativeSpeed(frontVehicleSpeed, vehicleSpeed);  // Get relative speed\n\n    std::cout << \"Front Vehicle Speed: \" << frontVehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n\n    if (isSlowVehicleAhead(frontVehicleSpeed, relativeSpeed)) {\n        std::cout << \"WARNING: SLOW MOVING VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Slow Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a pedestrian at a crosswalk. If a pedestrian is detected within 5 meters of the vehicle's path, trigger a warning.",
      "input": "Real-time data from pedestrian detection camera and proximity sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 5.0f;  // Pedestrian detection threshold in meters\n\n// Function to simulate pedestrian detection distance\nfloat detectPedestrian() {\n    return 4.0f;  // Simulate pedestrian detected 4 meters ahead\n}\n\n// Function to check for pedestrian in path\nbool isPedestrianInPath(float distance) {\n    return distance < PEDESTRIAN_DETECTION_THRESHOLD;  // Trigger warning if pedestrian is within threshold\n}\n\n// Test case for pedestrian detection\nint main() {\n    float pedestrianDistance = detectPedestrian();  // Get distance to pedestrian\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianInPath(pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN AT CROSSWALK!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian in Path.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden lane departure. If the vehicle crosses the lane markings without signaling, trigger a warning.",
      "input": "Real-time data from lane detection camera and steering angle sensor.",
      "output": "#include <iostream>\n\nconst float LANE_DEPARTURE_THRESHOLD = 1.0f;  // Lane departure threshold in meters\n\n// Function to simulate lane departure distance\nfloat detectLaneDeparture() {\n    return 1.2f;  // Simulate lane departure of 1.2 meters\n}\n\n// Function to check for lane departure risk\nbool isLaneDepartureRisk(float laneDepartureDistance) {\n    return laneDepartureDistance > LANE_DEPARTURE_THRESHOLD;  // Trigger warning if lane departure exceeds threshold\n}\n\n// Test case for lane departure detection\nint main() {\n    float laneDepartureDistance = detectLaneDeparture();  // Get lane departure distance\n    std::cout << \"Lane Departure Distance: \" << laneDepartureDistance << \" meters\" << std::endl;\n\n    if (isLaneDepartureRisk(laneDepartureDistance)) {\n        std::cout << \"WARNING: LANE DEPARTURE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects stopped traffic ahead. If the vehicle ahead has a speed of 0 km/h and the vehicle's relative speed is greater than 10 km/h, trigger a warning.",
      "input": "Real-time data from vehicle speed sensors and relative speed sensors.",
      "output": "#include <iostream>\n\nconst float STOPPED_VEHICLE_SPEED_THRESHOLD = 0.0f;  // Stopped vehicle speed threshold\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // Relative speed threshold\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 0.0f;  // Simulate stopped vehicle ahead\n}\n\n// Function to simulate vehicle's speed\nfloat getVehicleSpeed() {\n    return 20.0f;  // Simulate vehicle speed of 20 km/h\n}\n\n// Function to calculate relative speed\nfloat getRelativeSpeed(float frontVehicleSpeed, float vehicleSpeed) {\n    return vehicleSpeed - frontVehicleSpeed;  // Relative speed between two vehicles\n}\n\n// Function to check for stopped traffic ahead\nbool isStoppedTrafficAhead(float frontVehicleSpeed, float relativeSpeed) {\n    return frontVehicleSpeed == STOPPED_VEHICLE_SPEED_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD;  // Trigger warning if stopped traffic ahead\n}\n\n// Test case for stopped traffic detection\nint main() {\n    float frontVehicleSpeed = getFrontVehicleSpeed();  // Get front vehicle speed\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float relativeSpeed = getRelativeSpeed(frontVehicleSpeed, vehicleSpeed);  // Get relative speed\n\n    std::cout << \"Front Vehicle Speed: \" << frontVehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n\n    if (isStoppedTrafficAhead(frontVehicleSpeed, relativeSpeed)) {\n        std::cout << \"WARNING: STOPPED TRAFFIC AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Stopped Traffic Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is going too fast on a curve. If the vehicle's speed exceeds 60 km/h while turning, trigger a warning.",
      "input": "Real-time data from vehicle speed sensor and GPS curve data.",
      "output": "#include <iostream>\n\nconst float CURVE_SPEED_THRESHOLD = 60.0f;  // Speed threshold for curves in km/h\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 65.0f;  // Simulate vehicle speed of 65 km/h\n}\n\n// Function to simulate curve detection\nbool isOnCurve() {\n    return true;  // Simulate vehicle on a curve\n}\n\n// Function to check for speed on curve risk\nbool isSpeedingOnCurve(float vehicleSpeed) {\n    return isOnCurve() && vehicleSpeed > CURVE_SPEED_THRESHOLD;  // Trigger warning if speed exceeds threshold while on a curve\n}\n\n// Test case for speed on curve detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isSpeedingOnCurve(vehicleSpeed)) {\n        std::cout << \"WARNING: EXCESSIVE SPEED ON CURVE!\" << std::endl;\n    } else {\n        std::cout << \"No Speeding Risk on Curve.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects the risk of a rear-end collision. If the relative speed between vehicles is greater than 20 km/h and the distance is less than 5 meters, trigger a warning.",
      "input": "Real-time data from vehicle speed sensor and rear-facing radar.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0f;  // Distance threshold for rear-end collision risk\nconst float COLLISION_SPEED_THRESHOLD = 20.0f;  // Speed threshold for rear-end collision risk\n\n// Function to simulate relative speed to vehicle behind\nfloat getRelativeSpeed() {\n    return 25.0f;  // Simulate relative speed of 25 km/h\n}\n\n// Function to simulate distance to vehicle behind\nfloat getDistanceToRearVehicle() {\n    return 3.0f;  // Simulate distance to rear vehicle of 3 meters\n}\n\n// Function to check for rear-end collision risk\nbool isRearEndCollisionRisk(float relativeSpeed, float distanceToRearVehicle) {\n    return relativeSpeed > COLLISION_SPEED_THRESHOLD && distanceToRearVehicle < COLLISION_DISTANCE_THRESHOLD;  // Trigger warning if collision risk is detected\n}\n\n// Test case for rear-end collision detection\nint main() {\n    float relativeSpeed = getRelativeSpeed();  // Get relative speed to vehicle behind\n    float distanceToRearVehicle = getDistanceToRearVehicle();  // Get distance to rear vehicle\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Distance to Rear Vehicle: \" << distanceToRearVehicle << \" meters\" << std::endl;\n\n    if (isRearEndCollisionRisk(relativeSpeed, distanceToRearVehicle)) {\n        std::cout << \"WARNING: REAR-END COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Rear-End Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high traffic density ahead. If the vehicle density in front exceeds 30 vehicles per kilometer, trigger a warning.",
      "input": "Real-time data from traffic density sensors.",
      "output": "#include <iostream>\n\nconst int DENSITY_THRESHOLD = 30;  // Vehicle density threshold\n\n// Function to simulate traffic density\nint getTrafficDensity() {\n    return 35;  // Simulate high traffic density of 35 vehicles per kilometer\n}\n\n// Function to check for high traffic density\nbool isHighTrafficDensity(int trafficDensity) {\n    return trafficDensity > DENSITY_THRESHOLD;  // Trigger warning if density exceeds threshold\n}\n\n// Test case for traffic density detection\nint main() {\n    int trafficDensity = getTrafficDensity();  // Get traffic density\n    std::cout << \"Traffic Density: \" << trafficDensity << \" vehicles per km\" << std::endl;\n\n    if (isHighTrafficDensity(trafficDensity)) {\n        std::cout << \"WARNING: HIGH TRAFFIC DENSITY AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No High Traffic Density Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects hard braking by the vehicle ahead. If the deceleration rate exceeds 5 m/s^2, trigger a warning.",
      "input": "Real-time data from vehicle deceleration sensors.",
      "output": "#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 5.0f;  // Hard braking deceleration threshold in m/s^2\n\n// Function to simulate vehicle deceleration rate\nfloat getVehicleDeceleration() {\n    return 6.0f;  // Simulate hard braking with deceleration of 6 m/s^2\n}\n\n// Function to check for hard braking risk\nbool isHardBrakingRisk(float deceleration) {\n    return deceleration > DECELERATION_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for hard braking detection\nint main() {\n    float deceleration = getVehicleDeceleration();  // Get vehicle deceleration rate\n    std::cout << \"Deceleration Rate: \" << deceleration << \" m/s^2\" << std::endl;\n\n    if (isHardBrakingRisk(deceleration)) {\n        std::cout << \"WARNING: HARD BRAKING AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Hard Braking Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a pedestrian crossing in front of the vehicle. If a pedestrian is detected within 3 meters of the vehicle's path, trigger a warning.",
      "input": "Real-time data from pedestrian detection sensors and proximity sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DISTANCE_THRESHOLD = 3.0f;  // Pedestrian detection threshold in meters\n\n// Function to simulate pedestrian detection distance\nfloat detectPedestrian() {\n    return 2.5f;  // Simulate pedestrian detected 2.5 meters ahead\n}\n\n// Function to check for pedestrian in the vehicle's path\nbool isPedestrianInPath(float distance) {\n    return distance < PEDESTRIAN_DISTANCE_THRESHOLD;  // Trigger warning if pedestrian is within threshold\n}\n\n// Test case for pedestrian detection\nint main() {\n    float pedestrianDistance = detectPedestrian();  // Get pedestrian distance\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianInPath(pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN CROSSING!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is following too closely behind another vehicle. If the distance to the vehicle ahead is less than 2 meters and the relative speed is greater than 10 km/h, trigger a warning.",
      "input": "Real-time data from vehicle sensors (distance and speed).",
      "output": "#include <iostream>\n\nconst float CLOSE_FOLLOWING_THRESHOLD = 2.0f;  // Distance threshold in meters\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // Relative speed threshold in km/h\n\n// Function to simulate distance to the vehicle ahead\nfloat getDistanceToVehicleAhead() {\n    return 1.5f;  // Simulate close following vehicle 1.5 meters away\n}\n\n// Function to simulate relative speed\nfloat getRelativeSpeed() {\n    return 15.0f;  // Simulate relative speed of 15 km/h\n}\n\n// Function to check for close following risk\nbool isCloseFollowing(float distanceToVehicle, float relativeSpeed) {\n    return distanceToVehicle < CLOSE_FOLLOWING_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD;  // Trigger warning if too close\n}\n\n// Test case for close following detection\nint main() {\n    float distanceToVehicle = getDistanceToVehicleAhead();  // Get distance to vehicle ahead\n    float relativeSpeed = getRelativeSpeed();  // Get relative speed\n\n    std::cout << \"Distance to Vehicle Ahead: \" << distanceToVehicle << \" meters\" << std::endl;\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n\n    if (isCloseFollowing(distanceToVehicle, relativeSpeed)) {\n        std::cout << \"WARNING: CLOSE FOLLOWING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Close Following Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle ahead is suddenly stopping. If the vehicle ahead decelerates rapidly (greater than 4 m/s\u00b2), trigger a warning.",
      "input": "Real-time data from vehicle deceleration sensors and front-facing radar.",
      "output": "#include <iostream>\n\nconst float SUDDEN_STOP_THRESHOLD = 4.0f;  // Deceleration threshold in m/s^2\n\n// Function to simulate front vehicle deceleration rate\nfloat getFrontVehicleDeceleration() {\n    return 5.0f;  // Simulate sudden stop with 5 m/s^2 deceleration\n}\n\n// Function to check for sudden stop risk\nbool isSuddenStopAhead(float deceleration) {\n    return deceleration > SUDDEN_STOP_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for sudden stop detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get front vehicle deceleration\n    std::cout << \"Front Vehicle Deceleration: \" << deceleration << \" m/s^2\" << std::endl;\n\n    if (isSuddenStopAhead(deceleration)) {\n        std::cout << \"WARNING: SUDDEN STOP AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Stop Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects an incorrect lane change. If the vehicle crosses lane markings without a signal, trigger a warning.",
      "input": "Real-time data from lane detection sensors and steering angle sensor.",
      "output": "#include <iostream>\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f;  // Lane departure threshold in meters\n\n// Function to simulate lane detection status\nbool isLaneDepartureDetected() {\n    return true;  // Simulate lane departure\n}\n\n// Function to simulate whether the turn signal is on\nbool isTurnSignalOn() {\n    return false;  // Simulate no turn signal active\n}\n\n// Function to check for incorrect lane change\nbool isIncorrectLaneChange() {\n    return isLaneDepartureDetected() && !isTurnSignalOn();  // Trigger warning if lane departure occurs without signal\n}\n\n// Test case for lane change detection\nint main() {\n    if (isIncorrectLaneChange()) {\n        std::cout << \"WARNING: INCORRECT LANE CHANGE!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a vehicle in the blind spot. If another vehicle is detected in the blind spot zone and the driver attempts to change lanes, trigger a warning.",
      "input": "Real-time data from blind spot monitoring sensors and steering angle sensor.",
      "output": "#include <iostream>\n\nconst float BLIND_SPOT_ZONE_THRESHOLD = 3.0f;  // Blind spot zone threshold in meters\n\n// Function to simulate vehicle detection in the blind spot\nbool isVehicleInBlindSpot() {\n    return true;  // Simulate a vehicle detected in the blind spot\n}\n\n// Function to simulate steering angle (change lane attempt)\nfloat getSteeringAngle() {\n    return 30.0f;  // Simulate a lane change attempt with 30-degree steering angle\n}\n\n// Function to check for blind spot collision risk\nbool isBlindSpotRisk() {\n    return isVehicleInBlindSpot() && getSteeringAngle() > 20.0f;  // Trigger warning if vehicle is in blind spot during lane change\n}\n\n// Test case for blind spot detection\nint main() {\n    if (isBlindSpotRisk()) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Blind Spot Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects an object (e.g., vehicle or obstruction) in front of the vehicle at an intersection. If an object is detected within 10 meters, trigger a warning.",
      "input": "Real-time data from front-facing camera and proximity sensors.",
      "output": "#include <iostream>\n\nconst float OBJECT_DETECTION_THRESHOLD = 10.0f;  // Object detection threshold in meters\n\n// Function to simulate object detection distance\nfloat detectObjectAtIntersection() {\n    return 8.0f;  // Simulate an object detected 8 meters ahead\n}\n\n// Function to check for object in path\nbool isObjectInPath(float distance) {\n    return distance < OBJECT_DETECTION_THRESHOLD;  // Trigger warning if object is within threshold\n}\n\n// Test case for object detection at intersection\nint main() {\n    float objectDistance = detectObjectAtIntersection();  // Get object distance\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isObjectInPath(objectDistance)) {\n        std::cout << \"WARNING: OBJECT AHEAD AT INTERSECTION!\" << std::endl;\n    } else {\n        std::cout << \"No Object Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects reduced visibility due to weather conditions (e.g., fog, rain). If visibility drops below a certain threshold (100 meters), trigger a warning.",
      "input": "Real-time data from visibility sensors (e.g., camera, radar).",
      "output": "#include <iostream>\n\nconst float VISIBILITY_THRESHOLD = 100.0f;  // Visibility threshold in meters\n\n// Function to simulate current visibility\nfloat getCurrentVisibility() {\n    return 80.0f;  // Simulate reduced visibility (80 meters)\n}\n\n// Function to check for reduced visibility risk\nbool isReducedVisibility(float visibility) {\n    return visibility < VISIBILITY_THRESHOLD;  // Trigger warning if visibility is below threshold\n}\n\n// Test case for visibility detection\nint main() {\n    float visibility = getCurrentVisibility();  // Get current visibility\n    std::cout << \"Current Visibility: \" << visibility << \" meters\" << std::endl;\n\n    if (isReducedVisibility(visibility)) {\n        std::cout << \"WARNING: REDUCED VISIBILITY AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Reduced Visibility Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects slippery road conditions. If the road surface friction drops below a threshold, trigger a warning.",
      "input": "Real-time data from road surface friction sensors and weather sensors.",
      "output": "#include <iostream>\n\nconst float ROAD_FRICTION_THRESHOLD = 0.3f;  // Road surface friction threshold\n\n// Function to simulate road surface friction\nfloat getRoadSurfaceFriction() {\n    return 0.2f;  // Simulate slippery road condition with low friction\n}\n\n// Function to check for slippery road risk\nbool isSlipperyRoad(float friction) {\n    return friction < ROAD_FRICTION_THRESHOLD;  // Trigger warning if friction is below threshold\n}\n\n// Test case for slippery road detection\nint main() {\n    float friction = getRoadSurfaceFriction();  // Get road surface friction\n    std::cout << \"Road Surface Friction: \" << friction << std::endl;\n\n    if (isSlipperyRoad(friction)) {\n        std::cout << \"WARNING: SLIPPERY ROAD CONDITIONS!\" << std::endl;\n    } else {\n        std::cout << \"No Slippery Road Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects an obstacle in the vehicle's path. If an obstacle is detected within 5 meters, trigger a warning.",
      "input": "Real-time data from front-facing radar and ultrasonic sensors.",
      "output": "#include <iostream>\n\nconst float OBSTACLE_DISTANCE_THRESHOLD = 5.0f;  // Obstacle detection threshold in meters\n\n// Function to simulate obstacle detection distance\nfloat detectObstacleInPath() {\n    return 3.0f;  // Simulate obstacle detected 3 meters ahead\n}\n\n// Function to check for obstacle in path\nbool isObstacleInPath(float distance) {\n    return distance < OBSTACLE_DISTANCE_THRESHOLD;  // Trigger warning if obstacle is within threshold\n}\n\n// Test case for obstacle detection\nint main() {\n    float obstacleDistance = detectObstacleInPath();  // Get obstacle distance\n    std::cout << \"Obstacle Distance: \" << obstacleDistance << \" meters\" << std::endl;\n\n    if (isObstacleInPath(obstacleDistance)) {\n        std::cout << \"WARNING: OBSTACLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Obstacle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects the risk of collision while reversing. If the vehicle is reversing and detects an object within 2 meters, trigger a warning.",
      "input": "Real-time data from rear sensors and reverse gear status.",
      "output": "#include <iostream>\n\nconst float REVERSE_COLLISION_THRESHOLD = 2.0f;  // Collision threshold for reversing in meters\n\n// Function to simulate rear object detection distance\nfloat detectRearObject() {\n    return 1.5f;  // Simulate an object detected 1.5 meters behind\n}\n\n// Function to check for collision risk while reversing\nbool isReverseCollisionRisk(float distance) {\n    return distance < REVERSE_COLLISION_THRESHOLD;  // Trigger warning if object is within threshold\n}\n\n// Test case for reverse collision risk detection\nint main() {\n    bool isReversing = true;  // Assume vehicle is in reverse\n    if (isReversing) {\n        float rearObjectDistance = detectRearObject();  // Get distance to rear object\n        std::cout << \"Rear Object Distance: \" << rearObjectDistance << \" meters\" << std::endl;\n\n        if (isReverseCollisionRisk(rearObjectDistance)) {\n            std::cout << \"WARNING: COLLISION RISK WHILE REVERSING!\" << std::endl;\n        } else {\n            std::cout << \"No Collision Risk While Reversing.\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a slow-moving vehicle ahead. If the vehicle ahead is moving at less than 20 km/h, trigger a warning.",
      "input": "Real-time data from front radar and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float SLOW_MOVING_THRESHOLD = 20.0f;  // Slow-moving vehicle speed threshold in km/h\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 15.0f;  // Simulate a slow-moving vehicle ahead at 15 km/h\n}\n\n// Function to check if vehicle ahead is moving too slowly\nbool isSlowMovingAhead(float speed) {\n    return speed < SLOW_MOVING_THRESHOLD;  // Trigger warning if vehicle ahead is too slow\n}\n\n// Test case for slow-moving vehicle detection\nint main() {\n    float vehicleSpeed = getFrontVehicleSpeed();  // Get speed of vehicle ahead\n    std::cout << \"Front Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isSlowMovingAhead(vehicleSpeed)) {\n        std::cout << \"WARNING: SLOW MOVING VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Slow Moving Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects uneven road surfaces. If the vehicle detects a significant bump or uneven terrain (greater than 5 cm variation), trigger a warning.",
      "input": "Real-time data from road surface monitoring sensors (e.g., accelerometers).",
      "output": "#include <iostream>\n\nconst float ROAD_SURFACE_VARIATION_THRESHOLD = 0.05f;  // Road surface variation threshold in meters\n\n// Function to simulate road surface bump variation\nfloat getRoadSurfaceVariation() {\n    return 0.06f;  // Simulate a road bump with 6 cm variation\n}\n\n// Function to check for uneven road surface\nbool isUnevenRoadSurface(float variation) {\n    return variation > ROAD_SURFACE_VARIATION_THRESHOLD;  // Trigger warning if variation exceeds threshold\n}\n\n// Test case for uneven road surface detection\nint main() {\n    float surfaceVariation = getRoadSurfaceVariation();  // Get road surface variation\n    std::cout << \"Road Surface Variation: \" << surfaceVariation << \" meters\" << std::endl;\n\n    if (isUnevenRoadSurface(surfaceVariation)) {\n        std::cout << \"WARNING: UNEVEN ROAD SURFACE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Uneven Road Surface Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is approaching a traffic signal with insufficient time to stop. If the signal is about to turn red within 5 seconds, trigger a warning.",
      "input": "Real-time data from traffic signal detection cameras and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst int TRAFFIC_SIGNAL_WARNING_TIME = 5;  // Time to red light warning threshold in seconds\n\n// Function to simulate traffic signal status\nbool isTrafficLightRed() {\n    return true;  // Simulate red light\n}\n\n// Function to simulate time to red light turning on\nint timeToRedLight() {\n    return 4;  // Simulate 4 seconds to red light\n}\n\n// Function to check if there's insufficient time to stop at a red light\nbool isTrafficSignalViolation(int timeToRed) {\n    return isTrafficLightRed() && timeToRed < TRAFFIC_SIGNAL_WARNING_TIME;  // Trigger warning if time to red light is less than threshold\n}\n\n// Test case for traffic signal violation detection\nint main() {\n    int redLightTime = timeToRedLight();  // Get time to red light\n    std::cout << \"Time to Red Light: \" << redLightTime << \" seconds\" << std::endl;\n\n    if (isTrafficSignalViolation(redLightTime)) {\n        std::cout << \"WARNING: TRAFFIC SIGNAL VIOLATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Traffic Signal Violation Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle ahead has malfunctioning brake lights. If the brake lights of the vehicle ahead are not detected when decelerating, trigger a warning.",
      "input": "Real-time data from brake light monitoring sensors and front vehicle speed sensors.",
      "output": "#include <iostream>\n\n// Function to simulate detection of brake lights in the vehicle ahead\nbool areBrakeLightsFunctional() {\n    return false;  // Simulate malfunctioning brake lights\n}\n\n// Function to simulate front vehicle deceleration\nfloat getFrontVehicleDeceleration() {\n    return 3.0f;  // Simulate deceleration at 3 m/s^2\n}\n\n// Function to check for malfunctioning brake lights\nbool isMalfunctioningBrakeLights(float deceleration) {\n    return !areBrakeLightsFunctional() && deceleration > 2.0f;  // Trigger warning if brake lights are malfunctioning and decelerating\n}\n\n// Test case for malfunctioning brake lights detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get front vehicle deceleration\n    std::cout << \"Front Vehicle Deceleration: \" << deceleration << \" m/s^2\" << std::endl;\n\n    if (isMalfunctioningBrakeLights(deceleration)) {\n        std::cout << \"WARNING: MALFUNCTIONING BRAKE LIGHTS AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Brake Light Malfunction Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a rapid lane departure. If the vehicle crosses lane markings at a speed greater than 60 km/h without turn signals, trigger a warning.",
      "input": "Real-time data from lane departure sensors and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float LANE_DEPARTURE_SPEED_THRESHOLD = 60.0f;  // Speed threshold for lane departure in km/h\n\n// Function to simulate current vehicle speed\nfloat getCurrentSpeed() {\n    return 65.0f;  // Simulate vehicle moving at 65 km/h\n}\n\n// Function to simulate lane departure detection\nbool isLaneDepartureDetected() {\n    return true;  // Simulate lane departure detected\n}\n\n// Function to check for rapid lane departure\nbool isRapidLaneDeparture(float speed) {\n    return isLaneDepartureDetected() && speed > LANE_DEPARTURE_SPEED_THRESHOLD;  // Trigger warning if lane departure is detected at high speed\n}\n\n// Test case for rapid lane departure detection\nint main() {\n    float speed = getCurrentSpeed();  // Get current vehicle speed\n    std::cout << \"Current Vehicle Speed: \" << speed << \" km/h\" << std::endl;\n\n    if (isRapidLaneDeparture(speed)) {\n        std::cout << \"WARNING: RAPID LANE DEPARTURE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Rapid Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a tailgating vehicle. If the vehicle behind is within 2 meters and moving faster than 10 km/h, trigger a warning.",
      "input": "Real-time data from rear radar sensors and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float TAILGATING_DISTANCE_THRESHOLD = 2.0f;  // Tailgating distance threshold in meters\nconst float TAILGATING_SPEED_THRESHOLD = 10.0f;  // Tailgating speed threshold in km/h\n\n// Function to simulate tailgating vehicle's distance\nfloat getTailgatingDistance() {\n    return 1.5f;  // Simulate a vehicle within 1.5 meters\n}\n\n// Function to simulate tailgating vehicle's speed\nfloat getTailgatingSpeed() {\n    return 15.0f;  // Simulate a vehicle moving at 15 km/h\n}\n\n// Function to check if a vehicle is tailgating\nbool isTailgating(float distance, float speed) {\n    return distance < TAILGATING_DISTANCE_THRESHOLD && speed > TAILGATING_SPEED_THRESHOLD;  // Trigger warning if tailgating\n}\n\n// Test case for tailgating detection\nint main() {\n    float distance = getTailgatingDistance();  // Get tailgating vehicle's distance\n    float speed = getTailgatingSpeed();  // Get tailgating vehicle's speed\n\n    if (isTailgating(distance, speed)) {\n        std::cout << \"WARNING: VEHICLE TAILGATING!\" << std::endl;\n    } else {\n        std::cout << \"No Tailgating Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects heavy rainfall. If rainfall is detected at a rate greater than 20 mm/h, trigger a warning to reduce speed.",
      "input": "Real-time data from rainfall sensors and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float RAINFALL_THRESHOLD = 20.0f;  // Heavy rainfall threshold in mm/h\n\n// Function to simulate rainfall intensity\nfloat getRainfallIntensity() {\n    return 25.0f;  // Simulate rainfall intensity of 25 mm/h\n}\n\n// Function to check for heavy rainfall\nbool isHeavyRainfall(float intensity) {\n    return intensity > RAINFALL_THRESHOLD;  // Trigger warning if rainfall exceeds threshold\n}\n\n// Test case for heavy rainfall detection\nint main() {\n    float rainfallIntensity = getRainfallIntensity();  // Get rainfall intensity\n    std::cout << \"Rainfall Intensity: \" << rainfallIntensity << \" mm/h\" << std::endl;\n\n    if (isHeavyRainfall(rainfallIntensity)) {\n        std::cout << \"WARNING: HEAVY RAINFALL AHEAD! REDUCE SPEED.\" << std::endl;\n    } else {\n        std::cout << \"No Heavy Rainfall Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if there is a crosswalk ahead. If a crosswalk is detected within 30 meters and there is a pedestrian nearby, trigger a warning.",
      "input": "Real-time data from camera and pedestrian detection sensors.",
      "output": "#include <iostream>\n\nconst float CROSSWALK_DETECTION_THRESHOLD = 30.0f;  // Crosswalk detection threshold in meters\nconst float PEDESTRIAN_PROXIMITY_THRESHOLD = 5.0f;  // Proximity threshold for pedestrian in meters\n\n// Function to simulate crosswalk detection distance\nfloat getCrosswalkDistance() {\n    return 20.0f;  // Simulate crosswalk detected 20 meters ahead\n}\n\n// Function to simulate pedestrian proximity\nfloat getPedestrianProximity() {\n    return 3.0f;  // Simulate a pedestrian 3 meters away\n}\n\n// Function to check for crosswalk and pedestrian risk\nbool isCrosswalkRisk(float crosswalkDistance, float pedestrianProximity) {\n    return crosswalkDistance < CROSSWALK_DETECTION_THRESHOLD && pedestrianProximity < PEDESTRIAN_PROXIMITY_THRESHOLD;  // Trigger warning if both conditions met\n}\n\n// Test case for crosswalk detection\nint main() {\n    float crosswalkDistance = getCrosswalkDistance();  // Get distance to crosswalk\n    float pedestrianProximity = getPedestrianProximity();  // Get pedestrian proximity\n\n    if (isCrosswalkRisk(crosswalkDistance, pedestrianProximity)) {\n        std::cout << \"WARNING: PEDESTRIAN ON CROSSWALK AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Crosswalk Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a sudden lane change. If the vehicle suddenly changes lanes without signaling, trigger a warning.",
      "input": "Real-time data from lane change sensors and turn signal status.",
      "output": "#include <iostream>\n\nconst bool TURN_SIGNAL_STATUS = false;  // Assume the turn signal is off\n\n// Function to simulate lane change detection\nbool isLaneChangeDetected() {\n    return true;  // Simulate sudden lane change detection\n}\n\n// Function to check for sudden lane change without signaling\nbool isSuddenLaneChange() {\n    return isLaneChangeDetected() && !TURN_SIGNAL_STATUS;  // Trigger warning if lane change is detected without signaling\n}\n\n// Test case for sudden lane change detection\nint main() {\n    if (isSuddenLaneChange()) {\n        std::cout << \"WARNING: SUDDEN LANE CHANGE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Lane Change Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects obstructions in the blind spot. If an obstruction is detected in the blind spot while attempting a lane change, trigger a warning.",
      "input": "Real-time data from blind spot sensors and lane change signals.",
      "output": "#include <iostream>\n\nconst float BLIND_SPOT_DETECTION_THRESHOLD = 3.0f;  // Blind spot obstruction detection threshold in meters\n\n// Function to simulate blind spot detection distance\nfloat getBlindSpotDistance() {\n    return 2.5f;  // Simulate an obstruction in the blind spot 2.5 meters away\n}\n\n// Function to simulate lane change signal status\nbool isLaneChangeSignalOn() {\n    return true;  // Simulate lane change signal on\n}\n\n// Function to check for obstruction in blind spot during lane change\nbool isBlindSpotObstruction(float blindSpotDistance) {\n    return blindSpotDistance < BLIND_SPOT_DETECTION_THRESHOLD && isLaneChangeSignalOn();  // Trigger warning if obstruction is in the blind spot while signaling lane change\n}\n\n// Test case for blind spot obstruction detection\nint main() {\n    float blindSpotDistance = getBlindSpotDistance();  // Get distance to blind spot obstruction\n\n    if (isBlindSpotObstruction(blindSpotDistance)) {\n        std::cout << \"WARNING: OBSTRUCTION IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Obstruction in Blind Spot.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects stop sign violation. If the vehicle approaches a stop sign at a speed greater than 5 km/h, trigger a warning.",
      "input": "Real-time data from traffic sign recognition cameras and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float STOP_SIGN_VIOLATION_THRESHOLD_SPEED = 5.0f;  // Speed threshold for stop sign violation in km/h\n\n// Function to simulate stop sign detection\nbool isStopSignDetected() {\n    return true;  // Simulate stop sign detected\n}\n\n// Function to simulate vehicle speed\nfloat getCurrentSpeed() {\n    return 6.0f;  // Simulate vehicle moving at 6 km/h\n}\n\n// Function to check for stop sign violation\nbool isStopSignViolation(float speed) {\n    return isStopSignDetected() && speed > STOP_SIGN_VIOLATION_THRESHOLD_SPEED;  // Trigger warning if vehicle violates stop sign\n}\n\n// Test case for stop sign violation detection\nint main() {\n    float speed = getCurrentSpeed();  // Get current vehicle speed\n\n    if (isStopSignViolation(speed)) {\n        std::cout << \"WARNING: STOP SIGN VIOLATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Stop Sign Violation Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden braking by the vehicle ahead. If the vehicle ahead decelerates faster than 3 m/s\u00b2, trigger a warning.",
      "input": "Real-time data from front radar and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float SUDDEN_BRAKING_THRESHOLD = 3.0f;  // Sudden braking threshold in m/s\u00c2\u00b2\n\n// Function to simulate deceleration of the vehicle ahead\nfloat getFrontVehicleDeceleration() {\n    return 3.5f;  // Simulate a deceleration of 3.5 m/s\u00c2\u00b2\n}\n\n// Function to check for sudden braking\nbool isSuddenBraking(float deceleration) {\n    return deceleration > SUDDEN_BRAKING_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for sudden braking detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get deceleration of vehicle ahead\n\n    if (isSuddenBraking(deceleration)) {\n        std::cout << \"WARNING: SUDDEN BRAKING AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Braking Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects foggy weather conditions. If fog is detected with visibility below 100 meters, trigger a warning.",
      "input": "Real-time data from weather sensors and visibility measurement systems.",
      "output": "#include <iostream>\n\nconst float FOG_VISIBILITY_THRESHOLD = 100.0f;  // Visibility threshold for foggy weather in meters\n\n// Function to simulate foggy weather condition\nfloat getVisibility() {\n    return 90.0f;  // Simulate visibility of 90 meters in foggy weather\n}\n\n// Function to check for foggy weather\nbool isFoggyWeather(float visibility) {\n    return visibility < FOG_VISIBILITY_THRESHOLD;  // Trigger warning if visibility is less than threshold\n}\n\n// Test case for foggy weather detection\nint main() {\n    float visibility = getVisibility();  // Get visibility in foggy weather\n\n    if (isFoggyWeather(visibility)) {\n        std::cout << \"WARNING: FOGGY WEATHER AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Foggy Weather Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians crossing in front of the vehicle. If a pedestrian is detected within 5 meters of the vehicle and moving toward it, trigger a collision warning.",
      "input": "Real-time data from pedestrian detection sensors and vehicle proximity sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 5.0f;  // Pedestrian proximity threshold in meters\nconst float PEDESTRIAN_SPEED_THRESHOLD = 1.0f;  // Pedestrian speed threshold in m/s\n\n// Function to simulate pedestrian detection distance\nfloat getPedestrianDistance() {\n    return 4.0f;  // Simulate a pedestrian 4 meters away\n}\n\n// Function to simulate pedestrian speed\nfloat getPedestrianSpeed() {\n    return 1.5f;  // Simulate a pedestrian moving at 1.5 m/s towards the vehicle\n}\n\n// Function to check for pedestrian collision risk\nbool isPedestrianRisk(float distance, float speed) {\n    return distance < PEDESTRIAN_DETECTION_THRESHOLD && speed > PEDESTRIAN_SPEED_THRESHOLD;  // Trigger warning if pedestrian is too close and moving towards vehicle\n}\n\n// Test case for pedestrian collision detection\nint main() {\n    float distance = getPedestrianDistance();  // Get distance to pedestrian\n    float speed = getPedestrianSpeed();  // Get speed of pedestrian\n\n    if (isPedestrianRisk(distance, speed)) {\n        std::cout << \"WARNING: PEDESTRIAN AHEAD! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects animals crossing the road. If an animal is detected within 10 meters of the vehicle, trigger a collision warning.",
      "input": "Real-time data from camera and motion sensors.",
      "output": "#include <iostream>\n\nconst float ANIMAL_DETECTION_THRESHOLD = 10.0f;  // Animal proximity threshold in meters\n\n// Function to simulate animal detection distance\nfloat getAnimalDistance() {\n    return 8.0f;  // Simulate an animal 8 meters away from the vehicle\n}\n\n// Function to check for animal collision risk\nbool isAnimalRisk(float distance) {\n    return distance < ANIMAL_DETECTION_THRESHOLD;  // Trigger warning if animal is within proximity threshold\n}\n\n// Test case for animal collision detection\nint main() {\n    float distance = getAnimalDistance();  // Get distance to detected animal\n\n    if (isAnimalRisk(distance)) {\n        std::cout << \"WARNING: ANIMAL CROSSING! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Animal Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is approaching a red light at high speed. If the vehicle is within 50 meters of the red light and moving faster than 10 km/h, trigger a warning.",
      "input": "Real-time data from traffic light cameras and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float RED_LIGHT_THRESHOLD_DISTANCE = 50.0f;  // Distance threshold for red light detection in meters\nconst float RED_LIGHT_THRESHOLD_SPEED = 10.0f;  // Speed threshold in km/h\n\n// Function to simulate distance to red light\nfloat getRedLightDistance() {\n    return 40.0f;  // Simulate distance of 40 meters to red light\n}\n\n// Function to simulate vehicle speed\nfloat getCurrentSpeed() {\n    return 12.0f;  // Simulate vehicle moving at 12 km/h\n}\n\n// Function to check for red light violation\nbool isRedLightViolation(float distance, float speed) {\n    return distance < RED_LIGHT_THRESHOLD_DISTANCE && speed > RED_LIGHT_THRESHOLD_SPEED;  // Trigger warning if red light detected and speed is high\n}\n\n// Test case for red light violation detection\nint main() {\n    float distance = getRedLightDistance();  // Get distance to red light\n    float speed = getCurrentSpeed();  // Get current vehicle speed\n\n    if (isRedLightViolation(distance, speed)) {\n        std::cout << \"WARNING: RED LIGHT VIOLATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Red Light Violation Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects slippery road conditions. If road traction is low (e.g., due to ice or rain), trigger a warning.",
      "input": "Real-time data from road condition sensors.",
      "output": "#include <iostream>\n\nconst float SLIPPERY_ROAD_THRESHOLD = 0.5f;  // Traction threshold for slippery roads\n\n// Function to simulate road traction condition\nfloat getRoadTraction() {\n    return 0.3f;  // Simulate slippery road with low traction\n}\n\n// Function to check for slippery road condition\nbool isSlipperyRoad(float traction) {\n    return traction < SLIPPERY_ROAD_THRESHOLD;  // Trigger warning if traction is below threshold\n}\n\n// Test case for slippery road condition detection\nint main() {\n    float traction = getRoadTraction();  // Get current road traction\n\n    if (isSlipperyRoad(traction)) {\n        std::cout << \"WARNING: SLIPPERY ROAD CONDITIONS AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Slippery Road Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden stops by vehicles ahead. If the vehicle ahead decelerates abruptly, trigger a collision warning.",
      "input": "Real-time data from front radar and vehicle deceleration sensors.",
      "output": "#include <iostream>\n\nconst float SUDDEN_STOP_DECELERATION_THRESHOLD = 4.0f;  // Deceleration threshold for sudden stop in m/s\u00c2\u00b2\n\n// Function to simulate deceleration of the vehicle ahead\nfloat getFrontVehicleDeceleration() {\n    return 5.0f;  // Simulate deceleration of 5 m/s\u00c2\u00b2\n}\n\n// Function to check for sudden stop ahead\nbool isSuddenStop(float deceleration) {\n    return deceleration > SUDDEN_STOP_DECELERATION_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for sudden stop detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get deceleration of vehicle ahead\n\n    if (isSuddenStop(deceleration)) {\n        std::cout << \"WARNING: SUDDEN STOP AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Stop Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting tailgating. If the distance between your car and the vehicle ahead is less than 2 seconds of headway, trigger a warning.",
      "input": "Real-time data from radar sensors to measure distance and speed.",
      "output": "#include <iostream>\n\nconst float SAFE_HEADWAY_TIME = 2.0f; // Minimum safe time headway in seconds\n\n// Function to get distance to the vehicle ahead\nfloat getVehicleDistance() {\n    return 15.0f; // Simulated distance in meters\n}\n\n// Function to get the speed of the vehicle\nfloat getVehicleSpeed() {\n    return 10.0f; // Simulated speed in m/s\n}\n\n// Function to check for tailgating\nbool isTailgating(float distance, float speed) {\n    float time_headway = distance / speed;\n    return time_headway < SAFE_HEADWAY_TIME;\n}\n\nint main() {\n    float distance = getVehicleDistance();\n    float speed = getVehicleSpeed();\n\n    if (isTailgating(distance, speed)) {\n        std::cout << \"WARNING: Tailgating detected! Maintain a safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting lane departure when an obstacle is present in the adjacent lane. Trigger a warning if the vehicle drifts into a lane with an obstacle within 5 meters.",
      "input": "Real-time data from lane sensors and proximity sensors.",
      "output": "#include <iostream>\n\nconst float OBSTACLE_DETECTION_THRESHOLD = 5.0f; // Obstacle proximity threshold in meters\n\nbool isLaneDepartureDetected() {\n    return true; // Simulate lane departure detection\n}\n\nfloat getObstacleDistance() {\n    return 3.0f; // Simulate obstacle 3 meters away in adjacent lane\n}\n\nbool isLaneDepartureRisk(float obstacle_distance) {\n    return isLaneDepartureDetected() && obstacle_distance < OBSTACLE_DETECTION_THRESHOLD;\n}\n\nint main() {\n    float obstacle_distance = getObstacleDistance();\n\n    if (isLaneDepartureRisk(obstacle_distance)) {\n        std::cout << \"WARNING: Lane departure into an obstacle detected!\" << std::endl;\n    } else {\n        std::cout << \"No lane departure risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting a risk of rear-end collision. If the vehicle ahead decelerates at more than 4 m/s\u00b2 and the distance is less than 10 meters, trigger a warning.",
      "input": "Real-time data from radar and deceleration sensors.",
      "output": "#include <iostream>\n\nconst float SAFE_DECELERATION_THRESHOLD = 4.0f; // Deceleration threshold in m/s\u00c2\u00b2\nconst float SAFE_DISTANCE_THRESHOLD = 10.0f;   // Distance threshold in meters\n\nfloat getFrontVehicleDeceleration() {\n    return 5.0f; // Simulated deceleration\n}\n\nfloat getVehicleDistance() {\n    return 8.0f; // Simulated distance\n}\n\nbool isRearEndCollisionRisk(float deceleration, float distance) {\n    return deceleration > SAFE_DECELERATION_THRESHOLD && distance < SAFE_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float deceleration = getFrontVehicleDeceleration();\n    float distance = getVehicleDistance();\n\n    if (isRearEndCollisionRisk(deceleration, distance)) {\n        std::cout << \"WARNING: Risk of rear-end collision!\" << std::endl;\n    } else {\n        std::cout << \"No rear-end collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting potential intersection collisions. Trigger a warning if an incoming vehicle is detected within 15 meters at an intersection.",
      "input": "Real-time data from intersection cameras and radar.",
      "output": "#include <iostream>\n\nconst float INTERSECTION_PROXIMITY_THRESHOLD = 15.0f; // Proximity threshold for intersection collision\n\nfloat getIncomingVehicleDistance() {\n    return 10.0f; // Simulated incoming vehicle distance\n}\n\nbool isIntersectionCollisionRisk(float distance) {\n    return distance < INTERSECTION_PROXIMITY_THRESHOLD;\n}\n\nint main() {\n    float distance = getIncomingVehicleDistance();\n\n    if (isIntersectionCollisionRisk(distance)) {\n        std::cout << \"WARNING: Risk of collision at intersection!\" << std::endl;\n    } else {\n        std::cout << \"No intersection collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting collision risks in stop-and-go traffic. If the vehicle ahead is within 2 meters and decelerating, trigger a warning.",
      "input": "Real-time data from proximity sensors and deceleration sensors.",
      "output": "#include <iostream>\n\nconst float STOP_AND_GO_DISTANCE_THRESHOLD = 2.0f; // Distance threshold in meters\n\nfloat getVehicleDistance() {\n    return 1.5f; // Simulated distance\n}\n\nbool isForwardCollisionRisk(float distance) {\n    return distance < STOP_AND_GO_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float distance = getVehicleDistance();\n\n    if (isForwardCollisionRisk(distance)) {\n        std::cout << \"WARNING: Risk of forward collision in stop-and-go traffic!\" << std::endl;\n    } else {\n        std::cout << \"No forward collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect stationary objects ahead. If the vehicle is moving at over 5 m/s and an object is detected within 5 meters, trigger a warning.",
      "input": "Real-time data from LiDAR sensors.",
      "output": "#include <iostream>\n\nconst float STATIONARY_OBJECT_DISTANCE_THRESHOLD = 5.0f;\nconst float VEHICLE_SPEED_THRESHOLD = 5.0f;\n\nfloat getVehicleSpeed() {\n    return 6.0f;\n}\n\nfloat getStationaryObjectDistance() {\n    return 4.0f;\n}\n\nbool isStationaryObjectRisk(float speed, float distance) {\n    return speed > VEHICLE_SPEED_THRESHOLD && distance < STATIONARY_OBJECT_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getStationaryObjectDistance();\n\n    if (isStationaryObjectRisk(speed, distance)) {\n        std::cout << \"WARNING: Stationary object ahead!\" << std::endl;\n    } else {\n        std::cout << \"No stationary object risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn drivers of foggy conditions reducing visibility below 50 meters.",
      "input": "Real-time data from visibility sensors.",
      "output": "#include <iostream>\n\nconst float VISIBILITY_THRESHOLD = 50.0f;\n\nfloat getVisibility() {\n    return 30.0f; // Simulated visibility\n}\n\nbool isFogRisk(float visibility) {\n    return visibility < VISIBILITY_THRESHOLD;\n}\n\nint main() {\n    float visibility = getVisibility();\n\n    if (isFogRisk(visibility)) {\n        std::cout << \"WARNING: Reduced visibility due to fog!\" << std::endl;\n    } else {\n        std::cout << \"Visibility is clear.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting a risk in adaptive cruise control. Trigger a warning if the vehicle ahead slows down and the following distance becomes less than 1 second of headway.",
      "input": "Real-time data from radar for speed and distance measurements.",
      "output": "#include <iostream>\n\nconst float MIN_HEADWAY_TIME = 1.0f; // Minimum acceptable headway time in seconds\n\nfloat getFrontVehicleSpeed() {\n    return 15.0f; // Simulated front vehicle speed in m/s\n}\n\nfloat getFrontVehicleDistance() {\n    return 10.0f; // Simulated front vehicle distance in meters\n}\n\nbool isACCWarningTriggered(float speed, float distance) {\n    float headway_time = distance / speed;\n    return headway_time < MIN_HEADWAY_TIME;\n}\n\nint main() {\n    float speed = getFrontVehicleSpeed();\n    float distance = getFrontVehicleDistance();\n\n    if (isACCWarningTriggered(speed, distance)) {\n        std::cout << \"WARNING: Adaptive Cruise Control - Follow distance too short!\" << std::endl;\n    } else {\n        std::cout << \"ACC: Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn drivers if they are exceeding the speed limit in a designated zone.",
      "input": "Real-time data from GPS and speedometer sensors.",
      "output": "#include <iostream>\n\nconst float SPEED_LIMIT = 60.0f; // Speed limit in km/h\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed in km/h\n}\n\nbool isSpeeding(float speed) {\n    return speed > SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isSpeeding(speed)) {\n        std::cout << \"WARNING: Speeding! Reduce your speed immediately.\" << std::endl;\n    } else {\n        std::cout << \"Speed within limits.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect emergency braking scenarios and alert the driver.",
      "input": "Real-time data from brake sensors and proximity sensors.",
      "output": "#include <iostream>\n\nconst float BRAKE_FORCE_THRESHOLD = 6.0f; // Brake force threshold in m/s\u00c2\u00b2\nconst float DISTANCE_THRESHOLD = 5.0f;   // Safe distance threshold in meters\n\nfloat getBrakeForce() {\n    return 7.0f; // Simulated brake force\n}\n\nfloat getVehicleDistance() {\n    return 4.0f; // Simulated vehicle distance\n}\n\nbool isEmergencyBrakingRisk(float brake_force, float distance) {\n    return brake_force > BRAKE_FORCE_THRESHOLD && distance < DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float brake_force = getBrakeForce();\n    float distance = getVehicleDistance();\n\n    if (isEmergencyBrakingRisk(brake_force, distance)) {\n        std::cout << \"WARNING: Emergency braking detected!\" << std::endl;\n    } else {\n        std::cout << \"No emergency braking risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if a pedestrian is detected within a crosswalk.",
      "input": "Real-time data from vision sensors and object detection algorithms.",
      "output": "#include <iostream>\n\nconst float CROSSWALK_DISTANCE_THRESHOLD = 2.0f; // Threshold for pedestrian distance in meters\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getPedestrianDistance() {\n    return 1.5f; // Simulated pedestrian distance\n}\n\nbool isPedestrianCrossingRisk(float distance) {\n    return isPedestrianDetected() && distance < CROSSWALK_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float pedestrian_distance = getPedestrianDistance();\n\n    if (isPedestrianCrossingRisk(pedestrian_distance)) {\n        std::cout << \"WARNING: Pedestrian detected on crosswalk!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn the driver if the road is slippery based on traction control system data.",
      "input": "Real-time data from traction control system.",
      "output": "#include <iostream>\n\nconst float TRACTION_LOSS_THRESHOLD = 0.5f; // Simulated threshold for traction loss\n\nfloat getTractionLevel() {\n    return 0.3f; // Simulated traction level\n}\n\nbool isSlipperyRoadRisk(float traction_level) {\n    return traction_level < TRACTION_LOSS_THRESHOLD;\n}\n\nint main() {\n    float traction_level = getTractionLevel();\n\n    if (isSlipperyRoadRisk(traction_level)) {\n        std::cout << \"WARNING: Slippery road ahead! Drive carefully.\" << std::endl;\n    } else {\n        std::cout << \"Road conditions normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect low visibility in tunnels and alert the driver to reduce speed.",
      "input": "Real-time data from visibility and light sensors.",
      "output": "#include <iostream>\n\nconst float TUNNEL_VISIBILITY_THRESHOLD = 20.0f; // Visibility threshold in meters\n\nfloat getTunnelVisibility() {\n    return 15.0f; // Simulated visibility\n}\n\nbool isTunnelVisibilityRisk(float visibility) {\n    return visibility < TUNNEL_VISIBILITY_THRESHOLD;\n}\n\nint main() {\n    float visibility = getTunnelVisibility();\n\n    if (isTunnelVisibilityRisk(visibility)) {\n        std::cout << \"WARNING: Low visibility in tunnel! Reduce speed.\" << std::endl;\n    } else {\n        std::cout << \"Tunnel visibility is clear.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if another vehicle is detected in their blind spot.",
      "input": "Real-time data from blind spot sensors.",
      "output": "#include <iostream>\n\nbool isVehicleInBlindSpot() {\n    return true; // Simulated detection of a vehicle in the blind spot\n}\n\nint main() {\n    if (isVehicleInBlindSpot()) {\n        std::cout << \"WARNING: Vehicle detected in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn the driver if the vehicle speed exceeds safe limits during hill descent.",
      "input": "Real-time data from slope sensors and speedometer.",
      "output": "#include <iostream>\n\nconst float HILL_DESCENT_SPEED_LIMIT = 20.0f; // Speed limit for hill descent in km/h\n\nfloat getVehicleSpeed() {\n    return 25.0f; // Simulated vehicle speed\n}\n\nbool isHillDescentSpeedRisk(float speed) {\n    return speed > HILL_DESCENT_SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isHillDescentSpeedRisk(speed)) {\n        std::cout << \"WARNING: Reduce speed during hill descent!\" << std::endl;\n    } else {\n        std::cout << \"Speed within safe limits for hill descent.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect speed bumps ahead and alert the driver if the vehicle speed is too high.",
      "input": "Real-time data from road profile sensors and speedometer.",
      "output": "#include <iostream>\n\nconst float SPEED_BUMP_SPEED_LIMIT = 10.0f; // Speed limit for speed bump in km/h\n\nbool isSpeedBumpDetected() {\n    return true; // Simulated detection of a speed bump\n}\n\nfloat getVehicleSpeed() {\n    return 15.0f; // Simulated vehicle speed\n}\n\nbool isSpeedBumpRisk(float speed) {\n    return isSpeedBumpDetected() && speed > SPEED_BUMP_SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isSpeedBumpRisk(speed)) {\n        std::cout << \"WARNING: Reduce speed for speed bump!\" << std::endl;\n    } else {\n        std::cout << \"Safe approach to speed bump.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect stop signs and alert the driver if the vehicle fails to slow down.",
      "input": "Real-time data from vision sensors and speedometer.",
      "output": "#include <iostream>\n\nconst float STOP_SPEED_LIMIT = 5.0f; // Speed limit when approaching a stop sign in km/h\n\nbool isStopSignDetected() {\n    return true; // Simulated detection of a stop sign\n}\n\nfloat getVehicleSpeed() {\n    return 20.0f; // Simulated vehicle speed in km/h\n}\n\nbool isStopWarningTriggered(float speed) {\n    return isStopSignDetected() && speed > STOP_SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isStopWarningTriggered(speed)) {\n        std::cout << \"WARNING: Approaching stop sign too fast!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle slowing appropriately for stop sign.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if the vehicle is drifting out of its lane.",
      "input": "Real-time data from lane detection algorithms.",
      "output": "#include <iostream>\n\nbool isVehicleDrifting() {\n    return true; // Simulated detection of lane departure\n}\n\nint main() {\n    if (isVehicleDrifting()) {\n        std::cout << \"WARNING: Lane departure detected! Correct your steering.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is within the lane.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect collision risks at intersections based on vehicle positions and speeds.",
      "input": "Real-time data from radar sensors and GPS.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 10.0f; // Collision threshold in meters\n\nfloat getDistanceToCrossingVehicle() {\n    return 8.0f; // Simulated distance to another vehicle\n}\n\nfloat getCrossingVehicleSpeed() {\n    return 5.0f; // Simulated speed of the other vehicle\n}\n\nbool isCrossingCollisionRisk(float distance, float speed) {\n    return distance < COLLISION_DISTANCE_THRESHOLD && speed > 0.0f;\n}\n\nint main() {\n    float distance = getDistanceToCrossingVehicle();\n    float speed = getCrossingVehicleSpeed();\n\n    if (isCrossingCollisionRisk(distance, speed)) {\n        std::cout << \"WARNING: Collision risk at intersection!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk at intersection.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn the driver if vehicle speed is too high for a curve ahead.",
      "input": "Real-time data from GPS and gyroscope sensors.",
      "output": "#include <iostream>\n\nconst float CURVE_SAFE_SPEED = 30.0f; // Safe speed limit for curve in km/h\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Simulated vehicle speed\n}\n\nbool isCurveSpeedRisk(float speed) {\n    return speed > CURVE_SAFE_SPEED;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isCurveSpeedRisk(speed)) {\n        std::cout << \"WARNING: Reduce speed for the curve!\" << std::endl;\n    } else {\n        std::cout << \"Safe speed for the curve.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to assist parking by detecting nearby obstacles.",
      "input": "Real-time data from ultrasonic sensors.",
      "output": "#include <iostream>\n\nconst float PARKING_OBSTACLE_DISTANCE = 0.5f; // Distance threshold for parking in meters\n\nfloat getObstacleDistance() {\n    return 0.3f; // Simulated distance to obstacle\n}\n\nbool isParkingObstacleRisk(float distance) {\n    return distance < PARKING_OBSTACLE_DISTANCE;\n}\n\nint main() {\n    float distance = getObstacleDistance();\n\n    if (isParkingObstacleRisk(distance)) {\n        std::cout << \"WARNING: Obstacle too close during parking!\" << std::endl;\n    } else {\n        std::cout << \"Safe parking distance.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if they are tailgating another vehicle.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nconst float MIN_FOLLOW_DISTANCE = 2.0f; // Minimum safe distance in meters\n\nfloat getFollowingDistance() {\n    return 1.5f; // Simulated following distance\n}\n\nbool isTailgatingRisk(float distance) {\n    return distance < MIN_FOLLOW_DISTANCE;\n}\n\nint main() {\n    float distance = getFollowingDistance();\n\n    if (isTailgatingRisk(distance)) {\n        std::cout << \"WARNING: Too close to the vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if visibility is too low during night driving.",
      "input": "Real-time data from light sensors.",
      "output": "#include <iostream>\n\nconst float NIGHT_VISIBILITY_THRESHOLD = 30.0f; // Visibility threshold in meters\n\nfloat getVisibilityDistance() {\n    return 25.0f; // Simulated visibility distance\n}\n\nbool isLowVisibilityRisk(float visibility) {\n    return visibility < NIGHT_VISIBILITY_THRESHOLD;\n}\n\nint main() {\n    float visibility = getVisibilityDistance();\n\n    if (isLowVisibilityRisk(visibility)) {\n        std::cout << \"WARNING: Low visibility! Drive cautiously.\" << std::endl;\n    } else {\n        std::cout << \"Visibility is clear for night driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor engine temperature and alert the driver if overheating occurs.",
      "input": "Real-time data from temperature sensors.",
      "output": "#include <iostream>\n\nconst float MAX_ENGINE_TEMP = 100.0f; // Maximum safe engine temperature in Celsius\n\nfloat getEngineTemperature() {\n    return 105.0f; // Simulated engine temperature\n}\n\nbool isEngineOverheating(float temperature) {\n    return temperature > MAX_ENGINE_TEMP;\n}\n\nint main() {\n    float temperature = getEngineTemperature();\n\n    if (isEngineOverheating(temperature)) {\n        std::cout << \"WARNING: Engine overheating! Stop the vehicle immediately.\" << std::endl;\n    } else {\n        std::cout << \"Engine temperature is normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a collision warning if the distance to the vehicle ahead is below a critical threshold.",
      "input": "Real-time data from LiDAR sensors.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0f; // Minimum safe distance in meters\n\nfloat getDistanceToVehicleAhead() {\n    return 4.5f; // Simulated distance to the vehicle ahead\n}\n\nbool isCollisionWarningTriggered(float distance) {\n    return distance < COLLISION_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionWarningTriggered(distance)) {\n        std::cout << \"WARNING: Risk of collision with the vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance to the vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to calculate a dynamic collision warning threshold based on the vehicle's speed.",
      "input": "Real-time data from radar sensors and speedometer.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 12.0f; // Simulated distance to vehicle ahead in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    float dynamic_threshold = speed / 10.0f; // Dynamic threshold based on speed (1 second rule)\n    return distance < dynamic_threshold;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to include braking reaction time in collision warning calculations.",
      "input": "Real-time data from radar sensors, speedometer, and braking system.",
      "output": "#include <iostream>\n\nconst float BRAKING_REACTION_TIME = 1.5f; // Reaction time in seconds\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 15.0f; // Simulated distance to vehicle ahead in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    float reaction_distance = (speed * 1000.0f / 3600.0f) * BRAKING_REACTION_TIME; // Convert speed to m/s\n    return distance < reaction_distance;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision imminent! Apply brakes.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to integrate radar and LiDAR data for improved collision warning.",
      "input": "Real-time data from radar and LiDAR sensors.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance in meters\n}\n\nfloat getLidarDistance() {\n    return 9.5f; // Simulated LiDAR distance in meters\n}\n\nfloat calculateAverageDistance(float radar_distance, float lidar_distance) {\n    return (radar_distance + lidar_distance) / 2.0f;\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 8.0f; // Threshold in meters\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float radar_distance = getRadarDistance();\n    float lidar_distance = getLidarDistance();\n\n    float average_distance = calculateAverageDistance(radar_distance, lidar_distance);\n\n    if (isCollisionRisk(average_distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to adjust the collision threshold based on weather conditions.",
      "input": "Real-time data from weather sensors and radar.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 15.0f; // Simulated distance in meters\n}\n\nbool isRainyWeather() {\n    return true; // Simulated weather condition\n}\n\nbool isCollisionRisk(float distance, bool rainy_weather) {\n    const float DRY_THRESHOLD = 10.0f;\n    const float WET_THRESHOLD = 15.0f;\n    float threshold = rainy_weather ? WET_THRESHOLD : DRY_THRESHOLD;\n    return distance < threshold;\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n    bool rainy_weather = isRainyWeather();\n\n    if (isCollisionRisk(distance, rainy_weather)) {\n        std::cout << \"WARNING: Collision risk in current weather!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to recommend a speed adjustment if collision risk is detected.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 10.0f; // Simulated distance in meters\n}\n\nfloat recommendSafeSpeed(float distance) {\n    return (distance * 3.6f) / 2.0f; // Convert distance to a safe speed in km/h\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (distance < 15.0f) {\n        float recommended_speed = recommendSafeSpeed(distance);\n        std::cout << \"WARNING: Reduce speed to \" << recommended_speed << \" km/h!\" << std::endl;\n    } else {\n        std::cout << \"Current speed is safe.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect collision risk in stop-and-go traffic.",
      "input": "Real-time data from radar sensors.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 3.0f; // Simulated distance in meters\n}\n\nbool isCollisionRiskInTraffic(float distance) {\n    const float TRAFFIC_THRESHOLD = 2.5f; // Safe distance for heavy traffic\n    return distance < TRAFFIC_THRESHOLD;\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionRiskInTraffic(distance)) {\n        std::cout << \"WARNING: Collision risk in traffic! Maintain gap.\" << std::endl;\n    } else {\n        std::cout << \"Safe gap in traffic maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an emergency braking alert if collision risk is imminent.",
      "input": "Real-time data from radar sensors and speedometer.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 2.0f; // Simulated distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed in km/h\n}\n\nbool isEmergencyBrakingRequired(float speed, float distance) {\n    const float EMERGENCY_THRESHOLD = 2.5f; // Threshold for emergency braking\n    return distance < EMERGENCY_THRESHOLD && speed > 0.0f;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (isEmergencyBrakingRequired(speed, distance)) {\n        std::cout << \"WARNING: Apply emergency brakes immediately!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a collision warning if the radar-measured distance falls below a safe threshold.",
      "input": "Real-time radar distance data.",
      "output": "#include <iostream>\n\nconst float SAFE_DISTANCE_THRESHOLD = 10.0f; // Safe distance in meters\n\nfloat getRadarDistance() {\n    return 8.5f; // Simulated radar distance (real-time input)\n}\n\nint main() {\n    float distance = getRadarDistance();\n\n    if (distance < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to calculate collision risk using speed and radar distance data.",
      "input": "Real-time speed from the speedometer and radar distance.",
      "output": "#include <iostream>\n\nconst float SAFE_SPEED_DISTANCE_FACTOR = 0.5f; // Safe factor (speed * factor)\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Speed in km/h (real-time input)\n}\n\nfloat getRadarDistance() {\n    return 20.0f; // Distance in meters (real-time input)\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float safe_distance = speed * SAFE_SPEED_DISTANCE_FACTOR / 3.6f; // Convert speed to m/s\n\n    if (distance < safe_distance) {\n        std::cout << \"WARNING: Collision risk detected! Reduce speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to fuse radar and LiDAR distances to assess collision risk.",
      "input": "Real-time data from radar and LiDAR sensors.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 9.0f; // Radar distance (real-time input)\n}\n\nfloat getLidarDistance() {\n    return 9.5f; // LiDAR distance (real-time input)\n}\n\nfloat calculateFusedDistance(float radar, float lidar) {\n    return (radar + lidar) / 2.0f; // Average fusion of distances\n}\n\nint main() {\n    const float COLLISION_THRESHOLD = 10.0f; // Safe threshold\n    float radar_distance = getRadarDistance();\n    float lidar_distance = getLidarDistance();\n    float fused_distance = calculateFusedDistance(radar_distance, lidar_distance);\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to dynamically adjust the collision threshold based on weather conditions.",
      "input": "Real-time radar distance and weather conditions (rainy or dry).",
      "output": "#include <iostream>\n\nbool isRainyWeather() {\n    return true; // Simulated weather input\n}\n\nfloat getRadarDistance() {\n    return 12.0f; // Radar-measured distance\n}\n\nint main() {\n    const float DRY_THRESHOLD = 10.0f;\n    const float WET_THRESHOLD = 15.0f;\n\n    bool rainy = isRainyWeather();\n    float distance = getRadarDistance();\n    float threshold = rainy ? WET_THRESHOLD : DRY_THRESHOLD;\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk in current weather!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect collision risk in stop-and-go traffic.",
      "input": "Real-time data from radar sensors.",
      "output": "#include <iostream>\n\nconst float TRAFFIC_DISTANCE_THRESHOLD = 2.0f; // Safe distance for traffic in meters\n\nfloat getDistanceToVehicleAhead() {\n    return 1.8f; // Radar-measured distance (real-time input)\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n\n    if (distance < TRAFFIC_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk in traffic! Maintain gap.\" << std::endl;\n    } else {\n        std::cout << \"Safe traffic gap maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a warning if the vehicle ahead brakes suddenly.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nconst float SUDDEN_BRAKING_THRESHOLD = 2.0f; // Acceleration threshold in m/s^2\n\nfloat getVehicleAcceleration() {\n    return -3.0f; // Simulated acceleration (negative for braking)\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 7.0f; // Radar distance in meters\n}\n\nint main() {\n    float acceleration = getVehicleAcceleration();\n    float distance = getDistanceToVehicleAhead();\n\n    if (acceleration < -SUDDEN_BRAKING_THRESHOLD && distance < 10.0f) {\n        std::cout << \"WARNING: Sudden braking detected! Maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Normal driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to adjust warning timing based on the vehicle's speed.",
      "input": "Real-time radar distance and speedometer readings.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 20.0f; // Distance in meters\n}\n\nint main() {\n    const float TIME_TO_COLLISION = 2.0f; // Time in seconds\n    float speed = getVehicleSpeed() / 3.6f; // Convert to m/s\n    float distance = getDistanceToVehicleAhead();\n\n    if (distance / speed < TIME_TO_COLLISION) {\n        std::cout << \"WARNING: Collision risk detected! Adjust speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue collision warnings based on distance on curved roads.",
      "input": "Real-time radar distance and GPS-curvature data.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 18.0f; // Distance in meters\n}\n\nbool isOnCurvedRoad() {\n    return true; // Simulated road curvature status\n}\n\nint main() {\n    const float CURVED_THRESHOLD = 20.0f;\n    const float STRAIGHT_THRESHOLD = 10.0f;\n\n    float distance = getDistanceToVehicleAhead();\n    bool curved_road = isOnCurvedRoad();\n    float threshold = curved_road ? CURVED_THRESHOLD : STRAIGHT_THRESHOLD;\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected! Adjust speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning if radar detects an object within 10 meters.",
      "input": "Radar detected distance: 8.5 meters. Collision threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid detectCollision(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.5F;\n    float collision_threshold = 10.0F;\n\n    detectCollision(radar_distance, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn the driver when a LiDAR sensor detects a vehicle closer than the threshold during urban driving.",
      "input": "LiDAR data: 7.2 meters. Threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid processUrbanFCW(float lidar_distance, float threshold) {\n    if (lidar_distance < threshold) {\n        std::cout << \"WARNING: Vehicle detected at \" << lidar_distance << \" meters. Slow down!\" << std::endl;\n    } else {\n        std::cout << \"Safe urban driving. Distance: \" << lidar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 7.2F;\n    float threshold = 8.0F;\n\n    processUrbanFCW(lidar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Use radar data to detect multiple objects and alert if any is below the danger threshold.",
      "input": "Object distances: 15 meters, 12 meters, and 9 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjects(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {15.0F, 12.0F, 9.0F};\n    float collision_threshold = 10.0F;\n\n    checkMultipleObjects(object_distances, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide a warning based on a dynamic threshold calculated from vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicCollisionWarning(float speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Distance to object \" << distance << \" meters below threshold \" << threshold << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at \" << speed << \" km/h.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;  // km/h\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicCollisionWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Combine radar and camera data to warn if the detected object is confirmed as a car within the threshold.",
      "input": "Radar distance: 9 meters. Camera confirmation: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid radarCameraFCW(float distance, bool isCar, float threshold) {\n    if (isCar && distance < threshold) {\n        std::cout << \"WARNING: Car detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 9.0F;\n    bool camera_confirmation = true;\n    float collision_threshold = 10.0F;\n\n    radarCameraFCW(radar_distance, camera_confirmation, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn the driver of a collision if an object is detected during reverse parking.",
      "input": "Reverse radar distance: 1.2 meters. Parking mode: Enabled. Threshold: 2 meters.",
      "output": "#include <iostream>\n\nvoid reverseParkingWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during reverse parking!\" << std::endl;\n    } else {\n        std::cout << \"Reverse parking clear. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float reverse_distance = 1.2F;\n    float parking_threshold = 2.0F;\n\n    reverseParkingWarning(reverse_distance, parking_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Evaluate real-time radar data to warn if objects are detected in low visibility conditions.",
      "input": "Radar distance: 12 meters. Low visibility mode: Enabled. Adjusted threshold: 14 meters.",
      "output": "#include <iostream>\n\nvoid lowVisibilityWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Low visibility collision risk! Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Low visibility safe. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;\n    float adjusted_threshold = 14.0F;\n\n    lowVisibilityWarning(radar_distance, adjusted_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Alert the driver during stop-and-go traffic if the radar detects an object within 3 meters.",
      "input": "Stop-and-go radar distance: 2.5 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoFCW(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Close object detected at \" << distance << \" meters in stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Stop-and-go distance clear.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;\n    float collision_threshold = 3.0F;\n\n    stopAndGoFCW(radar_distance, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn of a stationary object detected ahead at night by radar.",
      "input": "Night mode active. Radar distance: 16 meters. Threshold: 20 meters.",
      "output": "#include <iostream>\n\nvoid nightModeFCW(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Stationary object detected at \" << distance << \" meters. Reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at night.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 16.0F;\n    float night_threshold = 20.0F;\n\n    nightModeFCW(radar_distance, night_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning if the distance from a detected object is less than 10 meters.",
      "input": "Radar distance: 8.5 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid detectCollision(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.5F;\n    float collision_threshold = 10.0F;\n\n    detectCollision(radar_distance, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Use LiDAR data to detect objects within a threshold and alert if an object is within range.",
      "input": "LiDAR distance: 7.2 meters. Threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid checkDistanceWithLiDAR(float lidar_distance, float threshold) {\n    if (lidar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << lidar_distance << \" meters. Maintain a safe distance!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << lidar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 7.2F;\n    float threshold = 8.0F;\n\n    checkDistanceWithLiDAR(lidar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Evaluate multiple objects and warn if any of them is too close.",
      "input": "Object distances: 15 meters, 12 meters, 9 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjects(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {15.0F, 12.0F, 9.0F};\n    float collision_threshold = 10.0F;\n\n    checkMultipleObjects(object_distances, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Adjust the collision warning threshold based on vehicle speed, and trigger a warning if the distance is below the dynamic threshold.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicThresholdWarning(float speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h, Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;  // km/h\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicThresholdWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Combine radar and camera data to detect a vehicle and warn if it\u2019s too close.",
      "input": "Radar distance: 9 meters. Camera confirmation: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid radarCameraCollisionWarning(float distance, bool isCar, float threshold) {\n    if (isCar && distance < threshold) {\n        std::cout << \"WARNING: Car detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 9.0F;\n    bool camera_confirmation = true;\n    float collision_threshold = 10.0F;\n\n    radarCameraCollisionWarning(radar_distance, camera_confirmation, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger an alert if the radar detects an object too close during reverse parking.",
      "input": "Reverse radar distance: 1.2 meters. Threshold: 2 meters.",
      "output": "#include <iostream>\n\nvoid reverseParkingAlert(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during reverse parking!\" << std::endl;\n    } else {\n        std::cout << \"Reverse parking clear. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float reverse_distance = 1.2F;\n    float parking_threshold = 2.0F;\n\n    reverseParkingAlert(reverse_distance, parking_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Evaluate radar data and issue a warning in low visibility conditions if the detected object is within the threshold.",
      "input": "Radar distance: 12 meters. Low visibility mode: Enabled. Threshold: 14 meters.",
      "output": "#include <iostream>\n\nvoid lowVisibilityWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Low visibility hazard!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at low visibility.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;\n    float low_visibility_threshold = 14.0F;\n\n    lowVisibilityWarning(radar_distance, low_visibility_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide a collision warning if an object is detected in stop-and-go traffic.",
      "input": "Radar distance: 2.5 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters in stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Clear in stop-and-go traffic. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;\n    float stop_and_go_threshold = 3.0F;\n\n    stopAndGoCollisionWarning(radar_distance, stop_and_go_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn if an object is detected at night and is within the danger zone.",
      "input": "Radar distance: 16 meters. Threshold: 20 meters.",
      "output": "#include <iostream>\n\nvoid nightModeCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Stationary object detected at \" << distance << \" meters. Reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe night driving.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 16.0F;\n    float night_threshold = 20.0F;\n\n    nightModeCollisionWarning(radar_distance, night_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide an alert if a pedestrian is detected too close while driving in rainy conditions.",
      "input": "Pedestrian distance: 6 meters. Threshold for rainy conditions: 8 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianRainCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters in rainy conditions.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving in rainy conditions.\" << std::endl;\n    }\n}\n\nint main() {\n    float pedestrian_distance = 6.0F;\n    float rainy_threshold = 8.0F;\n\n    pedestrianRainCollisionWarning(pedestrian_distance, rainy_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning when an object is detected within 10 meters using radar data.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F;\n    float threshold = 10.0F;\n\n    checkCollisionWarning(radar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Check if any object is too close from multiple objects detected using radar.",
      "input": "Object distances: 18 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {18.0F, 5.0F, 12.0F};\n    float collision_threshold = 10.0F;\n\n    checkMultipleObjectsDistance(object_distances, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Use both camera and radar data to issue a collision warning.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected by camera at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.0F;\n    bool camera_detection = true;\n    float threshold = 10.0F;\n\n    combinedCollisionWarning(radar_distance, camera_detection, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Change the collision warning threshold based on vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicSpeedThresholdWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger an alert if a pedestrian is detected within 5 meters using radar data.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 4.0F;\n    float pedestrian_threshold = 5.0F;\n\n    pedestrianCollisionWarning(radar_distance, pedestrian_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide collision warning if an object is too close during stop-and-go traffic.",
      "input": "Radar distance: 2.5 meters. Threshold for stop-and-go traffic: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Clear in stop-and-go traffic.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;\n    float stop_and_go_threshold = 3.0F;\n\n    stopAndGoCollisionWarning(radar_distance, stop_and_go_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Activate collision warning if an object is detected within the threshold while driving at night.",
      "input": "Radar distance: 12 meters. Threshold: 15 meters.",
      "output": "#include <iostream>\n\nvoid nightTimeCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters at night.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at night.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;\n    float night_threshold = 15.0F;\n\n    nightTimeCollisionWarning(radar_distance, night_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Issue a collision warning if an object is detected during low visibility conditions, even at a larger distance.",
      "input": "Radar distance: 25 meters. Threshold for low visibility: 30 meters.",
      "output": "#include <iostream>\n\nvoid lowVisibilityCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Low visibility hazard!\" << std::endl;\n    } else {\n        std::cout << \"Clear visibility.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 25.0F;\n    float low_visibility_threshold = 30.0F;\n\n    lowVisibilityCollisionWarning(radar_distance, low_visibility_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide an alert if an object is detected too close while reversing.",
      "input": "Reverse radar distance: 1.8 meters. Threshold: 2 meters.",
      "output": "#include <iostream>\n\nvoid reverseParkingAlert(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during reverse parking.\" << std::endl;\n    } else {\n        std::cout << \"Clear for reverse parking.\" << std::endl;\n    }\n}\n\nint main() {\n    float reverse_distance = 1.8F;\n    float parking_threshold = 2.0F;\n\n    reverseParkingAlert(reverse_distance, parking_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Detect sudden obstacles at high speed and trigger a warning if too close.",
      "input": "Vehicle speed: 100 km/h. Radar distance: 5 meters. Threshold: 6 meters.",
      "output": "#include <iostream>\n\nvoid suddenObstacleWarning(float vehicle_speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Sudden obstacle detected at \" << distance << \" meters. Slow down!\" << std::endl;\n    } else {\n        std::cout << \"Obstacle at a safe distance.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 100.0F;\n    float radar_distance = 5.0F;\n    float obstacle_threshold = 6.0F;\n\n    suddenObstacleWarning(vehicle_speed, radar_distance, obstacle_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Generate a forward collision warning if an object is detected within 10 meters using radar.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    /* Check if radar distance is less than the threshold */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F;\n    float threshold = 10.0F;\n\n    checkCollisionWarning(radar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Detect multiple objects and trigger a collision warning if any of them are too close.",
      "input": "Object distances: 18 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    /* Loop through all object distances to check if any object is too close */\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {18.0F, 5.0F, 12.0F};\n    float threshold = 10.0F;\n\n    checkMultipleObjectsDistance(object_distances, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Generate a forward collision warning when both radar and camera detect objects.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    /* Trigger warning if both radar and camera detect an object within the threshold distance */\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.0F;\n    bool camera_detection = true;\n    float threshold = 10.0F;\n\n    combinedCollisionWarning(radar_distance, camera_detection, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Change the collision warning threshold based on the vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    /* Warn if object is too close based on speed-adjusted threshold */\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicSpeedThresholdWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning if a pedestrian is detected within 5 meters.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    /* Detect pedestrian and trigger warning if too close */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 4.0F;\n    float pedestrian_threshold = 5.0F;\n\n    pedestrianCollisionWarning(radar_distance, pedestrian_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Implement a basic forward collision warning system that triggers a warning when an object is detected within a specified threshold distance.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    /* Trigger warning if object is closer than the threshold distance */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Develop a system that checks the distance of multiple objects and triggers a collision warning if any object is too close.",
      "input": "Object distances: 18 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    /* Check each object distance to see if any is below the threshold */\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}"
    },
    {
      "instruction": "Combine radar and camera data to trigger a forward collision warning when both detect an object within the threshold distance.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    /* Trigger warning if both radar and camera detect object within threshold */\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Create a forward collision warning system that adjusts the threshold distance dynamically based on vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    /* Adjust collision warning threshold based on vehicle speed */\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a forward collision warning when a pedestrian is detected within a critical distance.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    /* Check if the distance to the pedestrian is below the critical threshold */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Provide a collision warning when an object is detected too close during stop-and-go traffic conditions.",
      "input": "Radar distance: 2.5 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    /* Trigger a warning if an object is too close in stop-and-go traffic */\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters in stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance in stop-and-go traffic.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a forward collision warning if the radar detects an object within a certain distance when the vehicle is traveling at high speed.",
      "input": "Vehicle speed: 120 km/h. Radar distance: 30 meters. Threshold: 25 meters.",
      "output": "#include <iostream>\n\nvoid highSpeedCollisionWarning(float speed, float radar_distance, float threshold) {\n    /* Trigger a warning if the vehicle is moving fast and the object is too close */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a collision warning based on the size of detected objects and their distance.",
      "input": "Object size: 3 meters. Radar distance: 10 meters. Threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid objectSizeBasedCollisionWarning(float object_size, float radar_distance, float threshold) {\n    /* Trigger warning based on object size and distance to vehicle */\n    if (object_size > 2.0F && radar_distance < threshold) {\n        std::cout << \"WARNING: Large object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from object.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Generate a warning if the car ahead makes a sudden stop within a short distance.",
      "input": "Radar distance: 6 meters. Relative speed: 30 km/h. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid suddenStopCollisionWarning(float radar_distance, float relative_speed, float threshold) {\n    /* Trigger warning if a sudden stop is detected and object is too close */\n    if (radar_distance < threshold && relative_speed > 20.0F) {\n        std::cout << \"WARNING: Sudden stop detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Provide a collision warning system during nighttime driving if an object is detected within a specified distance.",
      "input": "Radar distance: 10 meters. Nighttime driving detected: True. Threshold: 12 meters.",
      "output": "#include <iostream>\n\nvoid nighttimeCollisionWarning(float radar_distance, bool nighttime, float threshold) {\n    /* Trigger a warning if object is too close during nighttime driving */\n    if (nighttime && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters during nighttime.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a simple forward collision warning system that triggers a warning if the object is within a defined threshold distance.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a logic to check multiple objects' distances and trigger a warning if any object is too close.",
      "input": "Object distances: 15 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}"
    },
    {
      "instruction": "Combine radar and camera data for collision warning, where both must detect an object within a threshold distance to trigger a warning.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Adjust the collision warning threshold dynamically based on vehicle speed. The threshold decreases as the vehicle's speed increases.",
      "input": "Vehicle speed: 80 km/h. Radar distance: 10 meters. Threshold: 15 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    if (speed > 60.0F) {\n        threshold = 10.0F; // Decrease threshold at high speed\n    }\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a forward collision warning system for detecting pedestrians within a threshold distance.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Create a forward collision warning system for stop-and-go traffic where objects are detected close to the vehicle.",
      "input": "Radar distance: 3 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance in stop-and-go traffic.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a forward collision warning system for high-speed driving where the warning triggers if an object is too close at high speed.",
      "input": "Vehicle speed: 120 km/h. Radar distance: 30 meters. Threshold: 25 meters.",
      "output": "#include <iostream>\n\nvoid highSpeedCollisionWarning(float speed, float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Create a system that triggers a collision warning if a large object is detected within a specified distance.",
      "input": "Object size: 3 meters. Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid objectSizeBasedWarning(float object_size, float radar_distance, float threshold) {\n    if (object_size > 2.0F && radar_distance < threshold) {\n        std::cout << \"WARNING: Large object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from object.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Develop a system that triggers a warning if an object ahead of the vehicle makes a sudden stop.",
      "input": "Radar distance: 6 meters. Relative speed: 30 km/h. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid suddenStopWarning(float radar_distance, float relative_speed, float threshold) {\n    if (radar_distance < threshold && relative_speed > 20.0F) {\n        std::cout << \"WARNING: Sudden stop detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a collision warning during nighttime driving if an object is detected within the threshold.",
      "input": "Radar distance: 10 meters. Nighttime driving detected: True. Threshold: 12 meters.",
      "output": "#include <iostream>\n\nvoid nighttimeCollisionWarning(float radar_distance, bool nighttime, float threshold) {\n    if (nighttime && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters during nighttime.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using radar distance data.",
      "input": "Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar data\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on vehicle speed.",
      "input": "Vehicle speed: 50 km/h, Radar distance: 9.5 meters.",
      "output": "#include <iostream>\n\nconst float BASE_THRESHOLD = 8.0f;\nconst float SPEED_ADJUSTMENT = 0.1f;\n\nfloat getSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 9.5f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getSpeed();\n    float distance = getRadarDistance();\n    float threshold = BASE_THRESHOLD + (speed * SPEED_ADJUSTMENT);\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using LiDAR distance data.",
      "input": "LiDAR distance: 6.8 meters.",
      "output": "#include <iostream>\n\nfloat getLiDARDistance() {\n    return 6.8f; // Simulated LiDAR data\n}\n\nint main() {\n    float distance = getLiDARDistance();\n    const float COLLISION_THRESHOLD = 7.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that uses radar and camera data fusion for distance calculation.",
      "input": "Radar distance: 7.2 meters, Camera distance: 6.0 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 7.2f; // Simulated radar data\n}\n\nfloat getCameraDistance() {\n    return 6.0f; // Simulated camera data\n}\n\nfloat calculateFusionDistance(float radar, float camera) {\n    return (radar + camera) / 2.0f; // Fusion of radar and camera data\n}\n\nint main() {\n    float radar = getRadarDistance();\n    float camera = getCameraDistance();\n\n    float fused_distance = calculateFusionDistance(radar, camera);\n    const float COLLISION_THRESHOLD = 7.0f;\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW based on object detection with radar and camera.",
      "input": "Object type: Vehicle, Radar distance: 6.0 meters, Camera distance: 5.5 meters.",
      "output": "#include <iostream>\n#include <string>\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nfloat getCameraDistance() {\n    return 5.5f; // Simulated camera data\n}\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nint main() {\n    float radar = getRadarDistance();\n    float camera = getCameraDistance();\n    std::string objectType = getObjectType();\n    const float VEHICLE_THRESHOLD = 8.0f;\n    const float PEDESTRIAN_THRESHOLD = 5.0f;\n    float threshold = (objectType == \"Vehicle\") ? VEHICLE_THRESHOLD : PEDESTRIAN_THRESHOLD;\n\n    if ((radar + camera) / 2.0f < threshold) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic collision threshold based on vehicle speed.",
      "input": "Speed: 80 km/h, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n\nconst float BASE_THRESHOLD = 6.0f;\nconst float SPEED_ADJUSTMENT = 0.1f;\n\nfloat getSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getSpeed();\n    float distance = getRadarDistance();\n    float threshold = BASE_THRESHOLD + (speed * SPEED_ADJUSTMENT);\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using LiDAR distance data for collision detection.",
      "input": "LiDAR distance: 5.0 meters.",
      "output": "#include <iostream>\n\nfloat getLiDARDistance() {\n    return 5.0f; // Simulated LiDAR data\n}\n\nint main() {\n    float distance = getLiDARDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using multi-sensor fusion from radar, camera, and LiDAR data.",
      "input": "Radar distance: 6.0 meters, Camera distance: 5.5 meters, LiDAR distance: 7.0 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nfloat getCameraDistance() {\n    return 5.5f; // Simulated camera data\n}\n\nfloat getLiDARDistance() {\n    return 7.0f; // Simulated LiDAR data\n}\n\nfloat calculateFusionDistance(float radar, float camera, float lidar) {\n    return (radar + camera + lidar) / 3.0f; // Average distance from all sensors\n}\n\nint main() {\n    float radar = getRadarDistance();\n    float camera = getCameraDistance();\n    float lidar = getLiDARDistance();\n\n    float fused_distance = calculateFusionDistance(radar, camera, lidar);\n    const float COLLISION_THRESHOLD = 6.5f;\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that specifically detects pedestrians and triggers a warning.",
      "input": "Pedestrian detected, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar data\n}\n\nint main() {\n    bool pedestrian_detected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    const float PEDESTRIAN_THRESHOLD = 5.0f;\n\n    if (pedestrian_detected && distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts collision threshold dynamically at high speed.",
      "input": "Speed: 120 km/h, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nconst float BASE_THRESHOLD = 6.0f;\nconst float SPEED_ADJUSTMENT = 0.2f;\n\nfloat getSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getSpeed();\n    float distance = getRadarDistance();\n    float threshold = BASE_THRESHOLD + (speed * SPEED_ADJUSTMENT);\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected at high speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained at high speed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to implement a simple radar-based FCW with a fixed threshold.",
      "input": "Radar distance: 4.8 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 4.8f; // Simulated radar distance\n}\n\nint main() {\n    const float COLLISION_THRESHOLD = 5.0f;\n    float distance = getRadarDistance();\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the threshold based on weather conditions.",
      "input": "Weather condition: Rainy, Radar distance: 6.2 meters.",
      "output": "#include <iostream>\n\nenum Weather { SUNNY, RAINY, SNOWY }; \n\nfloat getRadarDistance() {\n    return 6.2f; // Simulated radar data\n}\n\nWeather getWeatherCondition() {\n    return RAINY; // Simulated weather condition\n}\n\nint main() {\n    Weather weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = 5.0f;\n\n    if (weather == RAINY) {\n        COLLISION_THRESHOLD = 4.5f; // Adjust threshold in rainy conditions\n    }\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the threshold based on the object type (e.g., vehicle, pedestrian).",
      "input": "Object type: Vehicle, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n#include <string>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = (objectType == \"Vehicle\") ? 6.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained from \" << objectType << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the threshold is adjusted based on the vehicle speed.",
      "input": "Vehicle speed: 40 km/h, Radar distance: 7.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 7.5f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = 6.0f + (speed / 10.0f); // Dynamic threshold based on speed\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with pedestrian detection using radar data.",
      "input": "Pedestrian detected, Radar distance: 4.2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 4.2f; // Simulated radar data\n}\n\nint main() {\n    bool pedestrian_detected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    const float PEDESTRIAN_THRESHOLD = 4.5f;\n\n    if (pedestrian_detected && distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected or safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using camera data integrated with radar.",
      "input": "Camera distance: 5.0 meters, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nfloat getCameraDistance() {\n    return 5.0f; // Simulated camera data\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nint main() {\n    float camera = getCameraDistance();\n    float radar = getRadarDistance();\n    float fused_distance = (camera + radar) / 2.0f; // Fusion of camera and radar data\n    const float COLLISION_THRESHOLD = 5.5f;\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with a high-speed collision warning that triggers above a certain speed.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float SPEED_THRESHOLD = 100.0f;\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (speed > SPEED_THRESHOLD && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on road curvature.",
      "input": "Road curvature: 15 degrees, Radar distance: 6.3 meters.",
      "output": "#include <iostream>\n\nfloat getRoadCurvature() {\n    return 15.0f; // Simulated road curvature\n}\n\nfloat getRadarDistance() {\n    return 6.3f; // Simulated radar data\n}\n\nint main() {\n    float curvature = getRoadCurvature();\n    float distance = getRadarDistance();\n    const float BASE_THRESHOLD = 6.0f;\n    float threshold = (curvature > 10.0f) ? BASE_THRESHOLD * 1.1f : BASE_THRESHOLD;\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected due to road curvature!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that differentiates between pedestrians and vehicles.",
      "input": "Object type: Pedestrian, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float VEHICLE_THRESHOLD = 6.0f;\n    const float PEDESTRIAN_THRESHOLD = 4.0f;\n\n    if (objectType == \"Pedestrian\" && distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters.\" << std::endl;\n    } else if (objectType == \"Vehicle\" && distance < VEHICLE_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that activates emergency braking when a collision is imminent.",
      "input": "Radar distance: 2.5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.5f; // Simulated radar data\n}\n\nbool isEmergencyBrakingRequired(float distance) {\n    const float EMERGENCY_THRESHOLD = 3.0f;\n    return distance < EMERGENCY_THRESHOLD; // Trigger emergency braking if below threshold\n}\n\nint main() {\n    float distance = getRadarDistance();\n\n    if (isEmergencyBrakingRequired(distance)) {\n        std::cout << \"WARNING: Collision imminent, emergency braking activated!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the threshold based on the vehicle's current speed.",
      "input": "Vehicle speed: 80 km/h, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float BASE_THRESHOLD = 6.0f;\n    float COLLISION_THRESHOLD = BASE_THRESHOLD - (speed / 100.0f);\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that considers the velocity of the vehicle and calculates the time-to-collision.",
      "input": "Vehicle speed: 60 km/h, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar data\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / speed; // Time to collision calculation\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float time_to_collision = calculateTimeToCollision(speed, distance);\n\n    if (time_to_collision < 3.0f) {\n        std::cout << \"WARNING: High collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that automatically adjusts the distance threshold based on road type.",
      "input": "Road type: Highway, Radar distance: 7.0 meters.",
      "output": "#include <iostream>\n\nenum RoadType { CITY, HIGHWAY, RURAL };\n\nRoadType getRoadType() {\n    return HIGHWAY; // Simulated road type\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Simulated radar data\n}\n\nint main() {\n    RoadType road_type = getRoadType();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = (road_type == HIGHWAY) ? 8.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that also incorporates lane departure warning into the decision-making process.",
      "input": "Lane departure: Yes, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulated lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar data\n}\n\nint main() {\n    bool lane_departure = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 5.0f;\n\n    if (lane_departure && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure and collision risk detected!\" << std::endl;\n    } else if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that only activates when a vehicle ahead is detected.",
      "input": "Vehicle ahead: Detected, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nbool isVehicleAheadDetected() {\n    return true; // Simulated vehicle ahead detection\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar data\n}\n\nint main() {\n    bool vehicle_ahead = isVehicleAheadDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (vehicle_ahead && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates time-to-collision with pedestrians and triggers a warning if necessary.",
      "input": "Object type: Pedestrian, Radar distance: 3.0 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / (speed / 3.6f); // Time to collision (km/h to m/s conversion)\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    std::string objectType = getObjectType();\n    float time_to_collision = calculateTimeToCollision(speed, distance);\n\n    if (objectType == \"Pedestrian\" && time_to_collision < 2.0f) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dual thresholds based on the vehicle's speed: one for city speed and one for highway speed.",
      "input": "Vehicle speed: 110 km/h, Radar distance: 8.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 110.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float CITY_SPEED_THRESHOLD = 5.0f;\n    const float HIGHWAY_SPEED_THRESHOLD = 8.0f;\n    float COLLISION_THRESHOLD = (speed < 50.0f) ? CITY_SPEED_THRESHOLD : HIGHWAY_SPEED_THRESHOLD;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision threshold based on whether it is day or night.",
      "input": "Time of day: Night, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nbool isNightTime() {\n    return true; // Simulated night-time condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nint main() {\n    bool night_time = isNightTime();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = night_time ? 5.0f : 7.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the weather condition (rain/sunny).",
      "input": "Weather condition: Rain, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAIN, FOGGY };\n\nWeatherCondition getWeatherCondition() {\n    return RAIN; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar data\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAIN) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects multiple objects and provides warnings for each detected object.",
      "input": "Object 1: Vehicle, Radar distance: 4.5 meters, Object 2: Pedestrian, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType(int objectId) {\n    if (objectId == 1) {\n        return \"Vehicle\";\n    } else if (objectId == 2) {\n        return \"Pedestrian\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\nfloat getRadarDistance(int objectId) {\n    if (objectId == 1) {\n        return 4.5f;\n    } else if (objectId == 2) {\n        return 2.0f;\n    } else {\n        return 0.0f;\n    }\n}\n\nint main() {\n    for (int i = 1; i <= 2; ++i) {\n        std::string objectType = getObjectType(i);\n        float distance = getRadarDistance(i);\n        const float COLLISION_THRESHOLD = (objectType == \"Pedestrian\") ? 3.0f : 6.0f;\n\n        if (distance < COLLISION_THRESHOLD) {\n            std::cout << \"WARNING: \" << objectType << \" detected at \" << distance << \" meters.\" << std::endl;\n        } else {\n            std::cout << \"Safe distance maintained for \" << objectType << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the collision warning threshold adjusts based on the vehicle's speed.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (speed > 80.0f) ? 5.0f : 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that compares distances of multiple objects and triggers a warning for the closest object.",
      "input": "Object 1: Car, Radar distance: 7.5 meters, Object 2: Pedestrian, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance(int objectId) {\n    if (objectId == 1) {\n        return 7.5f; // Distance to Car\n    } else if (objectId == 2) {\n        return 3.5f; // Distance to Pedestrian\n    } else {\n        return 0.0f; // Invalid Object\n    }\n}\n\nint main() {\n    float carDistance = getRadarDistance(1);\n    float pedestrianDistance = getRadarDistance(2);\n    float closestDistance = (carDistance < pedestrianDistance) ? carDistance : pedestrianDistance;\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (closestDistance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with the closest object!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision detection threshold based on whether it is day or night.",
      "input": "Time of day: Day, Vehicle speed: 60 km/h, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nbool isDayTime() {\n    return true; // Simulated time of day\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar data\n}\n\nint main() {\n    bool daytime = isDayTime();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float DAYTIME_THRESHOLD = (daytime) ? 5.5f : 4.5f;\n\n    if (distance < DAYTIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with pedestrian detection and a stricter collision threshold if the vehicle is moving slowly.",
      "input": "Object type: Pedestrian, Vehicle speed: 30 km/h, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (speed < 40.0f) ? 1.5f : 3.0f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates the following distance based on the vehicle's speed and triggers a warning if the distance is too short.",
      "input": "Vehicle speed: 80 km/h, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float followingDistance = speed / 2.0f; // Following distance = speed / 2 (for simplicity)\n\n    if (distance < followingDistance) {\n        std::cout << \"WARNING: Following distance too short!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on weather conditions.",
      "input": "Weather condition: Rain, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAIN, SNOW };\n\nWeatherCondition getWeatherCondition() {\n    return RAIN; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAIN) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the vehicle's speed dynamically if a collision risk is detected.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 3.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid adjustVehicleSpeed(float& speed) {\n    speed = 80.0f; // Reduce speed to avoid collision\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.5f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Reducing speed...\" << std::endl;\n        adjustVehicleSpeed(speed);\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects the object type (vehicle or pedestrian) and adjusts the collision threshold accordingly.",
      "input": "Object type: Vehicle, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float VEHICLE_THRESHOLD = 5.0f;\n    const float PEDESTRIAN_THRESHOLD = 2.0f;\n    const float COLLISION_THRESHOLD = (objectType == \"Vehicle\") ? VEHICLE_THRESHOLD : PEDESTRIAN_THRESHOLD;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that tracks the vehicle's distance over time to ensure long-term safety.",
      "input": "Radar distance: 3.0 meters, Time elapsed: 5 seconds.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n    const int TIME_ELAPSED = 5; // Time in seconds\n\n    if (distance < COLLISION_THRESHOLD && TIME_ELAPSED > 3) {\n        std::cout << \"WARNING: Collision risk detected after long-term monitoring!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a reactive warning system when a collision risk is detected.",
      "input": "Radar distance: 3.0 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nvoid triggerWarning() {\n    std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.5f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        triggerWarning();\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect objects using a Haar Cascade Classifier and issue collision warnings when necessary.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', and handle all type conversions explicitly.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\nvoid detectObjects(cv::Mat &frame, cv::CascadeClassifier &classifier) {\n    std::vector<cv::Rect> objects;\n    classifier.detectMultiScale(frame, objects);\n\n    for (size_t i = 0; i < objects.size(); ++i) {\n        cv::Rect object = objects[i];\n        cv::rectangle(frame, object, cv::Scalar(0, 255, 0), 2);\n        if (object.x < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    cv::CascadeClassifier classifier;\n    if (!classifier.load(\"haarcascade_car.xml\")) {\n        std::cerr << \"Error: Unable to load classifier.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObjects(frame, classifier);\n        cv::imshow(\"Forward Collision Warning System\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to estimate the speed of a vehicle based on the changes in the position of objects across frames.",
      "input": "Use OpenCV for video frame processing and motion estimation, avoid 'using namespace', and explicitly handle all type conversions.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float VEHICLE_SPEED_THRESHOLD = 30.0f; // Speed threshold for warning\n\nvoid estimateSpeed(cv::Mat &prevFrame, cv::Mat &currentFrame, float &speed) {\n    cv::Mat diffFrame;\n    cv::absdiff(prevFrame, currentFrame, diffFrame);\n    cv::threshold(diffFrame, diffFrame, 50, 255, cv::THRESH_BINARY);\n\n    int nonZeroCount = cv::countNonZero(diffFrame);\n    speed = static_cast<float>(nonZeroCount) / 100.0f;\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat prevFrame, currentFrame;\n    float speed = 0.0f;\n    while (true) {\n        capture >> currentFrame;\n        if (currentFrame.empty()) {\n            break;\n        }\n\n        if (!prevFrame.empty()) {\n            estimateSpeed(prevFrame, currentFrame, speed);\n            if (speed > VEHICLE_SPEED_THRESHOLD) {\n                cv::putText(currentFrame, \"WARNING: VEHICLE TOO FAST\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n            }\n        }\n\n        prevFrame = currentFrame.clone();\n        cv::imshow(\"Speed Estimation\", currentFrame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to calculate the distance to detected objects using camera focal length and object width.",
      "input": "Use OpenCV for image processing and avoid 'using namespace'. Handle all type conversions explicitly and ensure proper error checking.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float CAR_WIDTH_METERS = 1.8f; // Car width in meters\n\nfloat calculateDistance(int objectWidth, int imageWidth) {\n    if (objectWidth == 0) {\n        return -1.0f; // Error: Object width is zero\n    }\n    return (CAR_WIDTH_METERS * FOCAL_LENGTH_X) / static_cast<float>(objectWidth);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        int objectWidth = 200; // Example object width\n        float distance = calculateDistance(objectWidth, frame.cols);\n        if (distance > 0.0f) {\n            std::string distanceText = \"Distance: \" + std::to_string(distance) + \" m\";\n            cv::putText(frame, distanceText, cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255, 0, 0), 2);\n        }\n        cv::imshow(\"Distance Calculation\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to perform lane detection using edge detection techniques.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectLane(cv::Mat &frame) {\n    cv::Mat grayFrame, edges;\n    cv::cvtColor(frame, grayFrame, cv::COLOR_BGR2GRAY);\n    cv::GaussianBlur(grayFrame, grayFrame, cv::Size(5, 5), 1.5, 1.5);\n    cv::Canny(grayFrame, edges, 50, 150);\n    cv::imshow(\"Lane Detection\", edges);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLane(frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to issue a warning when an obstacle is detected within a specified range.",
      "input": "Use OpenCV for image processing, explicitly handle all type conversions, and avoid 'using namespace'.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float OBSTACLE_THRESHOLD = 5.0f; // Obstacle threshold in meters\n\nvoid issueWarning(cv::Mat &frame, float distance) {\n    if (distance < OBSTACLE_THRESHOLD) {\n        cv::putText(frame, \"WARNING: OBSTACLE AHEAD\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        float distance = 4.0f; // Example distance\n        issueWarning(frame, distance);\n        cv::imshow(\"Obstacle Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect objects using contours and issue collision warnings based on the object's size.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD_AREA = 5000.0f; // Threshold for object area\n\nvoid detectObjectAndWarn(cv::Mat &frame) {\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::GaussianBlur(gray, gray, cv::Size(5, 5), 1.5, 1.5);\n    cv::Canny(gray, edges, 50, 150);\n\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(edges, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    for (size_t i = 0; i < contours.size(); ++i) {\n        float area = cv::contourArea(contours[i]);\n        if (area > COLLISION_THRESHOLD_AREA) {\n            cv::drawContours(frame, contours, i, cv::Scalar(0, 255, 0), 2);\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObjectAndWarn(frame);\n        cv::imshow(\"Object Detection and Collision Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect lane lines using Hough Transform and issue collision warnings when a lane deviation is detected.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectLane(cv::Mat &frame) {\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::GaussianBlur(gray, gray, cv::Size(5, 5), 1.5, 1.5);\n    cv::Canny(gray, edges, 50, 150);\n\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 50, 50, 10);\n\n    for (size_t i = 0; i < lines.size(); ++i) {\n        cv::Vec4i l = lines[i];\n        cv::line(frame, cv::Point(l[0], l[1]), cv::Point(l[2], l[3]), cv::Scalar(0, 255, 0), 2);\n    }\n\n    if (lines.size() < 2) {\n        cv::putText(frame, \"WARNING: LANE DEVIATION\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLane(frame);\n        cv::imshow(\"Lane Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to track detected objects and issue collision warnings when objects come too close.",
      "input": "Use OpenCV for object tracking, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Distance threshold\n\nvoid trackObject(cv::Mat &frame) {\n    static cv::Ptr<cv::Tracker> tracker = cv::TrackerKCF::create();\n    static cv::Rect2d roi;\n    static bool isTracking = false;\n\n    if (!isTracking) {\n        roi = cv::selectROI(\"Select Object\", frame, false, false);\n        tracker->init(frame, roi);\n        isTracking = true;\n    } else {\n        tracker->update(frame, roi);\n        cv::rectangle(frame, roi, cv::Scalar(0, 255, 0), 2);\n\n        float distance = roi.width / 100.0f; // Example: using width as a proxy for distance\n        if (distance < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        trackObject(frame);\n        cv::imshow(\"Object Tracking\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to estimate the speed of a vehicle and issue a collision warning if the speed exceeds a threshold.",
      "input": "Use OpenCV for video frame processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_THRESHOLD = 40.0f; // Speed threshold for warning\n\nvoid estimateSpeed(cv::Mat &frame, float &speed) {\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::GaussianBlur(gray, gray, cv::Size(5, 5), 1.5, 1.5);\n    cv::Canny(gray, edges, 50, 150);\n\n    int nonZeroCount = cv::countNonZero(edges);\n    speed = static_cast<float>(nonZeroCount) / 100.0f;\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    float speed = 0.0f;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        estimateSpeed(frame, speed);\n        if (speed > SPEED_THRESHOLD) {\n            cv::putText(frame, \"WARNING: VEHICLE TOO FAST\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n        cv::imshow(\"Speed Estimation and Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect traffic lights and issue an alert when the light turns red.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficLight(cv::Mat &frame) {\n    cv::Mat hsv, maskRed, maskGreen, maskYellow;\n    cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV);\n\n    cv::inRange(hsv, cv::Scalar(0, 120, 70), cv::Scalar(10, 255, 255), maskRed);\n    cv::inRange(hsv, cv::Scalar(36, 50, 70), cv::Scalar(89, 255, 255), maskGreen);\n    cv::inRange(hsv, cv::Scalar(20, 100, 100), cv::Scalar(30, 255, 255), maskYellow);\n\n    if (cv::countNonZero(maskRed) > 10000) {\n        cv::putText(frame, \"WARNING: RED LIGHT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficLight(frame);\n        cv::imshow(\"Traffic Light Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect vehicles using Haar Cascade Classifier and issue a collision warning when detected.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nvoid detectVehicle(cv::Mat &frame) {\n    cv::CascadeClassifier vehicleCascade;\n    if (!vehicleCascade.load(\"haarcascade_car.xml\")) {\n        std::cerr << \"Error: Unable to load Haar cascade classifier.\" << std::endl;\n        return;\n    }\n\n    std::vector<cv::Rect> vehicles;\n    vehicleCascade.detectMultiScale(frame, vehicles, 1.1, 3, 0, cv::Size(30, 30));\n\n    for (size_t i = 0; i < vehicles.size(); ++i) {\n        cv::rectangle(frame, vehicles[i], cv::Scalar(0, 255, 0), 2);\n        cv::putText(frame, \"VEHICLE DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectVehicle(frame);\n        cv::imshow(\"Vehicle Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to estimate the distance to an object using stereo vision and issue a collision warning when the object is too close.",
      "input": "Use OpenCV for stereo vision, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BASELINE = 0.1f; // Distance between stereo cameras in meters\nconst float FOCAL_LENGTH = 800.0f; // Camera focal length in pixels\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision warning distance\n\nvoid estimateDistance(cv::Mat &leftImage, cv::Mat &rightImage) {\n    cv::Mat disparity, disparityNormalized;\n    cv::Ptr<cv::StereoBM> stereoBM = cv::StereoBM::create(16, 9);\n    stereoBM->compute(leftImage, rightImage, disparity);\n\n    disparity.convertTo(disparityNormalized, CV_8U, 255.0 / (16.0 * 16.0));\n\n    float distance = (BASELINE * FOCAL_LENGTH) / (disparity.at<short>(100, 100) / 16.0f);\n\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(leftImage, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture leftCapture(0), rightCapture(1);\n    if (!leftCapture.isOpened() || !rightCapture.isOpened()) {\n        std::cerr << \"Error: Unable to open stereo video sources.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat leftFrame, rightFrame;\n    while (true) {\n        leftCapture >> leftFrame;\n        rightCapture >> rightFrame;\n        if (leftFrame.empty() || rightFrame.empty()) {\n            break;\n        }\n\n        estimateDistance(leftFrame, rightFrame);\n        cv::imshow(\"Stereo Vision - Distance Estimation\", leftFrame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    leftCapture.release();\n    rightCapture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect moving objects using background subtraction and issue collision warnings when an object is detected too close.",
      "input": "Use OpenCV for background subtraction, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision distance threshold\n\nvoid detectMovingObject(cv::Mat &frame) {\n    static cv::Ptr<cv::BackgroundSubtractor> bgSubtractor = cv::createBackgroundSubtractorMOG2();\n    cv::Mat fgMask;\n    bgSubtractor->apply(frame, fgMask);\n\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(fgMask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    for (size_t i = 0; i < contours.size(); ++i) {\n        cv::Rect boundingBox = cv::boundingRect(contours[i]);\n        if (boundingBox.area() > 500) {\n            cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n            if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n                cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n            }\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectMovingObject(frame);\n        cv::imshow(\"Object Detection - Background Subtraction\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to estimate depth and issue collision warnings based on distance from a single camera.",
      "input": "Use OpenCV for image processing, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float OBJECT_WIDTH_METERS = 1.8f; // Example object width in meters\nconst float FOCAL_LENGTH_PIXELS = 800.0f; // Camera focal length in pixels\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision threshold distance\n\nfloat estimateDepth(int objectWidth, int imageWidth) {\n    if (objectWidth == 0) {\n        return -1.0f; // Error: Invalid object width\n    }\n    return (OBJECT_WIDTH_METERS * FOCAL_LENGTH_PIXELS) / static_cast<float>(objectWidth);\n}\n\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(600, 400, 200, 100); // Example bounding box\n    float distance = estimateDepth(boundingBox.width, frame.cols);\n\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        processFrame(frame);\n        cv::imshow(\"Depth Estimation and Collision Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect lanes and issue an alert when the vehicle drifts out of its lane.",
      "input": "Use OpenCV for lane detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectLane(cv::Mat &frame) {\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::Canny(gray, edges, 50, 150);\n\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 100, 50, 10);\n\n    for (size_t i = 0; i < lines.size(); ++i) {\n        cv::line(frame, cv::Point(lines[i][0], lines[i][1]), cv::Point(lines[i][2], lines[i][3]), cv::Scalar(0, 255, 0), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLane(frame);\n        cv::imshow(\"Lane Detection for FCW\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting pedestrians using a pre-trained model and issuing a collision warning.",
      "input": "Use OpenCV for pedestrian detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nvoid detectPedestrian(cv::Mat &frame) {\n    cv::CascadeClassifier pedestrianCascade;\n    if (!pedestrianCascade.load(\"haarcascade_fullbody.xml\")) {\n        std::cerr << \"Error: Unable to load pedestrian detection model.\" << std::endl;\n        return;\n    }\n\n    std::vector<cv::Rect> pedestrians;\n    pedestrianCascade.detectMultiScale(frame, pedestrians, 1.1, 3, 0, cv::Size(30, 30));\n\n    for (size_t i = 0; i < pedestrians.size(); ++i) {\n        cv::rectangle(frame, pedestrians[i], cv::Scalar(0, 255, 0), 2);\n        cv::putText(frame, \"PEDESTRIAN DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectPedestrian(frame);\n        cv::imshow(\"Pedestrian Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for estimating the speed of a vehicle using optical flow and issuing a collision warning if the speed is too high.",
      "input": "Use OpenCV for optical flow, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD_SPEED = 20.0f; // Speed threshold in m/s\n\nvoid estimateSpeed(cv::Mat &prevFrame, cv::Mat &currentFrame) {\n    cv::Mat flow;\n    cv::calcOpticalFlowFarneback(prevFrame, currentFrame, flow, 0.5, 3, 15, 3, 5, 1.2, 0);\n\n    float speed = cv::mean(flow)[0]; // Estimate speed as mean optical flow\n    if (speed > COLLISION_THRESHOLD_SPEED) {\n        cv::putText(currentFrame, \"WARNING: SPEED TOO HIGH\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat prevFrame, currentFrame;\n    while (true) {\n        capture >> currentFrame;\n        if (currentFrame.empty()) {\n            break;\n        }\n\n        if (!prevFrame.empty()) {\n            estimateSpeed(prevFrame, currentFrame);\n        }\n\n        prevFrame = currentFrame.clone();\n        cv::imshow(\"Vehicle Speed Estimation\", currentFrame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect lane departures and issue a warning when the vehicle crosses the lane boundary.",
      "input": "Use OpenCV for lane detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectLaneDeparture(cv::Mat &frame) {\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::Canny(gray, edges, 50, 150);\n\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 100, 50, 10);\n\n    for (size_t i = 0; i < lines.size(); ++i) {\n        cv::line(frame, cv::Point(lines[i][0], lines[i][1]), cv::Point(lines[i][2], lines[i][3]), cv::Scalar(0, 255, 0), 2);\n    }\n\n    if (lines.size() == 0) {\n        cv::putText(frame, \"WARNING: LANE DEPARTURE\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLaneDeparture(frame);\n        cv::imshow(\"Lane Departure Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect objects in real-time using YOLOv4 and issue a collision warning if an object is detected too close.",
      "input": "Use OpenCV for object detection with YOLOv4, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Distance threshold\n\nvoid detectObjectYOLO(cv::Mat &frame) {\n    cv::dnn::Net net = cv::dnn::readNet(\"yolov4.weights\", \"yolov4.cfg\");\n    std::vector<cv::Mat> detections;\n    cv::Mat blob = cv::dnn::blobFromImage(frame, 0.00392, cv::Size(416, 416), cv::Scalar(0, 0, 0), true, false);\n    net.setInput(blob);\n    net.forward(detections);\n\n    for (const auto& detection : detections) {\n        float confidence = detection.at<float>(5);\n        if (confidence > 0.5) {\n            cv::Rect boundingBox;\n            boundingBox.x = static_cast<int>(detection.at<float>(0) * frame.cols);\n            boundingBox.y = static_cast<int>(detection.at<float>(1) * frame.rows);\n            boundingBox.width = static_cast<int>(detection.at<float>(2) * frame.cols);\n            boundingBox.height = static_cast<int>(detection.at<float>(3) * frame.rows);\n\n            cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n            if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n                cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n            }\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObjectYOLO(frame);\n        cv::imshow(\"Real-Time Object Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect traffic lights and issue a warning if the light is red.",
      "input": "Use OpenCV for traffic light detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficLight(cv::Mat &frame) {\n    cv::Mat hsv, maskRed, maskGreen, maskYellow;\n    cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV);\n\n    // Red detection\n    cv::inRange(hsv, cv::Scalar(0, 120, 70), cv::Scalar(10, 255, 255), maskRed);\n    cv::inRange(hsv, cv::Scalar(170, 120, 70), cv::Scalar(180, 255, 255), maskRed);\n    if (cv::countNonZero(maskRed) > 1000) {\n        cv::putText(frame, \"WARNING: RED LIGHT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n\n    // Green detection\n    cv::inRange(hsv, cv::Scalar(35, 100, 100), cv::Scalar(85, 255, 255), maskGreen);\n    if (cv::countNonZero(maskGreen) > 1000) {\n        cv::putText(frame, \"GREEN LIGHT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficLight(frame);\n        cv::imshow(\"Traffic Light Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for vehicle detection using Haar Cascade classifier and issue a collision warning if the vehicle is too close.",
      "input": "Use OpenCV for vehicle detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Distance threshold\n\nvoid detectVehicle(cv::Mat &frame) {\n    cv::CascadeClassifier vehicleCascade;\n    if (!vehicleCascade.load(\"haarcascade_car.xml\")) {\n        std::cerr << \"Error: Unable to load vehicle detection model.\" << std::endl;\n        return;\n    }\n\n    std::vector<cv::Rect> vehicles;\n    vehicleCascade.detectMultiScale(frame, vehicles, 1.1, 3, 0, cv::Size(30, 30));\n\n    for (size_t i = 0; i < vehicles.size(); ++i) {\n        cv::rectangle(frame, vehicles[i], cv::Scalar(0, 255, 0), 2);\n        cv::putText(frame, \"VEHICLE DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        // Check if the detected vehicle is too close\n        if (vehicles[i].width < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectVehicle(frame);\n        cv::imshow(\"Vehicle Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting traffic signs and issuing a collision warning if the sign indicates a stop or caution.",
      "input": "Use OpenCV for traffic sign detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 3.0f; // Distance threshold\n\nvoid detectTrafficSign(cv::Mat &frame) {\n    cv::CascadeClassifier signCascade;\n    if (!signCascade.load(\"haarcascade_stop.xml\")) {\n        std::cerr << \"Error: Unable to load traffic sign detection model.\" << std::endl;\n        return;\n    }\n\n    std::vector<cv::Rect> signs;\n    signCascade.detectMultiScale(frame, signs, 1.1, 3, 0, cv::Size(30, 30));\n\n    for (size_t i = 0; i < signs.size(); ++i) {\n        cv::rectangle(frame, signs[i], cv::Scalar(0, 255, 0), 2);\n        cv::putText(frame, \"TRAFFIC SIGN DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        // Check if the traffic sign indicates a stop or caution\n        if (signs[i].width < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficSign(frame);\n        cv::imshow(\"Traffic Sign Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect objects using the YOLO model and issue a collision warning if any detected object is too close.",
      "input": "Use OpenCV for YOLO object detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Distance threshold\n\nvoid detectObjectYOLO(cv::Mat &frame) {\n    cv::dnn::Net net = cv::dnn::readNet(\"yolov4.weights\", \"yolov4.cfg\");\n    std::vector<cv::Mat> detections;\n    cv::Mat blob = cv::dnn::blobFromImage(frame, 0.00392, cv::Size(416, 416), cv::Scalar(0, 0, 0), true, false);\n    net.setInput(blob);\n    net.forward(detections);\n\n    for (const auto& detection : detections) {\n        float confidence = detection.at<float>(5);\n        if (confidence > 0.5) {\n            cv::Rect boundingBox;\n            boundingBox.x = static_cast<int>(detection.at<float>(0) * frame.cols);\n            boundingBox.y = static_cast<int>(detection.at<float>(1) * frame.rows);\n            boundingBox.width = static_cast<int>(detection.at<float>(2) * frame.cols);\n            boundingBox.height = static_cast<int>(detection.at<float>(3) * frame.rows);\n\n            cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n            if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n                cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n            }\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObjectYOLO(frame);\n        cv::imshow(\"YOLO Object Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect pedestrians and issue a collision warning if a pedestrian is detected too close.",
      "input": "Use OpenCV for pedestrian detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Distance threshold\n\nvoid detectPedestrian(cv::Mat &frame) {\n    cv::CascadeClassifier pedestrianCascade;\n    if (!pedestrianCascade.load(\"haarcascade_fullbody.xml\")) {\n        std::cerr << \"Error: Unable to load pedestrian detection model.\" << std::endl;\n        return;\n    }\n\n    std::vector<cv::Rect> pedestrians;\n    pedestrianCascade.detectMultiScale(frame, pedestrians, 1.1, 3, 0, cv::Size(30, 30));\n\n    for (size_t i = 0; i < pedestrians.size(); ++i) {\n        cv::rectangle(frame, pedestrians[i], cv::Scalar(0, 255, 0), 2);\n        cv::putText(frame, \"PEDESTRIAN DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        if (pedestrians[i].width < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectPedestrian(frame);\n        cv::imshow(\"Pedestrian Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for lane detection and issue a collision warning if the vehicle deviates from its lane.",
      "input": "Use OpenCV for lane detection, avoid 'using namespace', handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\nconst float DEVIATION_THRESHOLD = 50.0f; // Lane deviation threshold\n\nvoid detectLane(cv::Mat &frame) {\n    cv::Mat gray, edges;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::GaussianBlur(gray, gray, cv::Size(5, 5), 1.5, 1.5);\n    cv::Canny(gray, edges, 50, 150);\n\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 100, 50, 10);\n\n    for (size_t i = 0; i < lines.size(); ++i) {\n        cv::line(frame, cv::Point(lines[i][0], lines[i][1]), cv::Point(lines[i][2], lines[i][3]), cv::Scalar(0, 255, 0), 2);\n    }\n\n    // Simple deviation check based on lane lines\n    if (lines.size() < 2) {\n        cv::putText(frame, \"WARNING: LANE DEVIATION\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLane(frame);\n        cv::imshow(\"Lane Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting proximity using sensors and issue a collision warning if the vehicle gets too close.",
      "input": "Use simulated sensor data for proximity detection, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PROXIMITY_THRESHOLD_METERS = 2.0f; // Proximity threshold\n\nvoid checkProximity(float distance) {\n    if (distance < PROXIMITY_THRESHOLD_METERS) {\n        std::cout << \"WARNING: COLLISION RISK! Vehicle too close.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is at a safe distance.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float simulatedDistance = 1.5f; // Simulated proximity value\n    checkProximity(simulatedDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate radar sensor input for detecting obstacles and issue a collision warning if an object is detected within a danger zone.",
      "input": "Use radar sensor data to simulate object detection, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float DANGER_ZONE_METERS = 3.0f; // Danger zone threshold\n\nvoid detectObjectWithRadar(float distance) {\n    if (distance < DANGER_ZONE_METERS) {\n        std::cout << \"WARNING: COLLISION RISK! Object detected within the danger zone.\" << std::endl;\n    } else {\n        std::cout << \"No objects detected within the danger zone.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float radarSensorDistance = 2.5f; // Simulated radar sensor reading\n    detectObjectWithRadar(radarSensorDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting obstacles using LiDAR data and issue a collision warning if an obstacle is within a predefined safe distance.",
      "input": "Simulate LiDAR data processing for obstacle detection, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE_METERS = 5.0f; // Safe distance threshold\n\nvoid detectObstacleWithLiDAR(float distance) {\n    if (distance < SAFE_DISTANCE_METERS) {\n        std::cout << \"WARNING: COLLISION RISK! Obstacle detected.\" << std::endl;\n    } else {\n        std::cout << \"No obstacles detected within the safe distance.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float simulatedLiDARDistance = 3.0f; // Simulated LiDAR data\n    detectObstacleWithLiDAR(simulatedLiDARDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to process camera feed and issue a collision warning if an object is detected within a collision threshold.",
      "input": "Simulate camera input for object detection, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD_METERS = 4.0f; // Collision threshold\n\nvoid processCameraFeed(cv::Mat &frame) {\n    // Simulate object detection\n    cv::Rect detectedObject(100, 100, 50, 50); // Simulated object bounding box\n    cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n    if (detectedObject.width < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        processCameraFeed(frame);\n        cv::imshow(\"Collision Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to process GPS data and issue a collision warning if the vehicle is approaching a predefined hazard zone.",
      "input": "Simulate GPS coordinates and check against hazard zone boundaries, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float HAZARD_ZONE_LAT = 37.7749f; // Simulated latitude of hazard zone\nconst float HAZARD_ZONE_LON = -122.4194f; // Simulated longitude of hazard zone\nconst float COLLISION_RADIUS_METERS = 50.0f; // Collision radius\n\nvoid checkProximityToHazardZone(float vehicleLat, float vehicleLon) {\n    float distanceToHazard = sqrt(pow(vehicleLat - HAZARD_ZONE_LAT, 2) + pow(vehicleLon - HAZARD_ZONE_LON, 2)) * 100000; // Simplified distance calculation\n    if (distanceToHazard < COLLISION_RADIUS_METERS) {\n        std::cout << \"WARNING: COLLISION RISK! Approaching hazard zone.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is at a safe distance.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleLatitude = 37.7750f; // Simulated vehicle latitude\n    float vehicleLongitude = -122.4195f; // Simulated vehicle longitude\n    checkProximityToHazardZone(vehicleLatitude, vehicleLongitude);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting obstacles using reverse parking sensors and issue an alert if the vehicle gets too close to an object.",
      "input": "Simulate sensor input for reverse parking, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REVERSE_THRESHOLD_METERS = 1.0f; // Reverse proximity threshold\n\nvoid checkReverseProximity(float distance) {\n    if (distance < REVERSE_THRESHOLD_METERS) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from object.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float reverseDistance = 0.8f; // Simulated reverse parking sensor reading\n    checkReverseProximity(reverseDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting traffic lights in the camera feed and issue a warning if the light turns red.",
      "input": "Simulate traffic light detection using OpenCV, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst cv::Scalar RED_LIGHT_COLOR(0, 0, 255); // Red light color in BGR\n\nvoid detectTrafficLight(cv::Mat &frame) {\n    // Simulated traffic light detection (e.g., red light)\n    cv::Rect trafficLight(50, 50, 100, 100); // Simulated bounding box\n    cv::rectangle(frame, trafficLight, RED_LIGHT_COLOR, 2);\n    cv::putText(frame, \"WARNING: RED LIGHT AHEAD!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, RED_LIGHT_COLOR, 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficLight(frame);\n        cv::imshow(\"Traffic Light Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting vehicles in the blind spot using side cameras and issue an alert if a vehicle is detected.",
      "input": "Simulate vehicle detection using side cameras, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD_METERS = 3.0f; // Blind spot distance threshold\n\nvoid detectVehicleInBlindSpot(cv::Mat &frame) {\n    cv::Rect detectedVehicle(200, 200, 100, 50); // Simulated vehicle bounding box\n    cv::rectangle(frame, detectedVehicle, cv::Scalar(0, 255, 0), 2);\n    if (detectedVehicle.width < BLIND_SPOT_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: VEHICLE IN BLIND SPOT!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate side camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectVehicleInBlindSpot(frame);\n        cv::imshow(\"Blind Spot Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to process GPS data and issue a speed limit alert if the vehicle exceeds a predefined speed.",
      "input": "Simulate GPS speed data and compare it with the speed limit, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_LIMIT = 100.0f; // Speed limit in km/h\n\nvoid checkSpeedLimit(float vehicleSpeed) {\n    if (vehicleSpeed > SPEED_LIMIT) {\n        std::cout << \"WARNING: SPEED LIMIT EXCEEDED!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle speed is within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 110.0f; // Simulated vehicle speed\n    checkSpeedLimit(vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to detect headlights using camera input and issue an alert if headlights are not turned on at night.",
      "input": "Simulate camera input to detect headlights, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectHeadlights(cv::Mat &frame) {\n    // Simulated detection of headlights (just a rectangular area for example)\n    cv::Rect headlightArea(100, 100, 50, 30); // Simulated headlights area\n    cv::rectangle(frame, headlightArea, cv::Scalar(0, 255, 0), 2);\n    if (headlightArea.width < 50) { // Simulated check for headlights\n        cv::putText(frame, \"WARNING: HEADLIGHTS OFF!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectHeadlights(frame);\n        cv::imshow(\"Headlight Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate Automatic Emergency Braking (AEB) when an object comes too close to the vehicle.",
      "input": "Use sensor data to simulate the approach of an object, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision threshold\n\nvoid applyEmergencyBraking(float distance) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: APPLYING EMERGENCY BRAKES!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from object. No need to brake.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObject = 3.0f; // Simulated object distance\n    applyEmergencyBraking(distanceToObject);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting drowsiness through camera input and issue a warning if the driver shows signs of fatigue.",
      "input": "Simulate facial recognition or eye tracking for detecting drowsiness, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectDrowsiness(cv::Mat &frame) {\n    cv::Rect eyes(100, 100, 50, 20); // Simulated eye tracking\n    cv::rectangle(frame, eyes, cv::Scalar(255, 0, 0), 2);\n    if (eyes.width < 50) { // Simulated drowsiness check\n        cv::putText(frame, \"WARNING: DROWSINESS DETECTED!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectDrowsiness(frame);\n        cv::imshow(\"Drowsiness Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for detecting lane departure and issuing a warning if the vehicle moves out of its lane without signaling.",
      "input": "Simulate lane detection using camera feed and issue warnings for lane departure, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectLaneDeparture(cv::Mat &frame) {\n    cv::Rect lane(0, 0, 640, 480); // Simulated lane detection area\n    cv::rectangle(frame, lane, cv::Scalar(255, 0, 0), 2);\n    if (lane.width < 500) { // Simulated lane departure\n        cv::putText(frame, \"WARNING: LANE DEPARTURE!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLaneDeparture(frame);\n        cv::imshow(\"Lane Departure Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to check tire pressure from sensors and issue an alert if the pressure is low.",
      "input": "Simulate tire pressure sensor data, handle all type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LOW_PRESSURE_THRESHOLD = 30.0f; // Tire pressure threshold\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < LOW_PRESSURE_THRESHOLD) {\n        std::cout << \"WARNING: LOW TIRE PRESSURE!\" << std::endl;\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 28.0f; // Simulated tire pressure\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a parking assistance system by detecting nearby obstacles and providing visual feedback.",
      "input": "Use camera or sensor input to simulate obstacle detection, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectParkingObstacles(cv::Mat &frame) {\n    cv::Rect obstacle(200, 200, 50, 50); // Simulated obstacle detection\n    cv::rectangle(frame, obstacle, cv::Scalar(0, 0, 255), 2);\n    cv::putText(frame, \"WARNING: OBSTACLE AHEAD!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectParkingObstacles(frame);\n        cv::imshow(\"Parking Assistance System\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a blind spot detection system that alerts the driver when another vehicle is detected in the blind spot.",
      "input": "Simulate blind spot detection using camera feed, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectBlindSpot(cv::Mat &frame) {\n    cv::Rect blindSpot(100, 200, 50, 50); // Simulated blind spot detection\n    cv::rectangle(frame, blindSpot, cv::Scalar(0, 0, 255), 2);\n    cv::putText(frame, \"WARNING: VEHICLE IN BLIND SPOT!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectBlindSpot(frame);\n        cv::imshow(\"Blind Spot Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to implement an adaptive cruise control system that adjusts vehicle speed based on the distance to the car ahead.",
      "input": "Simulate sensor input for distance detection, handle type conversions, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance threshold\n\nvoid adjustCruiseControl(float distance) {\n    if (distance < SAFE_DISTANCE_METERS) {\n        std::cout << \"WARNING: TOO CLOSE! SLOWING DOWN.\" << std::endl;\n    } else {\n        std::cout << \"Cruise control active: Maintaining speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToCar = 8.0f; // Simulated sensor data for distance\n    adjustCruiseControl(distanceToCar);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic emergency braking system that triggers braking when an obstacle is detected in the vehicle's path.",
      "input": "Simulate obstacle detection using a sensor or camera feed, handle all type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectObstacle(cv::Mat &frame) {\n    cv::Rect obstacle(200, 200, 50, 50); // Simulated obstacle detection\n    cv::rectangle(frame, obstacle, cv::Scalar(0, 0, 255), 2);\n    cv::putText(frame, \"WARNING: OBSTACLE AHEAD! BRAKING...\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObstacle(frame);\n        cv::imshow(\"AEB System\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for recognizing traffic signs using a camera and providing feedback to the driver.",
      "input": "Simulate traffic sign recognition from a video feed, handle all type conversions, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficSign(cv::Mat &frame) {\n    cv::Rect trafficSign(150, 150, 100, 100); // Simulated traffic sign detection\n    cv::rectangle(frame, trafficSign, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, \"STOP SIGN DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficSign(frame);\n        cv::imshow(\"Traffic Sign Recognition\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate vehicle speed monitoring using sensor input and issue alerts for over-speeding.",
      "input": "Simulate vehicle speed data, handle all type conversions, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_LIMIT = 80.0f; // Speed limit in km/h\n\nvoid checkSpeed(float vehicleSpeed) {\n    if (vehicleSpeed > SPEED_LIMIT) {\n        std::cout << \"WARNING: OVER-SPEEDING!\" << std::endl;\n    } else {\n        std::cout << \"Speed is within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentSpeed = 90.0f; // Simulated vehicle speed\n    checkSpeed(currentSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate pedestrian detection using camera feed and alert the driver if a pedestrian is detected.",
      "input": "Simulate pedestrian detection from a video feed, handle all type conversions, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectPedestrian(cv::Mat &frame) {\n    cv::Rect pedestrian(300, 200, 50, 100); // Simulated pedestrian detection\n    cv::rectangle(frame, pedestrian, cv::Scalar(255, 0, 0), 2);\n    cv::putText(frame, \"WARNING: PEDESTRIAN AHEAD!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectPedestrian(frame);\n        cv::imshow(\"Pedestrian Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a rear view camera system that shows the camera feed on the screen.",
      "input": "Simulate rear view camera feed, handle all type conversions, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nint main(void) {\n    cv::VideoCapture capture(1); // Simulate rear view camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::imshow(\"Rear View Camera\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a collision avoidance system that triggers an alert if another vehicle is detected too close.",
      "input": "Simulate proximity detection using a sensor or camera feed, handle all type conversions, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid checkProximity(cv::Mat &frame) {\n    cv::Rect vehicle(150, 150, 100, 50); // Simulated vehicle detection\n    cv::rectangle(frame, vehicle, cv::Scalar(255, 0, 0), 2);\n    cv::putText(frame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        checkProximity(frame);\n        cv::imshow(\"Collision Avoidance\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a system that monitors the vehicle's status (e.g., speed, fuel) and displays alerts.",
      "input": "Simulate vehicle status data, handle all type conversions, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MIN_FUEL_LEVEL = 10.0f; // Minimum fuel level\nconst float MAX_SPEED = 120.0f; // Maximum speed\n\nvoid checkVehicleStatus(float speed, float fuel) {\n    if (fuel < MIN_FUEL_LEVEL) {\n        std::cout << \"WARNING: LOW FUEL!\" << std::endl;\n    } else if (speed > MAX_SPEED) {\n        std::cout << \"WARNING: OVER-SPEEDING!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle status: Normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentSpeed = 130.0f; // Simulated speed\n    float currentFuel = 8.0f; // Simulated fuel level\n    checkVehicleStatus(currentSpeed, currentFuel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to control headlights based on ambient light conditions.",
      "input": "Simulate ambient light sensor input, handle all type conversions, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_THRESHOLD = 50.0f; // Ambient light threshold\n\nvoid controlHeadlights(float lightLevel) {\n    if (lightLevel < LIGHT_THRESHOLD) {\n        std::cout << \"Turning on headlights...\" << std::endl;\n    } else {\n        std::cout << \"Headlights off: Sufficient light.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentLightLevel = 30.0f; // Simulated light level\n    controlHeadlights(currentLightLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a lane departure warning system that alerts the driver when the vehicle crosses a lane marking.",
      "input": "Simulate lane detection from a camera feed, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectLaneDeparture(cv::Mat &frame) {\n    cv::Rect laneMarking(100, 150, 200, 10); // Simulated lane marking detection\n    cv::rectangle(frame, laneMarking, cv::Scalar(255, 0, 0), 2);\n    cv::putText(frame, \"WARNING: LANE DEPARTURE!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectLaneDeparture(frame);\n        cv::imshow(\"Lane Departure Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a parking assistance system that provides feedback when the vehicle is close to an obstacle.",
      "input": "Simulate proximity sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MIN_DISTANCE = 0.5f; // Minimum safe distance in meters\n\nvoid checkParkingDistance(float distance) {\n    if (distance < MIN_DISTANCE) {\n        std::cout << \"WARNING: TOO CLOSE TO OBJECT!\" << std::endl;\n    } else {\n        std::cout << \"Parking distance: Safe.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentDistance = 0.3f; // Simulated sensor data for parking distance\n    checkParkingDistance(currentDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a tire pressure monitoring system that alerts the driver if tire pressure is low.",
      "input": "Simulate tire pressure sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MIN_PRESSURE = 30.0f; // Minimum pressure in psi\n\nvoid checkTirePressure(float pressure) {\n    if (pressure < MIN_PRESSURE) {\n        std::cout << \"WARNING: LOW TIRE PRESSURE!\" << std::endl;\n    } else {\n        std::cout << \"Tire pressure: Normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentPressure = 25.0f; // Simulated tire pressure\n    checkTirePressure(currentPressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a blind spot monitoring system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate vehicle detection in blind spots, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_DISTANCE = 10.0f; // Distance in meters for blind spot detection\n\nvoid checkBlindSpot(float distance) {\n    if (distance < BLIND_SPOT_DISTANCE) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"Blind spot: Clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 5.0f; // Simulated vehicle distance in blind spot\n    checkBlindSpot(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a system that detects traffic signals and provides alerts to the driver.",
      "input": "Simulate traffic signal detection using a camera feed, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficSignal(cv::Mat &frame) {\n    cv::Rect trafficSignal(150, 150, 50, 100); // Simulated traffic signal detection\n    cv::rectangle(frame, trafficSignal, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, \"TRAFFIC SIGNAL DETECTED\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficSignal(frame);\n        cv::imshow(\"Traffic Signal Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive headlight control system that adjusts headlight brightness based on ambient light.",
      "input": "Simulate ambient light sensor input, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_THRESHOLD = 100.0f; // Light level threshold in lux\n\nvoid adjustHeadlights(float lightLevel) {\n    if (lightLevel < LIGHT_THRESHOLD) {\n        std::cout << \"Turning on high beams.\" << std::endl;\n    } else {\n        std::cout << \"Headlights on low beams.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentLightLevel = 80.0f; // Simulated ambient light level\n    adjustHeadlights(currentLightLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate an automatic parking system that autonomously parks the vehicle.",
      "input": "Simulate sensor data for parking space detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SPACE_THRESHOLD = 2.0f; // Parking space size threshold\n\nvoid parkVehicle(float spaceWidth) {\n    if (spaceWidth < PARKING_SPACE_THRESHOLD) {\n        std::cout << \"WARNING: PARKING SPACE TOO SMALL!\" << std::endl;\n    } else {\n        std::cout << \"Parking the vehicle...\" << std::endl;\n    }\n}\n\nint main(void) {\n    float availableSpace = 2.5f; // Simulated parking space width\n    parkVehicle(availableSpace);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a collision warning system that alerts the driver if another vehicle is detected in the proximity.",
      "input": "Simulate vehicle detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_WARNING_DISTANCE = 3.0f; // Safe distance in meters\n\nvoid checkForCollision(float distance) {\n    if (distance < COLLISION_WARNING_DISTANCE) {\n        std::cout << \"WARNING: COLLISION RISK AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 2.0f; // Simulated vehicle distance in proximity\n    checkForCollision(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian collision detection system that triggers an alert when a pedestrian is detected in the vehicle's path.",
      "input": "Simulate pedestrian detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectPedestrian(cv::Mat &frame) {\n    cv::Rect pedestrian(300, 200, 50, 100); // Simulated pedestrian detection\n    cv::rectangle(frame, pedestrian, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, \"WARNING: PEDESTRIAN AHEAD!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectPedestrian(frame);\n        cv::imshow(\"Pedestrian Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic emergency braking system that triggers braking when an obstacle is detected.",
      "input": "Simulate obstacle detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BRAKING_DISTANCE = 1.0f; // Emergency braking distance in meters\n\nvoid triggerEmergencyBraking(float distance) {\n    if (distance < BRAKING_DISTANCE) {\n        std::cout << \"WARNING: OBSTACLE AHEAD! BRAKING!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance. No action needed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 0.5f; // Simulated obstacle distance\n    triggerEmergencyBraking(obstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive cruise control system that adjusts the vehicle's speed based on the distance to the car ahead.",
      "input": "Simulate distance sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE = 2.0f; // Safe distance in meters for adaptive cruise control\n\nvoid adjustSpeed(float distance) {\n    if (distance < SAFE_DISTANCE) {\n        std::cout << \"Slowing down to maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToCar = 1.5f; // Simulated distance to the car ahead\n    adjustSpeed(distanceToCar);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a rear collision warning system that alerts the driver when there is an object behind the vehicle.",
      "input": "Simulate rear sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REAR_COLLISION_THRESHOLD = 1.5f; // Rear collision threshold in meters\n\nvoid checkRearCollision(float distance) {\n    if (distance < REAR_COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: OBJECT BEHIND!\" << std::endl;\n    } else {\n        std::cout << \"Rear area clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rearDistance = 1.0f; // Simulated rear distance sensor data\n    checkRearCollision(rearDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward collision warning system that detects and tracks objects ahead, and issues a warning when an object is too close.",
      "input": "Simulate object detection and tracking, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_WARNING_THRESHOLD = 5.0f; // Collision threshold in meters\n\nvoid detectObject(cv::Mat &frame) {\n    // Simulate object detection\n    cv::Rect detectedObject(100, 100, 50, 100); // Simulated bounding box\n    cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, \"Object detected ahead\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nvoid checkForCollision(float distance) {\n    if (distance < COLLISION_WARNING_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK AHEAD!\" << std::endl;\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObject(frame);\n        checkForCollision(4.0f); // Simulated distance to object\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a blind spot detection system that triggers an alert when a vehicle is detected in the blind spot.",
      "input": "Simulate sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_DISTANCE = 10.0f; // Blind spot detection threshold in meters\n\nvoid detectBlindSpot(float distance) {\n    if (distance < BLIND_SPOT_DISTANCE) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"Blind spot clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float detectedDistance = 7.0f; // Simulated distance of a vehicle in the blind spot\n    detectBlindSpot(detectedDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate a pedestrian detection system that alerts the driver if a pedestrian is in front of the vehicle.",
      "input": "Simulate pedestrian detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectPedestrian(cv::Mat &frame) {\n    cv::Rect pedestrian(300, 200, 50, 100); // Simulated pedestrian detection\n    cv::rectangle(frame, pedestrian, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, \"WARNING: PEDESTRIAN AHEAD!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectPedestrian(frame);\n        cv::imshow(\"Pedestrian Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code to simulate an automatic emergency braking system that activates brakes if an obstacle is detected too close.",
      "input": "Simulate obstacle distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BRAKING_DISTANCE = 1.0f; // Emergency braking distance in meters\n\nvoid triggerBrakes(float distance) {\n    if (distance < BRAKING_DISTANCE) {\n        std::cout << \"BRAKING! OBSTACLE DETECTED AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance. No braking needed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 0.5f; // Simulated obstacle distance\n    triggerBrakes(obstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traffic sign recognition system that identifies stop signs and alerts the driver.",
      "input": "Simulate traffic sign recognition, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficSign(cv::Mat &frame) {\n    cv::Rect stopSign(150, 150, 50, 50); // Simulated stop sign detection\n    cv::rectangle(frame, stopSign, cv::Scalar(0, 0, 255), 2);\n    cv::putText(frame, \"STOP SIGN DETECTED!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate camera feed\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectTrafficSign(frame);\n        cv::imshow(\"Traffic Sign Recognition\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a lane departure warning system that alerts the driver if the vehicle drifts out of its lane.",
      "input": "Simulate lane position data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 1.0f; // Lane departure threshold in meters\n\nvoid checkLanePosition(float position) {\n    if (position > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"WARNING: LANE DEPARTURE!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lanePosition = 1.5f; // Simulated lane position (positive value indicates lane departure)\n    checkLanePosition(lanePosition);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a cross traffic alert system that warns the driver of crossing traffic while reversing.",
      "input": "Simulate crossing vehicle sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float CROSS_TRAFFIC_THRESHOLD = 3.0f; // Cross traffic detection threshold in meters\n\nvoid detectCrossTraffic(float distance) {\n    if (distance < CROSS_TRAFFIC_THRESHOLD) {\n        std::cout << \"WARNING: CROSS TRAFFIC DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"Cross traffic area clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float crossTrafficDistance = 2.5f; // Simulated cross traffic distance\n    detectCrossTraffic(crossTrafficDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a tire pressure monitoring system that alerts the driver when tire pressure is too low.",
      "input": "Simulate tire pressure sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LOW_PRESSURE_THRESHOLD = 30.0f; // Low tire pressure threshold in psi\n\nvoid checkTirePressure(float pressure) {\n    if (pressure < LOW_PRESSURE_THRESHOLD) {\n        std::cout << \"WARNING: LOW TIRE PRESSURE!\" << std::endl;\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 25.0f; // Simulated tire pressure value\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a lane-keeping assistance system that gently steers the vehicle to keep it in its lane.",
      "input": "Simulate lane position data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_THRESHOLD = 0.5f; // Lane departure threshold in meters\n\nvoid steerToCenter(float position) {\n    if (position > LANE_THRESHOLD) {\n        std::cout << \"Steering to keep the vehicle in lane.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is centered in lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentLanePosition = 0.7f; // Simulated lane position (positive indicates lane departure)\n    steerToCenter(currentLanePosition);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a vehicle speed limiting system that prevents the vehicle from exceeding a set maximum speed.",
      "input": "Simulate vehicle speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MAX_SPEED = 120.0f; // Maximum allowed speed in km/h\n\nvoid enforceSpeedLimit(float speed) {\n    if (speed > MAX_SPEED) {\n        std::cout << \"Speed limit exceeded. Slowing down.\" << std::endl;\n    } else {\n        std::cout << \"Speed within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentSpeed = 130.0f; // Simulated current speed\n    enforceSpeedLimit(currentSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a parking assist system that provides visual guidance for parking into a space.",
      "input": "Simulate parking space proximity data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_THRESHOLD = 0.5f; // Parking space proximity threshold in meters\n\nvoid parkingAssist(float distance) {\n    if (distance < PARKING_THRESHOLD) {\n        std::cout << \"Space detected, assist activated.\" << std::endl;\n    } else {\n        std::cout << \"No parking space detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float parkingSpaceDistance = 0.3f; // Simulated distance to parking space\n    parkingAssist(parkingSpaceDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a tire wear monitoring system that alerts the driver if tire wear is excessive.",
      "input": "Simulate tire wear sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_WEAR_THRESHOLD = 0.8f; // Tire wear threshold\n\nvoid monitorTireWear(float wear) {\n    if (wear > TIRE_WEAR_THRESHOLD) {\n        std::cout << \"WARNING: Excessive tire wear detected!\" << std::endl;\n    } else {\n        std::cout << \"Tire wear is within limits.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentTireWear = 0.9f; // Simulated tire wear percentage\n    monitorTireWear(currentTireWear);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a vehicle stability control system that prevents the vehicle from skidding.",
      "input": "Simulate sensor data for yaw rate and steering angle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float YAW_RATE_THRESHOLD = 0.5f; // Yaw rate threshold in degrees per second\n\nvoid checkVehicleStability(float yawRate) {\n    if (yawRate > YAW_RATE_THRESHOLD) {\n        std::cout << \"Stability control activated. Adjusting yaw.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is stable.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentYawRate = 0.6f; // Simulated yaw rate\n    checkVehicleStability(currentYawRate);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward object detection system that identifies obstacles ahead and issues a warning if too close.",
      "input": "Simulate object detection using image processing, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float OBJECT_DETECTION_THRESHOLD = 2.0f; // Object detection distance threshold in meters\n\nvoid detectObjectAhead(cv::Mat &frame) {\n    cv::Rect detectedObject(50, 50, 100, 100); // Simulated object detection\n    cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, \"Obstacle detected ahead!\", cv::Point(10, 10), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate video capture\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detectObjectAhead(frame);\n        cv::imshow(\"Object Detection\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a blind spot monitoring system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate sensor data for blind spot detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 6.0f; // Blind spot detection threshold in meters\n\nvoid monitorBlindSpot(float distance) {\n    if (distance < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle detected in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"Blind spot clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float blindSpotDistance = 5.0f; // Simulated blind spot distance\n    monitorBlindSpot(blindSpotDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic lane change assistance system that executes a lane change when safe to do so.",
      "input": "Simulate lane position and vehicle detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_CHANGE_THRESHOLD = 1.0f; // Lane change threshold in meters\n\nvoid executeLaneChange(float distanceToOtherVehicle) {\n    if (distanceToOtherVehicle > LANE_CHANGE_THRESHOLD) {\n        std::cout << \"Executing lane change.\" << std::endl;\n    } else {\n        std::cout << \"Not safe to change lanes.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToOtherVehicle = 3.0f; // Simulated distance to vehicle in adjacent lane\n    executeLaneChange(distanceToOtherVehicle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an emergency vehicle detection system that triggers an alert when an emergency vehicle is detected.",
      "input": "Simulate emergency vehicle detection using sound or light signals, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float EMERGENCY_VEHICLE_DETECTION_THRESHOLD = 5.0f; // Distance threshold for detection\n\nvoid detectEmergencyVehicle(float distance) {\n    if (distance < EMERGENCY_VEHICLE_DETECTION_THRESHOLD) {\n        std::cout << \"EMERGENCY VEHICLE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No emergency vehicle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float emergencyVehicleDistance = 4.0f; // Simulated distance to emergency vehicle\n    detectEmergencyVehicle(emergencyVehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive lighting system that adjusts the vehicle\u2019s headlights based on driving conditions.",
      "input": "Simulate driving condition data (e.g., speed, ambient light), handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_THRESHOLD = 20.0f; // Speed threshold in km/h for adaptive lighting\n\nvoid adjustHeadlights(float speed) {\n    if (speed > SPEED_THRESHOLD) {\n        std::cout << \"Increasing headlight intensity for higher speed.\" << std::endl;\n    } else {\n        std::cout << \"Decreasing headlight intensity for lower speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 25.0f; // Simulated vehicle speed\n    adjustHeadlights(vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic headlight adjustment system that adjusts headlights based on ambient light levels.",
      "input": "Simulate ambient light data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float AMBIENT_LIGHT_THRESHOLD = 50.0f; // Threshold for low light conditions\n\nvoid adjustHeadlights(float ambientLight) {\n    if (ambientLight < AMBIENT_LIGHT_THRESHOLD) {\n        std::cout << \"Low light detected, headlights on.\" << std::endl;\n    } else {\n        std::cout << \"Sufficient ambient light, headlights off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentLightLevel = 40.0f; // Simulated ambient light level\n    adjustHeadlights(currentLightLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward collision mitigation system that applies brakes if an imminent collision is detected.",
      "input": "Simulate distance data and relative speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 3.0f; // Collision detection threshold in meters\nconst float RELATIVE_SPEED_THRESHOLD = 5.0f; // Speed threshold for collision mitigation in km/h\n\nvoid applyBrakes(float distance, float relativeSpeed) {\n    if (distance < COLLISION_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision! Applying brakes.\" << std::endl;\n    } else {\n        std::cout << \"No collision detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentDistance = 2.5f; // Simulated distance to object\n    float currentRelativeSpeed = 6.0f; // Simulated relative speed\n    applyBrakes(currentDistance, currentRelativeSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive cruise control system that adjusts vehicle speed based on the distance to the vehicle ahead.",
      "input": "Simulate distance data and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float CRUISE_CONTROL_DISTANCE_THRESHOLD = 20.0f; // Distance threshold for cruise control in meters\n\nvoid adjustCruiseSpeed(float distance, float currentSpeed) {\n    if (distance < CRUISE_CONTROL_DISTANCE_THRESHOLD) {\n        std::cout << \"Adjusting speed to maintain safe distance.\" << std::endl;\n        currentSpeed -= 10.0f; // Simulated speed reduction\n    } else {\n        std::cout << \"Maintaining cruise speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToVehicleAhead = 15.0f; // Simulated distance to the vehicle ahead\n    float vehicleSpeed = 100.0f; // Simulated vehicle speed\n    adjustCruiseSpeed(distanceToVehicleAhead, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traffic sign recognition system that recognizes speed limit signs and adjusts the vehicle speed accordingly.",
      "input": "Simulate image data and speed limit sign recognition, handle type conversions explicitly, and include error handling.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV for image processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst int SPEED_LIMIT_THRESHOLD = 50; // Speed limit threshold in km/h\n\nvoid recognizeTrafficSign(cv::Mat &frame) {\n    // Simulate speed limit sign recognition\n    std::string detectedSign = \"Speed Limit 60 km/h\";\n    std::cout << \"Detected sign: \" << detectedSign << std::endl;\n}\n\nvoid adjustSpeed(int speedLimit) {\n    if (speedLimit > SPEED_LIMIT_THRESHOLD) {\n        std::cout << \"Speed limit is high. Adjusting vehicle speed.\" << std::endl;\n    } else {\n        std::cout << \"Speed limit is within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    cv::VideoCapture capture(0); // Simulate video capture\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        recognizeTrafficSign(frame);\n        adjustSpeed(60); // Simulated speed limit from detected sign\n        cv::imshow(\"Traffic Sign Recognition\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a reverse collision detection system that provides alerts if there is an obstacle while reversing.",
      "input": "Simulate rear distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REAR_COLLISION_THRESHOLD = 1.0f; // Reverse collision detection threshold in meters\n\nvoid detectRearCollision(float distance) {\n    if (distance < REAR_COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected behind vehicle!\" << std::endl;\n    } else {\n        std::cout << \"Clear path behind vehicle.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rearDistance = 0.5f; // Simulated rear distance to obstacle\n    detectRearCollision(rearDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic emergency braking system that applies brakes when an obstacle is detected too close.",
      "input": "Simulate obstacle distance and relative speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float OBSTACLE_THRESHOLD = 2.0f; // Obstacle detection threshold in meters\nconst float BRAKING_SPEED_THRESHOLD = 5.0f; // Speed threshold for emergency braking\n\nvoid applyEmergencyBrakes(float distance, float relativeSpeed) {\n    if (distance < OBSTACLE_THRESHOLD && relativeSpeed > BRAKING_SPEED_THRESHOLD) {\n        std::cout << \"Emergency braking applied.\" << std::endl;\n    } else {\n        std::cout << \"No need for emergency braking.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 1.5f; // Simulated distance to obstacle\n    float vehicleSpeed = 10.0f; // Simulated vehicle speed\n    applyEmergencyBrakes(distanceToObstacle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a blind spot detection and warning system that alerts the driver if there is a vehicle in the blind spot.",
      "input": "Simulate blind spot sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 3.0f; // Blind spot detection threshold in meters\n\nvoid monitorBlindSpot(float distance) {\n    if (distance < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"Blind spot clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToBlindSpotVehicle = 2.5f; // Simulated distance to vehicle in blind spot\n    monitorBlindSpot(distanceToBlindSpotVehicle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a parking assistance system that alerts the driver when an obstacle is detected while parking.",
      "input": "Simulate parking sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SENSOR_THRESHOLD = 1.0f; // Parking sensor threshold in meters\n\nvoid monitorParking(float distance) {\n    if (distance < PARKING_SENSOR_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected during parking!\" << std::endl;\n    } else {\n        std::cout << \"Parking path clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float parkingSensorDistance = 0.8f; // Simulated parking sensor distance\n    monitorParking(parkingSensorDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traction control system that adjusts the engine power to prevent wheel spin.",
      "input": "Simulate wheel speed and vehicle acceleration, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float WHEEL_SPEED_THRESHOLD = 10.0f; // Wheel speed threshold for traction control\n\nvoid controlTraction(float wheelSpeed, float vehicleAcceleration) {\n    if (wheelSpeed > WHEEL_SPEED_THRESHOLD) {\n        std::cout << \"WARNING: Wheel spin detected! Adjusting engine power.\" << std::endl;\n    } else {\n        std::cout << \"Traction control not needed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentWheelSpeed = 12.0f; // Simulated wheel speed\n    float currentAcceleration = 5.0f; // Simulated vehicle acceleration\n    controlTraction(currentWheelSpeed, currentAcceleration);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a lane departure warning system that alerts the driver when the vehicle deviates from its lane.",
      "input": "Simulate lane deviation sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEVIATION_THRESHOLD = 0.5f; // Lane deviation threshold in meters\n\nvoid detectLaneDeparture(float deviation) {\n    if (deviation > LANE_DEVIATION_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle within lane boundaries.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDeviation = 0.6f; // Simulated lane deviation\n    detectLaneDeparture(laneDeviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a lane centering assistance system that adjusts steering to keep the vehicle centered in the lane.",
      "input": "Simulate lane position data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_CENTER_THRESHOLD = 0.5f; // Lane centering threshold in meters\n\nvoid adjustSteering(float lanePosition) {\n    if (lanePosition > LANE_CENTER_THRESHOLD) {\n        std::cout << \"Adjusting steering to keep vehicle centered.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is centered in lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentLanePosition = 0.6f; // Simulated lane position deviation\n    adjustSteering(currentLanePosition);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian detection system that alerts the driver when a pedestrian is detected in the vehicle's path.",
      "input": "Simulate object detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 2.0f; // Detection threshold for pedestrian in meters\n\nvoid detectPedestrian(float distance) {\n    if (distance < PEDESTRIAN_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToPedestrian = 1.5f; // Simulated distance to pedestrian\n    detectPedestrian(distanceToPedestrian);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a cross traffic alert system that provides a warning if cross traffic is detected while backing up.",
      "input": "Simulate cross traffic sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float CROSS_TRAFFIC_THRESHOLD = 3.0f; // Cross traffic detection threshold in meters\n\nvoid detectCrossTraffic(float distance) {\n    if (distance < CROSS_TRAFFIC_THRESHOLD) {\n        std::cout << \"WARNING: Cross traffic detected!\" << std::endl;\n    } else {\n        std::cout << \"No cross traffic detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToCrossTraffic = 2.5f; // Simulated cross traffic distance\n    detectCrossTraffic(distanceToCrossTraffic);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a speed limit adherence system that alerts the driver if they exceed the speed limit.",
      "input": "Simulate speed sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst int SPEED_LIMIT = 60; // Speed limit in km/h\n\nvoid checkSpeed(int currentSpeed) {\n    if (currentSpeed > SPEED_LIMIT) {\n        std::cout << \"WARNING: Speed limit exceeded!\" << std::endl;\n    } else {\n        std::cout << \"Speed within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    int currentSpeed = 70; // Simulated current speed\n    checkSpeed(currentSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic parking system that automatically parks the vehicle when a parking space is detected.",
      "input": "Simulate parking space detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SPACE_THRESHOLD = 2.5f; // Parking space detection threshold in meters\n\nvoid parkVehicle(float spaceSize) {\n    if (spaceSize > PARKING_SPACE_THRESHOLD) {\n        std::cout << \"Parking space detected, parking vehicle.\" << std::endl;\n    } else {\n        std::cout << \"No suitable parking space detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float parkingSpaceSize = 3.0f; // Simulated parking space size\n    parkVehicle(parkingSpaceSize);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a tire pressure monitoring system that alerts the driver when tire pressure is low.",
      "input": "Simulate tire pressure sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_PRESSURE_THRESHOLD = 30.0f; // Tire pressure threshold in PSI\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"WARNING: Low tire pressure!\" << std::endl;\n    } else {\n        std::cout << \"Tire pressure is adequate.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentTirePressure = 28.0f; // Simulated tire pressure\n    checkTirePressure(currentTirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a lane departure prevention system that adjusts the steering to keep the vehicle in the lane.",
      "input": "Simulate lane deviation data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEVIATION_THRESHOLD = 0.7f; // Lane deviation threshold in meters\n\nvoid preventLaneDeparture(float deviation) {\n    if (deviation > LANE_DEVIATION_THRESHOLD) {\n        std::cout << \"Adjusting steering to prevent lane departure.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is within lane boundaries.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDeviation = 0.8f; // Simulated lane deviation\n    preventLaneDeparture(laneDeviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a front collision alert system that alerts the driver if the vehicle is about to collide with an object in front.",
      "input": "Simulate front distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float FRONT_COLLISION_THRESHOLD = 2.0f; // Front collision detection threshold in meters\n\nvoid checkFrontCollision(float distance) {\n    if (distance < FRONT_COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Front collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObjectInFront = 1.5f; // Simulated distance to object in front\n    checkFrontCollision(distanceToObjectInFront);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic windshield wiper control system that activates the wipers when rain is detected.",
      "input": "Simulate rain detection sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_DETECTION_THRESHOLD = 50.0f; // Rain detection threshold in mm/h\n\nvoid controlWipers(float rainIntensity) {\n    if (rainIntensity > RAIN_DETECTION_THRESHOLD) {\n        std::cout << \"Activating windshield wipers.\" << std::endl;\n    } else {\n        std::cout << \"No rain detected, wipers off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rainIntensity = 60.0f; // Simulated rain intensity\n    controlWipers(rainIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive cruise control system that adjusts the vehicle's speed to maintain a safe distance from the car in front.",
      "input": "Simulate vehicle speed and distance to car ahead, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE_THRESHOLD = 5.0f; // Safe distance threshold in meters\n\nvoid adjustCruiseControl(float vehicleSpeed, float distanceToCar) {\n    if (distanceToCar < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"Adjusting speed to maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Cruise control active, maintaining speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentVehicleSpeed = 100.0f; // Simulated vehicle speed in km/h\n    float distanceToCarAhead = 3.0f; // Simulated distance to car ahead in meters\n    adjustCruiseControl(currentVehicleSpeed, distanceToCarAhead);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traffic signal recognition system that detects traffic lights and issues an alert if the light is red.",
      "input": "Simulate traffic light detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RED_LIGHT_THRESHOLD = 1.0f; // Simulated threshold for red light detection\n\nvoid checkTrafficLight(float signalIntensity) {\n    if (signalIntensity > RED_LIGHT_THRESHOLD) {\n        std::cout << \"WARNING: Red light detected!\" << std::endl;\n    } else {\n        std::cout << \"Traffic light is not red.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float detectedSignalIntensity = 1.2f; // Simulated red light signal intensity\n    checkTrafficLight(detectedSignalIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a vehicle speed detection system that calculates and displays the vehicle's speed based on wheel rotation data.",
      "input": "Simulate wheel rotation data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float WHEEL_CIRCUMFERENCE = 2.0f; // Wheel circumference in meters\n\nvoid calculateSpeed(int wheelRotations, int timeInterval) {\n    if (timeInterval == 0) {\n        std::cerr << \"Error: Time interval cannot be zero.\" << std::endl;\n        return;\n    }\n    float speed = (wheelRotations * WHEEL_CIRCUMFERENCE) / static_cast<float>(timeInterval);\n    std::cout << \"Vehicle speed: \" << speed << \" meters per second.\" << std::endl;\n}\n\nint main(void) {\n    int wheelRotations = 100; // Simulated wheel rotations\n    int timeInterval = 5; // Simulated time interval in seconds\n    calculateSpeed(wheelRotations, timeInterval);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic headlights activation system that turns on the headlights when the ambient light is low.",
      "input": "Simulate ambient light sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_SENSOR_THRESHOLD = 100.0f; // Light sensor threshold for activating headlights\n\nvoid activateHeadlights(float ambientLightLevel) {\n    if (ambientLightLevel < LIGHT_SENSOR_THRESHOLD) {\n        std::cout << \"Activating headlights.\" << std::endl;\n    } else {\n        std::cout << \"Ambient light sufficient, headlights off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentLightLevel = 80.0f; // Simulated ambient light level\n    activateHeadlights(currentLightLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a blind spot monitoring system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate vehicle position detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_DETECTION_THRESHOLD = 1.5f; // Detection threshold for blind spot in meters\n\nvoid monitorBlindSpot(float vehicleDistance) {\n    if (vehicleDistance < BLIND_SPOT_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToVehicleInBlindSpot = 1.0f; // Simulated distance to vehicle in blind spot\n    monitorBlindSpot(distanceToVehicleInBlindSpot);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a rearview camera system that displays a warning if there is an obstacle detected behind the vehicle.",
      "input": "Simulate rearview camera detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float OBSTACLE_DETECTION_THRESHOLD = 1.0f; // Detection threshold for obstacles in meters\n\nvoid detectObstacle(float distance) {\n    if (distance < OBSTACLE_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected behind the vehicle!\" << std::endl;\n    } else {\n        std::cout << \"No obstacle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 0.5f; // Simulated distance to obstacle\n    detectObstacle(distanceToObstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a fuel efficiency monitoring system that calculates and displays fuel consumption rate.",
      "input": "Simulate fuel consumption and distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid calculateFuelEfficiency(float distanceTravelled, float fuelConsumed) {\n    if (fuelConsumed == 0.0f) {\n        std::cerr << \"Error: Fuel consumption cannot be zero.\" << std::endl;\n        return;\n    }\n    float efficiency = distanceTravelled / fuelConsumed;\n    std::cout << \"Fuel efficiency: \" << efficiency << \" km/l.\" << std::endl;\n}\n\nint main(void) {\n    float distanceTravelled = 150.0f; // Simulated distance in kilometers\n    float fuelConsumed = 10.0f; // Simulated fuel consumption in liters\n    calculateFuelEfficiency(distanceTravelled, fuelConsumed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a rainwater accumulation detection system that monitors the accumulation of water on the vehicle's surface and alerts the driver if it exceeds a threshold.",
      "input": "Simulate rainwater accumulation sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float WATER_THRESHOLD = 5.0f; // Rainwater accumulation threshold in liters\n\nvoid checkWaterAccumulation(float accumulatedWater) {\n    if (accumulatedWater > WATER_THRESHOLD) {\n        std::cout << \"WARNING: Excessive rainwater accumulation detected.\" << std::endl;\n    } else {\n        std::cout << \"Water accumulation within safe limits.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentAccumulatedWater = 6.0f; // Simulated rainwater accumulation\n    checkWaterAccumulation(currentAccumulatedWater);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a collision detection and automatic braking system that applies the brakes when an imminent collision is detected.",
      "input": "Simulate distance data to objects, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 2.0f; // Collision threshold distance in meters\n\nvoid applyBrakes(float distanceToObject) {\n    if (distanceToObject < COLLISION_THRESHOLD) {\n        std::cout << \"Collision imminent! Applying brakes.\" << std::endl;\n    } else {\n        std::cout << \"No immediate collision risk.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObject = 1.5f; // Simulated distance to object\n    applyBrakes(distanceToObject);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive lighting system that adjusts the headlights' brightness depending on ambient light conditions while driving at night.",
      "input": "Simulate ambient light sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float NIGHT_DRIVING_LIGHT_THRESHOLD = 20.0f; // Light threshold for night driving\n\nvoid adjustHeadlightsForNight(float ambientLightLevel) {\n    if (ambientLightLevel < NIGHT_DRIVING_LIGHT_THRESHOLD) {\n        std::cout << \"Adjusting headlights for night driving.\" << std::endl;\n    } else {\n        std::cout << \"Ambient light sufficient for daytime driving.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentAmbientLight = 15.0f; // Simulated ambient light level\n    adjustHeadlightsForNight(currentAmbientLight);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a driver attention monitoring system that issues an alert if the system detects signs of drowsiness or distraction.",
      "input": "Simulate driver eye movement data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float EYE_CLOSURE_THRESHOLD = 0.5f; // Eye closure threshold for drowsiness detection\n\nvoid monitorDriverAttention(float eyeClosureLevel) {\n    if (eyeClosureLevel > EYE_CLOSURE_THRESHOLD) {\n        std::cout << \"WARNING: Driver appears drowsy or distracted!\" << std::endl;\n    } else {\n        std::cout << \"Driver alertness is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentEyeClosureLevel = 0.6f; // Simulated eye closure level\n    monitorDriverAttention(currentEyeClosureLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a parking assistance system that calculates the distance between the vehicle and an obstacle, alerting the driver if the distance is too small.",
      "input": "Simulate distance sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_THRESHOLD = 0.5f; // Parking threshold in meters\n\nvoid checkParkingDistance(float distanceToObstacle) {\n    if (distanceToObstacle < PARKING_THRESHOLD) {\n        std::cout << \"WARNING: Too close to the obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance to obstacle.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 0.4f; // Simulated distance to obstacle\n    checkParkingDistance(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a tire pressure monitoring system that alerts the driver if tire pressure is too low.",
      "input": "Simulate tire pressure data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_PRESSURE_THRESHOLD = 30.0f; // Tire pressure threshold in PSI\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"WARNING: Low tire pressure!\" << std::endl;\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentTirePressure = 28.0f; // Simulated tire pressure\n    checkTirePressure(currentTirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a lane departure warning system that alerts the driver when the vehicle is drifting out of its lane.",
      "input": "Simulate lane detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 2.0f; // Lane departure threshold in meters\n\nvoid checkLaneDeparture(float deviationFromCenter) {\n    if (deviationFromCenter > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is in the lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float deviation = 2.5f; // Simulated deviation from lane center\n    checkLaneDeparture(deviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian detection system that alerts the driver when a pedestrian is detected in the vehicle's path.",
      "input": "Simulate pedestrian detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 1.0f; // Pedestrian detection threshold in meters\n\nvoid checkPedestrianDistance(float pedestrianDistance) {\n    if (pedestrianDistance < PEDESTRIAN_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected in path!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected in path.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float pedestrianDistance = 0.8f; // Simulated distance to pedestrian\n    checkPedestrianDistance(pedestrianDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a cross traffic alert system that warns the driver when a vehicle is detected approaching from the side.",
      "input": "Simulate cross traffic detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float CROSS_TRAFFIC_DETECTION_THRESHOLD = 2.0f; // Detection threshold in meters\n\nvoid checkCrossTraffic(float crossTrafficDistance) {\n    if (crossTrafficDistance < CROSS_TRAFFIC_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Cross traffic detected!\" << std::endl;\n    } else {\n        std::cout << \"No cross traffic detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float crossTraffic = 1.5f; // Simulated distance to cross traffic\n    checkCrossTraffic(crossTraffic);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive cruise control system that adjusts the vehicle's speed to maintain a safe following distance.",
      "input": "Simulate distance to the leading vehicle and current vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_FOLLOWING_DISTANCE = 20.0f; // Safe following distance in meters\n\nvoid adjustCruiseControlSpeed(float currentDistance, float currentSpeed) {\n    if (currentDistance < SAFE_FOLLOWING_DISTANCE) {\n        std::cout << \"Decreasing speed to maintain safe following distance.\" << std::endl;\n        // Decrease speed logic here\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToLeadVehicle = 15.0f; // Simulated distance to the leading vehicle\n    float vehicleSpeed = 50.0f; // Simulated current vehicle speed\n    adjustCruiseControlSpeed(distanceToLeadVehicle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic emergency braking system that applies brakes when a collision is imminent.",
      "input": "Simulate distance and speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float EMERGENCY_BRAKING_THRESHOLD = 2.0f; // Collision detection threshold in meters\n\nvoid applyEmergencyBrakes(float distanceToObject, float relativeSpeed) {\n    if (distanceToObject < EMERGENCY_BRAKING_THRESHOLD && relativeSpeed > 10.0f) {\n        std::cout << \"Emergency braking activated!\" << std::endl;\n    } else {\n        std::cout << \"No emergency braking needed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.5f; // Simulated distance to object\n    float speed = 12.0f; // Simulated relative speed\n    applyEmergencyBrakes(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an intelligent speed assistance system that adjusts the vehicle's speed based on road sign data.",
      "input": "Simulate road sign detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MAX_SPEED_LIMIT = 60.0f; // Speed limit based on road sign\n\nvoid adjustSpeedToSign(float currentSpeed, float speedLimit) {\n    if (currentSpeed > speedLimit) {\n        std::cout << \"Reducing speed to match road sign.\" << std::endl;\n        // Speed adjustment logic here\n    } else {\n        std::cout << \"Speed is within limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 70.0f; // Simulated vehicle speed\n    float roadSignSpeedLimit = 60.0f; // Simulated road sign speed limit\n    adjustSpeedToSign(vehicleSpeed, roadSignSpeedLimit);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a driver drowsiness detection system that alerts the driver when signs of drowsiness are detected.",
      "input": "Simulate eye blink frequency and head position data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float EYE_BLINK_THRESHOLD = 10.0f; // Eye blink frequency threshold\n\nvoid detectDrowsiness(float blinkFrequency) {\n    if (blinkFrequency < EYE_BLINK_THRESHOLD) {\n        std::cout << \"WARNING: Signs of drowsiness detected!\" << std::endl;\n    } else {\n        std::cout << \"Driver is alert.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float blinkFrequency = 5.0f; // Simulated blink frequency\n    detectDrowsiness(blinkFrequency);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a vehicle stability control system that detects vehicle skidding and applies corrective actions.",
      "input": "Simulate vehicle speed and yaw rate data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float YAW_RATE_THRESHOLD = 5.0f; // Yaw rate threshold for skidding detection\n\nvoid detectSkid(float yawRate) {\n    if (yawRate > YAW_RATE_THRESHOLD) {\n        std::cout << \"Skid detected! Activating corrective actions.\" << std::endl;\n        // Skid correction logic here\n    } else {\n        std::cout << \"Vehicle stability normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentYawRate = 6.0f; // Simulated yaw rate\n    detectSkid(currentYawRate);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a blind spot detection system that alerts the driver if a vehicle is detected in the blind spot.",
      "input": "Simulate blind spot sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 2.0f; // Threshold for blind spot detection in meters\n\nvoid checkBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.5f; // Simulated distance to vehicle in blind spot\n    checkBlindSpot(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward collision mitigation system that reduces vehicle speed if a collision is imminent.",
      "input": "Simulate object distance and vehicle speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 5.0f; // Collision mitigation threshold in meters\n\nvoid reduceSpeedIfNecessary(float distanceToObject, float currentSpeed) {\n    if (distanceToObject < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision imminent, reducing speed!\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Speed is safe.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Simulated distance to object\n    float speed = 60.0f; // Simulated current speed\n    reduceSpeedIfNecessary(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic parking system that automatically steers the vehicle into a parking space.",
      "input": "Simulate parking space detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SPACE_THRESHOLD = 2.5f; // Parking space detection threshold in meters\n\nvoid parkVehicle(float distanceToParkingSpace) {\n    if (distanceToParkingSpace < PARKING_SPACE_THRESHOLD) {\n        std::cout << \"Parking space detected, parking vehicle...\" << std::endl;\n        // Logic to park the vehicle\n    } else {\n        std::cout << \"No parking space detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.0f; // Simulated distance to parking space\n    parkVehicle(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a hill start assist system that prevents the vehicle from rolling backward on an incline.",
      "input": "Simulate vehicle inclination and brake force data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float INCLINE_THRESHOLD = 5.0f; // Incline threshold for hill start assist\n\nvoid preventRollbackOnHill(float inclineAngle) {\n    if (inclineAngle > INCLINE_THRESHOLD) {\n        std::cout << \"Hill detected, engaging hill start assist.\" << std::endl;\n        // Logic to prevent rollback\n    } else {\n        std::cout << \"No hill detected, normal driving.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float incline = 6.0f; // Simulated incline angle\n    preventRollbackOnHill(incline);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an adaptive headlights system that adjusts the vehicle\u2019s headlights based on steering angle.",
      "input": "Simulate steering angle data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float STEERING_ANGLE_THRESHOLD = 30.0f; // Steering angle threshold for headlight adjustment\n\nvoid adjustHeadlights(float steeringAngle) {\n    if (steeringAngle > STEERING_ANGLE_THRESHOLD) {\n        std::cout << \"Adjusting headlights for steering angle.\" << std::endl;\n        // Logic to adjust headlights\n    } else {\n        std::cout << \"Headlights are in normal position.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float angle = 35.0f; // Simulated steering angle\n    adjustHeadlights(angle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic rain sensing system that adjusts the windshield wipers' speed based on rainfall intensity.",
      "input": "Simulate rain intensity data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_INTENSITY_THRESHOLD = 50.0f; // Rain intensity threshold\n\nvoid adjustWiperSpeed(float rainIntensity) {\n    if (rainIntensity > RAIN_INTENSITY_THRESHOLD) {\n        std::cout << \"Heavy rain detected, increasing wiper speed.\" << std::endl;\n        // Logic to increase wiper speed\n    } else {\n        std::cout << \"Light rain detected, maintaining normal wiper speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rainIntensity = 60.0f; // Simulated rain intensity\n    adjustWiperSpeed(rainIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a collision avoidance system that alters the vehicle's trajectory to avoid a collision.",
      "input": "Simulate collision risk and vehicle speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_RISK_THRESHOLD = 3.0f; // Collision risk threshold in meters\n\nvoid avoidCollision(float distanceToObject) {\n    if (distanceToObject < COLLISION_RISK_THRESHOLD) {\n        std::cout << \"Warning: Collision risk detected, altering trajectory.\" << std::endl;\n        // Logic to avoid collision\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Simulated distance to object\n    avoidCollision(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traffic sign recognition system that alerts the driver when a traffic sign is detected.",
      "input": "Simulate traffic sign detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SIGN_DETECTION_THRESHOLD = 1.0f; // Sign detection threshold in meters\n\nvoid detectTrafficSign(float distanceToSign) {\n    if (distanceToSign < SIGN_DETECTION_THRESHOLD) {\n        std::cout << \"Traffic sign detected, alerting driver.\" << std::endl;\n        // Logic to alert driver\n    } else {\n        std::cout << \"No traffic sign detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 0.5f; // Simulated distance to traffic sign\n    detectTrafficSign(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an emergency vehicle detection system that alerts the driver when an emergency vehicle is detected nearby.",
      "input": "Simulate emergency vehicle detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float EMERGENCY_VEHICLE_DETECTION_THRESHOLD = 5.0f; // Detection threshold for emergency vehicles\n\nvoid detectEmergencyVehicle(float distanceToEmergencyVehicle) {\n    if (distanceToEmergencyVehicle < EMERGENCY_VEHICLE_DETECTION_THRESHOLD) {\n        std::cout << \"Emergency vehicle detected, alerting driver.\" << std::endl;\n        // Logic to alert driver\n    } else {\n        std::cout << \"No emergency vehicle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Simulated distance to emergency vehicle\n    detectEmergencyVehicle(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian detection system that warns the driver if a pedestrian is detected in the vehicle\u2019s path.",
      "input": "Simulate pedestrian detection and distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 2.0f; // Pedestrian detection threshold in meters\n\nvoid detectPedestrian(float distanceToPedestrian) {\n    if (distanceToPedestrian < PEDESTRIAN_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected in path!\" << std::endl;\n        // Logic to warn the driver\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.5f; // Simulated distance to pedestrian\n    detectPedestrian(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Departure Warning system that alerts the driver if the vehicle unintentionally drifts out of the lane.",
      "input": "Simulate lane position and steering data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f; // Lane departure threshold in meters\n\nvoid checkLaneDeparture(float deviationFromLane) {\n    if (deviationFromLane > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure detected!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle is within the lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float deviation = 0.6f; // Simulated lane deviation\n    checkLaneDeparture(deviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that adjusts the vehicle's speed based on the distance to the car in front.",
      "input": "Simulate distance to vehicle and current speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float FOLLOW_DISTANCE_THRESHOLD = 3.0f; // Following distance threshold in meters\n\nvoid adjustSpeedForSafety(float distanceToCar, float currentSpeed) {\n    if (distanceToCar < FOLLOW_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Reducing speed to maintain safe distance.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Vehicle is at safe distance.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Simulated distance to car ahead\n    float speed = 60.0f; // Simulated current speed\n    adjustSpeedForSafety(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian protection system that automatically applies the brakes if a pedestrian is detected in the vehicle's path.",
      "input": "Simulate pedestrian detection and distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f; // Pedestrian detection threshold in meters\n\nvoid applyBrakesIfPedestrianDetected(float distanceToPedestrian) {\n    if (distanceToPedestrian < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected, applying brakes!\" << std::endl;\n        // Logic to apply brakes\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.5f; // Simulated distance to pedestrian\n    applyBrakesIfPedestrianDetected(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a rear cross-traffic alert system that warns the driver of traffic approaching from behind when reversing.",
      "input": "Simulate rear cross-traffic detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REAR_CROSS_TRAFFIC_THRESHOLD = 5.0f; // Threshold for detecting cross traffic in meters\n\nvoid checkRearCrossTraffic(float distanceToTraffic) {\n    if (distanceToTraffic < REAR_CROSS_TRAFFIC_THRESHOLD) {\n        std::cout << \"WARNING: Rear cross-traffic detected!\" << std::endl;\n        // Logic to alert driver\n    } else {\n        std::cout << \"No rear cross-traffic detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Simulated distance to approaching traffic\n    checkRearCrossTraffic(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traction control system that reduces engine power to prevent wheel slip during acceleration.",
      "input": "Simulate wheel slip and acceleration data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float WHEEL_SLIP_THRESHOLD = 0.1f; // Wheel slip threshold\n\nvoid controlTraction(float wheelSlip) {\n    if (wheelSlip > WHEEL_SLIP_THRESHOLD) {\n        std::cout << \"WARNING: Wheel slip detected, reducing engine power.\" << std::endl;\n        // Logic to reduce engine power\n    } else {\n        std::cout << \"Traction is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float slip = 0.15f; // Simulated wheel slip\n    controlTraction(slip);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic emergency braking system that applies the brakes when a collision is imminent.",
      "input": "Simulate distance to object and speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0f; // Collision detection threshold\n\nvoid applyEmergencyBrakes(float distanceToObject) {\n    if (distanceToObject < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision imminent, applying emergency brakes!\" << std::endl;\n        // Logic to apply emergency brakes\n    } else {\n        std::cout << \"No imminent collision.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Simulated distance to object\n    applyEmergencyBrakes(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a traffic light recognition system that alerts the driver when the light is red.",
      "input": "Simulate traffic light recognition data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst int RED_LIGHT_THRESHOLD = 1; // Simulated red light recognition threshold\n\nvoid checkTrafficLight(int lightStatus) {\n    if (lightStatus == RED_LIGHT_THRESHOLD) {\n        std::cout << \"WARNING: Red light detected, stop!\" << std::endl;\n    } else {\n        std::cout << \"Traffic light is green or yellow.\" << std::endl;\n    }\n}\n\nint main(void) {\n    int lightStatus = 1; // Simulated red light status\n    checkTrafficLight(lightStatus);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an electronic stability control system that detects and mitigates vehicle skidding.",
      "input": "Simulate yaw rate and steering data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float YAW_RATE_THRESHOLD = 0.3f; // Yaw rate threshold for stability control\n\nvoid stabilizeVehicle(float yawRate) {\n    if (yawRate > YAW_RATE_THRESHOLD) {\n        std::cout << \"WARNING: Skidding detected, applying stability control.\" << std::endl;\n        // Logic to apply stability control\n    } else {\n        std::cout << \"Vehicle is stable.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float yaw = 0.4f; // Simulated yaw rate\n    stabilizeVehicle(yaw);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a blind spot monitoring system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate blind spot sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_DETECTION_THRESHOLD = 2.5f; // Blind spot detection threshold\n\nvoid monitorBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle in blind spot!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.8f; // Simulated distance to vehicle in blind spot\n    monitorBlindSpot(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a drowsiness detection system that alerts the driver if signs of drowsiness are detected.",
      "input": "Simulate drowsiness detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst int DROWSINESS_THRESHOLD = 5; // Drowsiness detection threshold\n\nvoid detectDrowsiness(int drowsinessLevel) {\n    if (drowsinessLevel > DROWSINESS_THRESHOLD) {\n        std::cout << \"WARNING: Drowsiness detected, take a break.\" << std::endl;\n        // Logic to alert driver\n    } else {\n        std::cout << \"Driver is alert.\" << std::endl;\n    }\n}\n\nint main(void) {\n    int drowsiness = 6; // Simulated drowsiness level\n    detectDrowsiness(drowsiness);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Speed Limit Warning system that alerts the driver when they exceed the set speed limit.",
      "input": "Simulate vehicle speed data and speed limit, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_LIMIT = 120.0f; // Speed limit in km/h\n\nvoid checkSpeedLimit(float currentSpeed) {\n    if (currentSpeed > SPEED_LIMIT) {\n        std::cout << \"WARNING: Speed limit exceeded!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Speed is within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float speed = 130.0f; // Simulated current speed\n    checkSpeedLimit(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Pressure Monitoring System (TPMS) that alerts the driver when the tire pressure is too low.",
      "input": "Simulate tire pressure data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MIN_TIRE_PRESSURE = 30.0f; // Minimum acceptable tire pressure in psi\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < MIN_TIRE_PRESSURE) {\n        std::cout << \"WARNING: Tire pressure is low!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float pressure = 28.0f; // Simulated tire pressure\n    checkTirePressure(pressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Headlights System that turns on headlights when it's dark outside.",
      "input": "Simulate ambient light sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_THRESHOLD = 50.0f; // Threshold for ambient light in lux\n\nvoid checkAmbientLight(float lightLevel) {\n    if (lightLevel < LIGHT_THRESHOLD) {\n        std::cout << \"Turning on headlights.\" << std::endl;\n        // Logic to turn on headlights\n    } else {\n        std::cout << \"Ambient light is sufficient.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lightLevel = 30.0f; // Simulated ambient light level\n    checkAmbientLight(lightLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Collision Avoidance System that automatically adjusts speed if an obstacle is detected in front.",
      "input": "Simulate obstacle detection and speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 3.0f; // Obstacle detection threshold in meters\n\nvoid adjustSpeedIfObstacleDetected(float distanceToObstacle, float currentSpeed) {\n    if (distanceToObstacle < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected, reducing speed.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"No obstacle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Simulated distance to obstacle\n    float speed = 50.0f; // Simulated speed\n    adjustSpeedIfObstacleDetected(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Keeping Assist system that steers the vehicle back into the lane if it drifts out.",
      "input": "Simulate lane deviation data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float DEVIATION_THRESHOLD = 0.5f; // Lane deviation threshold in meters\n\nvoid correctLanePosition(float deviation) {\n    if (deviation > DEVIATION_THRESHOLD) {\n        std::cout << \"WARNING: Lane deviation detected, steering back into lane.\" << std::endl;\n        // Logic to steer back into lane\n    } else {\n        std::cout << \"Vehicle is within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float deviation = 0.6f; // Simulated lane deviation\n    correctLanePosition(deviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Detection system that alerts the driver if another vehicle is detected in the blind spot.",
      "input": "Simulate blind spot sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 2.5f; // Blind spot detection threshold in meters\n\nvoid monitorBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle in blind spot!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.8f; // Simulated distance to vehicle in blind spot\n    monitorBlindSpot(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning system that alerts the driver if an imminent collision is detected.",
      "input": "Simulate vehicle speed, distance to obstacle, and collision threshold data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 5.0f; // Collision detection threshold in meters\n\nvoid checkForCollision(float distanceToObject, float currentSpeed) {\n    if (distanceToObject < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Imminent collision!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Simulated distance to object\n    float speed = 60.0f; // Simulated vehicle speed\n    checkForCollision(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Traffic Sign Recognition system that alerts the driver when a traffic sign is detected.",
      "input": "Simulate traffic sign detection and recognition data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst int STOP_SIGN = 1; // Simulated traffic sign detection constant\n\nvoid recognizeTrafficSign(int detectedSign) {\n    if (detectedSign == STOP_SIGN) {\n        std::cout << \"WARNING: Stop sign detected!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No stop sign detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    int sign = 1; // Simulated detected sign\n    recognizeTrafficSign(sign);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Parking Assistance System that assists the driver in parking by detecting objects near the vehicle.",
      "input": "Simulate proximity sensor data and vehicle orientation, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_THRESHOLD = 1.0f; // Proximity detection threshold in meters\n\nvoid assistParking(float distanceToObject) {\n    if (distanceToObject < PARKING_THRESHOLD) {\n        std::cout << \"WARNING: Object detected near vehicle, parking assistance activated.\" << std::endl;\n        // Logic for parking assistance\n    } else {\n        std::cout << \"No obstacles detected during parking.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 0.8f; // Simulated proximity to object\n    assistParking(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Wipers System that turns on wipers when it detects rain.",
      "input": "Simulate rain sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_SENSOR_THRESHOLD = 40.0f; // Rain intensity threshold\n\nvoid controlWipers(float rainIntensity) {\n    if (rainIntensity > RAIN_SENSOR_THRESHOLD) {\n        std::cout << \"Turning on wipers.\" << std::endl;\n        // Logic to activate wipers\n    } else {\n        std::cout << \"No rain detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rain = 50.0f; // Simulated rain intensity\n    controlWipers(rain);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Pedestrian Detection System that alerts the driver when a pedestrian is detected in front of the vehicle.",
      "input": "Simulate pedestrian detection, distance data, and threshold for warning, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 3.0f; // Pedestrian detection threshold in meters\n\nvoid detectPedestrian(float distanceToPedestrian) {\n    if (distanceToPedestrian < PEDESTRIAN_DETECTION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Simulated distance to pedestrian\n    detectPedestrian(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Emergency Braking (AEB) system that applies brakes when an imminent collision is detected.",
      "input": "Simulate vehicle speed, distance to object, and collision threshold data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 5.0f; // Collision threshold in meters\n\nvoid applyEmergencyBrakes(float distanceToObject, float currentSpeed) {\n    if (distanceToObject < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Applying emergency brakes!\" << std::endl;\n        // Logic to apply brakes\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Simulated distance to object\n    float speed = 40.0f; // Simulated speed\n    applyEmergencyBrakes(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control (ACC) system that adjusts the vehicle's speed based on the distance to the car ahead.",
      "input": "Simulate vehicle speed and distance to the car ahead, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE = 3.0f; // Safe distance in meters\n\nvoid adjustSpeedForTraffic(float distanceToCarAhead, float currentSpeed) {\n    if (distanceToCarAhead < SAFE_DISTANCE) {\n        std::cout << \"Slowing down to maintain safe distance.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Simulated distance to car ahead\n    float speed = 60.0f; // Simulated speed\n    adjustSpeedForTraffic(distance, speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a system that automatically turns on headlights when it is dark outside, based on ambient light sensor data.",
      "input": "Simulate ambient light sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_THRESHOLD = 50.0f; // Ambient light threshold in lux\n\nvoid checkNightMode(float lightLevel) {\n    if (lightLevel < LIGHT_THRESHOLD) {\n        std::cout << \"Turning on headlights.\" << std::endl;\n        // Logic to turn on headlights\n    } else {\n        std::cout << \"Ambient light is sufficient.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lightLevel = 30.0f; // Simulated light level\n    checkNightMode(lightLevel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects obstacles in front and alerts the driver when a collision is imminent.",
      "input": "Simulate obstacle detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 5.0f; // Collision warning threshold in meters\n\nvoid detectObstacle(float distanceToObstacle) {\n    if (distanceToObstacle < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision imminent!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Simulated distance to obstacle\n    detectObstacle(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Parking Assistance system that detects vehicles in the vicinity of the parking space.",
      "input": "Simulate proximity sensor data and vehicle detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_THRESHOLD = 2.0f; // Parking assistance threshold in meters\n\nvoid detectNearbyVehicle(float distanceToVehicle) {\n    if (distanceToVehicle < PARKING_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle detected near parking space.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle detected in parking space.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.5f; // Simulated distance to nearby vehicle\n    detectNearbyVehicle(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Detection system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate vehicle detection in blind spot, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 2.0f; // Blind spot detection threshold in meters\n\nvoid detectVehicleInBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle detected in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.8f; // Simulated distance to vehicle in blind spot\n    detectVehicleInBlindSpot(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a system that detects traffic lights and alerts the driver if the light is red.",
      "input": "Simulate traffic light detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst int RED_LIGHT = 1; // Simulated constant for red light detection\n\nvoid detectTrafficLight(int lightStatus) {\n    if (lightStatus == RED_LIGHT) {\n        std::cout << \"WARNING: Red light detected!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Traffic light is not red.\" << std::endl;\n    }\n}\n\nint main(void) {\n    int light = RED_LIGHT; // Simulated traffic light status\n    detectTrafficLight(light);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Windshield Wipers system that activates wipers when rain is detected.",
      "input": "Simulate rain sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_SENSOR_THRESHOLD = 40.0f; // Rain intensity threshold in mm/h\n\nvoid activateWipers(float rainIntensity) {\n    if (rainIntensity > RAIN_SENSOR_THRESHOLD) {\n        std::cout << \"Activating windshield wipers.\" << std::endl;\n        // Logic to activate wipers\n    } else {\n        std::cout << \"Rain intensity is low.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rain = 50.0f; // Simulated rain intensity\n    activateWipers(rain);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Departure Warning system that alerts the driver when the vehicle deviates from its lane.",
      "input": "Simulate lane position and threshold for deviation, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f; // Lane deviation threshold in meters\n\nvoid checkLaneDeparture(float deviation) {\n    if (deviation > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure detected!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float deviation = 0.6f; // Simulated lane deviation\n    checkLaneDeparture(deviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Pressure Monitoring System (TPMS) that alerts the driver when tire pressure is below the safe threshold.",
      "input": "Simulate tire pressure data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_PRESSURE_THRESHOLD = 30.0f; // Tire pressure threshold in psi\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"WARNING: Low tire pressure.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 28.0f; // Simulated tire pressure\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian detection system for autonomous vehicles, which warns the driver when pedestrians are detected in front of the vehicle.",
      "input": "Simulate pedestrian detection data and collision threshold, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_WARNING_THRESHOLD = 3.0f; // Pedestrian warning threshold in meters\n\nvoid detectPedestrian(float distanceToPedestrian) {\n    if (distanceToPedestrian < PEDESTRIAN_WARNING_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected in front of the vehicle.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float pedestrianDistance = 2.5f; // Simulated pedestrian distance\n    detectPedestrian(pedestrianDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Speed Detection system that checks if the vehicle speed exceeds the set limit and alerts the driver.",
      "input": "Simulate vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_LIMIT = 120.0f; // Speed limit in km/h\n\nvoid checkSpeed(float currentSpeed) {\n    if (currentSpeed > SPEED_LIMIT) {\n        std::cout << \"WARNING: Speed exceeds limit!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Speed is within the limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float speed = 130.0f; // Simulated vehicle speed\n    checkSpeed(speed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Lane Keeping Assist system that alerts the driver when the vehicle deviates from the lane without signaling.",
      "input": "Simulate lane position and deviation data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEVIATION_THRESHOLD = 0.5f; // Lane deviation threshold in meters\n\nvoid checkLanePosition(float deviation) {\n    if (deviation > LANE_DEVIATION_THRESHOLD) {\n        std::cout << \"WARNING: Lane deviation detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle is within the lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float deviation = 0.6f; // Simulated lane deviation\n    checkLanePosition(deviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Rear Collision Detection system that alerts the driver when an object is detected behind the vehicle while reversing.",
      "input": "Simulate distance to object, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REAR_COLLISION_THRESHOLD = 2.0f; // Rear collision detection threshold in meters\n\nvoid detectRearCollision(float distanceToObject) {\n    if (distanceToObject < REAR_COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Object detected behind vehicle.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No object detected behind vehicle.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 1.5f; // Simulated distance to object\n    detectRearCollision(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Headlights system that turns on headlights when ambient light is below a specified threshold.",
      "input": "Simulate ambient light sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_SENSOR_THRESHOLD = 50.0f; // Light sensor threshold in lux\n\nvoid controlHeadlights(float ambientLight) {\n    if (ambientLight < LIGHT_SENSOR_THRESHOLD) {\n        std::cout << \"Turning on headlights.\" << std::endl;\n        // Logic to turn on headlights\n    } else {\n        std::cout << \"Sufficient ambient light.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float light = 40.0f; // Simulated ambient light level\n    controlHeadlights(light);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a system that activates the windshield wipers automatically when rain is detected.",
      "input": "Simulate rain intensity, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_THRESHOLD = 30.0f; // Rain intensity threshold in mm/h\n\nvoid activateWipers(float rainIntensity) {\n    if (rainIntensity > RAIN_THRESHOLD) {\n        std::cout << \"Activating windshield wipers.\" << std::endl;\n        // Logic to activate wipers\n    } else {\n        std::cout << \"No rain detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rain = 35.0f; // Simulated rain intensity\n    activateWipers(rain);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that adjusts vehicle speed based on the distance to the vehicle ahead.",
      "input": "Simulate vehicle speed and distance, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE = 3.0f; // Safe distance threshold in meters\n\nvoid adjustSpeedForSafety(float distanceToVehicle) {\n    if (distanceToVehicle < SAFE_DISTANCE) {\n        std::cout << \"Slowing down to maintain safe distance.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.0f; // Simulated distance to vehicle ahead\n    adjustSpeedForSafety(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Collision Avoidance system that applies brakes if an obstacle is detected in the vehicle's path.",
      "input": "Simulate obstacle detection and distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_AVOIDANCE_THRESHOLD = 5.0f; // Collision avoidance threshold in meters\n\nvoid applyBrakesForCollision(float distanceToObstacle) {\n    if (distanceToObstacle < COLLISION_AVOIDANCE_THRESHOLD) {\n        std::cout << \"Collision detected! Applying brakes.\" << std::endl;\n        // Logic to apply brakes\n    } else {\n        std::cout << \"No collision detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Simulated distance to obstacle\n    applyBrakesForCollision(distance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Autonomous Parking Assistance system that detects parking spots and helps the vehicle park itself.",
      "input": "Simulate parking spot detection and distance to parking spot, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SPOT_THRESHOLD = 2.5f; // Parking spot detection threshold in meters\n\nvoid detectParkingSpot(float distanceToSpot) {\n    if (distanceToSpot < PARKING_SPOT_THRESHOLD) {\n        std::cout << \"Parking spot detected. Initiating parking process.\" << std::endl;\n        // Logic to park the vehicle\n    } else {\n        std::cout << \"No parking spot detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float spotDistance = 2.0f; // Simulated distance to parking spot\n    detectParkingSpot(spotDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic brake system that applies the brakes if the vehicle speed exceeds a predefined limit.",
      "input": "Simulate vehicle speed data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MAX_SPEED_LIMIT = 120.0f; // Speed limit in km/h\n\nvoid applyBrakesIfNeeded(float vehicleSpeed) {\n    if (vehicleSpeed > MAX_SPEED_LIMIT) {\n        std::cout << \"Warning: Speed exceeds limit! Applying brakes.\" << std::endl;\n        // Logic to apply brakes\n    } else {\n        std::cout << \"Speed is within limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float currentSpeed = 130.0f; // Simulated vehicle speed\n    applyBrakesIfNeeded(currentSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Detection system that alerts the driver when another vehicle is detected in the blind spot.",
      "input": "Simulate detection of vehicles in the blind spot, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 2.0f; // Detection threshold in meters\n\nvoid checkBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 1.5f; // Simulated distance to vehicle in blind spot\n    checkBlindSpot(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a forward collision avoidance system that warns the driver when a vehicle is detected in the path.",
      "input": "Simulate distance to detected vehicle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_WARNING_THRESHOLD = 5.0f; // Threshold in meters\n\nvoid checkForCollision(float distanceToVehicle) {\n    if (distanceToVehicle < COLLISION_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Collision risk ahead!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 4.0f; // Simulated distance to vehicle ahead\n    checkForCollision(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a pedestrian detection system for autonomous vehicles that alerts the driver when pedestrians are detected.",
      "input": "Simulate pedestrian distance, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_WARNING_THRESHOLD = 3.0f; // Distance in meters\n\nvoid detectPedestrian(float distanceToPedestrian) {\n    if (distanceToPedestrian < PEDESTRIAN_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float pedestrianDistance = 2.0f; // Simulated pedestrian distance\n    detectPedestrian(pedestrianDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Pressure Monitoring System (TPMS) that alerts the driver when tire pressure falls below a safe threshold.",
      "input": "Simulate tire pressure data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_PRESSURE_THRESHOLD = 30.0f; // Threshold in psi\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Low tire pressure!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 25.0f; // Simulated tire pressure\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an automatic light control system that turns on the vehicle's headlights when it gets dark outside.",
      "input": "Simulate ambient light intensity, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_INTENSITY_THRESHOLD = 50.0f; // Light intensity threshold in lux\n\nvoid controlLights(float ambientLightIntensity) {\n    if (ambientLightIntensity < LIGHT_INTENSITY_THRESHOLD) {\n        std::cout << \"Turning on headlights.\" << std::endl;\n        // Logic to turn on headlights\n    } else {\n        std::cout << \"Sufficient light, headlights off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float ambientLight = 40.0f; // Simulated ambient light intensity\n    controlLights(ambientLight);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that adjusts vehicle speed based on the distance to the vehicle ahead.",
      "input": "Simulate vehicle speed and distance data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE = 3.0f; // Safe distance in meters\n\nvoid adjustSpeedForSafety(float distanceToVehicle) {\n    if (distanceToVehicle < SAFE_DISTANCE) {\n        std::cout << \"Slowing down to maintain safe distance.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 2.0f; // Simulated distance to vehicle\n    adjustSpeedForSafety(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Monitoring system that alerts the driver when a vehicle is in the blind spot.",
      "input": "Simulate distance to vehicle in the blind spot, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 2.0f; // Blind spot detection threshold in meters\n\nvoid checkBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 1.5f; // Simulated vehicle distance in blind spot\n    checkBlindSpot(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Rear Parking Assistance system that alerts the driver if an obstacle is detected while reversing.",
      "input": "Simulate distance to rear obstacles, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REAR_OBSTACLE_THRESHOLD = 2.0f; // Threshold in meters\n\nvoid checkForRearObstacle(float distanceToObstacle) {\n    if (distanceToObstacle < REAR_OBSTACLE_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected behind vehicle.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No obstacle detected behind vehicle.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 1.5f; // Simulated distance to rear obstacle\n    checkForRearObstacle(obstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Departure Warning system that alerts the driver if the vehicle drifts out of its lane.",
      "input": "Simulate vehicle's position within lane, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f; // Lane departure threshold in meters\n\nvoid checkLaneDeparture(float deviationFromCenter) {\n    if (deviationFromCenter > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle is within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDeviation = 0.6f; // Simulated deviation from lane center\n    checkLaneDeparture(laneDeviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Lighting system that adjusts the headlights' intensity based on ambient light conditions.",
      "input": "Simulate light intensity data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_INTENSITY_THRESHOLD = 50.0f; // Threshold for light intensity in lux\n\nvoid adjustHeadlights(float ambientLightIntensity) {\n    if (ambientLightIntensity < LIGHT_INTENSITY_THRESHOLD) {\n        std::cout << \"Headlights on.\" << std::endl;\n        // Logic to turn on headlights\n    } else {\n        std::cout << \"Headlights off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lightIntensity = 30.0f; // Simulated light intensity\n    adjustHeadlights(lightIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Anti-lock Braking System (ABS) that activates when the vehicle's wheels lock up during braking.",
      "input": "Simulate wheel speed and braking force data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MAX_WHEEL_SPEED = 20.0f; // Max wheel speed in m/s\n\nvoid activateABS(float wheelSpeed) {\n    if (wheelSpeed > MAX_WHEEL_SPEED) {\n        std::cout << \"Warning: ABS Activated. Wheel speed too high.\" << std::endl;\n        // Logic to activate ABS\n    } else {\n        std::cout << \"ABS not required.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float wheelSpeed = 25.0f; // Simulated wheel speed during braking\n    activateABS(wheelSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Stability Control (VSC) system that adjusts the vehicle's braking or throttle when instability is detected.",
      "input": "Simulate vehicle's yaw rate and lateral acceleration, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float YAW_RATE_THRESHOLD = 0.5f; // Yaw rate threshold in rad/s\nconst float LATERAL_ACCEL_THRESHOLD = 1.0f; // Lateral acceleration threshold in m/s^2\n\nvoid activateVSC(float yawRate, float lateralAcceleration) {\n    if (yawRate > YAW_RATE_THRESHOLD || lateralAcceleration > LATERAL_ACCEL_THRESHOLD) {\n        std::cout << \"Warning: Vehicle instability detected. Activating VSC.\" << std::endl;\n        // Logic to adjust braking or throttle\n    } else {\n        std::cout << \"Vehicle stability maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float yawRate = 0.6f; // Simulated yaw rate\n    float lateralAccel = 1.2f; // Simulated lateral acceleration\n    activateVSC(yawRate, lateralAccel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Parking Assist system that warns the driver if there is an obstacle while parking.",
      "input": "Simulate distance to obstacles, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_OBSTACLE_THRESHOLD = 1.5f; // Threshold in meters\n\nvoid checkParkingObstacle(float distanceToObstacle) {\n    if (distanceToObstacle < PARKING_OBSTACLE_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected while parking.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No obstacle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 1.0f; // Simulated distance to obstacle while parking\n    checkParkingObstacle(obstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Keeping Assist system that steers the vehicle back into its lane if it starts to drift out.",
      "input": "Simulate vehicle position in lane, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f; // Lane departure threshold in meters\n\nvoid correctLaneDrift(float deviationFromCenter) {\n    if (deviationFromCenter > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected. Steering back into lane.\" << std::endl;\n        // Logic to steer the vehicle back into the lane\n    } else {\n        std::cout << \"Vehicle is within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDeviation = 0.6f; // Simulated deviation from lane center\n    correctLaneDrift(laneDeviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Collision Warning system that warns the driver if another vehicle is too close.",
      "input": "Simulate the distance to a detected vehicle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_WARNING_THRESHOLD = 3.0f; // Threshold for warning in meters\n\nvoid checkForCollision(float distanceToVehicle) {\n    if (distanceToVehicle < COLLISION_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Collision risk ahead!\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 2.5f; // Simulated distance to vehicle\n    checkForCollision(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Rear View Camera system that displays the rear view of the vehicle and alerts the driver of obstacles.",
      "input": "Simulate obstacle detection, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REAR_OBSTACLE_THRESHOLD = 2.0f; // Detection threshold in meters\n\nvoid checkRearObstacle(float distanceToObstacle) {\n    if (distanceToObstacle < REAR_OBSTACLE_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected behind vehicle.\" << std::endl;\n        // Logic to display rear view and alert the driver\n    } else {\n        std::cout << \"No obstacle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 1.5f; // Simulated distance to obstacle behind the vehicle\n    checkRearObstacle(obstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Front Parking Sensor system that alerts the driver when an obstacle is detected in front of the vehicle.",
      "input": "Simulate front distance to obstacle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float FRONT_OBSTACLE_THRESHOLD = 1.5f; // Front detection threshold in meters\n\nvoid checkFrontObstacle(float distanceToObstacle) {\n    if (distanceToObstacle < FRONT_OBSTACLE_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected in front of vehicle.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No obstacle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float frontObstacleDistance = 1.0f; // Simulated distance to front obstacle\n    checkFrontObstacle(frontObstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Drowsiness Detection system that alerts the driver if drowsiness is detected based on facial analysis.",
      "input": "Simulate drowsiness detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float DROWSINESS_THRESHOLD = 0.7f; // Threshold for drowsiness detection\n\nvoid checkDrowsiness(float drowsinessLevel) {\n    if (drowsinessLevel > DROWSINESS_THRESHOLD) {\n        std::cout << \"Warning: Driver drowsiness detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Driver is alert.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float driverDrowsiness = 0.8f; // Simulated drowsiness level\n    checkDrowsiness(driverDrowsiness);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that adjusts the vehicle's speed based on the distance to the car ahead.",
      "input": "Simulate the distance to a vehicle ahead and the current speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float CRUISE_CONTROL_THRESHOLD = 30.0f; // Cruise control distance threshold in meters\n\nvoid adjustSpeedForCruiseControl(float distanceToVehicle, float currentSpeed) {\n    if (distanceToVehicle < CRUISE_CONTROL_THRESHOLD) {\n        std::cout << \"Warning: Slowing down for safe distance.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 25.0f; // Simulated distance to vehicle ahead\n    float currentSpeed = 60.0f; // Simulated current speed\n    adjustSpeedForCruiseControl(vehicleDistance, currentSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Detection system that alerts the driver when another vehicle is in the blind spot.",
      "input": "Simulate vehicle position in the blind spot, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 3.0f; // Detection threshold in meters\n\nvoid checkBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 2.5f; // Simulated distance to vehicle in blind spot\n    checkBlindSpot(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Electronic Stability Program (ESP) that adjusts the brakes to stabilize the vehicle.",
      "input": "Simulate yaw rate and lateral acceleration, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float YAW_RATE_THRESHOLD = 0.5f; // Yaw rate threshold in rad/s\nconst float LATERAL_ACCEL_THRESHOLD = 1.0f; // Lateral acceleration threshold in m/s^2\n\nvoid activateESP(float yawRate, float lateralAcceleration) {\n    if (yawRate > YAW_RATE_THRESHOLD || lateralAcceleration > LATERAL_ACCEL_THRESHOLD) {\n        std::cout << \"Warning: Vehicle instability detected. Activating ESP.\" << std::endl;\n        // Logic to adjust brakes\n    } else {\n        std::cout << \"Vehicle stability maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float yawRate = 0.6f; // Simulated yaw rate\n    float lateralAccel = 1.2f; // Simulated lateral acceleration\n    activateESP(yawRate, lateralAccel);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Traffic Sign Recognition system that detects and classifies traffic signs.",
      "input": "Simulate input image data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficSign(std::string signType) {\n    if (signType == \"STOP\") {\n        std::cout << \"STOP sign detected. Driver should stop.\" << std::endl;\n        // Logic for STOP sign detection\n    } else if (signType == \"SPEED LIMIT\") {\n        std::cout << \"Speed limit sign detected. Adjust speed accordingly.\" << std::endl;\n        // Logic for SPEED LIMIT sign detection\n    } else {\n        std::cout << \"Unknown traffic sign.\" << std::endl;\n    }\n}\n\nint main(void) {\n    std::string signType = \"STOP\"; // Simulated detected traffic sign\n    detectTrafficSign(signType);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Pressure Monitoring System (TPMS) that alerts the driver if the tire pressure is low.",
      "input": "Simulate tire pressure data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_PRESSURE_THRESHOLD = 30.0f; // Threshold in PSI\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Tire pressure is low.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire pressure is normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 28.0f; // Simulated tire pressure\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Fuel Efficiency Monitoring System that displays the vehicle's current fuel efficiency.",
      "input": "Simulate fuel consumption and distance traveled, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid calculateFuelEfficiency(float fuelConsumed, float distanceTraveled) {\n    if (distanceTraveled > 0) {\n        float fuelEfficiency = distanceTraveled / fuelConsumed;\n        std::cout << \"Current fuel efficiency: \" << fuelEfficiency << \" km/L.\" << std::endl;\n    } else {\n        std::cout << \"Error: Distance traveled is zero.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float fuelConsumed = 5.0f; // Simulated fuel consumed in liters\n    float distanceTraveled = 100.0f; // Simulated distance traveled in kilometers\n    calculateFuelEfficiency(fuelConsumed, distanceTraveled);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Rain Sensing Wipers system that automatically activates the wipers when rain is detected.",
      "input": "Simulate rainfall intensity, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_INTENSITY_THRESHOLD = 0.2f; // Threshold for rain intensity\n\nvoid activateWipers(float rainIntensity) {\n    if (rainIntensity > RAIN_INTENSITY_THRESHOLD) {\n        std::cout << \"Rain detected. Activating wipers.\" << std::endl;\n        // Logic to activate wipers\n    } else {\n        std::cout << \"No rain detected. Wipers off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rainIntensity = 0.3f; // Simulated rain intensity\n    activateWipers(rainIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Emergency Braking (AEB) system that automatically applies the brakes if a collision is imminent.",
      "input": "Simulate vehicle speed and distance to obstacle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 2.0f; // Distance threshold in meters\n\nvoid applyBrakes(float vehicleSpeed, float distanceToObstacle) {\n    if (distanceToObstacle < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision imminent. Applying brakes.\" << std::endl;\n        // Logic to apply emergency braking\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 50.0f; // Simulated vehicle speed in km/h\n    float distanceToObstacle = 1.5f; // Simulated distance to obstacle\n    applyBrakes(vehicleSpeed, distanceToObstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Intelligent Headlight Control system that automatically adjusts the headlights' angle and brightness based on road conditions.",
      "input": "Simulate road conditions (e.g., turns, hills), handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TURN_ANGLE_THRESHOLD = 30.0f; // Threshold for road turns in degrees\n\nvoid adjustHeadlights(float roadTurnAngle) {\n    if (roadTurnAngle > TURN_ANGLE_THRESHOLD) {\n        std::cout << \"Adjusting headlights for road turn.\" << std::endl;\n        // Logic to adjust headlight angle and brightness\n    } else {\n        std::cout << \"Headlights are in normal mode.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float roadTurnAngle = 45.0f; // Simulated road turn angle\n    adjustHeadlights(roadTurnAngle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Detection System that detects nearby vehicles using sensors.",
      "input": "Simulate sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float VEHICLE_DETECTION_THRESHOLD = 5.0f; // Detection threshold in meters\n\nvoid detectVehicle(float distanceToVehicle) {\n    if (distanceToVehicle < VEHICLE_DETECTION_THRESHOLD) {\n        std::cout << \"Vehicle detected nearby.\" << std::endl;\n        // Logic to handle detected vehicle\n    } else {\n        std::cout << \"No vehicle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 3.0f; // Simulated distance to detected vehicle\n    detectVehicle(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Pedestrian Detection System that alerts the driver if a pedestrian is detected in front of the vehicle.",
      "input": "Simulate pedestrian presence, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 2.0f; // Detection threshold in meters\n\nvoid detectPedestrian(float distanceToPedestrian) {\n    if (distanceToPedestrian < PEDESTRIAN_DETECTION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float pedestrianDistance = 1.5f; // Simulated distance to pedestrian\n    detectPedestrian(pedestrianDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Departure Warning system that alerts the driver when the vehicle unintentionally drifts out of the lane.",
      "input": "Simulate lane boundary detection data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f; // Threshold for lane deviation in meters\n\nvoid checkLaneDeparture(float deviation) {\n    if (deviation > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDeviation = 0.6f; // Simulated lane deviation in meters\n    checkLaneDeparture(laneDeviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that adjusts the vehicle's speed to maintain a safe distance from the vehicle in front.",
      "input": "Simulate distance to leading vehicle and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE = 2.0f; // Safe distance threshold in meters\n\nvoid adjustCruiseControl(float distanceToLeadVehicle, float currentSpeed) {\n    if (distanceToLeadVehicle < SAFE_DISTANCE) {\n        std::cout << \"Reducing speed to maintain safe distance.\" << std::endl;\n        // Logic to reduce vehicle speed\n    } else {\n        std::cout << \"Maintaining cruise speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float leadVehicleDistance = 1.5f; // Simulated distance to leading vehicle\n    float vehicleSpeed = 60.0f; // Simulated vehicle speed in km/h\n    adjustCruiseControl(leadVehicleDistance, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Collision Detection system that alerts the driver if an obstacle is detected within a critical range.",
      "input": "Simulate the distance to obstacle and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 1.0f; // Critical threshold in meters\n\nvoid detectCollision(float distanceToObstacle, float speed) {\n    if (distanceToObstacle < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision imminent.\" << std::endl;\n        // Logic to take corrective action\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 0.8f; // Simulated distance to obstacle in meters\n    float vehicleSpeed = 50.0f; // Simulated vehicle speed in km/h\n    detectCollision(obstacleDistance, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Pedestrian Avoidance System that activates emergency braking if a pedestrian is detected ahead.",
      "input": "Simulate distance to pedestrian and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 2.0f; // Detection threshold in meters\n\nvoid avoidPedestrian(float distanceToPedestrian, float speed) {\n    if (distanceToPedestrian < PEDESTRIAN_DETECTION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected ahead. Activating emergency braking.\" << std::endl;\n        // Logic to apply emergency brakes\n    } else {\n        std::cout << \"Pedestrian not detected. Normal driving mode.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float pedestrianDistance = 1.5f; // Simulated distance to pedestrian\n    float vehicleSpeed = 40.0f; // Simulated vehicle speed in km/h\n    avoidPedestrian(pedestrianDistance, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Traffic Light Detection system that detects the status of traffic lights.",
      "input": "Simulate traffic light status (red, yellow, green), handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTrafficLight(std::string lightStatus) {\n    if (lightStatus == \"RED\") {\n        std::cout << \"Red light detected. Please stop.\" << std::endl;\n        // Logic to stop vehicle\n    } else if (lightStatus == \"YELLOW\") {\n        std::cout << \"Yellow light detected. Prepare to stop.\" << std::endl;\n        // Logic to slow down\n    } else if (lightStatus == \"GREEN\") {\n        std::cout << \"Green light detected. Proceed with caution.\" << std::endl;\n        // Logic to drive normally\n    } else {\n        std::cout << \"Invalid traffic light status.\" << std::endl;\n    }\n}\n\nint main(void) {\n    std::string lightStatus = \"RED\"; // Simulated traffic light status\n    detectTrafficLight(lightStatus);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Headlight system that adjusts the direction and brightness of headlights based on vehicle speed and road conditions.",
      "input": "Simulate vehicle speed and road conditions, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid adjustHeadlights(float speed, std::string roadCondition) {\n    if (speed > 50.0f && roadCondition == \"turn\") {\n        std::cout << \"Adjusting headlights for road turn.\" << std::endl;\n        // Logic to adjust headlight angle\n    } else {\n        std::cout << \"Normal headlight operation.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 60.0f; // Simulated vehicle speed in km/h\n    std::string roadCondition = \"turn\"; // Simulated road condition\n    adjustHeadlights(vehicleSpeed, roadCondition);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automated Parking System that assists the driver in parking the vehicle into a designated parking space.",
      "input": "Simulate parking space dimensions and vehicle dimensions, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid parkVehicle(float parkingSpaceWidth, float vehicleWidth) {\n    if (parkingSpaceWidth < vehicleWidth) {\n        std::cout << \"Error: Insufficient parking space.\" << std::endl;\n        // Logic to signal error\n    } else {\n        std::cout << \"Parking space is sufficient. Proceed with parking.\" << std::endl;\n        // Logic to park the vehicle\n    }\n}\n\nint main(void) {\n    float parkingSpaceWidth = 2.5f; // Simulated parking space width in meters\n    float vehicleWidth = 2.0f; // Simulated vehicle width in meters\n    parkVehicle(parkingSpaceWidth, vehicleWidth);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Monitoring system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate sensor input for vehicles in the blind spot, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 3.0f; // Threshold for detecting vehicles in meters\n\nvoid monitorBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle detected in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleDistance = 2.5f; // Simulated distance to vehicle in blind spot\n    monitorBlindSpot(vehicleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Window Control system that closes the windows when it detects rain.",
      "input": "Simulate rain sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float RAIN_SENSOR_THRESHOLD = 0.5f; // Threshold for rain detection\n\nvoid closeWindowsIfRain(float rainIntensity) {\n    if (rainIntensity > RAIN_SENSOR_THRESHOLD) {\n        std::cout << \"Rain detected. Closing windows.\" << std::endl;\n        // Logic to close windows\n    } else {\n        std::cout << \"No rain detected. Windows remain open.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float rainIntensity = 0.6f; // Simulated rain intensity\n    closeWindowsIfRain(rainIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Lighting Control system that adjusts vehicle interior lighting based on ambient light conditions.",
      "input": "Simulate ambient light intensity data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_INTENSITY_THRESHOLD = 50.0f; // Threshold for light intensity\n\nvoid adjustLighting(float ambientLightIntensity) {\n    if (ambientLightIntensity < LIGHT_INTENSITY_THRESHOLD) {\n        std::cout << \"Low light detected. Increasing interior lighting.\" << std::endl;\n        // Logic to increase lighting\n    } else {\n        std::cout << \"Normal light levels detected. Keeping lighting as is.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float ambientLightIntensity = 40.0f; // Simulated ambient light intensity\n    adjustLighting(ambientLightIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Pressure Monitoring System (TPMS) that alerts the driver if tire pressure falls below a threshold.",
      "input": "Simulate tire pressure readings, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float TIRE_PRESSURE_THRESHOLD = 32.0f; // Threshold in psi\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Tire pressure low.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire pressure normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 30.0f; // Simulated tire pressure\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Headlight Adjustment system that adjusts the headlights based on vehicle speed.",
      "input": "Simulate vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_THRESHOLD = 50.0f; // Speed threshold in km/h\n\nvoid adjustHeadlights(float speed) {\n    if (speed < SPEED_THRESHOLD) {\n        std::cout << \"Adjusting headlights for low speed.\" << std::endl;\n        // Logic to lower headlight intensity\n    } else {\n        std::cout << \"Maintaining headlights for high speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 60.0f; // Simulated vehicle speed in km/h\n    adjustHeadlights(vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Emergency Braking System (AEB) that applies the brakes when an imminent collision is detected.",
      "input": "Simulate distance to object and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_DISTANCE_THRESHOLD = 1.5f; // Critical threshold in meters\n\nvoid applyBrakes(float distanceToObject, float speed) {\n    if (distanceToObject < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"Collision imminent! Applying emergency brakes.\" << std::endl;\n        // Logic to apply brakes\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float objectDistance = 1.0f; // Simulated distance to object in meters\n    float vehicleSpeed = 30.0f; // Simulated vehicle speed in km/h\n    applyBrakes(objectDistance, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Speed Limit Detection system that notifies the driver when they exceed the speed limit.",
      "input": "Simulate speed limit and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MAX_SPEED_LIMIT = 60.0f; // Speed limit in km/h\n\nvoid checkSpeedLimit(float vehicleSpeed) {\n    if (vehicleSpeed > MAX_SPEED_LIMIT) {\n        std::cout << \"Warning: Speed limit exceeded.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Speed within limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 70.0f; // Simulated vehicle speed in km/h\n    checkSpeedLimit(vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Driver Fatigue Detection system that monitors driver behavior and provides alerts if fatigue is detected.",
      "input": "Simulate driver activity (eye movement, steering wheel behavior), handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float EYE_CLOSURE_THRESHOLD = 0.5f; // Eye closure percentage threshold\n\nvoid detectDriverFatigue(float eyeClosure) {\n    if (eyeClosure > EYE_CLOSURE_THRESHOLD) {\n        std::cout << \"Warning: Driver fatigue detected. Please take a break.\" << std::endl;\n        // Logic to alert driver\n    } else {\n        std::cout << \"Driver alertness normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float eyeClosure = 0.6f; // Simulated eye closure percentage\n    detectDriverFatigue(eyeClosure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Detection system that provides a warning if the vehicle is approaching another object too quickly.",
      "input": "Simulate distance to object and speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_WARNING_THRESHOLD = 1.2f; // Warning threshold in meters\n\nvoid detectForwardCollision(float distanceToObject, float speed) {\n    if (distanceToObject < COLLISION_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Approaching object too quickly.\" << std::endl;\n        // Logic to alert driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float objectDistance = 1.0f; // Simulated distance to object in meters\n    float vehicleSpeed = 40.0f; // Simulated vehicle speed in km/h\n    detectForwardCollision(objectDistance, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Auto Start/Stop system that turns off the engine when the vehicle is stopped and restarts it when the accelerator is pressed.",
      "input": "Simulate vehicle speed and accelerator status, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid autoStartStop(float vehicleSpeed, bool acceleratorPressed) {\n    if (vehicleSpeed == 0.0f && !acceleratorPressed) {\n        std::cout << \"Engine stopped.\" << std::endl;\n        // Logic to stop engine\n    } else if (acceleratorPressed) {\n        std::cout << \"Accelerator pressed. Restarting engine.\" << std::endl;\n        // Logic to restart engine\n    } else {\n        std::cout << \"Vehicle in motion. Engine running.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 0.0f; // Simulated vehicle speed\n    bool acceleratorPressed = false; // Simulated accelerator status\n    autoStartStop(vehicleSpeed, acceleratorPressed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Parking Assist system that helps the driver park the vehicle by providing proximity warnings.",
      "input": "Simulate proximity sensor data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_PROXIMITY_THRESHOLD = 1.0f; // Proximity threshold in meters\n\nvoid assistParking(float distanceToObstacle) {\n    if (distanceToObstacle < PARKING_PROXIMITY_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected. Proceed with caution.\" << std::endl;\n        // Logic to assist with parking\n    } else {\n        std::cout << \"Parking space available. Continue.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float obstacleDistance = 0.8f; // Simulated distance to obstacle in meters\n    assistParking(obstacleDistance);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Auto-Dimming Rearview Mirror system that adjusts the mirror brightness based on ambient light conditions.",
      "input": "Simulate ambient light intensity, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_INTENSITY_THRESHOLD = 50.0f; // Threshold for light intensity\n\nvoid adjustMirrorBrightness(float ambientLightIntensity) {\n    if (ambientLightIntensity > LIGHT_INTENSITY_THRESHOLD) {\n        std::cout << \"Dimming rearview mirror.\" << std::endl;\n        // Logic to dim rearview mirror\n    } else {\n        std::cout << \"Normal mirror brightness.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lightIntensity = 60.0f; // Simulated ambient light intensity\n    adjustMirrorBrightness(lightIntensity);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Stability Control (VSC) system that detects vehicle oversteer or understeer and adjusts braking force accordingly.",
      "input": "Simulate steering angle and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float STEERING_ANGLE_THRESHOLD = 15.0f; // Steering angle threshold in degrees\n\nvoid controlVehicleStability(float steeringAngle, float speed) {\n    if (steeringAngle > STEERING_ANGLE_THRESHOLD) {\n        std::cout << \"Oversteer detected. Adjusting braking force.\" << std::endl;\n        // Logic to apply braking force\n    } else {\n        std::cout << \"Vehicle stability normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSteering = 20.0f; // Simulated steering angle in degrees\n    float vehicleSpeed = 70.0f; // Simulated vehicle speed in km/h\n    controlVehicleStability(vehicleSteering, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Departure Warning System that alerts the driver if the vehicle drifts out of its lane without signaling.",
      "input": "Simulate vehicle's lateral position, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f; // Lateral position threshold in meters\n\nvoid checkLaneDeparture(float lateralPosition) {\n    if (lateralPosition > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lateralPosition = 0.6f; // Simulated lateral position in meters\n    checkLaneDeparture(lateralPosition);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that maintains a safe distance from the vehicle ahead by adjusting speed.",
      "input": "Simulate vehicle speed and distance to the vehicle ahead, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE_THRESHOLD = 2.0f; // Safe distance in meters\n\nvoid adjustSpeed(float distanceToVehicle, float currentSpeed) {\n    if (distanceToVehicle < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"Reducing speed to maintain safe distance.\" << std::endl;\n        // Logic to adjust speed\n    } else {\n        std::cout << \"Maintaining current speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToVehicle = 1.5f; // Simulated distance in meters\n    float currentSpeed = 80.0f; // Simulated speed in km/h\n    adjustSpeed(distanceToVehicle, currentSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Detection system that alerts the driver if there is a vehicle in the blind spot.",
      "input": "Simulate vehicle position relative to blind spots, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 1.0f; // Proximity threshold in meters\n\nvoid checkBlindSpot(float distanceToBlindSpot) {\n    if (distanceToBlindSpot < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"Warning: Vehicle in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Blind spot clear.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToBlindSpot = 0.8f; // Simulated distance to vehicle in blind spot\n    checkBlindSpot(distanceToBlindSpot);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Traction Control System (TCS) that adjusts the brakes when the vehicle's wheels slip during acceleration.",
      "input": "Simulate wheel slip percentage and vehicle speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SLIP_THRESHOLD = 10.0f; // Slip threshold in percentage\n\nvoid controlTraction(float wheelSlip) {\n    if (wheelSlip > SLIP_THRESHOLD) {\n        std::cout << \"Warning: Wheel slip detected. Adjusting traction control.\" << std::endl;\n        // Logic to apply brakes and control traction\n    } else {\n        std::cout << \"Normal traction.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float wheelSlip = 12.0f; // Simulated wheel slip percentage\n    controlTraction(wheelSlip);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Theft Detection system that detects unauthorized movement of the vehicle when parked.",
      "input": "Simulate motion sensors and vehicle status, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid detectTheft(bool isVehicleMoving) {\n    if (isVehicleMoving) {\n        std::cout << \"Alert: Unauthorized vehicle movement detected.\" << std::endl;\n        // Logic to trigger alarm\n    } else {\n        std::cout << \"Vehicle stationary. No theft detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    bool vehicleMoving = true; // Simulated vehicle movement status\n    detectTheft(vehicleMoving);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Parking Assist system that helps steer the vehicle into a parking space.",
      "input": "Simulate proximity data from sensors and steering control signals, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SPACE_THRESHOLD = 0.5f; // Proximity threshold for parking\n\nvoid assistParkingSteering(float distanceToObstacle) {\n    if (distanceToObstacle < PARKING_SPACE_THRESHOLD) {\n        std::cout << \"Steering to park the vehicle.\" << std::endl;\n        // Logic to steer the vehicle\n    } else {\n        std::cout << \"Parking space available. Continue.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 0.4f; // Simulated distance to obstacle in meters\n    assistParkingSteering(distanceToObstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Hill Start Assist system that prevents the vehicle from rolling backward when starting on an incline.",
      "input": "Simulate vehicle incline and brake status, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float INCLINE_THRESHOLD = 10.0f; // Incline threshold in degrees\n\nvoid preventRollback(float inclineAngle, bool isBrakeApplied) {\n    if (inclineAngle > INCLINE_THRESHOLD && !isBrakeApplied) {\n        std::cout << \"Hill start assist activated: Preventing rollback.\" << std::endl;\n        // Logic to prevent rollback\n    } else {\n        std::cout << \"Vehicle on flat ground or brake applied.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float inclineAngle = 12.0f; // Simulated incline angle in degrees\n    bool isBrakeApplied = false; // Simulated brake status\n    preventRollback(inclineAngle, isBrakeApplied);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Lighting System that adjusts the headlights based on vehicle speed and steering angle.",
      "input": "Simulate vehicle speed and steering angle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float STEERING_ANGLE_THRESHOLD = 15.0f; // Steering angle threshold in degrees\n\nvoid adjustHeadlights(float vehicleSpeed, float steeringAngle) {\n    if (vehicleSpeed > 40.0f && steeringAngle > STEERING_ANGLE_THRESHOLD) {\n        std::cout << \"Adjusting headlights for high speed and steering.\" << std::endl;\n        // Logic to adjust headlights\n    } else {\n        std::cout << \"Maintaining regular headlight setting.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 50.0f; // Simulated speed in km/h\n    float steeringAngle = 20.0f; // Simulated steering angle in degrees\n    adjustHeadlights(vehicleSpeed, steeringAngle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Anti-lock Braking System (ABS) that prevents the wheels from locking during braking by modulating brake pressure.",
      "input": "Simulate wheel speed and brake pressure, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BRAKE_PRESSURE_THRESHOLD = 60.0f; // Brake pressure threshold\n\nvoid controlABS(float wheelSpeed, float brakePressure) {\n    if (wheelSpeed == 0.0f && brakePressure > BRAKE_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Wheel lock detected. Reducing brake pressure.\" << std::endl;\n        // Logic to modulate brake pressure\n    } else {\n        std::cout << \"ABS system operating normally.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float wheelSpeed = 0.0f; // Simulated wheel speed in km/h\n    float brakePressure = 70.0f; // Simulated brake pressure\n    controlABS(wheelSpeed, brakePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Reverse Parking Sensor system that provides warnings when the vehicle is too close to an obstacle while reversing.",
      "input": "Simulate distance to the obstacle while reversing, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REVERSE_THRESHOLD = 1.0f; // Proximity threshold in meters\n\nvoid checkReverseParking(float distanceToObstacle) {\n    if (distanceToObstacle < REVERSE_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected while reversing.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance while reversing.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 0.5f; // Simulated distance to obstacle in meters\n    checkReverseParking(distanceToObstacle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Front Collision Warning system that alerts the driver if the vehicle is too close to an object in front.",
      "input": "Simulate vehicle's speed and distance to the object in front, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SAFE_DISTANCE_THRESHOLD = 3.0f; // Safe distance in meters\n\nvoid checkFrontCollision(float distanceToObject, float vehicleSpeed) {\n    if (distanceToObject < SAFE_DISTANCE_THRESHOLD && vehicleSpeed > 20.0f) {\n        std::cout << \"Warning: Front collision risk.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObject = 2.5f; // Simulated distance to object in meters\n    float vehicleSpeed = 30.0f; // Simulated vehicle speed in km/h\n    checkFrontCollision(distanceToObject, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Speed Limit Alert system that warns the driver if the vehicle exceeds the speed limit in a particular area.",
      "input": "Simulate vehicle speed and set speed limit for the area, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_LIMIT = 50.0f; // Speed limit in km/h\n\nvoid checkSpeedLimit(float vehicleSpeed) {\n    if (vehicleSpeed > SPEED_LIMIT) {\n        std::cout << \"Warning: Speed limit exceeded.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Vehicle within speed limit.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 55.0f; // Simulated vehicle speed in km/h\n    checkSpeedLimit(vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Emergency Braking (AEB) system that applies the brakes automatically if a collision is imminent.",
      "input": "Simulate vehicle's distance to an obstacle and its speed, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 1.0f; // Distance threshold for imminent collision in meters\n\nvoid applyEmergencyBrakes(float distanceToObstacle, float vehicleSpeed) {\n    if (distanceToObstacle < COLLISION_THRESHOLD && vehicleSpeed > 10.0f) {\n        std::cout << \"Warning: Imminent collision detected. Applying emergency brakes.\" << std::endl;\n        // Logic to apply emergency braking\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 0.8f; // Simulated distance to obstacle in meters\n    float vehicleSpeed = 30.0f; // Simulated vehicle speed in km/h\n    applyEmergencyBrakes(distanceToObstacle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Proximity Detection system that alerts the driver if another vehicle is too close.",
      "input": "Simulate the distance between vehicles, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PROXIMITY_THRESHOLD = 1.5f; // Proximity threshold in meters\n\nvoid checkVehicleProximity(float distanceToVehicle) {\n    if (distanceToVehicle < PROXIMITY_THRESHOLD) {\n        std::cout << \"Warning: Vehicle too close.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToVehicle = 1.2f; // Simulated distance to vehicle in meters\n    checkVehicleProximity(distanceToVehicle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Lane Keeping Assistance system that provides steering adjustments to keep the vehicle within its lane.",
      "input": "Simulate lane position data, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_DEVIATION_THRESHOLD = 0.3f; // Lane deviation threshold in meters\n\nvoid assistLaneKeeping(float laneDeviation) {\n    if (laneDeviation > LANE_DEVIATION_THRESHOLD) {\n        std::cout << \"Warning: Lane deviation detected. Adjusting steering.\" << std::endl;\n        // Logic to adjust steering\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDeviation = 0.4f; // Simulated lane deviation in meters\n    assistLaneKeeping(laneDeviation);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Headlights system that adjusts the headlights based on vehicle speed and steering angle.",
      "input": "Simulate vehicle speed and steering angle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float SPEED_THRESHOLD = 30.0f; // Speed threshold for adjusting headlights in km/h\n\nvoid adjustHeadlights(float vehicleSpeed, float steeringAngle) {\n    if (vehicleSpeed > SPEED_THRESHOLD && steeringAngle > 15.0f) {\n        std::cout << \"Adjusting headlights for high speed and steering.\" << std::endl;\n        // Logic to adjust headlights\n    } else {\n        std::cout << \"Maintaining regular headlight setting.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleSpeed = 35.0f; // Simulated vehicle speed in km/h\n    float steeringAngle = 20.0f; // Simulated steering angle in degrees\n    adjustHeadlights(vehicleSpeed, steeringAngle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Parking Brake System that ensures the vehicle remains stationary when parked.",
      "input": "Simulate vehicle's speed and brake status, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid engageParkingBrake(bool isVehicleParked) {\n    if (isVehicleParked) {\n        std::cout << \"Engaging parking brake to keep the vehicle stationary.\" << std::endl;\n        // Logic to engage parking brake\n    } else {\n        std::cout << \"Vehicle not parked. Parking brake not engaged.\" << std::endl;\n    }\n}\n\nint main(void) {\n    bool isVehicleParked = true; // Simulated vehicle parked status\n    engageParkingBrake(isVehicleParked);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Hill Descent Control system that automatically applies brakes to maintain a safe speed while descending a steep hill.",
      "input": "Simulate vehicle's speed, incline angle, and brake status, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float INCLINE_ANGLE_THRESHOLD = 20.0f; // Incline angle threshold in degrees\n\nvoid controlHillDescent(float inclineAngle, float vehicleSpeed) {\n    if (inclineAngle > INCLINE_ANGLE_THRESHOLD && vehicleSpeed > 20.0f) {\n        std::cout << \"Hill descent control activated: Reducing speed.\" << std::endl;\n        // Logic to apply brakes and control speed\n    } else {\n        std::cout << \"Vehicle on flat ground or speed normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float inclineAngle = 25.0f; // Simulated incline angle in degrees\n    float vehicleSpeed = 25.0f; // Simulated vehicle speed in km/h\n    controlHillDescent(inclineAngle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Collision Mitigation System that reduces vehicle speed or applies brakes when a potential collision is detected.",
      "input": "Simulate vehicle's speed and distance to an obstacle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float COLLISION_THRESHOLD = 1.5f; // Distance threshold for potential collision in meters\n\nvoid mitigateCollision(float distanceToObstacle, float vehicleSpeed) {\n    if (distanceToObstacle < COLLISION_THRESHOLD && vehicleSpeed > 30.0f) {\n        std::cout << \"Potential collision detected. Applying mitigation.\" << std::endl;\n        // Logic to reduce speed or apply brakes\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 1.0f; // Simulated distance to obstacle in meters\n    float vehicleSpeed = 35.0f; // Simulated vehicle speed in km/h\n    mitigateCollision(distanceToObstacle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Pressure Monitoring System (TPMS) that alerts the driver if the tire pressure is too low.",
      "input": "Simulate tire pressure values, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LOW_PRESSURE_THRESHOLD = 30.0f; // Tire pressure threshold in PSI\n\nvoid checkTirePressure(float tirePressure) {\n    if (tirePressure < LOW_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Low tire pressure detected.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire pressure normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tirePressure = 28.0f; // Simulated tire pressure in PSI\n    checkTirePressure(tirePressure);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Blind Spot Detection system that alerts the driver when a vehicle is detected in the blind spot.",
      "input": "Simulate the position of vehicles relative to the blind spot sensors, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float BLIND_SPOT_THRESHOLD = 1.0f; // Distance threshold in meters for blind spot detection\n\nvoid checkBlindSpot(float distanceToVehicle) {\n    if (distanceToVehicle < BLIND_SPOT_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in blind spot.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToVehicle = 0.8f; // Simulated distance to vehicle in meters\n    checkBlindSpot(distanceToVehicle);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Adaptive Cruise Control system that adjusts the vehicle's speed based on the distance to the vehicle in front.",
      "input": "Simulate vehicle's speed and distance to the car ahead, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float FOLLOWING_DISTANCE = 2.0f; // Minimum following distance in meters\n\nvoid adjustCruiseControl(float distanceToVehicle, float vehicleSpeed) {\n    if (distanceToVehicle < FOLLOWING_DISTANCE) {\n        std::cout << \"Warning: Reducing speed for safe following distance.\" << std::endl;\n        // Logic to reduce speed\n    } else {\n        std::cout << \"Maintaining cruise speed.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToVehicle = 1.8f; // Simulated distance to vehicle in meters\n    float vehicleSpeed = 60.0f; // Simulated vehicle speed in km/h\n    adjustCruiseControl(distanceToVehicle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Electronic Stability Control system that applies brakes to individual wheels if it detects loss of control.",
      "input": "Simulate vehicle's speed and steering angle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float STEERING_ANGLE_THRESHOLD = 15.0f; // Steering angle threshold in degrees\n\nvoid activateStabilityControl(float steeringAngle, float vehicleSpeed) {\n    if (abs(steeringAngle) > STEERING_ANGLE_THRESHOLD && vehicleSpeed > 30.0f) {\n        std::cout << \"Activating electronic stability control: Adjusting brakes.\" << std::endl;\n        // Logic to adjust brakes for stability\n    } else {\n        std::cout << \"Vehicle is stable.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float steeringAngle = 20.0f; // Simulated steering angle in degrees\n    float vehicleSpeed = 50.0f; // Simulated vehicle speed in km/h\n    activateStabilityControl(steeringAngle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Reverse Collision Warning system that alerts the driver when an obstacle is detected behind the vehicle.",
      "input": "Simulate vehicle's reverse speed and distance to an obstacle, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float REVERSE_COLLISION_THRESHOLD = 0.5f; // Distance threshold in meters for reverse collision warning\n\nvoid checkReverseCollision(float distanceToObstacle, float vehicleSpeed) {\n    if (distanceToObstacle < REVERSE_COLLISION_THRESHOLD && vehicleSpeed > 5.0f) {\n        std::cout << \"Warning: Obstacle detected while reversing.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"No obstacle detected.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distanceToObstacle = 0.3f; // Simulated distance to obstacle in meters\n    float vehicleSpeed = 3.0f; // Simulated reverse speed in km/h\n    checkReverseCollision(distanceToObstacle, vehicleSpeed);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Traffic Sign Recognition system that detects traffic signs and alerts the driver to speed limits.",
      "input": "Simulate detected traffic signs and speed limit values, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid recognizeTrafficSign(std::string signType) {\n    if (signType == \"Speed Limit 50\") {\n        std::cout << \"Warning: Speed limit is 50 km/h.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Traffic sign recognized: \" << signType << std::endl;\n    }\n}\n\nint main(void) {\n    std::string signType = \"Speed Limit 50\"; // Simulated detected traffic sign\n    recognizeTrafficSign(signType);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Lane Change Assist system that changes lanes when safe and needed.",
      "input": "Simulate the vehicle's lane position, speed, and proximity to other vehicles, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LANE_POSITION_THRESHOLD = 0.5f; // Lane position threshold in meters\n\nvoid assistLaneChange(float lanePosition, float vehicleSpeed, bool isLaneClear) {\n    if (lanePosition > LANE_POSITION_THRESHOLD && isLaneClear && vehicleSpeed > 20.0f) {\n        std::cout << \"Lane change safe: Initiating lane change.\" << std::endl;\n        // Logic to change lanes\n    } else {\n        std::cout << \"Not safe to change lanes.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float lanePosition = 0.6f; // Simulated lane position in meters\n    float vehicleSpeed = 30.0f; // Simulated vehicle speed in km/h\n    bool isLaneClear = true; // Simulated lane clearance status\n    assistLaneChange(lanePosition, vehicleSpeed, isLaneClear);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an Automatic Parking system that assists the vehicle in parking in a designated spot.",
      "input": "Simulate the parking space dimensions, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float PARKING_SPACE_WIDTH = 2.5f; // Simulated parking space width in meters\n\nvoid assistParking(float vehicleWidth, bool isSpaceAvailable) {\n    if (vehicleWidth < PARKING_SPACE_WIDTH && isSpaceAvailable) {\n        std::cout << \"Parking space available. Initiating parking assist.\" << std::endl;\n        // Logic to assist in parking\n    } else {\n        std::cout << \"No parking space available.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float vehicleWidth = 2.0f; // Simulated vehicle width in meters\n    bool isSpaceAvailable = true; // Simulated availability of parking space\n    assistParking(vehicleWidth, isSpaceAvailable);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Vehicle Health Monitoring system that checks vital vehicle systems like engine and brake health.",
      "input": "Simulate engine and brake status, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nvoid checkVehicleHealth(bool isEngineHealthy, bool areBrakesHealthy) {\n    if (!isEngineHealthy) {\n        std::cout << \"Warning: Engine issue detected.\" << std::endl;\n        // Logic to alert the driver\n    }\n    if (!areBrakesHealthy) {\n        std::cout << \"Warning: Brake issue detected.\" << std::endl;\n        // Logic to alert the driver\n    }\n}\n\nint main(void) {\n    bool isEngineHealthy = false; // Simulated engine health status\n    bool areBrakesHealthy = true; // Simulated brake health status\n    checkVehicleHealth(isEngineHealthy, areBrakesHealthy);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Tire Temperature Monitoring system that alerts the driver when tire temperature exceeds safe limits.",
      "input": "Simulate tire temperatures, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float MAX_TIRE_TEMP = 80.0f; // Maximum safe tire temperature in degrees Celsius\n\nvoid checkTireTemperature(float tireTemp) {\n    if (tireTemp > MAX_TIRE_TEMP) {\n        std::cout << \"Warning: Tire temperature too high.\" << std::endl;\n        // Logic to alert the driver\n    } else {\n        std::cout << \"Tire temperature normal.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float tireTemp = 85.0f; // Simulated tire temperature in degrees Celsius\n    checkTireTemperature(tireTemp);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Headlight Control system that automatically switches headlights based on ambient light levels.",
      "input": "Simulate ambient light levels, handle type conversions explicitly, and include error handling.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\nconst float LIGHT_THRESHOLD = 50.0f; // Ambient light threshold in lux\n\nvoid controlHeadlights(float ambientLight) {\n    if (ambientLight < LIGHT_THRESHOLD) {\n        std::cout << \"Low light detected. Turning headlights on.\" << std::endl;\n        // Logic to turn on headlights\n    } else {\n        std::cout << \"Sufficient ambient light. Headlights off.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float ambientLight = 40.0f; // Simulated ambient light level in lux\n    controlHeadlights(ambientLight);\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for object detection and distance calculation using OpenCV.",
      "input": "Dataset of frames for vehicle detection and distance measurement.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library\n#include <iostream> // Input-output operations\n#include <cstdlib> // For system exit codes\n#include <string> // For string operations\n\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float CAR_WIDTH_METERS = 1.8f; // Car width in meters\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision threshold\n\nstruct DetectedObject {\n    cv::Rect boundingBox; // Bounding box of the object\n    float distance;       // Distance from the camera\n    std::string label;    // Label for the object\n};\n\n// Function to calculate distance to an object based on image dimensions\nfloat calculateDistance(int objectWidth, int imageWidth) {\n    if (objectWidth == 0) {\n        return -1.0f; // Invalid object width\n    }\n    return (CAR_WIDTH_METERS * FOCAL_LENGTH_X) / static_cast<float>(objectWidth);\n}\n\n// Function to process a single frame\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(600, 400, 200, 100); // Example bounding box\n    DetectedObject detectedObject;\n    detectedObject.boundingBox = boundingBox;\n\n    detectedObject.distance = calculateDistance(boundingBox.width, frame.cols);\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string distanceText = \"Distance: \" + std::to_string(detectedObject.distance) + \" m\";\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (detectedObject.distance < COLLISION_THRESHOLD_METERS && detectedObject.distance > 0.0f) {\n        cv::putText(frame, \"COLLISION WARNING!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        processFrame(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate a C++ code that simulates a forward collision warning system using a basic camera feed.",
      "input": "Camera input for simulation.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float FOCAL_LENGTH_X = 874.0f;\nconst float CAR_WIDTH_METERS = 1.8f;\nconst float COLLISION_THRESHOLD_METERS = 8.0f;\n\nstruct DetectedObject {\n    cv::Rect boundingBox;\n    float distance;\n    std::string label;\n};\n\nfloat calculateDistance(int objectWidth, int imageWidth) {\n    if (objectWidth == 0) return -1.0f;\n    return (CAR_WIDTH_METERS * FOCAL_LENGTH_X) / static_cast<float>(objectWidth);\n}\n\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(500, 400, 150, 80);\n    DetectedObject detectedObject;\n    detectedObject.boundingBox = boundingBox;\n    detectedObject.distance = calculateDistance(boundingBox.width, frame.cols);\n\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string distanceText = \"Distance: \" + std::to_string(detectedObject.distance) + \" m\";\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (detectedObject.distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Unable to open camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) break;\n        processFrame(frame);\n        cv::imshow(\"Collision Warning System\", frame);\n        if (cv::waitKey(30) == 'q') break;\n    }\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program that detects vehicles using OpenCV and alerts when a forward collision is imminent.",
      "input": "Video frames from a camera feed with vehicle detection.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float FOCAL_LENGTH_X = 874.0f;\nconst float CAR_WIDTH_METERS = 1.8f;\nconst float COLLISION_THRESHOLD_METERS = 6.0f;\n\nstruct DetectedObject {\n    cv::Rect boundingBox;\n    float distance;\n    std::string label;\n};\n\nfloat calculateDistance(int objectWidth, int imageWidth) {\n    if (objectWidth == 0) return -1.0f;\n    return (CAR_WIDTH_METERS * FOCAL_LENGTH_X) / static_cast<float>(objectWidth);\n}\n\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(800, 350, 100, 60);\n    DetectedObject detectedObject;\n    detectedObject.boundingBox = boundingBox;\n    detectedObject.distance = calculateDistance(boundingBox.width, frame.cols);\n\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string distanceText = \"Distance: \" + std::to_string(detectedObject.distance) + \" m\";\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (detectedObject.distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IN 6 METERS\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Unable to open camera feed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) break;\n        processFrame(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(30) == 'q') break;\n    }\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create a real-time vehicle detection and collision warning system using OpenCV.",
      "input": "Real-time video feed from a camera.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float FOCAL_LENGTH_X = 874.0f;\nconst float CAR_WIDTH_METERS = 1.8f;\nconst float COLLISION_THRESHOLD_METERS = 4.0f;\n\nstruct DetectedObject {\n    cv::Rect boundingBox;\n    float distance;\n    std::string label;\n};\n\nfloat calculateDistance(int objectWidth, int imageWidth) {\n    if (objectWidth == 0) return -1.0f;\n    return (CAR_WIDTH_METERS * FOCAL_LENGTH_X) / static_cast<float>(objectWidth);\n}\n\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(400, 300, 120, 60);\n    DetectedObject detectedObject;\n    detectedObject.boundingBox = boundingBox;\n    detectedObject.distance = calculateDistance(boundingBox.width, frame.cols);\n\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string distanceText = \"Distance: \" + std::to_string(detectedObject.distance) + \" m\";\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (detectedObject.distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"COLLISION WARNING!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Unable to open video feed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) break;\n        processFrame(frame);\n        cv::imshow(\"Vehicle Collision Warning\", frame);\n        if (cv::waitKey(30) == 'q') break;\n    }\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with lane detection. The system should process video frames, detect lane lines, estimate distances to objects in the lane, and issue collision warnings when necessary. Use OpenCV for image processing. Ensure error handling, detailed commenting, and compliance with MISRA standards.",
      "input": "Dataset of video frames with lane and vehicle data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\n// Constants for camera and collision parameters\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float CAR_WIDTH_METERS = 1.8f; // Average car width in meters\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning distance threshold\n\n// Function to detect lane lines in the frame\ncv::Mat detectLaneLines(cv::Mat &frame) {\n    cv::Mat gray, edges, roi, result;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n    cv::Canny(gray, edges, 50, 150); // Edge detection\n    // Region of interest (ROI) to focus on the lane area\n    roi = edges(cv::Rect(0, frame.rows / 2, frame.cols, frame.rows / 2));\n    return roi;\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame) {\n    // Detect lane lines\n    cv::Mat lanes = detectLaneLines(frame);\n\n    // Assuming object detection is implemented elsewhere and the detected distance is obtained\n    float distance = 5.0f; // Placeholder for actual object distance calculation\n\n    // Draw lane lines on the frame\n    cv::cvtColor(lanes, frame, cv::COLOR_GRAY2BGR);\n\n    // Collision warning check\n    if (distance < COLLISION_THRESHOLD_METERS && distance > 0.0f) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with speed estimation. The system should process video frames, estimate the speed of detected objects, and issue collision warnings if the object is moving too fast. Use OpenCV for image processing. Ensure error handling, detailed commenting, and compliance with MISRA standards.",
      "input": "Dataset of video frames with vehicle data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\n// Constants for camera and collision parameters\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning distance threshold\nconst float SPEED_THRESHOLD = 20.0f; // Speed threshold in m/s for warning\n\n// Function to estimate speed from object movement\nfloat estimateSpeed(cv::Rect prevBoundingBox, cv::Rect currBoundingBox, float timeElapsed) {\n    // Placeholder: Real speed estimation logic goes here\n    float distanceMoved = static_cast<float>(currBoundingBox.x - prevBoundingBox.x);\n    return distanceMoved / timeElapsed;\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame, cv::Rect prevBoundingBox) {\n    // Simulate object detection and tracking\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Estimate speed\n    float speed = estimateSpeed(prevBoundingBox, boundingBox, 0.1f); // 0.1 sec time interval\n\n    // Draw bounding box and speed on frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string speedText = \"Speed: \" + std::to_string(speed) + \" m/s\";\n    cv::putText(frame, speedText, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (speed > SPEED_THRESHOLD) {\n        cv::putText(frame, \"WARNING: OBJECT TOO FAST!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect prevBoundingBox(0, 0, 0, 0);\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, prevBoundingBox);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that classifies objects detected in video frames as 'Car', 'Pedestrian', etc., and issues collision warnings accordingly. Use OpenCV for image processing. Ensure error handling, detailed commenting, and compliance with MISRA standards.",
      "input": "Dataset of video frames with labeled objects.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\n// Constants for camera and collision parameters\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning distance threshold\n\n// Function to classify objects\nstd::string classifyObject(cv::Rect boundingBox) {\n    // Placeholder logic for object classification\n    return \"Car\"; // Example classification\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame) {\n    // Simulate object detection with bounding box\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Classify object\n    std::string objectType = classifyObject(boundingBox);\n\n    // Draw bounding box and object label on frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, objectType, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (objectType == \"Car\" && boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates the distance and speed of detected objects. The system should issue a warning if the object is too close and moving too fast. Use OpenCV for image processing. Ensure compliance with MISRA 2023 and include error handling and detailed comments.",
      "input": "Dataset of video frames with vehicle data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <cmath> // For mathematical operations\n\n// Constants for camera and collision parameters\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision threshold distance\nconst float SPEED_THRESHOLD = 20.0f; // Speed threshold for warning (m/s)\n\n// Function to calculate distance from focal length and bounding box size\nfloat calculateDistance(cv::Rect boundingBox) {\n    return (FocalLength * CAR_WIDTH) / boundingBox.width;\n}\n\n// Function to estimate speed from object movement\nfloat estimateSpeed(cv::Rect prevBoundingBox, cv::Rect currBoundingBox, float timeElapsed) {\n    float distanceMoved = static_cast<float>(currBoundingBox.x - prevBoundingBox.x);\n    return distanceMoved / timeElapsed;\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame, cv::Rect prevBoundingBox) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box for detected object\n\n    // Calculate distance to the object\n    float distance = calculateDistance(boundingBox);\n    // Estimate speed of the object\n    float speed = estimateSpeed(prevBoundingBox, boundingBox, 0.1f); // 0.1 sec time interval\n\n    // Draw bounding box and calculated values on the frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string speedText = \"Speed: \" + std::to_string(speed) + \" m/s\";\n    std::string distanceText = \"Distance: \" + std::to_string(distance) + \" meters\";\n    cv::putText(frame, speedText, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y + 20), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (distance < COLLISION_THRESHOLD_METERS && speed > SPEED_THRESHOLD) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect prevBoundingBox(0, 0, 0, 0);\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, prevBoundingBox);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that classifies detected objects as 'Car', 'Pedestrian', etc., and issues a warning if the object is too close. Use OpenCV for image processing. Ensure compliance with MISRA 2023 and include detailed comments and error handling.",
      "input": "Dataset of video frames with labeled objects.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <string> // For string handling\n\n// Constants for camera and collision parameters\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning distance threshold\n\n// Function to classify object types (example: Car, Pedestrian)\nstd::string classifyObject(cv::Rect boundingBox) {\n    // Placeholder logic for classification\n    if (boundingBox.width > 50) {\n        return \"Car\";\n    } else {\n        return \"Pedestrian\";\n    }\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame) {\n    // Simulate object detection and tracking\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Classify the object\n    std::string objectType = classifyObject(boundingBox);\n\n    // Draw bounding box and classification label\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    cv::putText(frame, objectType, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (objectType == \"Car\" && boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects vehicles in video frames using pre-trained models and issues a collision warning if the vehicle is too close. Use OpenCV and machine learning for detection. Ensure compliance with MISRA 2023 and include detailed comments and error handling.",
      "input": "Dataset of video frames with vehicle data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <opencv2/dnn.hpp> // OpenCV DNN module for model inference\n\n// Constants for camera and collision parameters\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to detect vehicles using a pre-trained model\nbool detectVehicle(cv::Mat &frame, cv::dnn::Net &net) {\n    cv::Mat blob = cv::dnn::blobFromImage(frame, 1.0, cv::Size(416, 416), cv::Scalar(0, 0, 0), true, false);\n    net.setInput(blob);\n    cv::Mat detections = net.forward();\n    // Placeholder for actual detection logic\n    return detections.total() > 0;\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame, cv::dnn::Net &net) {\n    if (detectVehicle(frame, net)) {\n        cv::putText(frame, \"WARNING: VEHICLE DETECTED!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Load pre-trained model\n    cv::dnn::Net net = cv::dnn::readNetFromDarknet(\"yolov3.cfg\", \"yolov3.weights\");\n    if (net.empty()) {\n        std::cerr << \"Error: Unable to load the pre-trained model.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, net);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that estimates the distance to detected objects based on their size in video frames and issues a warning if the object is too close. Use OpenCV for image processing. Ensure compliance with MISRA 2023 and include error handling and detailed comments.",
      "input": "Dataset of video frames with labeled object distances.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <cmath> // For mathematical operations\n\n// Constants for camera and collision parameters\nconst float FOCAL_LENGTH_X = 874.0f; // Camera focal length in X direction\nconst float CAR_WIDTH = 1.8f; // Average width of a car in meters\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning distance threshold\n\n// Function to estimate distance to an object based on its size\nfloat estimateDistance(cv::Rect boundingBox) {\n    return (FocalLength * CAR_WIDTH) / boundingBox.width;\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame) {\n    // Simulate object detection\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Estimate distance to object\n    float distance = estimateDistance(boundingBox);\n\n    // Draw bounding box and estimated distance on the frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string distanceText = \"Distance: \" + std::to_string(distance) + \" meters\";\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that issues real-time audible and visual alerts when a collision is imminent. Use OpenCV for object detection and sound alerts. Ensure compliance with MISRA 2023 and include error handling and detailed comments.",
      "input": "Dataset of video frames with collision data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <thread> // For threading\n#include <atomic> // For atomic operations\n\n// Constants for collision threshold\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to play audible alert\nvoid playAlert() {\n    // Simulating an audible alert (can be linked to actual sound functionality)\n    std::cout << \"ALERT: COLLISION IMMINENT!\" << std::endl;\n}\n\n// Function to process a single video frame\nvoid processFrame(cv::Mat &frame) {\n    // Simulate object detection\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Collision warning check\n    if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        // Trigger visual alert\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        // Trigger audible alert in a separate thread\n        std::thread(alertThread, playAlert).detach();\n    }\n}\n\nint main(void) {\n    // Open video capture device\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates distance based on object size in video frames and issues a warning if the object is too close. Use OpenCV for image processing and include error handling and detailed comments.",
      "input": "Dataset of video frames with object data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <cmath> // For mathematical operations\n\n// Constants\nconst float CAR_WIDTH = 1.8f; // Average width of a car in meters\nconst float FOCAL_LENGTH = 874.0f; // Camera focal length\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning distance\n\n// Function to calculate distance based on object size\nfloat calculateDistance(cv::Rect boundingBox) {\n    return (FOCAL_LENGTH * CAR_WIDTH) / boundingBox.width;\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame) {\n    // Simulating detection of a vehicle\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Calculate distance to the object\n    float distance = calculateDistance(boundingBox);\n\n    // Display bounding box and distance on the frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string distanceText = \"Distance: \" + std::to_string(distance) + \" meters\";\n    cv::putText(frame, distanceText, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects moving objects and triggers a warning if they are too close. Use OpenCV and object tracking for detecting motion. Ensure MISRA compliance and include error handling.",
      "input": "Dataset of video frames with moving vehicles.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to detect moving objects\nbool isMoving(cv::Rect prevBoundingBox, cv::Rect currBoundingBox) {\n    return abs(currBoundingBox.x - prevBoundingBox.x) > 5; // Example threshold for movement\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame, cv::Rect prevBoundingBox) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Check if the object is moving\n    if (isMoving(prevBoundingBox, boundingBox)) {\n        cv::putText(frame, \"MOVING OBJECT DETECTED!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 255), 2);\n    }\n\n    // Draw bounding box\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    prevBoundingBox = boundingBox; // Update previous bounding box for next frame\n\n    // Collision warning check\n    if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 100), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect prevBoundingBox(0, 0, 0, 0); // Initialize previous bounding box\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, prevBoundingBox);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates the speed of moving vehicles and issues a warning if the speed is too high. Use OpenCV for video processing. Ensure compliance with MISRA 2023 and include error handling.",
      "input": "Dataset of video frames with moving vehicle data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <cmath> // For mathematical operations\n\n// Constants\nconst float SPEED_THRESHOLD = 20.0f; // Speed threshold for warning (m/s)\n\n// Function to calculate speed of a moving object\nfloat calculateSpeed(cv::Rect prevBoundingBox, cv::Rect currBoundingBox, float timeElapsed) {\n    float distanceMoved = static_cast<float>(currBoundingBox.x - prevBoundingBox.x);\n    return distanceMoved / timeElapsed; // Speed in pixels per second\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame, cv::Rect prevBoundingBox) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Estimate the speed of the object\n    float speed = calculateSpeed(prevBoundingBox, boundingBox, 0.1f); // 0.1 second time interval\n\n    // Draw bounding box and speed on the frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string speedText = \"Speed: \" + std::to_string(speed) + \" m/s\";\n    cv::putText(frame, speedText, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (speed > SPEED_THRESHOLD) {\n        cv::putText(frame, \"WARNING: TOO FAST!\", cv::Point(50, 100), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect prevBoundingBox(0, 0, 0, 0); // Initialize previous bounding box\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, prevBoundingBox);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that tracks an object across multiple frames and triggers a collision warning if the object gets too close. Use OpenCV for object tracking. Ensure compliance with MISRA 2023 and include detailed comments.",
      "input": "Dataset of video frames with moving object data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to track object across frames\nvoid trackObject(cv::Mat &frame, cv::Rect &boundingBox) {\n    // Simulate object tracking\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame, cv::Rect &prevBoundingBox) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Track the object\n    trackObject(frame, boundingBox);\n\n    // Collision warning check\n    if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 100), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect prevBoundingBox(0, 0, 0, 0); // Initialize previous bounding box\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, prevBoundingBox);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates an alert system to notify the driver when a collision is imminent. The alert should include both visual and audible notifications. Use OpenCV and ensure MISRA compliance.",
      "input": "Dataset of video frames with vehicle positions.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n#include <thread> // For multi-threading\n#include <atomic> // For atomic operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to play an alert\nvoid playAlert() {\n    std::cout << \"ALERT: COLLISION IMMINENT!\" << std::endl;\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Collision warning check\n    if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        // Trigger visual alert\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        // Trigger audible alert in a separate thread\n        std::thread(alertThread, playAlert).detach();\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses object recognition and speed estimation to detect imminent collisions. The system should calculate the object's speed based on frame-to-frame position changes and issue a warning if necessary.",
      "input": "Dataset of video frames with moving vehicle data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\nconst float SPEED_THRESHOLD = 20.0f; // Speed threshold for warning (m/s)\n\n// Function to calculate the speed of an object\nfloat calculateSpeed(cv::Rect prevBoundingBox, cv::Rect currBoundingBox, float timeElapsed) {\n    float distanceMoved = static_cast<float>(currBoundingBox.x - prevBoundingBox.x);\n    return distanceMoved / timeElapsed; // Speed in pixels per second\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame, cv::Rect prevBoundingBox) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Estimate the speed of the object\n    float speed = calculateSpeed(prevBoundingBox, boundingBox, 0.1f); // 0.1 second time interval\n\n    // Draw bounding box and speed on the frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n    std::string speedText = \"Speed: \" + std::to_string(speed) + \" m/s\";\n    cv::putText(frame, speedText, cv::Point(boundingBox.x, boundingBox.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Collision warning check\n    if (speed > SPEED_THRESHOLD) {\n        cv::putText(frame, \"WARNING: TOO FAST!\", cv::Point(50, 100), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    cv::Rect prevBoundingBox(0, 0, 0, 0); // Initialize previous bounding box\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, prevBoundingBox);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates radar data to track object distance and speed. The system should issue a warning if the distance is less than a safety threshold and the speed exceeds a limit.",
      "input": "Radar dataset with object distance and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\nconst float SPEED_THRESHOLD = 20.0f; // Speed threshold for warning (m/s)\n\n// Function to process radar data and issue collision warning\nvoid processRadarData(float distance, float speed) {\n    // Collision warning check\n    if (distance < COLLISION_THRESHOLD_METERS && speed > SPEED_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT! Distance: \" << distance << \" Speed: \" << speed << \"\n\";\n    }\n    else {\n        std::cout << \"Safe Distance: \" << distance << \" Speed: \" << speed << \"\n\";\n    }\n}\n\nint main(void) {\n    float radarDistance = 8.0f; // Example radar distance in meters\n    float radarSpeed = 25.0f; // Example radar speed in m/s\n\n    // Process radar data\n    processRadarData(radarDistance, radarSpeed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with an adaptive threshold. The system adjusts the threshold for collision warning based on the speed of the detected vehicle, triggering a warning when the distance becomes too small at high speeds.",
      "input": "Video frames with moving vehicles and speed data.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD_METERS = 10.0f; // Base collision threshold\nconst float SPEED_ADJUSTMENT_FACTOR = 0.5f; // Speed adjustment factor for threshold\n\n// Function to adjust the collision threshold based on speed\nfloat adjustThreshold(float speed) {\n    return BASE_COLLISION_THRESHOLD_METERS - (SPEED_ADJUSTMENT_FACTOR * speed);\n}\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame, float speed) {\n    float adjustedThreshold = adjustThreshold(speed); // Adjusted threshold\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Collision warning check\n    if (boundingBox.width < adjustedThreshold) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n    else {\n        std::cout << \"Safe distance: \" << adjustedThreshold << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    float speed = 25.0f; // Example speed in m/s\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame, speed);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects multiple vehicles in the frame and issues a warning if any of them come too close. Use OpenCV for detecting and tracking multiple objects.",
      "input": "Dataset of video frames with multiple moving vehicles.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to process multiple objects\nvoid processObjects(cv::Mat &frame) {\n    std::vector<cv::Rect> boundingBoxes = {\n        cv::Rect(100, 100, 50, 50),\n        cv::Rect(200, 200, 60, 60),\n        cv::Rect(300, 300, 70, 70)\n    }; // Example bounding boxes for 3 objects\n\n    for (const auto& box : boundingBoxes) {\n        // Draw bounding box on frame\n        cv::rectangle(frame, box, cv::Scalar(0, 255, 0), 2);\n\n        // Collision warning check\n        if (box.width < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                        cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processObjects(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that provides visual feedback to the driver in the form of a graphical interface. The system should display a graphical warning when the distance is too close.",
      "input": "Video frames with vehicle data and graphical display support.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to display graphical feedback\nvoid displayFeedback(cv::Mat &frame) {\n    cv::putText(frame, \"Collision Warning: TOO CLOSE!\", cv::Point(50, 50), \n                cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n}\n\n// Function to process the frame and trigger warning\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n\n    // Collision warning check\n    if (boundingBox.width < COLLISION_THRESHOLD_METERS) {\n        displayFeedback(frame); // Show visual feedback\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the speed threshold dynamically based on the detected vehicle's distance from the sensor.",
      "input": "Radar data with distance and relative speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD_METERS = 10.0f; // Base collision threshold\n\n// Function to calculate dynamic threshold\nfloat dynamicThreshold(float distance) {\n    if (distance < 5.0f) {\n        return 5.0f; // Lower threshold when close\n    } else if (distance < 10.0f) {\n        return 8.0f; // Medium threshold\n    }\n    return BASE_COLLISION_THRESHOLD_METERS; // Default threshold\n}\n\n// Function to process radar data and issue collision warning\nvoid processRadarData(float distance, float speed) {\n    float adjustedThreshold = dynamicThreshold(distance); // Adjusted threshold based on distance\n    if (distance < adjustedThreshold && speed > 20.0f) { // Speed threshold for warning\n        std::cout << \"WARNING: COLLISION IMMINENT! Distance: \" << distance << \" Speed: \" << speed << \"\n\";\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \"\n\";\n    }\n}\n\nint main(void) {\n    float radarDistance = 6.0f; // Example radar distance in meters\n    float radarSpeed = 22.0f; // Example radar speed in m/s\n\n    // Process radar data\n    processRadarData(radarDistance, radarSpeed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects objects using machine learning, estimates their distance, and triggers a warning based on a pre-defined threshold.",
      "input": "Object detection and distance estimation data from a camera.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to detect and estimate the distance of an object\nvoid detectObject(cv::Mat &frame) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n    float estimatedDistance = 8.0f; // Example estimated distance in meters\n\n    // Draw bounding box on frame\n    cv::rectangle(frame, boundingBox, cv::Scalar(0, 255, 0), 2);\n\n    // Collision warning check\n    if (estimatedDistance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        detectObject(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates GPS data for vehicle location and triggers a warning when the vehicle is approaching a hazard at high speed.",
      "input": "GPS data for vehicle location and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\nconst float SPEED_THRESHOLD_METERS_PER_SECOND = 20.0f; // Speed threshold for warning\n\n// Function to process GPS data\nvoid processGPSData(float latitude, float longitude, float speed) {\n    // Simulate hazard location (latitude, longitude)\n    float hazardLatitude = 37.7749f; // Example hazard latitude\n    float hazardLongitude = -122.4194f; // Example hazard longitude\n\n    // Check if the vehicle is approaching the hazard\n    if (speed > SPEED_THRESHOLD_METERS_PER_SECOND) {\n        std::cout << \"WARNING: High Speed near Hazard Location!\" << std::endl;\n    }\n    if (latitude == hazardLatitude && longitude == hazardLongitude) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main(void) {\n    float latitude = 37.7749f; // Example latitude\n    float longitude = -122.4194f; // Example longitude\n    float speed = 25.0f; // Example speed in meters per second\n\n    // Process GPS data\n    processGPSData(latitude, longitude, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that analyzes video frames and triggers a warning when objects come within a predefined safety distance.",
      "input": "Dataset of video frames with moving objects.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to process each frame\nvoid processFrame(cv::Mat &frame) {\n    cv::Rect boundingBox(500, 400, 100, 50); // Example bounding box\n    float objectDistance = 8.0f; // Example object distance in meters\n\n    // Collision warning check\n    if (objectDistance < COLLISION_THRESHOLD_METERS) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the captured frame\n        processFrame(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that tracks multiple objects in a video stream and triggers a warning if any of the objects approach the vehicle.",
      "input": "Video frames with multiple moving objects.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image and video processing\n#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to track multiple objects\nvoid trackObjects(cv::Mat &frame) {\n    std::vector<cv::Rect> boundingBoxes = {\n        cv::Rect(300, 200, 50, 50),\n        cv::Rect(400, 250, 60, 60),\n        cv::Rect(500, 300, 70, 70)\n    }; // Example bounding boxes for 3 objects\n\n    for (const auto& box : boundingBoxes) {\n        // Draw bounding box on frame\n        cv::rectangle(frame, box, cv::Scalar(0, 255, 0), 2);\n\n        // Collision warning check\n        if (box.width < COLLISION_THRESHOLD_METERS) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50), \n                        cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main(void) {\n    // Open video capture\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Unable to open video source.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        // Track objects in the captured frame\n        trackObjects(frame);\n\n        // Display the frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit loop on 'q' key press\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with proximity sensors that warns the driver when an object is detected within a critical proximity.",
      "input": "Radar and proximity sensor data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float CRITICAL_PROXIMITY_METERS = 5.0f; // Critical proximity threshold for warning\nconst float WARNING_SPEED_THRESHOLD_METERS_PER_SECOND = 10.0f; // Speed threshold for warning\n\n// Function to check proximity and issue warning\nvoid checkProximity(float distance, float speed) {\n    if (distance < CRITICAL_PROXIMITY_METERS && speed > WARNING_SPEED_THRESHOLD_METERS_PER_SECOND) {\n        std::cout << \"WARNING: Proximity Danger! Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float proximityDistance = 4.0f; // Example proximity distance in meters\n    float vehicleSpeed = 12.0f; // Example vehicle speed in meters per second\n\n    // Check proximity and speed\n    checkProximity(proximityDistance, vehicleSpeed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that combines data from multiple sensors (radar and LIDAR) to make a collision risk prediction.",
      "input": "Radar and LIDAR data for vehicle distance and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 8.0f; // Collision threshold\n\n// Function to combine radar and LIDAR data\nvoid fuseSensorData(float radarDistance, float lidarDistance, float speed) {\n    float fusedDistance = (radarDistance + lidarDistance) / 2.0f; // Simple fusion: average of radar and LIDAR\n\n    // Collision warning check\n    if (fusedDistance < COLLISION_THRESHOLD_METERS && speed > 15.0f) {\n        std::cout << \"WARNING: Collision Risk Detected! Distance: \" << fusedDistance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << fusedDistance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float radarDistance = 7.0f; // Radar distance in meters\n    float lidarDistance = 6.5f; // LIDAR distance in meters\n    float speed = 18.0f; // Vehicle speed in meters per second\n\n    // Fuse sensor data and process the result\n    fuseSensorData(radarDistance, lidarDistance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that detects vehicle deceleration and issues a warning when a rapid deceleration is detected while approaching an obstacle.",
      "input": "Vehicle speed and acceleration data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float DECELERATION_THRESHOLD_METERS_PER_SECOND_SQUARED = -5.0f; // Deceleration threshold\nconst float COLLISION_DISTANCE_METERS = 10.0f; // Collision warning threshold\n\n// Function to check for deceleration and collision risk\nvoid checkDeceleration(float speed, float acceleration, float distance) {\n    if (acceleration < DECELERATION_THRESHOLD_METERS_PER_SECOND_SQUARED && distance < COLLISION_DISTANCE_METERS) {\n        std::cout << \"WARNING: High Deceleration and Collision Risk Detected! Speed: \" << speed << \" m/s, Acceleration: \" << acceleration << \" m/s^2\" << std::endl;\n    } else {\n        std::cout << \"Safe: Speed: \" << speed << \" m/s, Acceleration: \" << acceleration << \" m/s^2\" << std::endl;\n    }\n}\n\nint main(void) {\n    float speed = 20.0f; // Vehicle speed in meters per second\n    float acceleration = -6.0f; // Vehicle deceleration in meters per second squared\n    float distance = 5.0f; // Distance to obstacle in meters\n\n    // Check deceleration and collision risk\n    checkDeceleration(speed, acceleration, distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates lane detection data to trigger a warning if the vehicle is drifting toward an obstacle while out of lane.",
      "input": "Lane detection and obstacle distance data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float LANE_THRESHOLD_METERS = 4.0f; // Lane boundary threshold\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision threshold\n\n// Function to check for lane deviation and collision risk\nvoid checkLaneDeviation(float laneDistance, float obstacleDistance) {\n    if (laneDistance < LANE_THRESHOLD_METERS && obstacleDistance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Lane Deviation and Collision Risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Lane Distance: \" << laneDistance << \" Obstacle Distance: \" << obstacleDistance << std::endl;\n    }\n}\n\nint main(void) {\n    float laneDistance = 3.5f; // Distance from lane center in meters\n    float obstacleDistance = 4.5f; // Distance to obstacle in meters\n\n    // Check lane deviation and collision risk\n    checkLaneDeviation(laneDistance, obstacleDistance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the warning threshold dynamically based on the vehicle's speed.",
      "input": "Vehicle speed data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD_METERS = 10.0f; // Default collision threshold\n\n// Function to dynamically adjust the collision threshold based on speed\nfloat adjustThresholdBasedOnSpeed(float speed) {\n    if (speed > 30.0f) {\n        return 5.0f; // Smaller threshold for higher speed\n    } else if (speed > 15.0f) {\n        return 7.0f; // Medium threshold for moderate speed\n    }\n    return BASE_COLLISION_THRESHOLD_METERS; // Default threshold for lower speeds\n}\n\n// Function to process vehicle speed and distance for FCW\nvoid processSpeedAndDistance(float speed, float distance) {\n    float threshold = adjustThresholdBasedOnSpeed(speed); // Adjusted threshold\n    if (distance < threshold) {\n        std::cout << \"WARNING: COLLISION RISK! Speed: \" << speed << \" m/s, Distance: \" << distance << \" m\" << std::endl;\n    } else {\n        std::cout << \"Safe: Speed: \" << speed << \" m/s, Distance: \" << distance << \" m\" << std::endl;\n    }\n}\n\nint main(void) {\n    float speed = 25.0f; // Vehicle speed in meters per second\n    float distance = 6.0f; // Distance to obstacle in meters\n\n    // Process speed and distance data\n    processSpeedAndDistance(speed, distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that dynamically generates different warning messages based on the vehicle's speed and proximity to the obstacle.",
      "input": "Vehicle speed and distance data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision warning threshold\n\n// Function to generate dynamic warning messages\nvoid generateWarningMessage(float speed, float distance) {\n    if (speed > 25.0f && distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: High Speed and Collision Risk!\" << std::endl;\n    } else if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float speed = 28.0f; // Vehicle speed in meters per second\n    float distance = 8.0f; // Distance to obstacle in meters\n\n    // Generate warning message\n    generateWarningMessage(speed, distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that preprocesses sensor data (radar, LIDAR) before triggering the warning.",
      "input": "Raw sensor data for distance and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision threshold\n\n// Function to preprocess sensor data\nvoid preprocessSensorData(float &distance, float &speed) {\n    // Example data correction logic\n    if (distance < 0.0f) {\n        distance = 0.0f; // Correct negative distance value\n    }\n    if (speed < 0.0f) {\n        speed = 0.0f; // Correct negative speed value\n    }\n}\n\n// Function to trigger collision warning based on preprocessed data\nvoid processSensorData(float distance, float speed) {\n    preprocessSensorData(distance, speed); // Preprocess data\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 8.0f; // Sensor distance in meters\n    float speed = 20.0f; // Vehicle speed in meters per second\n\n    // Process sensor data\n    processSensorData(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that estimates the collision time based on the vehicle's speed and distance to the obstacle.",
      "input": "Vehicle speed and obstacle distance data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 10.0f; // Collision threshold\n\n// Function to estimate collision time\nfloat estimateCollisionTime(float speed, float distance) {\n    return distance / speed; // Time = Distance / Speed\n}\n\n// Function to process collision data and trigger warning\nvoid processCollisionData(float distance, float speed) {\n    float collisionTime = estimateCollisionTime(speed, distance); // Estimate collision time\n\n    if (collisionTime < 2.0f) {\n        std::cout << \"WARNING: Collision Risk Detected! Time to Collision: \" << collisionTime << \" seconds\" << std::endl;\n    } else {\n        std::cout << \"Safe: Time to Collision: \" << collisionTime << \" seconds\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 8.0f; // Distance to obstacle in meters\n    float speed = 15.0f; // Vehicle speed in meters per second\n\n    // Process collision data\n    processCollisionData(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that processes real-time sensor data for distance and speed to trigger warnings.",
      "input": "Real-time sensor data for vehicle speed and distance.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision threshold\nconst float SAFE_DISTANCE_METERS = 20.0f; // Safe distance for non-warning\n\n// Function to process real-time data\nvoid processRealTimeData(float distance, float speed) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk Detected! Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    } else if (distance > SAFE_DISTANCE_METERS) {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"Caution: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Real-time sensor distance in meters\n    float speed = 18.0f; // Real-time sensor speed in meters per second\n\n    // Process the real-time sensor data\n    processRealTimeData(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates accelerometer data to detect rapid deceleration and warn of potential collisions.",
      "input": "Accelerometer data for vehicle deceleration.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float DECELERATION_THRESHOLD_METERS_PER_SECOND_SQUARED = -4.0f; // Deceleration threshold\nconst float COLLISION_THRESHOLD_METERS = 6.0f; // Collision distance threshold\n\n// Function to check for rapid deceleration\nvoid checkDeceleration(float acceleration, float distance) {\n    if (acceleration < DECELERATION_THRESHOLD_METERS_PER_SECOND_SQUARED && distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Rapid Deceleration Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Acceleration: \" << acceleration << \" m/s^2, Distance: \" << distance << \" m\" << std::endl;\n    }\n}\n\nint main(void) {\n    float acceleration = -5.0f; // Vehicle deceleration in meters per second squared\n    float distance = 4.0f; // Distance to obstacle in meters\n\n    // Check for rapid deceleration and collision risk\n    checkDeceleration(acceleration, distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with dynamic threshold adjustment based on the vehicle's current speed.",
      "input": "Vehicle speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float BASE_THRESHOLD_METERS = 10.0f; // Base collision threshold\n\n// Function to dynamically adjust the collision threshold\nfloat dynamicThresholdAdjustment(float speed) {\n    if (speed > 30.0f) {\n        return 6.0f; // Reduce threshold for higher speed\n    }\n    return BASE_THRESHOLD_METERS; // Default threshold\n}\n\n// Function to check collision risk with dynamic threshold\nvoid checkCollisionRisk(float distance, float speed) {\n    float threshold = dynamicThresholdAdjustment(speed); // Adjust threshold based on speed\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 5.0f; // Distance to obstacle in meters\n    float speed = 35.0f; // Vehicle speed in meters per second\n\n    // Check for collision risk with dynamic threshold\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that processes data from multiple sensors (e.g., radar, camera) to detect potential collisions.",
      "input": "Radar and camera data for obstacle distance and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 8.0f; // Collision detection threshold\n\n// Function to process multiple sensor data\nvoid processMultiSensorData(float radarDistance, float cameraDistance, float speed) {\n    float averageDistance = (radarDistance + cameraDistance) / 2.0f; // Average distance from radar and camera\n    if (averageDistance < COLLISION_THRESHOLD_METERS && speed > 10.0f) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Average Distance: \" << averageDistance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float radarDistance = 7.0f; // Radar distance in meters\n    float cameraDistance = 6.5f; // Camera distance in meters\n    float speed = 15.0f; // Vehicle speed in meters per second\n\n    // Process sensor data\n    processMultiSensorData(radarDistance, cameraDistance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with an adaptive warning system based on vehicle speed and proximity to an obstacle.",
      "input": "Vehicle speed, distance, and proximity sensor data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance\nconst float WARNING_SPEED_THRESHOLD_METERS_PER_SECOND = 20.0f; // Speed threshold for warning\n\n// Function to adjust warning behavior\nvoid adaptiveWarning(float speed, float distance) {\n    if (distance < SAFE_DISTANCE_METERS && speed > WARNING_SPEED_THRESHOLD_METERS_PER_SECOND) {\n        std::cout << \"WARNING: Collision Risk! Speed: \" << speed << \" m/s, Distance: \" << distance << \" m\" << std::endl;\n    } else if (distance < SAFE_DISTANCE_METERS) {\n        std::cout << \"Caution: Close to obstacle, Speed: \" << speed << \" m/s, Distance: \" << distance << \" m\" << std::endl;\n    } else {\n        std::cout << \"Safe: Speed: \" << speed << \" m/s, Distance: \" << distance << \" m\" << std::endl;\n    }\n}\n\nint main(void) {\n    float speed = 25.0f; // Vehicle speed in meters per second\n    float distance = 7.0f; // Distance to obstacle in meters\n\n    // Adjust the warning based on speed and distance\n    adaptiveWarning(speed, distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that provides adjustable warning messages depending on the proximity and speed.",
      "input": "Vehicle speed and proximity to obstacles.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float WARNING_THRESHOLD_METERS = 8.0f; // Warning threshold\n\n// Function to display adjustable warning messages\nvoid displayWarning(float distance, float speed) {\n    if (distance < WARNING_THRESHOLD_METERS && speed > 15.0f) {\n        std::cout << \"WARNING: High Speed and Close Proximity!\" << std::endl;\n    } else if (distance < WARNING_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Close to Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 5.0f; // Distance to obstacle in meters\n    float speed = 18.0f; // Vehicle speed in meters per second\n\n    // Display warning based on distance and speed\n    displayWarning(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the warning threshold based on the vehicle's speed.",
      "input": "Vehicle speed and obstacle distance data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Function to calculate the dynamic warning threshold based on speed\nfloat dynamicWarningThreshold(float speed) {\n    if (speed > 25.0f) {\n        return 6.0f; // Reduce threshold for high-speed vehicles\n    }\n    return 10.0f; // Default threshold\n}\n\n// Function to check collision risk with dynamic threshold\nvoid checkCollisionRisk(float distance, float speed) {\n    float threshold = dynamicWarningThreshold(speed); // Dynamic threshold adjustment\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 8.0f; // Distance to obstacle in meters\n    float speed = 30.0f; // Vehicle speed in meters per second\n\n    // Check for collision risk with dynamic warning threshold\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that considers dynamic speed adjustments when calculating collision risk.",
      "input": "Vehicle speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance in meters\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision detection threshold\n\n// Function to dynamically adjust speed-based distance thresholds\nfloat dynamicSpeedThreshold(float speed) {\n    return speed > 20.0f ? COLLISION_THRESHOLD_METERS : SAFE_DISTANCE_METERS;\n}\n\n// Function to check collision risk with dynamic speed-based threshold\nvoid checkCollisionRisk(float distance, float speed) {\n    float threshold = dynamicSpeedThreshold(speed); // Adjust threshold based on speed\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.5f; // Distance to obstacle in meters\n    float speed = 25.0f; // Vehicle speed in meters per second\n\n    // Check for collision risk with dynamic speed threshold\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that triggers a proximity alert when the distance to an obstacle is too short.",
      "input": "Proximity sensor data (distance to obstacle).",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float PROXIMITY_ALERT_THRESHOLD_METERS = 3.0f; // Proximity alert threshold in meters\n\n// Function to check for proximity alert\nvoid checkProximityAlert(float distance) {\n    if (distance < PROXIMITY_ALERT_THRESHOLD_METERS) {\n        std::cout << \"ALERT: Too Close to Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance to Obstacle: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Distance to obstacle in meters\n\n    // Check proximity alert\n    checkProximityAlert(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that provides enhanced warnings based on the distance and speed of the vehicle.",
      "input": "Vehicle speed and distance to obstacle.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision detection threshold\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance\n\n// Function to check and display enhanced warning messages\nvoid displayEnhancedWarning(float distance, float speed) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"CRITICAL WARNING: Collision Risk! Speed: \" << speed << \" m/s, Distance: \" << distance << \" meters\" << std::endl;\n    } else if (distance < SAFE_DISTANCE_METERS) {\n        std::cout << \"WARNING: Approaching Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n    float speed = 18.0f; // Vehicle speed in meters per second\n\n    // Display enhanced warning\n    displayEnhancedWarning(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the collision warning threshold based on the vehicle's weight.",
      "input": "Vehicle weight, speed, and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float LIGHT_VEHICLE_WEIGHT_KG = 1500.0f; // Light vehicle weight in kg\nconst float HEAVY_VEHICLE_WEIGHT_KG = 3000.0f; // Heavy vehicle weight in kg\nconst float BASE_COLLISION_THRESHOLD_METERS = 6.0f; // Default collision threshold\n\n// Function to calculate adaptive threshold based on vehicle weight\nfloat adaptiveThreshold(float weight) {\n    return (weight > HEAVY_VEHICLE_WEIGHT_KG) ? BASE_COLLISION_THRESHOLD_METERS * 1.5f : BASE_COLLISION_THRESHOLD_METERS;\n}\n\n// Function to check collision risk with adaptive threshold\nvoid checkCollisionRisk(float distance, float speed, float weight) {\n    float threshold = adaptiveThreshold(weight); // Adjust threshold based on weight\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float speed = 20.0f; // Vehicle speed in meters per second\n    float weight = 2500.0f; // Vehicle weight in kilograms (heavy vehicle)\n\n    // Check for collision risk with adaptive threshold\n    checkCollisionRisk(distance, speed, weight);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses sensor fusion to integrate data from radar and LiDAR for collision risk detection.",
      "input": "Radar and LiDAR data for distance and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision threshold\n\n// Function to fuse radar and LiDAR sensor data\nfloat fuseSensorData(float radarDistance, float lidarDistance) {\n    return (radarDistance + lidarDistance) / 2.0f; // Average the sensor data\n}\n\n// Function to check collision risk based on fused sensor data\nvoid checkCollisionRisk(float radarDistance, float lidarDistance, float speed) {\n    float fusedDistance = fuseSensorData(radarDistance, lidarDistance); // Fuse sensor data\n    if (fusedDistance < COLLISION_THRESHOLD_METERS && speed > 10.0f) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Fused Distance: \" << fusedDistance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float radarDistance = 4.0f; // Radar distance in meters\n    float lidarDistance = 4.5f; // LiDAR distance in meters\n    float speed = 15.0f; // Vehicle speed in meters per second\n\n    // Check for collision risk based on fused sensor data\n    checkCollisionRisk(radarDistance, lidarDistance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses sensor fusion to integrate data from radar and LiDAR for collision risk detection.",
      "input": "Radar and LiDAR data for distance and speed.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision threshold\n\n// Function to fuse radar and LiDAR sensor data\nfloat fuseSensorData(float radarDistance, float lidarDistance) {\n    return (radarDistance + lidarDistance) / 2.0f; // Average the sensor data\n}\n\n// Function to check collision risk based on fused sensor data\nvoid checkCollisionRisk(float radarDistance, float lidarDistance, float speed) {\n    float fusedDistance = fuseSensorData(radarDistance, lidarDistance); // Fuse sensor data\n    if (fusedDistance < COLLISION_THRESHOLD_METERS && speed > 10.0f) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Fused Distance: \" << fusedDistance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float radarDistance = 4.0f; // Radar distance in meters\n    float lidarDistance = 4.5f; // LiDAR distance in meters\n    float speed = 15.0f; // Vehicle speed in meters per second\n\n    // Check for collision risk based on fused sensor data\n    checkCollisionRisk(radarDistance, lidarDistance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that dynamically adjusts the warning level based on both vehicle speed and proximity.",
      "input": "Speed and proximity data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance threshold\nconst float HIGH_SPEED_THRESHOLD_METERS = 5.0f; // Speed threshold for high-speed warnings\n\n// Function to dynamically adjust the warning level\nvoid adjustWarningLevel(float distance, float speed) {\n    if (distance < HIGH_SPEED_THRESHOLD_METERS && speed > 20.0f) {\n        std::cout << \"CRITICAL WARNING: High Speed and Close Proximity!\" << std::endl;\n    } else if (distance < SAFE_DISTANCE_METERS) {\n        std::cout << \"WARNING: Close to Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float speed = 25.0f; // Vehicle speed in meters per second\n\n    // Adjust the warning level based on distance and speed\n    adjustWarningLevel(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that triggers an emergency brake if a collision is imminent.",
      "input": "Speed and distance data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float EMERGENCY_BRAKE_THRESHOLD_METERS = 3.0f; // Threshold for emergency brake\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance threshold\n\n// Function to trigger emergency brake\nvoid triggerEmergencyBrake(float distance) {\n    if (distance < EMERGENCY_BRAKE_THRESHOLD_METERS) {\n        std::cout << \"EMERGENCY BRAKE: Collision Imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.5f; // Distance to obstacle in meters\n\n    // Trigger emergency brake if necessary\n    triggerEmergencyBrake(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts warning activation based on the vehicle's speed.",
      "input": "Speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float WARNING_THRESHOLD_METERS = 5.0f; // Threshold for warning activation\n\n// Function to check collision risk with speed-based activation\nvoid checkCollisionRisk(float distance, float speed) {\n    if (speed > 15.0f && distance < WARNING_THRESHOLD_METERS) {\n        std::cout << \"WARNING: High Speed, Close Proximity!\" << std::endl;\n    } else if (distance < WARNING_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Close to Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float speed = 20.0f; // Vehicle speed in meters per second\n\n    // Check for collision risk\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with a proximity detection system.",
      "input": "Proximity sensor data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float PROXIMITY_WARNING_THRESHOLD_METERS = 4.0f; // Proximity detection threshold\n\n// Function to check for proximity warning\nvoid checkProximityWarning(float distance) {\n    if (distance < PROXIMITY_WARNING_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Too Close to Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.5f; // Distance to obstacle in meters\n\n    // Check proximity warning\n    checkProximityWarning(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the collision warning threshold based on vehicle speed.",
      "input": "Speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance threshold\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float SPEED_THRESHOLD_METERS = 15.0f; // Speed threshold for adjusting collision warning\n\n// Function to adjust the collision threshold based on vehicle speed\nfloat adjustThresholdBySpeed(float speed) {\n    if (speed > SPEED_THRESHOLD_METERS) {\n        return COLLISION_THRESHOLD_METERS / 1.5f; // Adjust for higher speeds\n    } else {\n        return COLLISION_THRESHOLD_METERS; // Default threshold\n    }\n}\n\n// Function to check collision risk based on distance and speed\nvoid checkCollisionRisk(float distance, float speed) {\n    float threshold = adjustThresholdBySpeed(speed); // Adjust threshold based on speed\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk Detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.5f; // Distance to obstacle in meters\n    float speed = 20.0f; // Vehicle speed in meters per second\n\n    // Check collision risk based on adjusted threshold\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that includes pedestrian detection.",
      "input": "Distance to pedestrian data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 3.0f; // Collision warning threshold for pedestrian detection\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance threshold for pedestrians\n\n// Function to detect pedestrian and check collision risk\nvoid detectPedestrian(float distance) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Pedestrian Detected! Immediate Action Required!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance to Pedestrian: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 2.0f; // Distance to pedestrian in meters\n\n    // Detect pedestrian and check collision risk\n    detectPedestrian(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with lane change detection.",
      "input": "Distance to obstacle and lane change status data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision detection threshold\n\n// Function to check for collision risk based on lane change\nvoid checkLaneChangeCollisionRisk(float distance, bool isChangingLane) {\n    if (isChangingLane && distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk During Lane Change!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.5f; // Distance to obstacle in meters\n    bool isChangingLane = true; // Lane change status\n\n    // Check lane change collision risk\n    checkLaneChangeCollisionRisk(distance, isChangingLane);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the collision warning threshold based on obstacle size.",
      "input": "Distance to obstacle and size of obstacle data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD_METERS = 5.0f; // Base threshold for collision warning\n\n// Function to adjust the collision threshold based on obstacle size\nfloat adjustThresholdByObstacleSize(float obstacleSize) {\n    if (obstacleSize > 3.0f) { // Large obstacle\n        return BASE_COLLISION_THRESHOLD_METERS / 2.0f; // Reduce threshold\n    } else {\n        return BASE_COLLISION_THRESHOLD_METERS; // Default threshold\n    }\n}\n\n// Function to check collision risk based on distance and obstacle size\nvoid checkCollisionRisk(float distance, float obstacleSize) {\n    float threshold = adjustThresholdByObstacleSize(obstacleSize); // Adjust threshold based on obstacle size\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk with Large Obstacle!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float obstacleSize = 4.0f; // Size of the obstacle in meters\n\n    // Check collision risk based on adjusted threshold\n    checkCollisionRisk(distance, obstacleSize);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that provides real-time distance measurement and warning.",
      "input": "Real-time sensor data for obstacle distance.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision warning threshold\n\n// Function to check collision risk based on real-time distance\nvoid checkRealTimeCollisionRisk(float distance) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Real-time distance to obstacle in meters\n\n    // Check real-time collision risk\n    checkRealTimeCollisionRisk(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system with variable warning timing depending on the vehicle's speed.",
      "input": "Speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n#include <cstdlib> // For system operations like EXIT_FAILURE\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision warning threshold\nconst float SPEED_THRESHOLD_METERS = 20.0f; // Speed threshold for warning timing\n\n// Function to adjust warning timing based on speed\nvoid adjustWarningTiming(float speed) {\n    if (speed > SPEED_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Immediate Action Required!\" << std::endl;\n    } else {\n        std::cout << \"Warning: Distance to Obstacle is \" << \" meters\" << std::endl;\n    }\n}\n\n// Function to check collision risk based on distance\nvoid checkCollisionRisk(float distance, float speed) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        adjustWarningTiming(speed); // Adjust warning timing based on speed\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float speed = 25.0f; // Vehicle speed in meters per second\n\n    // Check collision risk\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that calculates speed and distance dynamically for the collision warning.",
      "input": "Speed and real-time distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float SAFE_DISTANCE_METERS = 10.0f; // Safe distance threshold\n\n// Function to dynamically calculate the speed based on time interval and distance\nfloat calculateSpeed(float distance, float timeInterval) {\n    if (timeInterval == 0.0f) {\n        return 0.0f; // Avoid division by zero\n    }\n    return distance / timeInterval; // Calculate speed as distance/time\n}\n\n// Function to check for collision risk based on distance and calculated speed\nvoid checkCollisionRisk(float distance, float timeInterval) {\n    float speed = calculateSpeed(distance, timeInterval); // Calculate speed dynamically\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk Detected! Speed: \" << speed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n    float timeInterval = 2.0f; // Time interval in seconds\n\n    // Check collision risk dynamically\n    checkCollisionRisk(distance, timeInterval);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that handles multiple obstacle detection in a single frame.",
      "input": "Distance and type of multiple obstacles data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Collision warning threshold\n\n// Structure to hold information about an obstacle\nstruct Obstacle {\n    float distance; // Distance to the obstacle in meters\n    std::string type; // Type of obstacle (e.g., car, pedestrian)\n};\n\n// Function to check for collision risk with multiple obstacles\nvoid checkMultipleObstaclesCollisionRisk(Obstacle obstacles[], int numObstacles) {\n    for (int i = 0; i < numObstacles; i++) {\n        if (obstacles[i].distance < COLLISION_THRESHOLD_METERS) {\n            std::cout << \"WARNING: Collision Risk with \" << obstacles[i].type << \" at distance: \" << obstacles[i].distance << \" meters.\" << std::endl;\n        } else {\n            std::cout << \"Safe: No collision risk with \" << obstacles[i].type << \" at distance: \" << obstacles[i].distance << \" meters.\" << std::endl;\n        }\n    }\n}\n\nint main(void) {\n    Obstacle obstacles[] = {\n        {3.5f, \"Car\"},\n        {7.0f, \"Pedestrian\"},\n        {4.0f, \"Bike\"}\n    };\n    int numObstacles = sizeof(obstacles) / sizeof(obstacles[0]);\n\n    // Check collision risk with multiple obstacles\n    checkMultipleObstaclesCollisionRisk(obstacles, numObstacles);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that dynamically adjusts the warning based on vehicle speed.",
      "input": "Speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD_METERS = 5.0f; // Base threshold for collision warning\nconst float SPEED_THRESHOLD_METERS = 20.0f; // Speed threshold to adjust warning\n\n// Function to dynamically adjust the collision warning based on speed\nfloat adjustWarningThreshold(float speed) {\n    if (speed > SPEED_THRESHOLD_METERS) {\n        return BASE_COLLISION_THRESHOLD_METERS / 2.0f; // Decrease threshold at high speeds\n    } else {\n        return BASE_COLLISION_THRESHOLD_METERS; // Default threshold\n    }\n}\n\n// Function to check collision risk with dynamic warning threshold\nvoid checkCollisionRisk(float distance, float speed) {\n    float adjustedThreshold = adjustWarningThreshold(speed); // Adjust threshold based on speed\n    if (distance < adjustedThreshold) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n    float speed = 25.0f; // Vehicle speed in meters per second\n\n    // Check collision risk with dynamic warning adjustment\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adapts the warning threshold based on the vehicle's dynamic behavior.",
      "input": "Distance to obstacle, speed, and acceleration data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD_METERS = 5.0f; // Base threshold for collision warning\nconst float ACCELERATION_THRESHOLD_METERS = 3.0f; // Acceleration threshold to adjust warning\n\n// Function to adjust the collision warning threshold based on acceleration\nfloat adjustThresholdByAcceleration(float acceleration) {\n    if (acceleration > ACCELERATION_THRESHOLD_METERS) {\n        return BASE_COLLISION_THRESHOLD_METERS / 2.0f; // Decrease threshold during high acceleration\n    } else {\n        return BASE_COLLISION_THRESHOLD_METERS; // Default threshold\n    }\n}\n\n// Function to check collision risk based on distance, speed, and acceleration\nvoid checkCollisionRisk(float distance, float speed, float acceleration) {\n    float adjustedThreshold = adjustThresholdByAcceleration(acceleration); // Adjust threshold based on acceleration\n    if (distance < adjustedThreshold) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s. Acceleration: \" << acceleration << \" m/s^2.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s. Acceleration: \" << acceleration << \" m/s^2.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float speed = 20.0f; // Speed of the vehicle in meters per second\n    float acceleration = 2.5f; // Acceleration of the vehicle in meters per second squared\n\n    // Check collision risk with adaptive threshold\n    checkCollisionRisk(distance, speed, acceleration);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that factors in obstacle size when determining collision risk.",
      "input": "Obstacle size and distance data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float OBSTACLE_SIZE_THRESHOLD_METERS = 2.0f; // Threshold for large obstacle detection\n\n// Function to check collision risk based on obstacle size\nvoid checkCollisionRisk(float distance, float obstacleSize) {\n    if (obstacleSize > OBSTACLE_SIZE_THRESHOLD_METERS && distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk with Large Obstacle! Distance: \" << distance << \" meters. Obstacle Size: \" << obstacleSize << \" meters.\" << std::endl;\n    } else if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters. Obstacle Size: \" << obstacleSize << \" meters.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n    float obstacleSize = 2.5f; // Obstacle size in meters\n\n    // Check collision risk based on obstacle size and distance\n    checkCollisionRisk(distance, obstacleSize);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that triggers emergency braking when the collision risk is detected.",
      "input": "Distance to obstacle, speed, and time-to-collision data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float EMERGENCY_BRAKING_SPEED_THRESHOLD = 10.0f; // Speed threshold for emergency braking\n\n// Function to trigger emergency braking\nvoid triggerEmergencyBraking(float speed) {\n    if (speed > EMERGENCY_BRAKING_SPEED_THRESHOLD) {\n        std::cout << \"Emergency Braking Activated! Speed: \" << speed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"No Emergency Braking. Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\n// Function to check collision risk and trigger emergency braking\nvoid checkCollisionRisk(float distance, float speed) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s\" << std::endl;\n        triggerEmergencyBraking(speed); // Trigger braking if collision is imminent\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters. Speed: \" << speed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n    float speed = 15.0f; // Speed of the vehicle in meters per second\n\n    // Check collision risk and trigger emergency braking if needed\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the collision threshold based on the road condition (dry or wet).",
      "input": "Road condition (dry or wet) and distance to obstacle.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float DRY_ROAD_THRESHOLD = 5.0f; // Safe threshold for dry roads\nconst float WET_ROAD_THRESHOLD = 3.5f; // Safe threshold for wet roads\n\n// Enum to represent road condition\nenum RoadCondition {DRY, WET};\n\n// Function to check collision risk based on road condition\nvoid checkCollisionRisk(float distance, RoadCondition condition) {\n    float threshold = (condition == DRY) ? DRY_ROAD_THRESHOLD : WET_ROAD_THRESHOLD;\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters on \" << (condition == DRY ? \"dry\" : \"wet\") << \" road.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters on \" << (condition == DRY ? \"dry\" : \"wet\") << \" road.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    RoadCondition condition = WET; // Current road condition (WET or DRY)\n\n    // Check collision risk based on road condition\n    checkCollisionRisk(distance, condition);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates night vision data to enhance collision detection at night.",
      "input": "Distance to obstacle and night vision data (represented by visibility factor).",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float NIGHT_VISION_VISIBILITY_THRESHOLD = 0.5f; // Minimum visibility factor for effective night vision\n\n// Function to adjust collision threshold based on night vision visibility\nfloat adjustThresholdForNightVision(float visibility) {\n    if (visibility < NIGHT_VISION_VISIBILITY_THRESHOLD) {\n        return COLLISION_THRESHOLD_METERS / 2.0f; // Reduce threshold if visibility is low\n    }\n    return COLLISION_THRESHOLD_METERS; // Use default threshold if visibility is good\n}\n\n// Function to check collision risk with night vision enhancement\nvoid checkCollisionRisk(float distance, float visibility) {\n    float adjustedThreshold = adjustThresholdForNightVision(visibility); // Adjust threshold based on visibility\n    if (distance < adjustedThreshold) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters. Night Vision Visibility: \" << visibility << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters. Night Vision Visibility: \" << visibility << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n    float visibility = 0.4f; // Night vision visibility factor\n\n    // Check collision risk with night vision integration\n    checkCollisionRisk(distance, visibility);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts vehicle speed based on proximity to an obstacle.",
      "input": "Speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float SPEED_REDUCTION_FACTOR = 0.5f; // Speed reduction factor for risk mitigation\n\n// Function to adjust speed based on distance to obstacle\nfloat adjustSpeed(float distance, float speed) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        return speed * SPEED_REDUCTION_FACTOR; // Reduce speed if close to an obstacle\n    }\n    return speed; // No adjustment if safe\n}\n\n// Function to check collision risk and adjust speed\nvoid checkCollisionRisk(float distance, float speed) {\n    float adjustedSpeed = adjustSpeed(distance, speed); // Adjust speed if necessary\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Adjusted Speed: \" << adjustedSpeed << \" m/s\" << std::endl;\n    } else {\n        std::cout << \"Safe: Speed: \" << adjustedSpeed << \" m/s\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n    float speed = 12.0f; // Speed of the vehicle in meters per second\n\n    // Check collision risk and adjust speed if needed\n    checkCollisionRisk(distance, speed);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that integrates lane departure detection.",
      "input": "Lane departure sensor data and distance to obstacle.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst bool LANE_DEPARTURE_DETECTED = true; // Flag indicating lane departure detection\n\n// Function to check lane departure and collision risk\nvoid checkLaneDepartureAndCollisionRisk(float distance) {\n    if (LANE_DEPARTURE_DETECTED) {\n        std::cout << \"WARNING: Lane Departure Detected! \" << std::endl;\n    }\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n\n    // Check lane departure and collision risk\n    checkLaneDepartureAndCollisionRisk(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that adjusts the speed limit based on proximity to an obstacle.",
      "input": "Speed and distance to obstacle data.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst float ADJUSTED_SPEED_LIMIT = 30.0f; // Adjusted speed limit when close to an obstacle\n\n// Function to adjust speed limit based on distance to obstacle\nfloat adjustSpeedLimit(float distance) {\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        return ADJUSTED_SPEED_LIMIT; // Reduce speed limit when close to an obstacle\n    }\n    return 60.0f; // Default speed limit\n}\n\n// Function to check collision risk and adjust speed limit\nvoid checkCollisionRisk(float distance) {\n    float adjustedSpeedLimit = adjustSpeedLimit(distance); // Adjust speed limit\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Adjusted Speed Limit: \" << adjustedSpeedLimit << \" km/h\" << std::endl;\n    } else {\n        std::cout << \"Safe: Speed Limit: \" << adjustedSpeedLimit << \" km/h\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 4.0f; // Distance to obstacle in meters\n\n    // Check collision risk and adjust speed limit\n    checkCollisionRisk(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that uses sensor fusion (camera and radar) for more accurate detection.",
      "input": "Distance to obstacle data from radar and camera.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\n\n// Function to fuse sensor data (radar and camera)\nfloat fuseSensorData(float radarDistance, float cameraDistance) {\n    return (radarDistance + cameraDistance) / 2.0f; // Average of radar and camera data\n}\n\n// Function to check collision risk based on fused sensor data\nvoid checkCollisionRisk(float radarDistance, float cameraDistance) {\n    float fusedDistance = fuseSensorData(radarDistance, cameraDistance); // Fuse radar and camera data\n    if (fusedDistance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Fused Distance: \" << fusedDistance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Fused Distance: \" << fusedDistance << \" meters.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float radarDistance = 4.0f; // Distance to obstacle from radar\n    float cameraDistance = 5.0f; // Distance to obstacle from camera\n\n    // Check collision risk with sensor fusion\n    checkCollisionRisk(radarDistance, cameraDistance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system that includes pedestrian detection for safety.",
      "input": "Pedestrian proximity data and distance to obstacle.",
      "output": "#include <iostream> // For input-output operations\n\n// Constants\nconst float COLLISION_THRESHOLD_METERS = 5.0f; // Threshold for collision warning\nconst bool PEDESTRIAN_DETECTED = true; // Flag indicating pedestrian detection\n\n// Function to check pedestrian detection and collision risk\nvoid checkPedestrianAndCollisionRisk(float distance) {\n    if (PEDESTRIAN_DETECTED) {\n        std::cout << \"WARNING: Pedestrian Detected!\" << std::endl;\n    }\n    if (distance < COLLISION_THRESHOLD_METERS) {\n        std::cout << \"WARNING: Collision Risk! Distance: \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe: Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main(void) {\n    float distance = 3.0f; // Distance to obstacle in meters\n\n    // Check pedestrian and collision risk\n    checkPedestrianAndCollisionRisk(distance);\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on weather conditions.",
      "input": "Weather condition: Rain, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAIN, SNOW };\n\nWeatherCondition getWeatherCondition() {\n    return RAIN; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAIN) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the vehicle's speed dynamically if a collision risk is detected.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 3.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid adjustVehicleSpeed(float& speed) {\n    speed = 80.0f; // Reduce speed to avoid collision\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.5f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Reducing speed...\" << std::endl;\n        adjustVehicleSpeed(speed);\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects the object type (vehicle or pedestrian) and adjusts the collision threshold accordingly.",
      "input": "Object type: Vehicle, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float VEHICLE_THRESHOLD = 5.0f;\n    const float PEDESTRIAN_THRESHOLD = 2.0f;\n    const float COLLISION_THRESHOLD = (objectType == \"Vehicle\") ? VEHICLE_THRESHOLD : PEDESTRIAN_THRESHOLD;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that tracks the vehicle's distance over time to ensure long-term safety.",
      "input": "Radar distance: 3.0 meters, Time elapsed: 5 seconds.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n    const int TIME_ELAPSED = 5; // Time in seconds\n\n    if (distance < COLLISION_THRESHOLD && TIME_ELAPSED > 3) {\n        std::cout << \"WARNING: Collision risk detected after long-term monitoring!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a reactive warning system when a collision risk is detected.",
      "input": "Radar distance: 3.0 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nvoid triggerWarning() {\n    std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.5f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        triggerWarning();\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision threshold based on road type.",
      "input": "Road type: Highway, Vehicle speed: 100 km/h, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nenum RoadType { HIGHWAY, CITY, COUNTRY };\n\nRoadType getRoadType() {\n    return HIGHWAY; // Simulated road type\n}\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar distance\n}\n\nint main() {\n    RoadType road = getRoadType();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = (road == HIGHWAY) ? 5.0f : 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts object detection sensitivity based on the distance to the object.",
      "input": "Object distance: 1.0 meters, Object type: Vehicle.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getObjectDistance() {\n    return 1.0f; // Simulated object distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getObjectDistance();\n    const float COLLISION_THRESHOLD = (distance < 2.0f) ? 1.0f : 2.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians and triggers a warning if the distance is too short.",
      "input": "Object type: Pedestrian, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 2.5f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates the following distance based on vehicle speed.",
      "input": "Vehicle speed: 70 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float followingDistance = (speed / 2.0f); // Following distance = speed / 2\n\n    std::cout << \"Following distance: \" << followingDistance << \" meters.\" << std::endl;\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning based on the type of object detected.",
      "input": "Object type: Vehicle, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates time to collision and triggers a warning if the time to collision is below a threshold.",
      "input": "Vehicle speed: 60 km/h, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / speed; // Time to collision formula\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float timeToCollision = calculateTimeToCollision(speed, distance);\n    const float COLLISION_TIME_THRESHOLD = 3.0f;\n\n    if (timeToCollision < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe time to collision.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that includes traffic light detection and adjusts collision detection based on the state of the light.",
      "input": "Traffic light state: Red, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nenum TrafficLightState { RED, YELLOW, GREEN };\n\nTrafficLightState getTrafficLightState() {\n    return RED; // Simulated traffic light state\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar distance\n}\n\nint main() {\n    TrafficLightState lightState = getTrafficLightState();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (lightState == RED) ? 2.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the collision threshold is adjusted based on the type of vehicle detected.",
      "input": "Vehicle type: Truck, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getVehicleType() {\n    return TRUCK; // Simulated vehicle type\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    VehicleType vehicle = getVehicleType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (vehicle == TRUCK) ? 8.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with specific detection and alert for pedestrians.",
      "input": "Object type: Pedestrian, Radar distance: 1.5 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 1.5f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 2.0f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with time-to-collision calculation and alert if the time is less than a threshold.",
      "input": "Vehicle speed: 80 km/h, Radar distance: 10.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / speed; // Time to collision formula\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float timeToCollision = calculateTimeToCollision(speed, distance);\n    const float COLLISION_TIME_THRESHOLD = 3.5f;\n\n    if (timeToCollision < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe time to collision.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision threshold based on weather conditions.",
      "input": "Weather condition: Rainy, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAINY, SNOWY };\n\nWeatherCondition getWeatherCondition() {\n    return RAINY; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAINY) ? 3.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic collision threshold based on the vehicle speed.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 10.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (speed > 100.0f) ? 8.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with intersection detection, triggering a warning if the vehicle is approaching an intersection.",
      "input": "Intersection detected: Yes, Radar distance: 15.0 meters.",
      "output": "#include <iostream>\n\nbool isIntersectionDetected() {\n    return true; // Simulated intersection detection\n}\n\nfloat getRadarDistance() {\n    return 15.0f; // Simulated radar distance\n}\n\nint main() {\n    bool intersection = isIntersectionDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (intersection) ? 5.0f : 10.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk at intersection!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the collision threshold is adjusted based on the size of the detected object.",
      "input": "Object size: Large (Truck), Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nenum ObjectSize { SMALL, MEDIUM, LARGE };\n\nObjectSize getObjectSize() {\n    return LARGE; // Simulated object size\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    ObjectSize size = getObjectSize();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (size == LARGE) ? 8.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with object!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers automatic braking if the distance to the object is less than the threshold.",
      "input": "Radar distance: 2.0 meters, Object type: Vehicle.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar data\n}\n\nvoid applyBrakes() {\n    std::cout << \"Automatic brakes applied!\" << std::endl;\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        applyBrakes();\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that distinguishes between vehicle and pedestrian and triggers a warning accordingly.",
      "input": "Object type: Pedestrian, Radar distance: 1.8 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 1.8f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (objectType == \"Pedestrian\") ? 2.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers an emergency alert when the radar distance is below a threshold and the vehicle speed is high.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 3.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid triggerEmergencyAlert() {\n    std::cout << \"EMERGENCY ALERT: Immediate action required!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float SPEED_THRESHOLD = 90.0f;\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (speed > SPEED_THRESHOLD && distance < COLLISION_THRESHOLD) {\n        triggerEmergencyAlert();\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that checks if the vehicle speed is too high given the distance to the detected object.",
      "input": "Vehicle speed: 150 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 150.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float SPEED_THRESHOLD = 120.0f;\n    const float COLLISION_THRESHOLD = 8.0f;\n\n    if (speed > SPEED_THRESHOLD && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected at high speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects lane departure and triggers a collision warning if there is a risk of lane departure combined with close proximity to an object.",
      "input": "Lane departure detected: Yes, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulated lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    bool laneDeparture = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (laneDeparture && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to lane departure!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that considers the type of vehicle ahead and adjusts the collision threshold accordingly.",
      "input": "Vehicle type ahead: Motorcycle, Radar distance: 2.5 meters.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getVehicleTypeAhead() {\n    return MOTORCYCLE; // Simulated vehicle type ahead\n}\n\nfloat getRadarDistance() {\n    return 2.5f; // Simulated radar distance\n}\n\nint main() {\n    VehicleType vehicle = getVehicleTypeAhead();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (vehicle == MOTORCYCLE) ? 2.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk with vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the curvature of the road ahead.",
      "input": "Road curvature: High, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nenum RoadCurvature { FLAT, LOW, HIGH };\n\nRoadCurvature getRoadCurvature() {\n    return HIGH; // Simulated road curvature\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    RoadCurvature curvature = getRoadCurvature();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (curvature == HIGH) ? 5.0f : 8.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to road curvature!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the vehicle's braking ability.",
      "input": "Vehicle speed: 60 km/h, Brake response time: 2 seconds.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getBrakeResponseTime() {\n    return 2.0f; // Simulated brake response time\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float brakeResponseTime = getBrakeResponseTime();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (brakeResponseTime > 1.5f) ? 3.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on fog conditions.",
      "input": "Fog condition: Heavy, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, LIGHT_FOG, HEAVY_FOG };\n\nWeatherCondition getWeatherCondition() {\n    return HEAVY_FOG; // Simulated fog condition\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == HEAVY_FOG) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected in foggy conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning if the vehicle is changing lanes and there is an object in the new lane.",
      "input": "Lane change detected: Yes, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nbool isLaneChangeDetected() {\n    return true; // Simulated lane change detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    bool laneChange = isLaneChangeDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (laneChange && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected during lane change!\" << std::endl;\n    } else {\n        std::cout << \"Safe lane change.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers automatic emergency braking when the distance is below a certain threshold.",
      "input": "Radar distance: 1.5 meters, Emergency braking status: False.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 1.5f; // Simulated radar distance\n}\n\nbool isEmergencyBrakingActive() {\n    return false; // Simulated emergency braking status\n}\n\nvoid applyBrakes() {\n    std::cout << \"Applying emergency brakes!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    bool braking = isEmergencyBrakingActive();\n    const float COLLISION_THRESHOLD = 2.0f;\n\n    if (distance < COLLISION_THRESHOLD && !braking) {\n        applyBrakes();\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians and triggers an automatic alert if within a specific range.",
      "input": "Object type: Pedestrian, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected!\" << std::endl;\n    } else {\n        std::cout << \"No immediate threat.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning if there is a cross traffic risk when pulling out of a parking spot.",
      "input": "Cross traffic detected: Yes, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isCrossTrafficDetected() {\n    return true; // Simulated cross traffic detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    bool crossTraffic = isCrossTrafficDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (crossTraffic && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Cross traffic risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to proceed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that checks if the vehicle's stopping distance exceeds the available road space.",
      "input": "Vehicle speed: 50 km/h, Road length available: 15 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getAvailableRoadLength() {\n    return 15.0f; // Simulated road length available\n}\n\nfloat calculateStoppingDistance(float speed) {\n    const float DECELERATION = 5.0f; // Simulated deceleration\n    return (speed * speed) / (2 * DECELERATION); // Simplified stopping distance formula\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float roadLength = getAvailableRoadLength();\n    float stoppingDistance = calculateStoppingDistance(speed);\n\n    if (stoppingDistance > roadLength) {\n        std::cout << \"WARNING: Insufficient road length to stop safely!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that dynamically adjusts the warning threshold based on the road's speed limit.",
      "input": "Vehicle speed: 80 km/h, Road speed limit: 60 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRoadSpeedLimit() {\n    return 60.0f; // Simulated road speed limit\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    float vehicleSpeed = getVehicleSpeed();\n    float speedLimit = getRoadSpeedLimit();\n    float distance = getRadarDistance();\n\n    if (vehicleSpeed > speedLimit && distance < 15.0f) {\n        std::cout << \"WARNING: Over-speeding! Slow down.\" << std::endl;\n    } else if (vehicleSpeed > speedLimit) {\n        std::cout << \"WARNING: Over-speeding! Reduce speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects if the vehicle is approaching heavy traffic and adjusts the collision risk threshold.",
      "input": "Traffic congestion: Heavy, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isTrafficHeavy() {\n    return true; // Simulated traffic congestion\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    bool traffic = isTrafficHeavy();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (traffic) ? 2.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk due to traffic!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision risk based on the size of the detected object ahead.",
      "input": "Object detected: Small vehicle, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nenum ObjectType { CAR, TRUCK, MOTORCYCLE, SMALL_VEHICLE };\n\nObjectType getDetectedObject() {\n    return SMALL_VEHICLE; // Simulated object detection\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    ObjectType detectedObject = getDetectedObject();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (detectedObject == SMALL_VEHICLE) ? 4.0f : 8.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with small vehicle!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that integrates with adaptive cruise control to maintain a safe distance based on the vehicle's speed.",
      "input": "Vehicle speed: 100 km/h, Distance to vehicle ahead: 5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    float vehicleSpeed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n    const float SAFE_DISTANCE = vehicleSpeed * 0.5f; // Simple rule for safe distance\n\n    if (distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Too close to vehicle ahead, activating cruise control adjustment.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians crossing the road and triggers a warning.",
      "input": "Object type: Pedestrian, Radar distance: 1.8 meters.",
      "output": "#include <iostream>\n\nstd::string getDetectedObject() {\n    return \"Pedestrian\"; // Simulated object detection\n}\n\nfloat getRadarDistance() {\n    return 1.8f; // Simulated radar distance\n}\n\nint main() {\n    std::string object = getDetectedObject();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 2.0f;\n\n    if (object == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision warning threshold based on poor visibility conditions.",
      "input": "Visibility: Poor, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nenum VisibilityCondition { CLEAR, POOR };\n\nVisibilityCondition getVisibilityCondition() {\n    return POOR; // Simulated poor visibility\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    VisibilityCondition visibility = getVisibilityCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (visibility == POOR) ? 2.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected in poor visibility conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning when a pedestrian is detected in a crosswalk.",
      "input": "Object type: Pedestrian, Crosswalk detected: Yes, Radar distance: 1.0 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianInCrosswalk() {\n    return true; // Simulated pedestrian in crosswalk detection\n}\n\nfloat getRadarDistance() {\n    return 1.0f; // Simulated radar distance\n}\n\nint main() {\n    bool pedestrianInCrosswalk = isPedestrianInCrosswalk();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 1.5f;\n\n    if (pedestrianInCrosswalk && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian in crosswalk!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected in crosswalk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that warns the driver when the car is too close to a stop sign.",
      "input": "Object detected: Stop sign, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nstd::string getDetectedObject() {\n    return \"Stop sign\"; // Simulated object detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string object = getDetectedObject();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (object == \"Stop sign\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Too close to stop sign!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the vehicle's headlights being in night mode.",
      "input": "Headlights: Night mode, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nbool areHeadlightsInNightMode() {\n    return true; // Simulated night mode\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Simulated radar distance\n}\n\nint main() {\n    bool nightMode = areHeadlightsInNightMode();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (nightMode) ? 6.0f : 10.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Low visibility due to night mode!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects rapid deceleration and warns if the car is approaching a dangerous situation.",
      "input": "Vehicle speed: 80 km/h, Deceleration rate: 8 m/s\u00b2.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDecelerationRate() {\n    return 8.0f; // Simulated deceleration rate in m/s\u00c2\u00b2\n}\n\nbool isRapidDeceleration(float decelerationRate) {\n    return decelerationRate > 7.0f; // Threshold for rapid deceleration\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float deceleration = getDecelerationRate();\n\n    if (isRapidDeceleration(deceleration)) {\n        std::cout << \"WARNING: Rapid deceleration detected!\" << std::endl;\n    } else {\n        std::cout << \"Normal deceleration.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects obstacles at intersections and issues a warning when a collision risk is detected.",
      "input": "Obstacle detected at intersection, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nbool isObstacleDetectedAtIntersection() {\n    return true; // Simulated obstacle detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    bool obstacle = isObstacleDetectedAtIntersection();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (obstacle && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected at intersection!\" << std::endl;\n    } else {\n        std::cout << \"Safe to proceed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on whether it's night time, considering lower visibility.",
      "input": "Vehicle speed: 60 km/h, Night time: True, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isNightTime() {\n    return true; // Simulated night time detection\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    bool nightTime = isNightTime();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = nightTime ? 8.0f : 12.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Low visibility due to night time driving.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects if a sudden lane change is made and issues a warning.",
      "input": "Vehicle speed: 90 km/h, Lane change detected: Yes, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nbool isLaneChangeDetected() {\n    return true; // Simulated lane change detection\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    bool laneChange = isLaneChangeDetected();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 5.0f;\n\n    if (laneChange && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Sudden lane change detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe lane change detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians and assesses collision risk based on their distance from the vehicle.",
      "input": "Pedestrian detected: Yes, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar distance\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (pedestrianDetected && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision warning threshold based on weather conditions.",
      "input": "Weather: Rainy, Vehicle speed: 70 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, RAINY, FOGGY };\n\nWeatherCondition getWeatherCondition() {\n    return RAINY; // Simulated weather condition\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAINY) ? 3.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Reduced visibility due to weather!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers emergency braking when collision risk is high.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid activateEmergencyBraking() {\n    std::cout << \"Emergency Braking Activated!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        activateEmergencyBraking();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that also triggers a warning when the car is detected to be drifting out of its lane.",
      "input": "Lane deviation detected: Yes, Vehicle speed: 70 km/h.",
      "output": "#include <iostream>\n\nbool isLaneDeviationDetected() {\n    return true; // Simulated lane deviation detection\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed\n}\n\nint main() {\n    bool laneDeviation = isLaneDeviationDetected();\n    float speed = getVehicleSpeed();\n\n    if (laneDeviation) {\n        std::cout << \"WARNING: Lane deviation detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that warns when the vehicle is too close to the vehicle ahead, i.e., tailgating.",
      "input": "Distance to vehicle ahead: 2 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar distance\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Tailgating detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that takes into account the vehicle's turn signal status when calculating collision risk.",
      "input": "Turn signal active: Yes, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nbool isTurnSignalActive() {\n    return true; // Simulated turn signal status\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Simulated radar distance\n}\n\nint main() {\n    bool turnSignal = isTurnSignalActive();\n    float distance = getRadarDistance();\n\n    if (turnSignal && distance < 10.0f) {\n        std::cout << \"WARNING: Turn signal active, be aware of vehicle maneuver!\" << std::endl;\n    } else {\n        std::cout << \"No turn signal detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects collision risk based on the distance from a detected object ahead of the vehicle.",
      "input": "Radar distance: 3 meters, Vehicle speed: 70 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed in km/h\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 5.0f; // 5 meters distance threshold\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW that adjusts the warning threshold based on the vehicle's speed.",
      "input": "Vehicle speed: 90 km/h, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float SPEED_THRESHOLD = 80.0f;\n    const float COLLISION_THRESHOLD_HIGH_SPEED = 4.0f;\n    const float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;\n    if (speed > SPEED_THRESHOLD) {\n        return distance < COLLISION_THRESHOLD_HIGH_SPEED;\n    } else {\n        return distance < COLLISION_THRESHOLD_LOW_SPEED;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Implement a MISRA C++ 2023-compliant FCW system that detects pedestrians and calculates collision risk based on proximity.",
      "input": "Pedestrian detected: Yes, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 3.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (pedestrianDetected && isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Pedestrian ahead!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that also checks if the vehicle is deviating from its lane and issues a warning.",
      "input": "Lane deviation detected: Yes, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isLaneDeviationDetected() {\n    return true; // Simulated lane deviation detection\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nint main() {\n    bool laneDeviation = isLaneDeviationDetected();\n    float distance = getRadarDistance();\n    if (laneDeviation) {\n        std::cout << \"WARNING: Lane deviation detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is within lane.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the warning threshold based on weather conditions (e.g., rainy or foggy).",
      "input": "Weather: Foggy, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, RAINY, FOGGY };\n\nWeatherCondition getWeatherCondition() {\n    return FOGGY; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == FOGGY) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Reduced visibility due to foggy conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that warns if the car is following too closely behind another vehicle (tailgating).",
      "input": "Distance to vehicle ahead: 1.5 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 1.5f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isTailgating(float distance) {\n    const float MIN_SAFE_DISTANCE = 2.0f; // Safe distance in meters\n    return distance < MIN_SAFE_DISTANCE;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isTailgating(distance)) {\n        std::cout << \"WARNING: Tailgating detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that accounts for the vehicle's turn signal status when determining collision risk.",
      "input": "Turn signal active: Yes, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nbool isTurnSignalActive() {\n    return true; // Simulated turn signal status\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nint main() {\n    bool turnSignal = isTurnSignalActive();\n    float distance = getRadarDistance();\n    if (turnSignal && distance < 5.0f) {\n        std::cout << \"WARNING: Turn signal active, vehicle may change lane!\" << std::endl;\n    } else {\n        std::cout << \"No turn signal detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers emergency braking when a collision risk is detected and too close.",
      "input": "Radar distance: 2 meters, Vehicle speed: 80 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nvoid activateEmergencyBraking() {\n    std::cout << \"Emergency Braking Activated!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 3.0f) {\n        activateEmergencyBraking();\n    } else {\n        std::cout << \"No immediate collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts collision risk thresholds based on the vehicle's speed.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float COLLISION_THRESHOLD_HIGH_SPEED = 4.0f;\n    const float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;\n    return (speed > 90.0f) ? (distance < COLLISION_THRESHOLD_HIGH_SPEED) : (distance < COLLISION_THRESHOLD_LOW_SPEED);\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that dynamically adjusts the collision warning threshold based on heavy traffic conditions.",
      "input": "Traffic conditions: Heavy, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nenum TrafficCondition { LIGHT, MODERATE, HEAVY };\n\nTrafficCondition getTrafficCondition() {\n    return HEAVY; // Simulate traffic condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nint main() {\n    TrafficCondition traffic = getTrafficCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (traffic == HEAVY) ? 3.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Heavy traffic, reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that differentiates collision risk based on the type of vehicle ahead (e.g., car, truck).",
      "input": "Vehicle ahead: Truck, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getAheadVehicleType() {\n    return TRUCK; // Simulated vehicle ahead\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(VehicleType type, float distance) {\n    const float CAR_THRESHOLD = 5.0f;\n    const float TRUCK_THRESHOLD = 8.0f;\n    const float MOTORCYCLE_THRESHOLD = 4.0f;\n\n    switch(type) {\n        case CAR: return distance < CAR_THRESHOLD;\n        case TRUCK: return distance < TRUCK_THRESHOLD;\n        case MOTORCYCLE: return distance < MOTORCYCLE_THRESHOLD;\n        default: return false;\n    }\n}\n\nint main() {\n    VehicleType vehicle = getAheadVehicleType();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(vehicle, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision risk warning based on the vehicle's dynamic speed and distance to the object ahead.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 4.0f;\n    const float LOW_SPEED_THRESHOLD = 6.0f;\n    if (speed > 100.0f) {\n        return distance < HIGH_SPEED_THRESHOLD;\n    } else {\n        return distance < LOW_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that uses both forward camera and radar data for collision detection and warning.",
      "input": "Radar distance: 5 meters, Camera detects an object ahead.",
      "output": "#include <iostream>\n\nbool isObjectDetectedByCamera() {\n    return true; // Simulate object detection by camera\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance, bool cameraDetection) {\n    const float COLLISION_THRESHOLD = 4.0f;\n    return cameraDetection && distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool cameraDetection = isObjectDetectedByCamera();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance, cameraDetection)) {\n        std::cout << \"WARNING: Object ahead!\" << std::endl;\n    } else {\n        std::cout << \"No object detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the duration of the warning based on the distance to the object ahead.",
      "input": "Radar distance: 3 meters, Warning threshold: 5 seconds.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nvoid activateWarning(float duration) {\n    std::cout << \"WARNING: Collision risk! Warning duration: \" << duration << \" seconds.\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 5.0f) {\n        activateWarning(5.0f); // Trigger warning for 5 seconds\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers automatic emergency braking when the radar detects an object within a critical distance.",
      "input": "Radar distance: 1.5 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 1.5f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nvoid activateAutomaticBraking() {\n    std::cout << \"Automatic emergency braking triggered!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 2.0f) {\n        activateAutomaticBraking();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects collision risk based on lane change signals from the vehicle ahead.",
      "input": "Lane change detected: Yes, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nbool isLaneChangeDetected() {\n    return true; // Simulate lane change detection\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nint main() {\n    bool laneChange = isLaneChangeDetected();\n    float distance = getRadarDistance();\n    if (laneChange && distance < 10.0f) {\n        std::cout << \"WARNING: Lane change detected, risk of collision!\" << std::endl;\n    } else {\n        std::cout << \"No lane change detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision risk based on pedestrian detection and vehicle speed.",
      "input": "Pedestrian detected: Yes, Vehicle speed: 20 km/h, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 20.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool pedestrianDetected, float speed, float distance) {\n    const float COLLISION_THRESHOLD = (speed < 30.0f) ? 3.0f : 2.0f;\n    return pedestrianDetected && distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(pedestrianDetected, speed, distance)) {\n        std::cout << \"WARNING: Pedestrian ahead!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects when the vehicle ahead stops and issues an appropriate warning.",
      "input": "Vehicle ahead speed: 0 km/h, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeedAhead() {\n    return 0.0f; // Speed of the vehicle ahead\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nvoid triggerFCW() {\n    std::cout << \"WARNING: Vehicle ahead has stopped!\" << std::endl;\n}\n\nint main() {\n    float speedAhead = getVehicleSpeedAhead();\n    float distance = getRadarDistance();\n    if (speedAhead == 0.0f && distance < 3.0f) {\n        triggerFCW();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning threshold based on road curvature.",
      "input": "Road curvature: Sharp turn, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nenum RoadCurvature { STRAIGHT, SLIGHT_TURN, SHARP_TURN };\n\nRoadCurvature getRoadCurvature() {\n    return SHARP_TURN; // Simulate sharp turn condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nint main() {\n    RoadCurvature curvature = getRoadCurvature();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (curvature == SHARP_TURN) ? 3.0f : 5.0f;\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Sharp turn, reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects cross-traffic and provides a warning when necessary.",
      "input": "Cross-traffic detected: Yes, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nbool isCrossTrafficDetected() {\n    return true; // Simulate cross-traffic detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nint main() {\n    bool crossTrafficDetected = isCrossTrafficDetected();\n    float distance = getRadarDistance();\n    if (crossTrafficDetected && distance < 6.0f) {\n        std::cout << \"WARNING: Cross-traffic detected, proceed with caution!\" << std::endl;\n    } else {\n        std::cout << \"No cross-traffic detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers a pedestrian avoidance warning if a pedestrian is detected and collision risk is high.",
      "input": "Pedestrian detected: Yes, Radar distance: 2 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(float distance, bool pedestrianDetected) {\n    const float PEDESTRIAN_THRESHOLD = 2.5f;\n    return pedestrianDetected && distance < PEDESTRIAN_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance, pedestrianDetected)) {\n        std::cout << \"WARNING: Pedestrian ahead, slow down or stop!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates lane departure warnings when the vehicle is at risk of colliding with a vehicle ahead while exiting the lane.",
      "input": "Lane departure: Yes, Vehicle ahead speed: 30 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulate lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeedAhead() {\n    return 30.0f; // Vehicle speed ahead\n}\n\nint main() {\n    bool laneDeparture = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    float speedAhead = getVehicleSpeedAhead();\n    if (laneDeparture && distance < 15.0f && speedAhead < 50.0f) {\n        std::cout << \"WARNING: Lane departure detected, vehicle ahead, slow down!\" << std::endl;\n    } else {\n        std::cout << \"No lane departure detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the threshold for collision warning based on the dynamic speed of the vehicle.",
      "input": "Vehicle speed: 90 km/h, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 5.0f;\n    const float NORMAL_SPEED_THRESHOLD = 8.0f;\n    if (speed > 80.0f) {\n        return distance < HIGH_SPEED_THRESHOLD;\n    } else {\n        return distance < NORMAL_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers the emergency brake if a collision risk is detected based on radar data.",
      "input": "Radar distance: 2 meters, Vehicle speed: 30 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Vehicle speed in km/h\n}\n\nvoid activateEmergencyBrake() {\n    std::cout << \"Emergency brake activated!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 3.0f) {\n        activateEmergencyBrake();\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision risk threshold based on the type of vehicle ahead (car, truck, motorcycle).",
      "input": "Vehicle ahead: Truck, Radar distance: 12 meters, Speed: 80 km/h.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getVehicleTypeAhead() {\n    return TRUCK; // Vehicle type ahead\n}\n\nfloat getRadarDistance() {\n    return 12.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(VehicleType type, float distance, float speed) {\n    const float CAR_THRESHOLD = 10.0f;\n    const float TRUCK_THRESHOLD = 15.0f;\n    const float MOTORCYCLE_THRESHOLD = 8.0f;\n\n    if (type == CAR) {\n        return distance < CAR_THRESHOLD && speed > 60.0f;\n    } else if (type == TRUCK) {\n        return distance < TRUCK_THRESHOLD && speed > 70.0f;\n    } else {\n        return distance < MOTORCYCLE_THRESHOLD && speed > 50.0f;\n    }\n}\n\nint main() {\n    VehicleType vehicleType = getVehicleTypeAhead();\n    float distance = getRadarDistance();\n    float speed = getVehicleSpeed();\n    if (isCollisionRisk(vehicleType, distance, speed)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision threshold based on weather conditions.",
      "input": "Weather: Foggy, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, FOGGY, RAINY };\n\nWeatherCondition getCurrentWeather() {\n    return FOGGY; // Current weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(WeatherCondition weather, float distance) {\n    const float CLEAR_THRESHOLD = 8.0f;\n    const float FOGGY_THRESHOLD = 4.0f;\n    const float RAINY_THRESHOLD = 6.0f;\n\n    if (weather == CLEAR) {\n        return distance < CLEAR_THRESHOLD;\n    } else if (weather == FOGGY) {\n        return distance < FOGGY_THRESHOLD;\n    } else { // RAINY\n        return distance < RAINY_THRESHOLD;\n    }\n}\n\nint main() {\n    WeatherCondition weather = getCurrentWeather();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(weather, distance)) {\n        std::cout << \"WARNING: Collision risk detected due to weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects rear-end collision risks when a vehicle is too close behind.",
      "input": "Rear vehicle speed: 100 km/h, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nfloat getRearVehicleSpeed() {\n    return 100.0f; // Rear vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nbool isRearEndCollisionRisk(float rearSpeed, float distance) {\n    const float COLLISION_THRESHOLD = 5.0f;\n    return rearSpeed > 90.0f && distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float rearSpeed = getRearVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isRearEndCollisionRisk(rearSpeed, distance)) {\n        std::cout << \"WARNING: Rear-end collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe from rear-end collision.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers a warning based on vehicle speed and proximity to other vehicles.",
      "input": "Vehicle speed: 110 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 110.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 5.0f;\n    const float NORMAL_SPEED_THRESHOLD = 8.0f;\n    return (speed > 100.0f && distance < HIGH_SPEED_THRESHOLD) || (distance < NORMAL_SPEED_THRESHOLD);\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the radar distance threshold based on the vehicle's speed.",
      "input": "Vehicle speed: 40 km/h, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float SLOW_SPEED_THRESHOLD = 10.0f;\n    const float NORMAL_SPEED_THRESHOLD = 7.0f;\n    if (speed < 50.0f) {\n        return distance < SLOW_SPEED_THRESHOLD;\n    } else {\n        return distance < NORMAL_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that provides an alert when the vehicle is driving on a narrow road with a vehicle ahead.",
      "input": "Road width: Narrow, Vehicle ahead speed: 20 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nbool isNarrowRoad() {\n    return true; // Simulate narrow road condition\n}\n\nfloat getVehicleSpeedAhead() {\n    return 20.0f; // Vehicle speed ahead\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nint main() {\n    bool narrowRoad = isNarrowRoad();\n    float speedAhead = getVehicleSpeedAhead();\n    float distance = getRadarDistance();\n    if (narrowRoad && distance < 8.0f && speedAhead < 30.0f) {\n        std::cout << \"WARNING: Narrow road ahead, vehicle approaching!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning system for night driving.",
      "input": "Time of day: Night, Radar distance: 8 meters, Vehicle speed: 40 km/h.",
      "output": "#include <iostream>\n\nbool isNightMode() {\n    return true; // Simulate night driving condition\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool nightMode, float distance) {\n    const float NIGHT_MODE_THRESHOLD = 6.0f;\n    const float NORMAL_MODE_THRESHOLD = 8.0f;\n\n    if (nightMode) {\n        return distance < NIGHT_MODE_THRESHOLD;\n    } else {\n        return distance < NORMAL_MODE_THRESHOLD;\n    }\n}\n\nint main() {\n    bool nightMode = isNightMode();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(nightMode, distance)) {\n        std::cout << \"WARNING: Collision risk detected in night mode!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects tailgating behavior and triggers an emergency alert.",
      "input": "Rear vehicle distance: 2 meters, Speed: 100 km/h.",
      "output": "#include <iostream>\n\nfloat getRearVehicleDistance() {\n    return 2.0f; // Rear vehicle distance in meters\n}\n\nfloat getRearVehicleSpeed() {\n    return 100.0f; // Rear vehicle speed in km/h\n}\n\nbool isTailgatingRisk(float rearDistance, float rearSpeed) {\n    const float TAILGATING_THRESHOLD = 3.0f;\n    return rearDistance < TAILGATING_THRESHOLD && rearSpeed > 90.0f;\n}\n\nint main() {\n    float rearDistance = getRearVehicleDistance();\n    float rearSpeed = getRearVehicleSpeed();\n    if (isTailgatingRisk(rearDistance, rearSpeed)) {\n        std::cout << \"WARNING: Tailgating risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the radar distance threshold based on vehicle speed.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float SPEED_THRESHOLD = 100.0f;\n    const float HIGH_SPEED_THRESHOLD = 5.0f;\n    const float NORMAL_SPEED_THRESHOLD = 8.0f;\n\n    if (speed > SPEED_THRESHOLD) {\n        return distance < HIGH_SPEED_THRESHOLD;\n    } else {\n        return distance < NORMAL_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers proximity alerts when driving in urban areas.",
      "input": "Location: Urban, Radar distance: 4 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nbool isUrbanArea() {\n    return true; // Simulate urban area condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool urbanArea, float distance) {\n    const float URBAN_AREA_THRESHOLD = 5.0f;\n    const float NORMAL_AREA_THRESHOLD = 8.0f;\n\n    if (urbanArea) {\n        return distance < URBAN_AREA_THRESHOLD;\n    } else {\n        return distance < NORMAL_AREA_THRESHOLD;\n    }\n}\n\nint main() {\n    bool urbanArea = isUrbanArea();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(urbanArea, distance)) {\n        std::cout << \"WARNING: Collision risk in urban area!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects long-distance vehicles and adjusts the alert accordingly.",
      "input": "Vehicle ahead distance: 50 meters, Speed: 80 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleAheadDistance() {\n    return 50.0f; // Vehicle ahead distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(float distance, float speed) {\n    const float LONG_DISTANCE_THRESHOLD = 45.0f;\n    const float COLLISION_SPEED_THRESHOLD = 60.0f;\n    return distance < LONG_DISTANCE_THRESHOLD && speed > COLLISION_SPEED_THRESHOLD;\n}\n\nint main() {\n    float distance = getVehicleAheadDistance();\n    float speed = getVehicleSpeed();\n    if (isCollisionRisk(distance, speed)) {\n        std::cout << \"WARNING: Long-distance vehicle detected, slow down!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers an alert when driving on hazardous road conditions such as icy roads.",
      "input": "Road condition: Icy, Radar distance: 6 meters, Vehicle speed: 30 km/h.",
      "output": "#include <iostream>\n\nenum RoadCondition { NORMAL, ICY, WET };\n\nRoadCondition getRoadCondition() {\n    return ICY; // Simulate icy road condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(RoadCondition condition, float distance) {\n    const float ICY_ROAD_THRESHOLD = 4.0f;\n    const float NORMAL_ROAD_THRESHOLD = 8.0f;\n\n    if (condition == ICY) {\n        return distance < ICY_ROAD_THRESHOLD;\n    } else {\n        return distance < NORMAL_ROAD_THRESHOLD;\n    }\n}\n\nint main() {\n    RoadCondition condition = getRoadCondition();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(condition, distance)) {\n        std::cout << \"WARNING: Hazardous road condition detected, slow down!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adapts the collision warning when detecting motorcycles ahead.",
      "input": "Vehicle ahead: Motorcycle, Radar distance: 6 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nbool isMotorcycleAhead() {\n    return true; // Simulate motorcycle ahead condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool motorcycleAhead, float distance) {\n    const float MOTORCYCLE_THRESHOLD = 5.0f;\n    const float NORMAL_THRESHOLD = 8.0f;\n\n    if (motorcycleAhead) {\n        return distance < MOTORCYCLE_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool motorcycleAhead = isMotorcycleAhead();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(motorcycleAhead, distance)) {\n        std::cout << \"WARNING: Motorcycle ahead, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates with an automated braking system to stop the vehicle in case of a detected collision risk.",
      "input": "Radar distance: 3 meters, Vehicle speed: 90 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nvoid applyBrakes() {\n    std::cout << \"Automated braking system activated!\" << std::endl;\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 4.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance)) {\n        applyBrakes();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates lane departure warning with forward collision detection.",
      "input": "Vehicle in lane: True, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nbool isLaneDeparture() {\n    return false; // Simulate lane departure condition\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 5.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool laneDeparture = isLaneDeparture();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance) || laneDeparture) {\n        std::cout << \"WARNING: Lane departure or collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning for foggy weather conditions.",
      "input": "Weather condition: Foggy, Radar distance: 4 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nbool isFoggyWeather() {\n    return true; // Simulate foggy weather condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool foggyWeather, float distance) {\n    const float FOG_THRESHOLD = 3.0f;\n    const float NORMAL_THRESHOLD = 6.0f;\n\n    if (foggyWeather) {\n        return distance < FOG_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool foggyWeather = isFoggyWeather();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(foggyWeather, distance)) {\n        std::cout << \"WARNING: Foggy weather, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects if the vehicle in front is decelerating and triggers an alert.",
      "input": "Lead vehicle speed: 70 km/h, Following vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getLeadVehicleSpeed() {\n    return 70.0f; // Lead vehicle speed in km/h\n}\n\nfloat getFollowingVehicleSpeed() {\n    return 60.0f; // Following vehicle speed in km/h\n}\n\nbool isDecelerating(float leadSpeed, float followSpeed) {\n    return followSpeed < leadSpeed;\n}\n\nint main() {\n    float leadSpeed = getLeadVehicleSpeed();\n    float followSpeed = getFollowingVehicleSpeed();\n    if (isDecelerating(leadSpeed, followSpeed)) {\n        std::cout << \"WARNING: Lead vehicle is decelerating, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers an adaptive alert when a pedestrian is detected in the vehicle's path.",
      "input": "Pedestrian detected: True, Radar distance: 3 meters, Vehicle speed: 20 km/h.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 20.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool pedestrianDetected, float distance) {\n    const float PEDESTRIAN_THRESHOLD = 4.0f;\n    return pedestrianDetected && distance < PEDESTRIAN_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(pedestrianDetected, distance)) {\n        std::cout << \"WARNING: Pedestrian detected, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning system based on the time of day (day or night).",
      "input": "Time of day: Day, Radar distance: 10 meters, Vehicle speed: 80 km/h.",
      "output": "#include <iostream>\n\nbool isDayTime() {\n    return true; // Simulate day time condition\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool dayTime, float distance) {\n    const float DAY_TIME_THRESHOLD = 12.0f;\n    const float NIGHT_TIME_THRESHOLD = 8.0f;\n\n    if (dayTime) {\n        return distance < DAY_TIME_THRESHOLD;\n    } else {\n        return distance < NIGHT_TIME_THRESHOLD;\n    }\n}\n\nint main() {\n    bool dayTime = isDayTime();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(dayTime, distance)) {\n        std::cout << \"WARNING: Collision risk detected in day mode!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects sharp curves ahead and adjusts collision warning thresholds.",
      "input": "Curve ahead: True, Radar distance: 6 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nbool isCurveAhead() {\n    return true; // Simulate curve ahead condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool curveAhead, float distance) {\n    const float CURVE_THRESHOLD = 5.0f;\n    const float NORMAL_THRESHOLD = 8.0f;\n\n    if (curveAhead) {\n        return distance < CURVE_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool curveAhead = isCurveAhead();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(curveAhead, distance)) {\n        std::cout << \"WARNING: Collision risk due to curve ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adapts the collision warning threshold based on the density of traffic.",
      "input": "Traffic flow: Dense, Radar distance: 4 meters, Vehicle speed: 30 km/h.",
      "output": "#include <iostream>\n\nbool isTrafficDense() {\n    return true; // Simulate dense traffic condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool denseTraffic, float distance) {\n    const float DENSE_TRAFFIC_THRESHOLD = 3.0f;\n    const float NORMAL_TRAFFIC_THRESHOLD = 6.0f;\n\n    if (denseTraffic) {\n        return distance < DENSE_TRAFFIC_THRESHOLD;\n    } else {\n        return distance < NORMAL_TRAFFIC_THRESHOLD;\n    }\n}\n\nint main() {\n    bool denseTraffic = isTrafficDense();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(denseTraffic, distance)) {\n        std::cout << \"WARNING: Collision risk due to dense traffic!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects fog and adjusts the vehicle speed and collision warning thresholds.",
      "input": "Weather: Foggy, Vehicle speed: 40 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nbool isFoggyWeather() {\n    return true; // Simulate foggy weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool foggyWeather, float distance) {\n    const float FOG_THRESHOLD = 4.0f;\n    const float NORMAL_THRESHOLD = 6.0f;\n\n    if (foggyWeather) {\n        return distance < FOG_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool foggyWeather = isFoggyWeather();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(foggyWeather, distance)) {\n        std::cout << \"WARNING: Collision risk in foggy conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects slow-moving traffic ahead and adjusts the warning system.",
      "input": "Lead vehicle speed: 20 km/h, Following vehicle speed: 25 km/h.",
      "output": "#include <iostream>\n\nfloat getLeadVehicleSpeed() {\n    return 20.0f; // Lead vehicle speed in km/h\n}\n\nfloat getFollowingVehicleSpeed() {\n    return 25.0f; // Following vehicle speed in km/h\n}\n\nbool isSlowMovingTraffic(float leadSpeed, float followSpeed) {\n    return followSpeed < leadSpeed;\n}\n\nint main() {\n    float leadSpeed = getLeadVehicleSpeed();\n    float followSpeed = getFollowingVehicleSpeed();\n    if (isSlowMovingTraffic(leadSpeed, followSpeed)) {\n        std::cout << \"WARNING: Slow-moving traffic detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers an automatic lane change when a collision risk is detected.",
      "input": "Collision risk: True, Vehicle speed: 90 km/h.",
      "output": "#include <iostream>\n\nbool isCollisionRisk() {\n    return true; // Simulate collision risk detection\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nvoid triggerLaneChange() {\n    std::cout << \"WARNING: Collision risk detected. Triggering automatic lane change!\" << std::endl;\n}\n\nint main() {\n    if (isCollisionRisk()) {\n        triggerLaneChange();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates blind spot detection with forward collision warning.",
      "input": "Blind spot detected: True, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nbool isBlindSpotDetected() {\n    return true; // Simulate blind spot detection\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 5.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool blindSpot = isBlindSpotDetected();\n    float distance = getRadarDistance();\n    if (blindSpot || isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Blind spot or collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects pedestrians at crosswalks and triggers a warning.",
      "input": "Pedestrian detected: True, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float PEDESTRIAN_THRESHOLD = 3.0f;\n    return distance < PEDESTRIAN_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (pedestrianDetected && isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Pedestrian detected at crosswalk, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the speed limit threshold based on weather conditions (clear, rainy, snowy).",
      "input": "Weather: Rainy, Vehicle speed: 60 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nenum Weather { CLEAR, RAINY, SNOWY }; // Weather conditions\n\nWeather currentWeather = RAINY;\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isSpeedLimitExceeded(Weather weather, float distance, float speed) {\n    const float NORMAL_SPEED_LIMIT = 80.0f;\n    const float RAINY_SPEED_LIMIT = 60.0f;\n    const float SNOWY_SPEED_LIMIT = 50.0f;\n    if (weather == RAINY) {\n        return speed > RAINY_SPEED_LIMIT && distance < 12.0f;\n    } else if (weather == SNOWY) {\n        return speed > SNOWY_SPEED_LIMIT && distance < 8.0f;\n    } else {\n        return speed > NORMAL_SPEED_LIMIT && distance < 15.0f;\n    }\n}\n\nint main() {\n    float distance = getRadarDistance();\n    float speed = getVehicleSpeed();\n    if (isSpeedLimitExceeded(currentWeather, distance, speed)) {\n        std::cout << \"WARNING: Speed limit exceeded for current weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects tailgating (following too closely) and triggers a warning.",
      "input": "Lead vehicle speed: 100 km/h, Following vehicle speed: 95 km/h, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nfloat getLeadVehicleSpeed() {\n    return 100.0f; // Lead vehicle speed in km/h\n}\n\nfloat getFollowingVehicleSpeed() {\n    return 95.0f; // Following vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nbool isTailgating(float leadSpeed, float followSpeed, float distance) {\n    const float MIN_DISTANCE = 5.0f;\n    return (followSpeed > leadSpeed) && (distance < MIN_DISTANCE);\n}\n\nint main() {\n    float leadSpeed = getLeadVehicleSpeed();\n    float followSpeed = getFollowingVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isTailgating(leadSpeed, followSpeed, distance)) {\n        std::cout << \"WARNING: Tailgating detected, increase following distance!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving distance maintained.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects autonomous vehicles in the vicinity and adjusts collision warnings accordingly.",
      "input": "Lead vehicle type: Autonomous, Radar distance: 6 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nenum VehicleType { HUMAN_CONTROLLED, AUTONOMOUS }; // Vehicle types\n\nVehicleType leadVehicle = AUTONOMOUS;\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isAutonomousVehicle(VehicleType vehicleType) {\n    return vehicleType == AUTONOMOUS;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isAutonomousVehicle(leadVehicle) && distance < 8.0f) {\n        std::cout << \"WARNING: Autonomous vehicle detected, adjust driving speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts collision warning when navigating a sharp curve at high speeds.",
      "input": "Vehicle speed: 120 km/h, Curve ahead: True, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isCurveAhead() {\n    return true; // Simulate curve ahead condition\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool curveAhead, float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 100.0f;\n    const float CURVE_THRESHOLD = 6.0f;\n    if (curveAhead && speed > HIGH_SPEED_THRESHOLD) {\n        return distance < CURVE_THRESHOLD;\n    } else {\n        return distance < 12.0f;\n    }\n}\n\nint main() {\n    bool curveAhead = isCurveAhead();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(curveAhead, speed, distance)) {\n        std::cout << \"WARNING: Collision risk in high-speed curve!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects potential lane departures and adjusts collision warnings based on vehicle position.",
      "input": "Lane departure detected: True, Vehicle speed: 90 km/h, Radar distance: 15 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulate lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 15.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool laneDeparture, float distance) {\n    const float LANE_DEPARTURE_THRESHOLD = 10.0f;\n    return laneDeparture && distance < LANE_DEPARTURE_THRESHOLD;\n}\n\nint main() {\n    bool laneDeparture = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(laneDeparture, distance)) {\n        std::cout << \"WARNING: Lane departure detected, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers automatic emergency braking when a collision risk is detected.",
      "input": "Collision risk: True, Vehicle speed: 70 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nbool isCollisionRisk() {\n    return true; // Simulate collision risk detection\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Vehicle speed in km/h\n}\n\nvoid triggerEmergencyBraking() {\n    std::cout << \"WARNING: Collision risk detected, emergency braking triggered!\" << std::endl;\n}\n\nint main() {\n    if (isCollisionRisk()) {\n        triggerEmergencyBraking();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for an FCW system to detect pedestrians using OpenCV. The system should estimate distance using bounding box size and alert the driver when a pedestrian is too close.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', use explicit type conversions, and include clear comments explaining logic and computations.",
      "output": "/* MISRA 2023-compliant C++ code detecting pedestrians */"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp> // OpenCV library for image processing\n#include <iostream>             // Standard I/O operations\n#include <cmath>                // Mathematical operations\n#include <string>               // String handling\n\n// Constants for the camera setup\nstatic const float FOCAL_LENGTH_X = 874.0F; // Focal length in x direction (pixels)\nstatic const float CAR_WIDTH_METERS = 1.8F; // Average car width in meters\nstatic const float COLLISION_THRESHOLD = 10.0F; // Warning threshold in meters\n\n// Structure to hold detected object data\nstruct DetectedObject {\n    cv::Rect bounding_box; // Object bounding box\n    float distance;        // Distance to the object in meters\n};\n\n// Function to calculate the estimated distance to an object\nstatic float calculate_distance(const int object_width_px, const int image_width_px)\n{\n    // Validate inputs to avoid division by zero\n    if (object_width_px <= 0 || image_width_px <= 0) {\n        return -1.0F; // Return invalid distance for error cases\n    }\n\n    // Compute the distance using a basic pinhole camera model\n    float distance = (CAR_WIDTH_METERS * FOCAL_LENGTH_X) / static_cast<float>(object_width_px);\n    return distance;\n}\n\n// Function to process an image and identify potential collision risks\nstatic void process_frame(cv::Mat &frame)\n{\n    // Simulate object detection (example bounding box)\n    cv::Rect detected_box(600, 400, 200, 100); // Example: object location\n    DetectedObject obj;\n    obj.bounding_box = detected_box;\n\n    // Calculate object distance using its pixel width\n    obj.distance = calculate_distance(obj.bounding_box.width, frame.cols);\n\n    // Draw bounding box and distance label on the frame\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2); // Green box\n    std::string distance_label = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_label, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10),\n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1);\n\n    // Check if the object is within the collision threshold\n    if (obj.distance > 0.0F && obj.distance < COLLISION_THRESHOLD) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(50, 50),\n                    cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\n// Main function to capture and process video frames\nint main(void)\n{\n    cv::VideoCapture video_capture(0); // Open the default camera\n    if (!video_capture.isOpened()) {\n        std::cerr << \"Error: Unable to open the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        video_capture >> frame; // Capture a frame\n        if (frame.empty()) {\n            break;\n        }\n\n        // Process the frame for collision warning\n        process_frame(frame);\n\n        // Display the processed frame\n        cv::imshow(\"Forward Collision Warning System\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(30) == 'q') {\n            break;\n        }\n    }\n\n    video_capture.release();\n    cv::destroyAllWindows();\n    return EXIT_SUCCESS;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\n// Camera parameters\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\n\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold.",
      "input": "Ensure compliance with MISRA standards. Avoid using 'using namespace'. Handle all type conversions explicitly.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object at a safe distance, which should not trigger a collision warning.",
      "input": "Object distance: 15 meters (greater than threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object at a collision distance (5 meters), which should trigger a warning.",
      "input": "Object distance: 5 meters (below threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object very close (2 meters) which should trigger a collision warning.",
      "input": "Object distance: 2 meters (well below threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with varying object sizes and distances to validate proper collision warning trigger.",
      "input": "Object at 12 meters, but with a very small bounding box. Distance is greater than the threshold.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 100, 50);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with no objects detected (empty frame), which should not trigger any warning.",
      "input": "Frame with no detected objects.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    // No detected objects, frame remains empty\n    cv::imshow(\"FCW - No Objects\", image);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with objects that do not require any warning due to their distance being well above the threshold.",
      "input": "Object distance: 20 meters (well above threshold).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 250, 125);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with objects detected at varying speeds and directions to see how the system responds.",
      "input": "Object moving at a high speed toward the vehicle.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 150, 75);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object detected at a safe distance (15 meters), which should not trigger any collision warning.",
      "input": "Object distance: 15 meters (well above threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object very close (2 meters), which should trigger a collision warning.",
      "input": "Object distance: 2 meters (well below threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with varying object sizes and distances to validate proper collision warning trigger.",
      "input": "Object at 12 meters, but with a very small bounding box. Distance is greater than the threshold.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 100, 50);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with no objects detected (empty frame), which should not trigger any warning.",
      "input": "Frame with no detected objects.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    // No object detected, no bounding box to process\n    cv::putText(image, \"No objects detected\", cv::Point(10, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object detected at varying angle (approaching from the side), ensuring proper collision warning.",
      "input": "Object at 8 meters approaching from the side of the vehicle.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(400, 400, 150, 75);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object moving in reverse direction, away from the vehicle, which should not trigger any warning.",
      "input": "Object at 12 meters, moving away from the vehicle.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 150, 75);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with a very small object (e.g., a motorcycle) detected at a safe distance of 20 meters.",
      "input": "Object (motorcycle) at 20 meters, no collision warning should be triggered.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 80, 40);  // Small object like a motorcycle\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object moving in the same direction as the vehicle, keeping a safe distance.",
      "input": "Object moving at the same speed as the car, distance: 10 meters.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object partially out of frame, but still within collision range.",
      "input": "Object partially out of frame at 9 meters, should trigger collision warning.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(800, 300, 100, 100);  // Object partially out of frame\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with multiple objects detected within the collision range (5 meters).",
      "input": "Multiple objects (2 cars) at 5 meters, both triggering the collision warning.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    std::vector<cv::Rect> detected_objects = {cv::Rect(500, 300, 200, 100), cv::Rect(800, 300, 180, 90)};\n    for (const auto &rect : detected_objects) {\n        DetectedObject obj;\n        obj.bounding_box = rect;\n        int object_width_in_image = obj.bounding_box.width;\n        obj.distance = calculate_distance(object_width_in_image, image.cols);\n        cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n        std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n        cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                    cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n        if (obj.distance < collision_threshold) {\n            cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                        1, cv::Scalar(0, 0, 255), 2);\n        }\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\n// Camera parameters\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\n\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n\n        if (frame.empty()) {\n            break;\n        }\n\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold.",
      "input": "Ensure compliance with MISRA standards. Avoid using 'using namespace'. Handle all type conversions explicitly.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object at a safe distance, which should not trigger a collision warning.",
      "input": "Object distance: 15 meters (greater than threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object at a collision distance (5 meters), which should trigger a warning.",
      "input": "Object distance: 5 meters (below threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object very close (2 meters) which should trigger a collision warning.",
      "input": "Object distance: 2 meters (well below threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with varying object sizes and distances to validate proper collision warning trigger.",
      "input": "Object at 12 meters, but with a very small bounding box. Distance is greater than the threshold.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 100, 50);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with no objects detected (empty frame), which should not trigger any warning.",
      "input": "Frame with no detected objects.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    // No detected objects, frame remains empty\n    cv::imshow(\"FCW - No Objects\", image);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with objects that do not require any warning due to their distance being well above the threshold.",
      "input": "Object distance: 20 meters (well above threshold).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 250, 125);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with objects detected at varying speeds and directions to see how the system responds.",
      "input": "Object moving at a high speed toward the vehicle.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 150, 75);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object detected at a safe distance (15 meters), which should not trigger any collision warning.",
      "input": "Object distance: 15 meters (well above threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object very close (2 meters), which should trigger a collision warning.",
      "input": "Object distance: 2 meters (well below threshold of 10 meters).",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 200, 100);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with varying object sizes and distances to validate proper collision warning trigger.",
      "input": "Object at 12 meters, but with a very small bounding box. Distance is greater than the threshold.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(600, 400, 100, 50);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with no objects detected (empty frame), which should not trigger any warning.",
      "input": "Frame with no detected objects.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    // No object detected, no bounding box to process\n    cv::putText(image, \"No objects detected\", cv::Point(10, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255, 0, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Test FCW system with an object detected at varying angle (approaching from the side), ensuring proper collision warning.",
      "input": "Object at 8 meters approaching from the side of the vehicle.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nconst float focal_length_x = 874.0f;\nconst float focal_length_y = 995.0f;\nconst float optical_center_x = 960.0f;\nconst float optical_center_y = 536.0f;\nconst float car_width = 1.8f;\nconst float collision_threshold = 10.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n    std::string label;\n};\n\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\nvoid process_image(cv::Mat &image) {\n    cv::Rect detected_object(400, 400, 150, 75);\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n    int object_width_in_image = obj.bounding_box.width;\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_image(frame);\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Lane Departure Warning (LDW) system using OpenCV. The system should detect lane markings and warn the driver if the vehicle deviates from its lane. Include robust error handling and detailed comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', use explicit casting where necessary, and provide detailed explanations for each function.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <vector>\n\nconst int lane_warning_threshold = 50;  // Warning threshold in pixels\n\nvoid process_frame(cv::Mat &frame) {\n    // Convert frame to grayscale\n    cv::Mat gray;\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Apply Canny edge detection\n    cv::Mat edges;\n    cv::Canny(gray, edges, 50, 150);\n\n    // Detect lines using Hough Transform\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 50, 50, 10);\n\n    for (const auto &line : lines) {\n        cv::line(frame, cv::Point(line[0], line[1]), cv::Point(line[2], line[3]), cv::Scalar(0, 255, 0), 2);\n    }\n\n    if (lines.size() < lane_warning_threshold) {\n        cv::putText(frame, \"Lane Departure Warning!\", cv::Point(50, 50),\n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    // Similar to FCW example\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "<Full code from the first example>"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for computer vision tasks\n#include <iostream>  // For console output\n#include <cstdlib>  // For system error handling\n\n// Constants for camera calibration\nconst float CAMERA_FOCAL_LENGTH_X = 874.0f;  // Focal length in pixels (x-axis)\nconst float AVERAGE_CAR_WIDTH = 1.8f;  // Approximate width of a car in meters\nconst float COLLISION_THRESHOLD = 10.0f;  // Distance threshold for collision warning (meters)\n\n// MISRA-compliant structure to represent detected objects\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Rectangle enclosing the detected object\n    float distance;         // Distance to the detected object (meters)\n    std::string label;      // Label identifying the object type\n};\n\n// Function to calculate the distance to an object based on its apparent width in the image\nfloat calculate_distance(const int object_width_pixels, const int image_width_pixels) {\n    if (object_width_pixels == 0) {\n        return -1.0f;  // Return an invalid distance if object width is zero\n    }\n    // Distance calculation using the pinhole camera model\n    return (AVERAGE_CAR_WIDTH * CAMERA_FOCAL_LENGTH_X) / static_cast<float>(object_width_pixels);\n}\n\n// Function to process an image frame and detect objects\nvoid process_frame(cv::Mat& frame) {\n    // Example hardcoded detection (normally this would involve a trained detector)\n    cv::Rect detected_object(600, 400, 200, 100);  // Hardcoded bounding box\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Compute the distance to the detected object\n    const int object_width = obj.bounding_box.width;\n    const int image_width = frame.cols;\n    obj.distance = calculate_distance(object_width, image_width);\n\n    // Draw bounding box and label on the frame\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10),\n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Trigger collision warning if the distance is below the threshold\n    if (obj.distance < COLLISION_THRESHOLD && obj.distance > 0) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50),\n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture video_capture(0);  // Open default camera\n\n    if (!video_capture.isOpened()) {\n        std::cerr << \"ERROR: Unable to open the camera.\" << std::endl;\n        return EXIT_FAILURE;  // Exit if the camera cannot be accessed\n    }\n\n    cv::Mat frame;\n    while (true) {\n        video_capture >> frame;  // Capture a frame\n\n        if (frame.empty()) {\n            break;  // Exit loop if no frame is captured\n        }\n\n        process_frame(frame);  // Process the captured frame\n\n        cv::imshow(\"Forward Collision Warning\", frame);  // Display the frame\n\n        if (cv::waitKey(1) == static_cast<int>('q')) {\n            break;  // Exit on 'q' key press\n        }\n    }\n\n    video_capture.release();  // Release the camera\n    cv::destroyAllWindows();  // Close OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Lane Departure Warning (LDW) system using OpenCV. The system should detect lane markings and warn the driver if the vehicle deviates from its lane. Include robust error handling and detailed comments.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', use explicit casting where necessary, and provide detailed explanations for each function.",
      "output": "#include <opencv2/opencv.hpp>  // OpenCV library for image processing\n#include <iostream>  // For console output\n\nconst int LANE_WARNING_THRESHOLD = 2;  // Threshold for detecting lane deviation\n\nvoid process_frame(cv::Mat& frame) {\n    cv::Mat gray_frame;\n    cv::cvtColor(frame, gray_frame, cv::COLOR_BGR2GRAY);  // Convert to grayscale\n\n    cv::Mat edges;\n    cv::Canny(gray_frame, edges, 50, 150);  // Apply edge detection\n\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 50, 50, 10);  // Detect lines\n\n    for (std::size_t i = 0; i < lines.size(); ++i) {\n        const cv::Vec4i& line = lines[i];\n        cv::line(frame, cv::Point(line[0], line[1]), cv::Point(line[2], line[3]), cv::Scalar(0, 255, 0), 2);\n    }\n\n    if (lines.size() < LANE_WARNING_THRESHOLD) {\n        cv::putText(frame, \"WARNING: LANE DEPARTURE\", cv::Point(50, 50),\n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture video_capture(0);\n    if (!video_capture.isOpened()) {\n        std::cerr << \"ERROR: Unable to open the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        video_capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_frame(frame);\n        cv::imshow(\"Lane Departure Warning\", frame);\n        if (cv::waitKey(1) == static_cast<int>('q')) {\n            break;\n        }\n    }\n\n    video_capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and provide detailed comments for key operations.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float CAMERA_FOCAL_LENGTH_X = 874.0f; // Camera focal length in pixels\nconst float AVERAGE_CAR_WIDTH = 1.8f;      // Average car width in meters\nconst float COLLISION_THRESHOLD = 10.0f;  // Collision threshold in meters\n\nstruct DetectedObject {\n    cv::Rect bounding_box; // Object bounding box\n    float distance;         // Distance to the object\n    std::string label;      // Object label (e.g., 'car')\n};\n\n// Function to calculate the distance to an object\nfloat calculate_distance(const int object_width_pixels) {\n    if (object_width_pixels <= 0) {\n        return -1.0f; // Return invalid distance for incorrect inputs\n    }\n    return (AVERAGE_CAR_WIDTH * CAMERA_FOCAL_LENGTH_X) / static_cast<float>(object_width_pixels);\n}\n\n// Function to process image and detect objects\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(500, 300, 100, 50); // Simulated detection\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate distance and check collision\n    obj.distance = calculate_distance(obj.bounding_box.width);\n    if (obj.distance < COLLISION_THRESHOLD) {\n        std::cout << \"Collision Warning! Object detected at distance: \" << obj.distance << \" meters.\\n\";\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0); // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame; // Capture frame\n        if (frame.empty()) {\n            break; // End if no frame\n        }\n\n        process_frame(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for implementing a Lane Departure Warning (LDW) system using OpenCV. The system should detect lane markings and issue warnings if the vehicle deviates from its lane.",
      "input": "Ensure compliance with MISRA standards: use explicit casting, avoid global variables, and document all functions.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <vector>\n\n// Function to detect lanes using Hough Transform\nvoid detect_lanes(const cv::Mat &input_frame, cv::Mat &output_frame) {\n    cv::Mat gray, edges;\n\n    // Convert to grayscale\n    cv::cvtColor(input_frame, gray, cv::COLOR_BGR2GRAY);\n\n    // Edge detection\n    cv::Canny(gray, edges, 50, 150);\n\n    // Hough Transform to detect lines\n    std::vector<cv::Vec4i> lines;\n    cv::HoughLinesP(edges, lines, 1, CV_PI / 180, 50, 50, 10);\n\n    // Draw the detected lines\n    output_frame = input_frame.clone();\n    for (const auto &line : lines) {\n        cv::line(output_frame, cv::Point(line[0], line[1]), cv::Point(line[2], line[3]), cv::Scalar(0, 255, 0), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to access camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame, output;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        detect_lanes(frame, output);\n        cv::imshow(\"Lane Departure Warning\", output);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for a Traffic Sign Recognition (TSR) system. The system should detect traffic signs in an image and classify them into predefined categories.",
      "input": "Ensure adherence to MISRA standards: handle exceptions properly, avoid dynamic memory allocation, and use explicit type conversions.",
      "output": "#include <opencv2/opencv.hpp>\n#include <opencv2/ml.hpp>\n#include <iostream>\n#include <vector>\n\n// Function to classify traffic signs\nvoid classify_signs(const cv::Mat &input_frame) {\n    cv::CascadeClassifier traffic_sign_cascade;\n    if (!traffic_sign_cascade.load(\"traffic_sign.xml\")) {\n        std::cerr << \"ERROR: Unable to load classifier.\" << std::endl;\n        return;\n    }\n\n    std::vector<cv::Rect> detected_signs;\n    cv::Mat gray;\n    cv::cvtColor(input_frame, gray, cv::COLOR_BGR2GRAY);\n\n    traffic_sign_cascade.detectMultiScale(gray, detected_signs);\n    for (const auto &sign : detected_signs) {\n        cv::rectangle(input_frame, sign, cv::Scalar(0, 255, 0), 2);\n        std::cout << \"Traffic sign detected at: \" << sign.x << \", \" << sign.y << std::endl;\n    }\n\n    cv::imshow(\"Traffic Sign Recognition\", input_frame);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to access camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        classify_signs(frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should detect objects in a video feed and warn if they are within a critical distance.",
      "input": "Ensure the code uses explicit type conversions, handles invalid inputs, and avoids 'using namespace'. Include test cases to validate functionality.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Constants for camera and collision threshold\nconst float CAMERA_FOCAL_LENGTH_X = 874.0f;\nconst float AVERAGE_CAR_WIDTH = 1.8f;\nconst float COLLISION_THRESHOLD = 10.0f;\n\n// Function to calculate the distance to an object\nfloat calculate_distance(const int object_width_pixels) {\n    if (object_width_pixels <= 0) {\n        return -1.0f; // Invalid input\n    }\n    return (AVERAGE_CAR_WIDTH * CAMERA_FOCAL_LENGTH_X) / static_cast<float>(object_width_pixels);\n}\n\n// Process each video frame for object detection and collision check\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(500, 300, 100, 50); // Simulated detection\n\n    // Calculate the object's distance\n    float distance = calculate_distance(detected_object.width);\n\n    // Draw bounding box and display distance\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(detected_object.x, detected_object.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    // Trigger collision warning if below threshold\n    if (distance < COLLISION_THRESHOLD && distance > 0.0f) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(200, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        process_frame(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create a MISRA 2023-compliant C++ program for an FCW system with dynamic threshold adjustment based on vehicle speed. The program should detect objects and calculate distance, adjusting the collision warning threshold dynamically.",
      "input": "Make sure to properly handle type casting and ensure all calculations are performed with safe casting methods. Implement speed-based threshold adjustments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Constants\nconst float BASE_COLLISION_THRESHOLD = 10.0f;\nconst float SPEED_THRESHOLD = 30.0f; // 30 km/h\nconst float CAR_WIDTH = 1.8f;\nconst float CAMERA_FOCAL_LENGTH = 874.0f;\n\n// Function to calculate distance to an object\nfloat calculate_distance(int object_width_pixels) {\n    return (CAR_WIDTH * CAMERA_FOCAL_LENGTH) / static_cast<float>(object_width_pixels);\n}\n\n// Function to adjust collision threshold based on speed\nfloat adjust_threshold(float vehicle_speed_kmh) {\n    return vehicle_speed_kmh > SPEED_THRESHOLD ? BASE_COLLISION_THRESHOLD - 2.0f : BASE_COLLISION_THRESHOLD;\n}\n\n// Process video frame for object detection and collision checking\nvoid process_frame(cv::Mat &frame, float vehicle_speed) {\n    cv::Rect detected_object(500, 300, 100, 50); // Simulated detection\n    float distance = calculate_distance(detected_object.width);\n    float threshold = adjust_threshold(vehicle_speed);\n\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(detected_object.x, detected_object.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);\n\n    if (distance < threshold) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(200, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    float vehicle_speed = 50.0f; // Simulated speed\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        process_frame(frame, vehicle_speed);\n        cv::imshow(\"Forward Collision Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ FCW system with obstacle detection using a stereo camera. Calculate depth information and trigger the warning if the object is too close.",
      "input": "Ensure that stereo depth estimation is performed correctly, avoid complex data types, and handle any exceptions in the code.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n\n// Constants\nconst float CAR_WIDTH = 1.8f;\nconst float COLLISION_THRESHOLD = 8.0f; // meters\nconst float CAMERA_FOCAL_LENGTH = 874.0f;\n\n// Function to compute the distance using stereo depth\nfloat calculate_distance_stereo(int pixel_disparity, int baseline) {\n    return (CAR_WIDTH * CAMERA_FOCAL_LENGTH * baseline) / static_cast<float>(pixel_disparity);\n}\n\n// Process stereo image to detect obstacles and calculate distance\nvoid process_stereo_image(cv::Mat &left_frame, cv::Mat &right_frame) {\n    // Compute disparity map (using OpenCV stereo block matching)\n    cv::Mat disparity;\n    cv::StereoBM stereo_matcher;\n    stereo_matcher(left_frame, right_frame, disparity);\n\n    // Calculate distance using disparity\n    int disparity_value = disparity.at<uchar>(240, 320);  // Sample pixel\n    float distance = calculate_distance_stereo(disparity_value, 60);  // 60 cm baseline\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat left_frame, right_frame;\n    // Simulate stereo image capture (not implemented here)\n    process_stereo_image(left_frame, right_frame);\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ code to implement a Forward Collision Warning system with object tracking. Use OpenCV to detect moving vehicles and issue warnings if the distance is below the threshold.",
      "input": "Ensure safe handling of object tracking and avoid undefined behavior by explicitly managing object lifetimes.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\n// Constants\nconst float COLLISION_THRESHOLD = 10.0f; // meters\nconst float CAR_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 874.0f;\n\n// Function to calculate distance based on object size\nfloat calculate_distance(int object_width) {\n    return (CAR_WIDTH * FOCAL_LENGTH) / static_cast<float>(object_width);\n}\n\n// Function to track objects\nvoid track_objects(cv::Mat &frame) {\n    cv::Rect detected_object(400, 200, 80, 40);  // Simulated detected object\n    float distance = calculate_distance(detected_object.width);\n\n    if (distance < COLLISION_THRESHOLD) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(200, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);\n}\n\nint main() {\n    cv::Mat frame;\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Cannot access camera.\" << std::endl;\n        return -1;\n    }\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        track_objects(frame);\n        cv::imshow(\"FCW System\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create a C++ Forward Collision Warning system using a single camera. The system should issue a warning based on object detection and calculate distance using a fixed camera angle.",
      "input": "Ensure all objects are validated before calculations, and avoid any potential memory leaks by properly releasing resources.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 12.0f;\nconst float CAR_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 874.0f;\n\nfloat calculate_distance(int object_width) {\n    return (CAR_WIDTH * FOCAL_LENGTH) / static_cast<float>(object_width);\n}\n\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_object(300, 250, 90, 45);  // Simulated detected object\n    float distance = calculate_distance(detected_object.width);\n    if (distance < COLLISION_THRESHOLD) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(100, 50), \n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Camera not accessible.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        process_frame(frame);\n        cv::imshow(\"FCW System\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create an FCW system for vehicles that uses LIDAR data to compute the relative position and speed of objects in the environment.",
      "input": "Ensure proper handling of raw sensor data and that all mathematical operations are performed within range to avoid overflow or underflow.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float LIDAR_RANGE = 100.0f; // max lidar range in meters\nconst float COLLISION_THRESHOLD = 5.0f;\n\n// Function to calculate relative speed\nfloat calculate_relative_speed(float lidar_distance, float lidar_angle) {\n    return (lidar_distance * std::cos(lidar_angle));\n}\n\n// Function to process lidar data\nvoid process_lidar_data(float distance, float angle) {\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 3.0f;  // Example distance\n    float lidar_angle = 0.5f;     // Example angle\n    process_lidar_data(lidar_distance, lidar_angle);\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ program for a forward collision warning system using radar data. The system should warn when an object enters the danger zone.",
      "input": "Ensure radar data processing avoids buffer overflow and that the system handles large input sizes efficiently.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float RADAR_RANGE = 50.0f;\nconst float COLLISION_THRESHOLD = 10.0f;\n\nfloat calculate_distance(float radar_signal_strength) {\n    return RADAR_RANGE / radar_signal_strength;\n}\n\nvoid process_radar_data(float radar_signal_strength) {\n    float distance = calculate_distance(radar_signal_strength);\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_signal_strength = 0.2f;  // Example strength\n    process_radar_data(radar_signal_strength);\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program to implement an FCW system that can calculate distance using both camera and radar sensor data, with priority given to radar data.",
      "input": "Ensure sensor fusion algorithms are implemented correctly and all data fusion operations are handled safely.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 10.0f;\nconst float RADAR_RANGE = 50.0f;\n\n// Function to calculate distance from radar data\nfloat calculate_radar_distance(float radar_signal_strength) {\n    return RADAR_RANGE / radar_signal_strength;\n}\n\n// Function to calculate distance from camera data\nfloat calculate_camera_distance(int object_width) {\n    return 1.8f * 874.0f / static_cast<float>(object_width);\n}\n\nvoid process_sensor_data(float radar_signal_strength, int camera_object_width) {\n    float radar_distance = calculate_radar_distance(radar_signal_strength);\n    float camera_distance = calculate_camera_distance(camera_object_width);\n    float distance = std::min(radar_distance, camera_distance);\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_signal_strength = 0.4f;\n    int camera_object_width = 90;\n    process_sensor_data(radar_signal_strength, camera_object_width);\n    return 0;\n}"
    },
    {
      "instruction": "Create an FCW system that uses ultrasonic sensors to measure proximity to obstacles and issue a warning when an object is too close.",
      "input": "Ensure that ultrasonic sensor data is handled properly and that safety margins are respected in all calculations.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float ULTRASONIC_MAX_RANGE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nfloat calculate_distance_from_ultrasonic(float signal_time) {\n    return (signal_time * 343.0f) / 2.0f;  // speed of sound = 343 m/s\n}\n\nvoid process_ultrasonic_data(float signal_time) {\n    float distance = calculate_distance_from_ultrasonic(signal_time);\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_signal_time = 0.005f;  // Example signal time\n    process_ultrasonic_data(ultrasonic_signal_time);\n    return 0;\n}"
    },
    {
      "instruction": "Create an FCW system that uses vehicle speed and sensor data to predict possible collisions, issuing warnings if the risk of collision is high.",
      "input": "Ensure that vehicle speed and sensor data are integrated correctly and that all calculations are performed using proper casting and range checks.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 10.0f;  // meters\nconst float SPEED_THRESHOLD = 30.0f;  // km/h\n\nfloat calculate_distance(float object_speed, float time_to_impact) {\n    return object_speed * time_to_impact;\n}\n\nvoid process_vehicle_data(float vehicle_speed, float time_to_impact) {\n    float distance = calculate_distance(vehicle_speed, time_to_impact);\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 40.0f;  // Example speed\n    float time_to_impact = 0.5f;  // Example time\n    process_vehicle_data(vehicle_speed, time_to_impact);\n    return 0;\n}"
    },
    {
      "instruction": "Create a C++ Forward Collision Warning system that uses a monocular camera to detect obstacles, estimate their size, and compute their distance.",
      "input": "Ensure proper handling of camera parameters and that object detection is robust to different lighting conditions.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float FOCAL_LENGTH = 800.0f;  // Focal length of the camera\nconst float CAR_WIDTH = 1.8f;  // Average car width\nconst float COLLISION_THRESHOLD = 5.0f;  // Threshold distance for warning\n\n// Function to estimate distance to object based on image width\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    return (CAR_WIDTH * FOCAL_LENGTH * image_width) / (object_width_in_image * FOCAL_LENGTH);\n}\n\nvoid detect_obstacles(cv::Mat &frame) {\n    // Simulated object detection with a bounding box\n    cv::Rect detected_object(200, 200, 100, 50);  // Example bounding box\n    int object_width_in_image = detected_object.width;\n    float distance = calculate_distance(object_width_in_image, frame.cols);\n\n    // Display warning if distance is below threshold\n    if (distance < COLLISION_THRESHOLD) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT!\", cv::Point(150, 50),\n                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n}\n\nint main() {\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Cannot access camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        detect_obstacles(frame);\n        cv::imshow(\"FCW System\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ program for a Forward Collision Warning system that uses stereo vision to estimate the distance to detected objects.",
      "input": "Make sure the disparity map is calculated correctly, and include error handling for invalid image data.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float BASELINE = 0.5f;  // Stereo camera baseline in meters\nconst float FOCAL_LENGTH = 800.0f;  // Focal length of the camera\nconst float COLLISION_THRESHOLD = 6.0f;  // Collision warning threshold in meters\n\n// Function to calculate distance from disparity\nfloat calculate_distance_from_disparity(float disparity) {\n    return (BASELINE * FOCAL_LENGTH) / disparity;\n}\n\nvoid process_stereo_frame(cv::Mat &left_frame, cv::Mat &right_frame) {\n    // Convert images to grayscale\n    cv::Mat gray_left, gray_right;\n    cv::cvtColor(left_frame, gray_left, cv::COLOR_BGR2GRAY);\n    cv::cvtColor(right_frame, gray_right, cv::COLOR_BGR2GRAY);\n\n    // Calculate disparity map\n    cv::Ptr<cv::StereoBM> stereo = cv::StereoBM::create();\n    cv::Mat disparity_map;\n    stereo->compute(gray_left, gray_right, disparity_map);\n\n    // Find the minimum disparity for an object\n    float min_disparity = cv::minMaxLoc(disparity_map).minVal;\n    float distance = calculate_distance_from_disparity(min_disparity);\n\n    // Display warning if distance is below threshold\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    cv::VideoCapture left_cam(0);  // Left camera\n    cv::VideoCapture right_cam(1);  // Right camera\n\n    if (!left_cam.isOpened() || !right_cam.isOpened()) {\n        std::cerr << \"Error: Cannot access one or both cameras.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat left_frame, right_frame;\n    while (true) {\n        left_cam >> left_frame;\n        right_cam >> right_frame;\n\n        if (left_frame.empty() || right_frame.empty()) {\n            break;\n        }\n        process_stereo_frame(left_frame, right_frame);\n        cv::imshow(\"Stereo FCW System\", left_frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ program that uses radar data to estimate the distance to detected objects for a Forward Collision Warning system.",
      "input": "Ensure radar signal processing handles high noise levels and invalid readings.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float RADAR_MAX_RANGE = 100.0f;  // Radar maximum range in meters\nconst float COLLISION_THRESHOLD = 10.0f;  // Distance threshold for warning\n\n// Function to calculate distance based on radar signal strength\nfloat calculate_distance_from_radar(float radar_signal_strength) {\n    if (radar_signal_strength == 0.0f) {\n        return RADAR_MAX_RANGE;  // Invalid signal, return max range\n    }\n    return RADAR_MAX_RANGE / radar_signal_strength;\n}\n\nvoid process_radar_data(float radar_signal_strength) {\n    float distance = calculate_distance_from_radar(radar_signal_strength);\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_signal_strength = 0.5f;  // Example radar signal strength\n    process_radar_data(radar_signal_strength);\n    return 0;\n}"
    },
    {
      "instruction": "Create a C++ FCW system that integrates both camera and LIDAR data to provide collision warnings.",
      "input": "Ensure the system uses appropriate calibration for both sensors and handles sensor data fusion correctly.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float CAR_WIDTH = 1.8f;  // Assumed average car width\nconst float FOCAL_LENGTH = 800.0f;  // Camera focal length\nconst float LIDAR_RANGE = 100.0f;  // LIDAR maximum range\nconst float COLLISION_THRESHOLD = 5.0f;  // Warning threshold distance\n\n// Function to calculate distance using camera data\nfloat calculate_camera_distance(int object_width) {\n    return (CAR_WIDTH * FOCAL_LENGTH) / static_cast<float>(object_width);\n}\n\n// Function to calculate distance using LIDAR data\nfloat calculate_lidar_distance(float lidar_signal_strength) {\n    return LIDAR_RANGE / lidar_signal_strength;\n}\n\nvoid process_data(float lidar_signal_strength, int object_width) {\n    float lidar_distance = calculate_lidar_distance(lidar_signal_strength);\n    float camera_distance = calculate_camera_distance(object_width);\n    float distance = std::min(lidar_distance, camera_distance);\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_signal_strength = 0.6f;  // Example LIDAR signal strength\n    int object_width = 120;  // Example object width in image\n    process_data(lidar_signal_strength, object_width);\n    return 0;\n}"
    },
    {
      "instruction": "Write a C++ FCW system that uses ultrasonic sensors to measure the proximity to obstacles and trigger warnings when an object is detected too close.",
      "input": "Ensure sensor calibration is handled correctly and that all edge cases, such as extreme sensor values, are accounted for.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float ULTRASONIC_MAX_RANGE = 10.0f;  // Max range of ultrasonic sensor in meters\nconst float COLLISION_THRESHOLD = 2.0f;  // Proximity threshold for warning\n\nfloat calculate_distance_from_signal(float signal_time) {\n    return (signal_time * 343.0f) / 2.0f;  // speed of sound = 343 m/s\n}\n\nvoid process_ultrasonic_data(float signal_time) {\n    float distance = calculate_distance_from_signal(signal_time);\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float signal_time = 0.005f;  // Example signal time in seconds\n    process_ultrasonic_data(signal_time);\n    return 0;\n}"
    },
    {
      "instruction": "Design a C++ Forward Collision Warning system that uses machine learning to predict collision risk based on sensor inputs.",
      "input": "Ensure the ML model is trained with realistic data and that the prediction process is optimized for real-time performance.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\n// Assuming a pre-trained machine learning model is available\nfloat predict_collision_risk(const cv::Mat &sensor_data) {\n    // Simulated prediction (this would be a model inference in real scenario)\n    return 0.75f;  // Simulated collision risk prediction\n}\n\nvoid process_sensor_data(cv::Mat &sensor_data) {\n    float risk = predict_collision_risk(sensor_data);\n    if (risk > 0.7f) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat sensor_data;  // Simulated sensor data\n    process_sensor_data(sensor_data);\n    return 0;\n}"
    },
    {
      "instruction": "Create a C++ FCW system using radar and camera data that triggers a warning when objects are detected too close.",
      "input": "Ensure proper synchronization of radar and camera data and handle timeouts and invalid sensor readings.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float CAR_WIDTH = 1.8f;  // Assumed average car width\nconst float FOCAL_LENGTH = 800.0f;  // Camera focal length\nconst float RADAR_MAX_RANGE = 100.0f;  // Radar max range\nconst float COLLISION_THRESHOLD = 5.0f;  // Warning threshold distance\n\n// Function to calculate distance from radar data\nfloat calculate_radar_distance(float radar_signal_strength) {\n    return RADAR_MAX_RANGE / radar_signal_strength;\n}\n\n// Function to calculate distance from camera data\nfloat calculate_camera_distance(int object_width) {\n    return (CAR_WIDTH * FOCAL_LENGTH) / static_cast<float>(object_width);\n}\n\nvoid process_data(float radar_signal_strength, int object_width) {\n    float radar_distance = calculate_radar_distance(radar_signal_strength);\n    float camera_distance = calculate_camera_distance(object_width);\n    float distance = std::min(radar_distance, camera_distance);\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_signal_strength = 0.8f;  // Example radar signal strength\n    int object_width = 120;  // Example object width\n    process_data(radar_signal_strength, object_width);\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ system that uses a forward-facing camera to detect objects in the path of a moving vehicle and generate a warning if an object is too close.",
      "input": "Ensure object detection works under varying lighting conditions and handle edge cases, such as occlusions.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float FOCAL_LENGTH = 800.0f;  // Camera focal length\nconst float CAR_WIDTH = 1.8f;  // Average car width\nconst float COLLISION_THRESHOLD = 3.0f;  // Distance threshold for warning\n\n// Function to calculate distance to object\nfloat calculate_distance(int object_width) {\n    return (CAR_WIDTH * FOCAL_LENGTH) / static_cast<float>(object_width);\n}\n\nvoid detect_objects(cv::Mat &frame) {\n    // Simulate object detection\n    cv::Rect detected_object(150, 150, 50, 25);  // Example bounding box\n    float distance = calculate_distance(detected_object.width);\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);\n}\n\nint main() {\n    cv::VideoCapture cap(0);  // Open camera\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Cannot access camera.\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        detect_objects(frame);\n        cv::imshow(\"FCW System\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using stereo cameras to compute depth information and issue warnings for objects within a 10-meter range.",
      "input": "Adhere to MISRA standards: validate camera inputs, handle all exceptions, and provide comments for depth calculations.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV for stereo image processing\n#include <iostream>  // For input and output operations\n\n// Threshold distance for collision warning\nconst float COLLISION_THRESHOLD = 10.0f;\n\n// Function to calculate depth using stereo disparity\nfloat calculate_depth(float disparity, float baseline, float focal_length) {\n    // Ensure disparity is not zero to avoid division by zero\n    if (disparity <= 0.0f) {\n        return -1.0f;  // Return error value if disparity is invalid\n    }\n    return (baseline * focal_length) / disparity;\n}\n\nint main() {\n    cv::Mat left_image, right_image;\n\n    // Load stereo images (simulated for demonstration)\n    left_image = cv::imread(\"left.jpg\", cv::IMREAD_GRAYSCALE);\n    right_image = cv::imread(\"right.jpg\", cv::IMREAD_GRAYSCALE);\n\n    if (left_image.empty() || right_image.empty()) {\n        std::cerr << \"Error: Could not load images.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Compute disparity map (example with OpenCV StereoBM)\n    cv::Ptr<cv::StereoBM> stereo = cv::StereoBM::create();\n    cv::Mat disparity;\n    stereo->compute(left_image, right_image, disparity);\n\n    // Example baseline and focal length values\n    float baseline = 0.1f;  // Distance between cameras in meters\n    float focal_length = 800.0f;  // Focal length in pixels\n\n    // Calculate depth at a specific point (e.g., center of detected object)\n    float depth = calculate_depth(disparity.at<float>(200, 200), baseline, focal_length);\n\n    if (depth > 0.0f && depth < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected at \" << depth << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system using a radar sensor to detect object distances and issue collision warnings when the distance is less than 6 meters.",
      "input": "Follow MISRA rules: validate radar data inputs, avoid global variables, and include detailed error-handling mechanisms.",
      "output": "#include <radar_library.hpp>  // Include radar library\n#include <iostream>  // For input and output operations\n\n// Threshold distance for collision warning\nconst float COLLISION_THRESHOLD = 6.0f;\n\nint main() {\n    // Simulate radar distance reading (example value for demonstration)\n    float radar_distance = 5.5f;\n\n    // Check if distance is below threshold\n    if (radar_distance > 0.0f && radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision imminent. Distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to monitor objects in close proximity and issue warnings when objects are detected within 2 meters.",
      "input": "Ensure compliance with MISRA standards: handle sensor data validation explicitly and include comments for proximity checks.",
      "output": "#include <iostream>  // For standard input and output\n\n// Threshold for collision warning\nconst float COLLISION_THRESHOLD = 2.0f;\n\nint main() {\n    // Simulate ultrasonic sensor reading\n    float sensor_distance = 1.8f;\n\n    // Check proximity and issue warning\n    if (sensor_distance > 0.0f && sensor_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected at \" << sensor_distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses LiDAR to detect objects and measure distances, issuing warnings for objects closer than 7 meters.",
      "input": "Adhere to MISRA standards: handle edge cases for missing LiDAR points, ensure safe type conversions, and include detailed comments for all operations.",
      "output": "#include <lidar_library.hpp>  // Example placeholder for LiDAR library\n#include <iostream>  // For input-output operations\n\n// Threshold distance for collision warning\nconst float COLLISION_THRESHOLD = 7.0f;\n\nint main() {\n    // Simulate LiDAR distance reading (example value)\n    float lidar_distance = 6.5f;\n\n    // Validate and process distance\n    if (lidar_distance > 0.0f && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected within \" << lidar_distance << \" meters.\" << std::endl;\n    } else if (lidar_distance <= 0.0f) {\n        std::cerr << \"Error: Invalid distance reading.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that integrates both camera and radar sensors to provide distance and speed estimation for objects.",
      "input": "Ensure proper synchronization of sensor data, detailed commenting for each step, and strict adherence to MISRA guidelines.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <radar_library.hpp>  // Example placeholder for radar library\n#include <iostream>\n\n// Collision warning threshold\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0f;\n\nint main() {\n    // Simulated sensor data\n    float radar_distance = 4.8f;\n    cv::Rect detected_object(100, 100, 50, 50);  // Example bounding box\n\n    // Check conditions for collision warning\n    if (radar_distance > 0.0f && radar_distance < COLLISION_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Object at \" << radar_distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses depth sensors to monitor objects in the front of a vehicle and trigger warnings for distances under 3 meters.",
      "input": "Ensure detailed commenting, safe handling of invalid sensor data, and compliance with MISRA standards.",
      "output": "#include <depth_sensor_library.hpp>  // Example placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;\n\nint main() {\n    // Example depth sensor reading\n    float depth_distance = 2.5f;\n\n    // Collision warning check\n    if (depth_distance > 0.0f && depth_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision imminent! Distance: \" << depth_distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using OpenCV to calculate object size and trigger warnings if the distance is below 4 meters.",
      "input": "Include error handling for invalid frames, detailed comments for each step, and explicit type conversions.",
      "output": "#include <opencv2/opencv.hpp>  // Include OpenCV library\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;\nconst float KNOWN_OBJECT_WIDTH = 2.0f;\n\nint main() {\n    cv::VideoCapture capture(0);\n    if (!capture.isOpened()) {\n        std::cerr << \"Error: Could not open video stream.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (capture.read(frame)) {\n        cv::Rect object(100, 100, 50, 50);\n        float distance = (800.0f * KNOWN_OBJECT_WIDTH) / object.width;\n        if (distance < COLLISION_THRESHOLD) {\n            std::cout << \"Warning: Object detected at \" << distance << \" meters.\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system using time-to-collision calculations derived from vehicle speed and object distance.",
      "input": "Adhere to MISRA rules: validate speed and distance inputs, use fixed-point arithmetic where applicable, and include detailed comments.",
      "output": "#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;\n\nint main() {\n    float vehicle_speed = 20.0f;  // m/s\n    float object_distance = 30.0f;  // meters\n    float time_to_collision = object_distance / vehicle_speed;\n\n    if (time_to_collision < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision imminent in \" << time_to_collision << \" seconds.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect obstacles within a 2-meter range and trigger warnings.",
      "input": "Ensure safe handling of sensor values, use explicit type conversions, and include detailed commenting in the code.",
      "output": "#include <ultrasonic_library.hpp>  // Placeholder for ultrasonic sensor library\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;\n\nint main() {\n    float ultrasonic_distance = 1.8f;  // Simulated ultrasonic reading\n\n    if (ultrasonic_distance > 0.0f && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected within \" << ultrasonic_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"All clear.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system that monitors multiple lanes using stereo vision and detects vehicles at risk of collision.",
      "input": "Include robust error handling for missing frames, ensure compliance with MISRA standards, and provide detailed comments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;\n\nint main() {\n    cv::Mat left_frame, right_frame;\n    cv::VideoCapture left_capture(0), right_capture(1);\n\n    if (!left_capture.isOpened() || !right_capture.isOpened()) {\n        std::cerr << \"Error: Cameras not opened.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    while (true) {\n        left_capture.read(left_frame);\n        right_capture.read(right_frame);\n\n        if (left_frame.empty() || right_frame.empty()) {\n            break;\n        }\n\n        // Simulated distance from stereo vision (replace with real calculations)\n        float distance = 4.5f;\n        if (distance < COLLISION_THRESHOLD) {\n            std::cout << \"Warning: Vehicle detected at \" << distance << \" meters.\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using accelerometer data to predict sudden deceleration events and alert drivers.",
      "input": "Ensure safe type conversions, include error handling for invalid sensor data, and provide detailed comments.",
      "output": "#include <accelerometer_library.hpp>  // Placeholder for accelerometer library\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = -5.0f;  // m/s^2\n\nint main() {\n    float acceleration = -6.0f;  // Simulated accelerometer reading\n\n    if (acceleration < DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sudden deceleration detected!\" << std::endl;\n    } else {\n        std::cout << \"Normal driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that integrates rear camera data to prevent rear-end collisions.",
      "input": "Handle invalid frame inputs gracefully, ensure safe pointer usage, and provide comments for clarity.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;\n\nint main() {\n    cv::Mat frame;\n    cv::VideoCapture rear_camera(0);\n\n    if (!rear_camera.isOpened()) {\n        std::cerr << \"Error: Rear camera not accessible.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    while (true) {\n        rear_camera.read(frame);\n\n        if (frame.empty()) {\n            break;\n        }\n\n        // Simulated distance calculation\n        float distance = 2.8f;\n        if (distance < COLLISION_THRESHOLD) {\n            std::cout << \"Warning: Rear collision risk! Distance: \" << distance << \" meters.\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lane departure warnings to detect risky scenarios.",
      "input": "Ensure safe handling of sensor inputs, avoid dynamic memory allocation, and include MISRA-compliant comments.",
      "output": "#include <lane_detection_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float LANE_WARNING_DISTANCE = 1.5f;\n\nint main() {\n    float lane_distance = 1.2f;  // Simulated lane distance\n\n    if (lane_distance < LANE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Vehicle close to lane boundary.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system to predict collisions based on vehicle speed and obstacle detection.",
      "input": "Provide detailed comments, handle edge cases, and ensure type safety.",
      "output": "#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;\n\nint main() {\n    float vehicle_speed = 25.0f;  // m/s\n    float obstacle_distance = 40.0f;  // meters\n    float reaction_time = 1.5f;  // seconds\n\n    float stopping_distance = vehicle_speed * reaction_time;\n\n    if (stopping_distance >= obstacle_distance) {\n        std::cout << \"Warning: Collision predicted.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using thermal cameras to detect objects at night.",
      "input": "Handle invalid thermal readings, ensure compliance with MISRA rules, and include descriptive comments.",
      "output": "#include <thermal_camera_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.5f;\n\nint main() {\n    float thermal_distance = 3.0f;  // Simulated thermal detection\n\n    if (thermal_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk at night. Distance: \" << thermal_distance << \" meters.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using proximity sensors in parking scenarios.",
      "input": "Include safe conversions and detailed comments for parking-specific collision warnings.",
      "output": "#include <proximity_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float PARKING_THRESHOLD = 1.0f;\n\nint main() {\n    float proximity_distance = 0.8f;  // Simulated reading\n\n    if (proximity_distance < PARKING_THRESHOLD) {\n        std::cout << \"Warning: Obstacle very close in parking scenario.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA 2023-compliant C++ code for an FCW system integrating brake pressure sensors for enhanced safety.",
      "input": "Handle sensor failures gracefully, ensure detailed comments, and comply with MISRA standards.",
      "output": "#include <brake_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float BRAKE_PRESSURE_THRESHOLD = 0.5f;  // Example threshold\n\nint main() {\n    float brake_pressure = 0.4f;  // Simulated brake pressure\n\n    if (brake_pressure < BRAKE_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Brake pressure too low, collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using LiDAR data to predict potential collisions at an intersection.",
      "input": "Handle invalid LiDAR readings, ensure safe memory management, and provide clear comments.",
      "output": "#include <lidar_library.hpp>  // Placeholder for LiDAR library\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float lidar_distance = 4.2f;  // Simulated LiDAR reading\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk at intersection.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using GPS data to monitor vehicle proximity to obstacles in a parking lot.",
      "input": "Ensure safe handling of GPS data and detailed comments explaining the calculations.",
      "output": "#include <gps_library.hpp>  // Placeholder for GPS library\n#include <iostream>\n\nconst float PARKING_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    float gps_distance = 1.0f;  // Simulated GPS distance\n\n    if (gps_distance < PARKING_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected in parking area.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar data to detect fast-moving objects in front of the vehicle.",
      "input": "Ensure radar data is processed securely, type conversions are handled properly, and all variables are initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder for radar library\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.5f;  // Simulated radar reading\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Fast-moving object detected!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using a combination of radar and camera data to predict forward collisions in heavy traffic.",
      "input": "Ensure safe handling of sensor fusion and proper error handling for both sensors.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float radar_distance = 2.5f;  // Simulated radar reading\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk based on radar data.\" << std::endl;\n    }\n\n    // Simulated object detection using camera\n    float detected_distance = 3.0f;\n    if (detected_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk based on camera data.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using tire pressure sensors to predict braking distance and avoid collisions.",
      "input": "Ensure proper error handling for sensor failure and clear comments for each sensor operation.",
      "output": "#include <tire_pressure_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float BRAKING_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float tire_pressure = 32.0f;  // Simulated tire pressure reading\n\n    if (tire_pressure < 30.0f) {\n        std::cout << \"Warning: Low tire pressure detected, braking distance may increase.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using vehicle speed and road curvature data to predict potential collisions on winding roads.",
      "input": "Ensure proper handling of road curvature data and comments explaining speed-curvature interaction.",
      "output": "#include <curvature_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float SPEED_THRESHOLD = 15.0f;  // m/s\nconst float CURVATURE_THRESHOLD = 30.0f;  // degrees\n\nint main() {\n    float vehicle_speed = 12.0f;  // Simulated vehicle speed\n    float road_curvature = 25.0f;  // Simulated road curvature\n\n    if (vehicle_speed > SPEED_THRESHOLD && road_curvature > CURVATURE_THRESHOLD) {\n        std::cout << \"Warning: High speed on curved road, collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses night vision to detect pedestrians crossing the road.",
      "input": "Ensure proper handling of night vision camera data and clear documentation.",
      "output": "#include <night_vision_camera.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float night_vision_distance = 1.5f;  // Simulated night vision reading\n\n    if (night_vision_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected at night.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system integrating automatic emergency braking based on collision prediction.",
      "input": "Ensure safe handling of braking mechanism, error checking, and adequate comments explaining the logic.",
      "output": "#include <braking_system.hpp>  // Placeholder for braking system library\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float predicted_distance = 1.8f;  // Simulated predicted collision distance\n\n    if (predicted_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision imminent, applying brakes.\" << std::endl;\n        // Activate emergency braking system\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using infrared sensors to detect low visibility conditions and predict collisions.",
      "input": "Handle possible sensor errors, ensure proper data validation, and include detailed comments.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float infrared_distance = 2.5f;  // Simulated infrared sensor reading\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Low visibility, collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using vehicle lane detection data to assess risk of unintended lane departure.",
      "input": "Ensure safe handling of lane detection data and provide MISRA-compliant comments for clarity.",
      "output": "#include <lane_detection_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f;  // meters\n\nint main() {\n    float lane_position = 0.3f;  // Simulated lane position data\n\n    if (lane_position > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure imminent!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect nearby objects during parking.",
      "input": "Ensure proper handling of sensor errors and avoid using uninitialized variables.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 0.5f;  // meters\n\nint main() {\n    float ultrasonic_distance = 0.3f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected during parking.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system that uses accelerometers to detect sudden deceleration and predict rear-end collisions.",
      "input": "Handle all type conversions explicitly and ensure safe initialization of all variables.",
      "output": "#include <accelerometer_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 3.0f;  // m/s^2\n\nint main() {\n    float acceleration = 2.5f;  // Simulated acceleration reading\n\n    if (acceleration > DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sudden deceleration detected, potential rear-end collision.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using machine learning models to classify potential collision risks based on real-time video frames.",
      "input": "Ensure compliance with MISRA guidelines for handling machine learning inference and ensure proper initialization of model variables.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <machine_learning_model.hpp>  // Placeholder\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    cv::Mat frame;  // Placeholder for camera frame\n    float predicted_distance = 1.5f;  // Simulated distance prediction from ML model\n\n    if (predicted_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk detected by ML model.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using a combination of GPS and radar data to predict potential collisions in an urban environment.",
      "input": "Ensure that GPS and radar data are handled securely and type conversions are managed properly.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float gps_distance = 4.0f;  // Simulated GPS distance\n    float radar_distance = 2.5f;  // Simulated radar reading\n\n    if (gps_distance < COLLISION_THRESHOLD || radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk detected based on GPS or radar data.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using video and LIDAR data to detect obstacles and trigger warnings when distance is too close.",
      "input": "Ensure correct sensor fusion, type-safe operations, and clear handling of data from both video and LIDAR sensors.",
      "output": "#include <opencv2/opencv.hpp>\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float lidar_distance = 1.8f;  // Simulated lidar distance\n    cv::Mat frame;  // Placeholder for video frame\n    float detected_distance = 1.5f;  // Simulated object detection from video\n\n    if (lidar_distance < COLLISION_THRESHOLD || detected_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected by LIDAR or video.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data and vehicle speed to assess collision risk.",
      "input": "Ensure the speed and radar data are processed securely with no uninitialized variables.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float radar_distance = 2.0f;  // Simulated radar distance\n    float vehicle_speed = 10.0f;  // Simulated vehicle speed in m/s\n\n    if (radar_distance < COLLISION_THRESHOLD && vehicle_speed > 8.0f) {\n        std::cout << \"Warning: Collision risk due to speed and radar distance.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect low-speed collisions in a parking lot.",
      "input": "Ensure no usage of unsafe or uninitialized variables and clear handling of sensor failures.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 0.8f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Low-speed collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses infrared sensors to detect pedestrians in low visibility conditions.",
      "input": "Handle infrared sensor errors gracefully and ensure all type conversions are explicit.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float infrared_distance = 1.5f;  // Simulated infrared sensor reading\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in low visibility.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using vehicle-to-vehicle communication to assess collision risks in heavy traffic.",
      "input": "Ensure safe communication between vehicles and proper handling of incoming data.",
      "output": "#include <vehicle_communication_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float v2v_distance = 1.8f;  // Simulated vehicle-to-vehicle distance\n\n    if (v2v_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk due to vehicle-to-vehicle communication.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and LiDAR data to assess the risk of colliding with an object ahead.",
      "input": "Ensure that both GPS and LiDAR data are processed properly and avoid unsafe use of memory or uninitialized variables.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float gps_distance = 2.5f;  // Simulated GPS distance\n    float lidar_distance = 2.0f;  // Simulated LIDAR reading\n\n    if (gps_distance < COLLISION_THRESHOLD || lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk detected from GPS or LIDAR.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar data to detect a vehicle ahead and predict potential collisions based on speed difference.",
      "input": "Ensure proper handling of radar data and explicit type conversion for safe operations.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\nconst float SPEED_DIFFERENCE_THRESHOLD = 20.0f;  // km/h\n\nint main() {\n    float radar_distance = 4.5f;  // Simulated radar distance\n    float vehicle_speed = 40.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 30.0f;  // Simulated speed of the vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: High collision risk due to speed difference and close distance.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect objects during low-speed maneuvers.",
      "input": "Handle sensor errors and ensure the proper initialization of all variables.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 0.8f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected during low-speed maneuver.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using video cameras to detect pedestrians in crosswalks and trigger warnings when they are too close.",
      "input": "Ensure type-safe operations and secure handling of video frames.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    cv::Mat frame;  // Placeholder for video frame\n    float pedestrian_distance = 1.0f;  // Simulated distance to pedestrian\n\n    if (pedestrian_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in crosswalk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses a combination of radar and lidar data to predict and warn about collisions.",
      "input": "Ensure proper sensor fusion and handle data initialization safely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float radar_distance = 3.0f;  // Simulated radar distance\n    float lidar_distance = 1.8f;  // Simulated lidar distance\n\n    if (radar_distance < COLLISION_THRESHOLD || lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk detected from radar or lidar.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS data and vehicle speed to predict potential collisions based on relative speed and distance.",
      "input": "Ensure GPS and speed data are processed securely with type-safe operations.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\nconst float SPEED_DIFFERENCE_THRESHOLD = 15.0f;  // km/h\n\nint main() {\n    float gps_distance = 4.5f;  // Simulated GPS distance\n    float vehicle_speed = 35.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 30.0f;  // Simulated speed of vehicle ahead\n\n    if (gps_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: Collision risk due to high speed difference.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using radar and vehicle cameras to detect vehicles ahead and calculate the risk of collision.",
      "input": "Ensure all type conversions are handled safely and that no uninitialized variables are used.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.8f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for vehicle camera frame\n    float vehicle_speed = 50.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 40.0f;  // Simulated vehicle speed ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > 15.0f) {\n        std::cout << \"Warning: Potential collision detected from radar and camera data.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect obstacles at low speeds in urban environments.",
      "input": "Ensure sensor errors are properly handled and all variables are initialized correctly.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.2f;  // meters\n\nint main() {\n    float ultrasonic_distance = 1.0f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Low-speed collision risk detected in urban environment.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using infrared sensors to detect pedestrians in the car's path and trigger a warning when necessary.",
      "input": "Ensure proper sensor fusion and safe handling of infrared data.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float infrared_distance = 1.5f;  // Simulated infrared sensor reading\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in the path.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and lidar data to estimate the risk of collision with stationary objects in the environment.",
      "input": "Ensure proper handling of lidar and GPS data with explicit type conversions and initialization of all variables.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float gps_distance = 3.5f;  // Simulated GPS distance\n    float lidar_distance = 3.0f;  // Simulated lidar distance\n\n    if (gps_distance < COLLISION_THRESHOLD || lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk due to close distance from stationary object.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA 2023-compliant C++ code for an FCW system using vehicle speed and camera data to predict and warn about potential rear-end collisions.",
      "input": "Ensure the vehicle speed and camera data are processed securely and type-safely.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed in km/h\n    cv::Mat frame;  // Placeholder for camera frame\n    float ahead_vehicle_speed = 50.0f;  // Simulated vehicle speed ahead\n\n    if ((vehicle_speed - ahead_vehicle_speed) > 20.0f && vehicle_speed > 30.0f) {\n        std::cout << \"Warning: High speed difference detected, rear-end collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using vehicle camera and radar to detect the distance between the car and a preceding vehicle at high speeds.",
      "input": "Ensure the proper initialization of variables, and handle data fusion securely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\nconst float SPEED_DIFFERENCE_THRESHOLD = 50.0f;  // km/h\n\nint main() {\n    float radar_distance = 1.5f;  // Simulated radar distance\n    float vehicle_speed = 90.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 60.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: High-speed collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors for low-speed detection of obstacles in parking scenarios.",
      "input": "Ensure secure handling of sensor data and explicit type initialization.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 0.8f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected during parking.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using infrared sensors to detect pedestrians at night in the vehicle's path and issue warnings.",
      "input": "Ensure that infrared sensor data is processed securely and efficiently.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float infrared_distance = 1.5f;  // Simulated infrared sensor reading\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in path at night.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar to detect a stationary vehicle ahead and trigger a collision warning.",
      "input": "Ensure that lidar data is safely handled with proper type initialization.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float lidar_distance = 2.8f;  // Simulated lidar distance\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Stationary vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses GPS and vehicle speed to estimate the relative speed difference between vehicles and predict collisions.",
      "input": "Ensure that GPS and speed data are processed securely, and type conversions are explicitly handled.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\nconst float SPEED_DIFFERENCE_THRESHOLD = 15.0f;  // km/h\n\nint main() {\n    float gps_distance = 4.0f;  // Simulated GPS distance\n    float vehicle_speed = 50.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 30.0f;  // Simulated speed of vehicle ahead\n\n    if (gps_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: Collision risk due to high speed difference.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a moving vehicle in the same lane and warn about a possible rear-end collision.",
      "input": "Ensure that all variables are initialized properly, and the data from both sensors is securely handled.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.0f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 40.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > 20.0f) {\n        std::cout << \"Warning: Rear-end collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors and vehicle speed to warn the driver about a potential collision with a nearby object.",
      "input": "Ensure that sensor data is securely handled and that proper error checks are in place.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.2f;  // meters\n\nint main() {\n    float ultrasonic_distance = 1.0f;  // Simulated ultrasonic sensor reading\n    float vehicle_speed = 40.0f;  // Simulated vehicle speed in km/h\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected, possible collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using a combination of radar and lidar sensors to detect and predict the likelihood of a collision with another vehicle at an intersection.",
      "input": "Ensure proper sensor data fusion and safe handling of variables.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.5f;  // Simulated radar distance\n    float lidar_distance = 3.0f;  // Simulated lidar distance\n\n    if (radar_distance < COLLISION_THRESHOLD || lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Potential collision risk at intersection detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar data to warn the driver about a potential collision with a vehicle making a sudden stop in front.",
      "input": "Ensure GPS and radar data are processed securely with type-safe operations.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float gps_distance = 2.0f;  // Simulated GPS distance\n    float radar_distance = 1.8f;  // Simulated radar distance\n\n    if (gps_distance < COLLISION_THRESHOLD || radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Collision risk due to sudden stop ahead.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and vehicle cameras to calculate the relative speed and predict potential rear-end collisions.",
      "input": "Ensure the proper initialization of variables and handling of sensor data.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.5f;  // meters\n\nint main() {\n    float radar_distance = 2.5f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n    float vehicle_speed = 75.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 55.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > 20.0f) {\n        std::cout << \"Warning: Rear-end collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and camera data to detect a vehicle in front at high speed and issue a warning about a potential rear-end collision. Include test case for distance and speed validation.",
      "input": "Use proper initialization of variables and sensor data processing.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\nconst float SPEED_DIFFERENCE_THRESHOLD = 30.0f;  // km/h\n\nint main() {\n    float radar_distance = 1.8f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n    float vehicle_speed = 80.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 50.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: Rear-end collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.8f, vehicle_speed = 80.0f, ahead_vehicle_speed = 50.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect objects in the path during parking and trigger a collision warning. Include a test case for object detection within the threshold distance.",
      "input": "Ensure sensor data is handled securely with explicit type initialization.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 0.9f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected during parking.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 0.9f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses infrared sensors to detect pedestrians at night. Issue a warning if the pedestrian is within a defined threshold. Include a test case for distance validation.",
      "input": "Process infrared sensor data securely and ensure proper variable initialization.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float infrared_distance = 2.0f;  // Simulated infrared sensor reading\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in path at night.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: infrared_distance = 2.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses lidar to detect a stationary vehicle ahead and triggers a warning. Include a test case for vehicle detection and warning.",
      "input": "Ensure lidar data is securely processed with proper error handling.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float lidar_distance = 2.5f;  // Simulated lidar distance\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Stationary vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS data to predict potential collision with a vehicle making a sudden stop. Include a test case to validate the GPS-based collision warning.",
      "input": "Ensure the handling of GPS data is secure with proper initialization of variables.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float gps_distance = 3.5f;  // Simulated GPS distance\n    float vehicle_speed = 70.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 10.0f;  // Simulated speed of vehicle ahead\n\n    if (gps_distance < COLLISION_THRESHOLD && vehicle_speed > ahead_vehicle_speed) {\n        std::cout << \"Warning: Collision risk due to sudden stop ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 3.5f, vehicle_speed = 70.0f, ahead_vehicle_speed = 10.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and camera fusion to detect vehicles at different speeds and predict collision risk. Include a test case for multi-sensor fusion.",
      "input": "Ensure that the radar and camera data fusion is done securely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.8f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 40.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && vehicle_speed - ahead_vehicle_speed > 20.0f) {\n        std::cout << \"Warning: Collision risk detected due to speed difference.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.8f, vehicle_speed = 60.0f, ahead_vehicle_speed = 40.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensors to detect obstacles during parking and issue a warning. Include a test case for distance validation in parking conditions.",
      "input": "Ensure that the ultrasonic sensor data is securely handled and the logic is safe.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.2f;  // meters\n\nint main() {\n    float ultrasonic_distance = 1.0f;  // Simulated ultrasonic sensor reading\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected during parking.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 1.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to issue a warning for a high-speed collision risk. Include a test case for vehicle speed and distance threshold.",
      "input": "Ensure that radar and camera data are fused properly with proper initialization.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\nconst float SPEED_DIFFERENCE_THRESHOLD = 50.0f;  // km/h\n\nint main() {\n    float radar_distance = 1.6f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n    float vehicle_speed = 100.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 40.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && vehicle_speed - ahead_vehicle_speed > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: High-speed collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.6f, vehicle_speed = 100.0f, ahead_vehicle_speed = 40.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar to detect close objects at a slow speed and trigger a warning. Include a test case for detecting stationary objects.",
      "input": "Ensure proper radar data handling and proper variable initialization.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    float radar_distance = 1.2f;  // Simulated radar distance\n    float vehicle_speed = 15.0f;  // Simulated vehicle speed in km/h\n\n    if (radar_distance < COLLISION_THRESHOLD && vehicle_speed < 20.0f) {\n        std::cout << \"Warning: Close object detected at slow speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.2f, vehicle_speed = 15.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses infrared sensors to detect pedestrians. Trigger a warning if a pedestrian is within the collision threshold. Include a test case for pedestrian detection.",
      "input": "Ensure infrared sensor data is processed securely and variables are initialized correctly.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float infrared_distance = 1.5f;  // Simulated infrared sensor distance\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in path.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: infrared_distance = 1.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and camera data to detect a vehicle in front and issues a warning if the vehicle is slowing down suddenly. Include a test case for detecting a sudden speed reduction.",
      "input": "Ensure that radar and camera data are processed securely with proper variable initialization.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\nconst float SUDDEN_SPEED_DROP = 15.0f;  // km/h\n\nint main() {\n    float radar_distance = 2.8f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed in km/h\n    float ahead_vehicle_speed = 30.0f;  // Simulated speed of vehicle ahead\n\n    if (radar_distance < COLLISION_THRESHOLD && (vehicle_speed - ahead_vehicle_speed) > SUDDEN_SPEED_DROP) {\n        std::cout << \"Warning: Sudden speed reduction ahead!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.8f, vehicle_speed = 60.0f, ahead_vehicle_speed = 30.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses ultrasonic sensors to detect objects behind the car during reverse parking. Trigger a warning if an object is within the collision threshold. Include a test case for object detection while reversing.",
      "input": "Ensure the ultrasonic data is handled securely with proper sensor initialization.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 0.8f;  // Simulated ultrasonic sensor reading during reverse\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected behind the car.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 0.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar to detect stationary vehicles ahead of the car. Issue a warning if the vehicle is within a collision threshold. Include a test case for stationary vehicle detection.",
      "input": "Ensure lidar data is processed securely with proper variable initialization and error handling.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float lidar_distance = 2.2f;  // Simulated lidar distance\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Stationary vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses GPS and radar data to predict a collision with an upcoming stop sign. Trigger a warning if the car is approaching too fast. Include a test case for high-speed approach detection.",
      "input": "Ensure proper initialization and secure handling of GPS and radar data.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\nconst float SPEED_THRESHOLD = 50.0f;  // km/h\n\nint main() {\n    float gps_distance = 3.8f;  // Simulated GPS distance to stop sign\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed in km/h\n\n    if (gps_distance < COLLISION_THRESHOLD && vehicle_speed > SPEED_THRESHOLD) {\n        std::cout << \"Warning: Approaching stop sign too fast!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 3.8f, vehicle_speed = 60.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses camera data to detect pedestrians in front of the car at night. Trigger a warning if the pedestrian is within a collision threshold. Include a test case for night-time pedestrian detection.",
      "input": "Process camera data securely and ensure proper initialization of variables.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    cv::Mat frame;  // Placeholder for camera frame\n    float pedestrian_distance = 1.5f;  // Simulated pedestrian distance at night\n\n    if (pedestrian_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected in front at night.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_distance = 1.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar to detect vehicles that are merging into the same lane. Trigger a warning if the merging vehicle is detected too close. Include a test case for merging vehicle detection.",
      "input": "Ensure that radar data is securely handled and variables are initialized properly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.5f;  // Simulated radar distance\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Merging vehicle detected too close.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar and lidar data to detect a vehicle approaching from the opposite direction. Trigger a warning if the vehicle is within a collision threshold. Include a test case for opposite direction vehicle detection.",
      "input": "Ensure radar and lidar data are handled securely and the sensor data fusion is implemented safely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float radar_distance = 4.5f;  // Simulated radar distance\n    float lidar_distance = 4.7f;  // Simulated lidar distance\n\n    if (radar_distance < COLLISION_THRESHOLD && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle approaching from opposite direction.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.5f, lidar_distance = 4.7f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and ultrasonic sensors to detect a vehicle approaching from behind during parking. Trigger a warning if the vehicle is too close. Include a test case for rear vehicle detection while parking.",
      "input": "Ensure GPS and ultrasonic sensor data are processed securely and variables are initialized properly.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float gps_distance = 3.0f;  // Simulated GPS distance\n    float ultrasonic_distance = 1.8f;  // Simulated ultrasonic distance while parking\n\n    if (gps_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Rear vehicle detected while parking.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 3.0f, ultrasonic_distance = 1.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar data to detect a vehicle making a sharp turn ahead. Trigger a warning if the vehicle is detected too close to the turn. Include a test case for sharp turn detection.",
      "input": "Ensure radar data handling is secure and variables are initialized correctly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.2f;  // Simulated radar distance\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected making a sharp turn ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using infrared sensors to detect an object in the path of the vehicle at night. Trigger a warning if the object is detected within the collision threshold. Include a test case for night-time object detection.",
      "input": "Process infrared sensor data securely and ensure correct variable initialization.",
      "output": "#include <infrared_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float infrared_distance = 2.0f;  // Simulated infrared sensor distance at night\n\n    if (infrared_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected in path at night.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: infrared_distance = 2.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses camera data to detect pedestrians crossing the road. Trigger a warning if the pedestrian is within a collision threshold. Include a test case for pedestrian detection.",
      "input": "Ensure proper initialization of camera data and variables.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    cv::Mat frame;  // Placeholder for camera frame\n    float pedestrian_distance = 1.0f;  // Simulated pedestrian distance\n\n    if (pedestrian_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_distance = 1.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect vehicles in a parking lot. Trigger a warning if the vehicle is detected too close. Include a test case for vehicle proximity in parking lots.",
      "input": "Ensure secure handling of ultrasonic sensor data and initialization of variables.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 1.2f;  // Simulated ultrasonic sensor distance in parking lot\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected too close in parking lot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 1.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and camera to detect a motorbike ahead. Trigger a warning if the motorbike is too close to the car. Include a test case for motorbike detection.",
      "input": "Ensure lidar and camera data are processed securely with proper error handling.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float lidar_distance = 2.5f;  // Simulated lidar distance to motorbike\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Motorbike detected too close ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar to detect a slow-moving vehicle ahead. Trigger a warning if the vehicle's speed is much lower than the car's speed. Include a test case for slow-moving vehicle detection.",
      "input": "Ensure that GPS and radar data are initialized securely and processed correctly.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float SPEED_THRESHOLD = 10.0f;  // km/h\n\nint main() {\n    float gps_distance = 5.0f;  // Simulated GPS distance to slow vehicle\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed\n    float ahead_vehicle_speed = 20.0f;  // Simulated speed of vehicle ahead\n\n    if (gps_distance < 5.0f && (vehicle_speed - ahead_vehicle_speed) > SPEED_THRESHOLD) {\n        std::cout << \"Warning: Slow-moving vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 5.0f, vehicle_speed = 60.0f, ahead_vehicle_speed = 20.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera data and radar to detect a cyclist in front of the car. Trigger a warning if the cyclist is within a collision threshold. Include a test case for cyclist detection.",
      "input": "Ensure correct initialization of camera and radar data, and proper handling of sensor fusion.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float radar_distance = 2.0f;  // Simulated radar distance\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Cyclist detected too close ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses radar data to detect a vehicle approaching from the side in an intersection. Trigger a warning if the vehicle is too close. Include a test case for side-approaching vehicle detection.",
      "input": "Ensure radar data is securely handled with appropriate initialization and sensor fusion.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 6.0f;  // meters\n\nint main() {\n    float radar_distance = 5.2f;  // Simulated radar distance to side-approaching vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Side-approaching vehicle detected at intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 5.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and lidar data to detect a sharp bend ahead. Trigger a warning if the bend is too sharp and the vehicle is moving too fast. Include a test case for sharp bend detection.",
      "input": "Ensure secure processing of GPS and lidar data, along with proper initialization of variables.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float BEND_ANGLE_THRESHOLD = 30.0f;  // degrees\nconst float SPEED_THRESHOLD = 50.0f;  // km/h\n\nint main() {\n    float gps_distance = 3.5f;  // Simulated GPS distance to sharp bend\n    float lidar_angle = 35.0f;  // Simulated lidar angle for bend\n    float vehicle_speed = 60.0f;  // Simulated vehicle speed\n\n    if (gps_distance < 4.0f && lidar_angle > BEND_ANGLE_THRESHOLD && vehicle_speed > SPEED_THRESHOLD) {\n        std::cout << \"Warning: Sharp bend ahead with high speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 3.5f, lidar_angle = 35.0f, vehicle_speed = 60.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a truck in the adjacent lane. Trigger a warning if the truck is detected too close. Include a test case for truck detection in an adjacent lane.",
      "input": "Ensure radar and lidar data are handled securely with proper initialization and sensor fusion.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 6.0f;  // meters\n\nint main() {\n    float radar_distance = 5.5f;  // Simulated radar distance to truck\n    float lidar_distance = 5.7f;  // Simulated lidar distance to truck\n\n    if (radar_distance < COLLISION_THRESHOLD && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Truck detected in adjacent lane too close.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 5.5f, lidar_distance = 5.7f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors and radar data to detect a car reversing into the vehicle's path. Trigger a warning if the car is too close. Include a test case for reversing vehicle detection.",
      "input": "Ensure sensor data is processed securely with correct variable initialization.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 1.8f;  // Simulated ultrasonic sensor distance to reversing vehicle\n    float radar_distance = 2.2f;  // Simulated radar distance to reversing vehicle\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD && radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Reversing vehicle detected in path.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 1.8f, radar_distance = 2.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar to detect a fallen tree ahead on the road. Trigger a warning if the tree is detected within the collision threshold. Include a test case for fallen tree detection.",
      "input": "Ensure camera and radar data are processed securely with proper error handling.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float radar_distance = 1.5f;  // Simulated radar distance to fallen tree\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Fallen tree detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar to detect a large object in front of the vehicle. Trigger a warning if the object is too close. Include a test case for large object detection.",
      "input": "Ensure radar sensor data is securely processed and initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.5f;  // Simulated radar distance to large object\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Large object detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar to detect a vehicle moving into the same lane. Trigger a warning if the vehicle is too close. Include a test case for lane-changing vehicle detection.",
      "input": "Ensure lidar data is properly initialized and processed.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float lidar_distance = 2.8f;  // Simulated lidar distance to lane-changing vehicle\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Lane-changing vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a car reversing from a parking spot. Trigger a warning if the reversing car is too close. Include a test case for reversing car detection.",
      "input": "Ensure radar and ultrasonic sensor data are securely processed.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float radar_distance = 1.9f;  // Simulated radar distance to reversing car\n    float ultrasonic_distance = 1.8f;  // Simulated ultrasonic distance to reversing car\n\n    if (radar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Reversing car detected too close.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.9f, ultrasonic_distance = 1.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera data to detect a pedestrian walking across the street. Trigger a warning if the pedestrian is too close. Include a test case for pedestrian detection.",
      "input": "Ensure that camera data is securely processed and initialized.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    float camera_distance = 1.2f;  // Simulated camera distance to pedestrian\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (camera_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 1.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar to detect a cyclist swerving into the lane. Trigger a warning if the cyclist is too close. Include a test case for cyclist swerve detection.",
      "input": "Ensure lidar and radar data are processed securely and initialized.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float lidar_distance = 2.0f;  // Simulated lidar distance to cyclist\n    float radar_distance = 2.3f;  // Simulated radar distance to cyclist\n\n    if (lidar_distance < COLLISION_THRESHOLD && radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Cyclist detected swerving into the lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.0f, radar_distance = 2.3f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera data to detect an animal crossing the road. Trigger a warning if the animal is detected too close. Include a test case for animal detection.",
      "input": "Ensure that camera data is processed securely and initialized.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float camera_distance = 1.5f;  // Simulated camera distance to animal\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (camera_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Animal detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 1.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar to detect a vehicle pulling out from a side road. Trigger a warning if the vehicle is too close. Include a test case for vehicle pulling out detection.",
      "input": "Ensure GPS and radar data are securely handled with proper initialization.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 6.0f;  // meters\n\nint main() {\n    float radar_distance = 5.5f;  // Simulated radar distance to vehicle pulling out\n    float gps_distance = 6.0f;  // Simulated GPS distance to vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD && gps_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle pulling out from side road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 5.5f, gps_distance = 6.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect a vehicle in the blind spot. Trigger a warning if the vehicle is too close. Include a test case for blind spot vehicle detection.",
      "input": "Ensure ultrasonic sensor data is securely processed and initialized.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float ultrasonic_distance = 2.3f;  // Simulated ultrasonic distance to vehicle in blind spot\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.3f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera to detect an obstacle in the vehicle's path. Trigger a warning if the obstacle is too close. Include a test case for obstacle detection.",
      "input": "Ensure radar and camera data are securely processed and initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.5f;  // Simulated radar distance to obstacle\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar to detect an obstacle in the vehicle's path. Trigger a warning if the object is too close. Include a test case for obstacle detection.",
      "input": "Ensure radar sensor data is processed and initialized correctly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.5f;  // Simulated radar distance to obstacle\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar to detect a vehicle in front of the car. Trigger a warning if the vehicle is too close. Include a test case for vehicle detection.",
      "input": "Ensure lidar data is processed and initialized correctly.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float lidar_distance = 1.8f;  // Simulated lidar distance to vehicle\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 1.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect pedestrians on the road. Trigger a warning if the pedestrian is too close. Include a test case for pedestrian detection.",
      "input": "Ensure radar and camera data are processed securely and initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    float radar_distance = 1.2f;  // Simulated radar distance to pedestrian\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and ultrasonic sensors to detect a motorcycle merging into the lane. Trigger a warning if the motorcycle is too close. Include a test case for motorcycle detection.",
      "input": "Ensure lidar and ultrasonic data are processed securely and initialized.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float lidar_distance = 1.5f;  // Simulated lidar distance to motorcycle\n    float ultrasonic_distance = 1.7f;  // Simulated ultrasonic distance to motorcycle\n\n    if (lidar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Motorcycle merging into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 1.5f, ultrasonic_distance = 1.7f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar to detect a car slowing down rapidly. Trigger a warning if the car is too close. Include a test case for rapid deceleration detection.",
      "input": "Ensure that radar and camera data are properly processed and initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.5f;  // Simulated radar distance to car\n    float speed_deceleration = 10.0f;  // Simulated deceleration rate\n\n    if (radar_distance < COLLISION_THRESHOLD && speed_deceleration > 8.0f) {\n        std::cout << \"Warning: Rapid deceleration detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.5f, speed_deceleration = 10.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar to detect a vehicle approaching from an intersection. Trigger a warning if the vehicle is too close. Include a test case for intersection vehicle detection.",
      "input": "Ensure GPS and radar data are processed securely and correctly.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float radar_distance = 4.0f;  // Simulated radar distance to vehicle\n    float gps_speed = 40.0f;  // Simulated vehicle speed approaching from intersection\n\n    if (radar_distance < COLLISION_THRESHOLD && gps_speed > 30.0f) {\n        std::cout << \"Warning: Vehicle approaching from intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.0f, gps_speed = 40.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect an object in the vehicle\u2019s blind spot. Trigger a warning if the object is too close. Include a test case for blind spot object detection.",
      "input": "Ensure ultrasonic sensor data is processed securely and initialized.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 1.5f;  // Simulated ultrasonic distance to object\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 1.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar to detect a large truck in front of the vehicle. Trigger a warning if the truck is too close. Include a test case for truck detection.",
      "input": "Ensure camera and radar data are securely processed and initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 6.0f;  // meters\n\nint main() {\n    float radar_distance = 5.8f;  // Simulated radar distance to truck\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Large truck detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 5.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and lidar to detect a vehicle entering an intersection. Trigger a warning if the vehicle is too close. Include a test case for intersection vehicle detection.",
      "input": "Ensure lidar and GPS data are securely processed and initialized.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float lidar_distance = 3.2f;  // Simulated lidar distance to vehicle entering intersection\n    float gps_speed = 25.0f;  // Simulated vehicle speed\n\n    if (lidar_distance < COLLISION_THRESHOLD && gps_speed > 20.0f) {\n        std::cout << \"Warning: Vehicle entering intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 3.2f, gps_speed = 25.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle too close in the vehicle\u2019s path. Trigger a warning if the vehicle is too close. Include a test case for vehicle detection.",
      "input": "Ensure radar and ultrasonic sensor data are securely processed and initialized.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.6f;  // Simulated radar distance to vehicle\n    float ultrasonic_distance = 3.8f;  // Simulated ultrasonic distance to vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected too close.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.6f, ultrasonic_distance = 3.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar to detect a pedestrian crossing the road. Trigger a warning if the pedestrian is too close. Include a test case for pedestrian detection.",
      "input": "Ensure the camera and radar data are processed correctly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    float radar_distance = 1.2f;  // Simulated radar distance to pedestrian\n    cv::Mat frame;  // Placeholder for camera frame\n\n    if (radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian crossing detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar to detect an obstacle that is slowly moving toward the vehicle. Trigger a warning if the object is too close. Include a test case for slow-moving object detection.",
      "input": "Ensure radar and lidar data are processed correctly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float radar_distance = 2.3f;  // Simulated radar distance to obstacle\n    float lidar_distance = 2.4f;  // Simulated lidar distance to obstacle\n\n    if (radar_distance < COLLISION_THRESHOLD && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Slow-moving obstacle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.3f, lidar_distance = 2.4f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors and radar to detect a vehicle merging into the lane. Trigger a warning if the vehicle is too close. Include a test case for lane-merging vehicle detection.",
      "input": "Ensure ultrasonic and radar sensor data are processed securely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.8f;  // Simulated radar distance to vehicle merging\n    float ultrasonic_distance = 2.9f;  // Simulated ultrasonic distance to vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle merging into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.8f, ultrasonic_distance = 2.9f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar to detect a motorcycle entering the vehicle's lane. Trigger a warning if the motorcycle is too close. Include a test case for motorcycle detection.",
      "input": "Ensure lidar data is processed and initialized correctly.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float lidar_distance = 2.3f;  // Simulated lidar distance to motorcycle\n\n    if (lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Motorcycle detected in lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.3f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera to detect a large truck in front of the vehicle with rapid deceleration. Trigger a warning if the vehicle is too close. Include a test case for truck and deceleration detection.",
      "input": "Ensure radar and camera data are processed and initialized securely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float radar_distance = 4.5f;  // Simulated radar distance to truck\n    float deceleration_rate = 15.0f;  // Simulated deceleration rate\n\n    if (radar_distance < COLLISION_THRESHOLD && deceleration_rate > 10.0f) {\n        std::cout << \"Warning: Large truck ahead with rapid deceleration.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.5f, deceleration_rate = 15.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar to detect an upcoming sharp curve. Trigger a warning if the vehicle is approaching too quickly. Include a test case for sharp curve detection.",
      "input": "Ensure GPS and radar data are processed securely and initialized.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 8.0f;  // meters\n\nint main() {\n    float radar_distance = 7.5f;  // Simulated radar distance to curve\n    float gps_speed = 60.0f;  // Simulated vehicle speed approaching curve\n\n    if (radar_distance < COLLISION_THRESHOLD && gps_speed > 50.0f) {\n        std::cout << \"Warning: Approaching sharp curve too quickly.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 7.5f, gps_speed = 60.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle following too closely. Trigger a warning if the vehicle is too close. Include a test case for following vehicle detection.",
      "input": "Ensure radar and ultrasonic sensor data are processed and initialized correctly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.8f;  // Simulated radar distance to vehicle\n    float ultrasonic_distance = 3.2f;  // Simulated ultrasonic distance to vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle following too closely.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.8f, ultrasonic_distance = 3.2f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar to detect an object in front of the car in low visibility conditions. Trigger a warning if the object is too close. Include a test case for object detection in low visibility.",
      "input": "Ensure radar and lidar data are processed correctly in low visibility conditions.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float radar_distance = 1.9f;  // Simulated radar distance to object\n    float lidar_distance = 2.0f;  // Simulated lidar distance to object\n\n    if (radar_distance < COLLISION_THRESHOLD && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected in low visibility conditions.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 1.9f, lidar_distance = 2.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and camera to detect a vehicle crossing a red light. Trigger a warning if the vehicle is too close. Include a test case for red light detection.",
      "input": "Ensure GPS and camera data are processed correctly.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float gps_speed = 15.0f;  // Simulated vehicle speed approaching intersection\n    bool red_light_detected = true;  // Simulated red light detection\n\n    if (gps_speed < 20.0f && red_light_detected) {\n        std::cout << \"Warning: Vehicle crossing red light.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_speed = 15.0f, red_light_detected = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and ultrasonic sensors to detect a bicycle in front of the vehicle. Trigger a warning if the bicycle is too close. Include a test case for bicycle detection.",
      "input": "Ensure lidar and ultrasonic sensor data are processed correctly.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.5f;  // meters\n\nint main() {\n    float lidar_distance = 1.2f;  // Simulated lidar distance to bicycle\n    float ultrasonic_distance = 1.3f;  // Simulated ultrasonic distance to bicycle\n\n    if (lidar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Bicycle detected in front.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 1.2f, ultrasonic_distance = 1.3f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar to detect a vehicle in the blind spot. Trigger a warning if the vehicle is too close. Include a test case for blind spot detection.",
      "input": "Ensure the radar and camera data are processed and initialized securely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = 2.8f;  // Simulated radar distance to vehicle\n    bool blind_spot_detected = true;  // Simulated blind spot detection\n\n    if (radar_distance < COLLISION_THRESHOLD && blind_spot_detected) {\n        std::cout << \"Warning: Vehicle in blind spot detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.8f, blind_spot_detected = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors and camera to detect a low-speed vehicle approaching the vehicle. Trigger a warning if the vehicle is too close. Include a test case for low-speed vehicle detection.",
      "input": "Ensure ultrasonic sensor and camera data are processed correctly.",
      "output": "#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <opencv2/opencv.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = 3.5f;  // Simulated ultrasonic distance to vehicle\n    bool low_speed_detected = true;  // Simulated low-speed detection\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD && low_speed_detected) {\n        std::cout << \"Warning: Low-speed vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 3.5f, low_speed_detected = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar to detect a truck ahead with a large distance gap. Trigger a warning if the gap is too small. Include a test case for large vehicle detection.",
      "input": "Ensure radar and lidar data are processed and initialized properly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 6.0f;  // meters\n\nint main() {\n    float radar_distance = 5.8f;  // Simulated radar distance to truck\n    float lidar_distance = 5.5f;  // Simulated lidar distance to truck\n\n    if (radar_distance < COLLISION_THRESHOLD && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Truck detected ahead with a small gap.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 5.8f, lidar_distance = 5.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS to detect a vehicle traveling at high speed ahead. Trigger a warning if the speed difference is significant. Include a test case for high-speed vehicle detection.",
      "input": "Ensure radar and GPS data are processed correctly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <gps_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float SPEED_THRESHOLD = 60.0f;  // km/h\n\nint main() {\n    float radar_distance = 15.0f;  // Simulated radar distance to vehicle\n    float gps_speed = 70.0f;  // Simulated vehicle speed\n\n    if (radar_distance < 50.0f && gps_speed > SPEED_THRESHOLD) {\n        std::cout << \"Warning: High-speed vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 15.0f, gps_speed = 70.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and lidar to detect a vehicle that suddenly brakes in front of the car. Trigger a warning if the vehicle decelerates too quickly. Include a test case for sudden deceleration detection.",
      "input": "Ensure camera and lidar data are processed correctly.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 8.0f;  // m/s^2\n\nint main() {\n    float lidar_distance = 3.5f;  // Simulated lidar distance to vehicle\n    float deceleration_rate = 9.0f;  // Simulated deceleration rate\n\n    if (lidar_distance < 10.0f && deceleration_rate > DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sudden deceleration detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 3.5f, deceleration_rate = 9.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle turning left in front of the car. Trigger a warning if the vehicle is too close. Include a test case for left-turning vehicle detection.",
      "input": "Ensure radar and ultrasonic sensors are processed and initialized securely.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // meters\n\nint main() {\n    float radar_distance = 3.5f;  // Simulated radar distance to turning vehicle\n    float ultrasonic_distance = 4.0f;  // Simulated ultrasonic distance to vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle turning left ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.5f, ultrasonic_distance = 4.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar to detect a vehicle merging onto the highway. Trigger a warning if the vehicle is too close. Include a test case for merging vehicle detection.",
      "input": "Ensure GPS and radar data are processed correctly.",
      "output": "#include <gps_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // meters\n\nint main() {\n    float radar_distance = 4.8f;  // Simulated radar distance to vehicle merging\n    float gps_speed = 80.0f;  // Simulated vehicle speed\n\n    if (radar_distance < COLLISION_THRESHOLD && gps_speed > 70.0f) {\n        std::cout << \"Warning: Merging vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.8f, gps_speed = 80.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar to detect a motorcyclist weaving through traffic. Trigger a warning if the motorcyclist is too close. Include a test case for motorcyclist detection.",
      "input": "Ensure lidar and radar data are processed securely.",
      "output": "#include <lidar_library.hpp>  // Placeholder\n#include <radar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // meters\n\nint main() {\n    float lidar_distance = 2.3f;  // Simulated lidar distance to motorcyclist\n    float radar_distance = 2.0f;  // Simulated radar distance to motorcyclist\n\n    if (lidar_distance < COLLISION_THRESHOLD && radar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Motorcyclist detected weaving ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 2.3f, radar_distance = 2.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and lidar to detect an emergency vehicle with flashing lights. Trigger a warning if the emergency vehicle is too close. Include a test case for emergency vehicle detection.",
      "input": "Ensure camera and lidar data are processed correctly.",
      "output": "#include <opencv2/opencv.hpp>  // Placeholder\n#include <lidar_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 10.0f;  // meters\n\nint main() {\n    bool emergency_vehicle_detected = true;  // Simulated emergency vehicle detection\n    float lidar_distance = 9.5f;  // Simulated lidar distance to emergency vehicle\n\n    if (emergency_vehicle_detected && lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Emergency vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: emergency_vehicle_detected = true, lidar_distance = 9.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle approaching from an intersection. Trigger a warning if the vehicle is too close. Include a test case for intersection vehicle detection.",
      "input": "Ensure radar and ultrasonic sensors are initialized properly.",
      "output": "#include <radar_library.hpp>  // Placeholder\n#include <ultrasonic_sensor_library.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 6.0f;  // meters\n\nint main() {\n    float radar_distance = 5.8f;  // Simulated radar distance to intersection vehicle\n    float ultrasonic_distance = 6.5f;  // Simulated ultrasonic distance to vehicle\n\n    if (radar_distance < COLLISION_THRESHOLD && ultrasonic_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Vehicle approaching from intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 5.8f, ultrasonic_distance = 6.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses real-time radar and camera data to detect a vehicle ahead. Trigger a warning if the vehicle's speed is below 10 km/h and the distance is less than 5 meters. Include real-time data processing with inputs from actual radar and camera sensors.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 10.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_speed = getCameraSpeed();  // Real-time vehicle speed from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle ahead with low speed and short distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.0f, camera_speed = 8.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and lidar data to detect a vehicle that has stopped at an intersection. Trigger a warning if the distance is less than 3 meters and the vehicle is stationary. Include real-time data processing with actual ultrasonic and lidar sensors.",
      "input": "Process real-time ultrasonic and lidar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    bool is_vehicle_stationary = isVehicleStationary();  // Real-time vehicle status\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD && is_vehicle_stationary) {\n        std::cout << \"Warning: Vehicle ahead has stopped at the intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.8f, is_vehicle_stationary = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle traveling too fast ahead. Trigger a warning if the vehicle's speed exceeds 120 km/h and the distance is less than 50 meters. Include real-time data processing with actual radar and GPS sensors.",
      "input": "Process real-time radar and GPS data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 50.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 120.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: High-speed vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 45.0f, gps_speed = 130.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and camera data to detect a pedestrian crossing the road ahead. Trigger a warning if the distance is less than 2 meters and the pedestrian is moving towards the vehicle. Include real-time data processing with actual lidar and camera sensors.",
      "input": "Process real-time lidar and camera data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // meters\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    bool is_pedestrian_moving = isPedestrianMoving();  // Real-time pedestrian status\n\n    if (lidar_distance < COLLISION_THRESHOLD && is_pedestrian_moving) {\n        std::cout << \"Warning: Pedestrian crossing ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 1.8f, is_pedestrian_moving = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle cutting into the lane ahead. Trigger a warning if the vehicle is within 3 meters and the lane change is abrupt. Include real-time data processing with actual radar and ultrasonic sensors.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    bool is_lane_change_abrupt = isLaneChangeAbrupt();  // Real-time lane change detection\n\n    if (radar_distance < COLLISION_THRESHOLD && is_lane_change_abrupt) {\n        std::cout << \"Warning: Abrupt lane change detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.5f, is_lane_change_abrupt = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a vehicle merging from the left side. Trigger a warning if the vehicle is within 5 meters and the merging speed exceeds 20 km/h. Include real-time data processing with actual lidar and radar sensors.",
      "input": "Process real-time lidar and radar data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Merging vehicle from left side detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 4.5f, radar_speed = 22.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar data to detect a vehicle braking suddenly ahead. Trigger a warning if the vehicle's deceleration is more than 5 m/s\u00b2. Include real-time data processing with actual camera and radar sensors.",
      "input": "Process real-time camera and radar data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 5.0f;  // m/s^2\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time vehicle deceleration\n\n    if (radar_distance < 10.0f && camera_deceleration > DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sudden braking detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 7.0f, camera_deceleration = 6.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle approaching an intersection. Trigger a warning if the vehicle is within 10 meters and its speed exceeds 30 km/h. Include real-time data processing with actual radar and GPS sensors.",
      "input": "Process real-time radar and GPS data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 30.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle approaching intersection at high speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, gps_speed = 35.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a vehicle tailgating. Trigger a warning if the vehicle is within 1 meter and traveling at high speed. Include real-time data processing with actual lidar and radar sensors.",
      "input": "Process real-time lidar and radar data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 1.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 60.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Tailgating detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 0.8f, radar_speed = 70.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect an object on the road ahead. Trigger a warning if the object is detected within 3 meters. Include real-time data processing with actual radar and lidar sensors.",
      "input": "Process real-time radar and lidar data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n\n    if (radar_distance < COLLISION_THRESHOLD || lidar_distance < COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Object detected on the road ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.5f, lidar_distance = 2.8f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using real-time lidar and radar data to detect a vehicle ahead that is traveling slower than the ego vehicle. Trigger a warning if the relative speed between the two vehicles is less than -5 km/h and the distance is less than 10 meters.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = -5.0f;  // km/h (relative speed)\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_relative_speed = getRadarRelativeSpeed();  // Real-time relative speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Slow-moving vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 8.0f, radar_relative_speed = -7.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle making a sudden lane change. Trigger a warning if the vehicle crosses into the lane within 5 meters and the speed is above 60 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 60.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Sudden lane change detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.0f, gps_speed = 70.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar sensors to detect a vehicle approaching from behind. Trigger a warning if the vehicle is within 3 meters and the speed is over 50 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 50.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle approaching from behind at high speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.5f, radar_speed = 60.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle that has braked suddenly. Trigger a warning if the vehicle decelerates at a rate exceeding 5 m/s\u00b2.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 5.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time deceleration from camera\n\n    if (radar_distance < 10.0f && camera_deceleration > DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sudden braking detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 6.0f, camera_deceleration = 6.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a vehicle entering an intersection ahead. Trigger a warning if the vehicle is within 20 meters and the speed is over 40 km/h.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 40.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle entering intersection ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 18.0f, radar_speed = 45.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and GPS data to detect a pedestrian crossing in front of the vehicle. Trigger a warning if the distance to the pedestrian is less than 1 meter and the pedestrian is moving towards the vehicle.",
      "input": "Process real-time lidar and GPS sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    bool is_pedestrian_moving = isPedestrianMoving();  // Real-time pedestrian movement detection\n\n    if (lidar_distance < COLLISION_THRESHOLD && is_pedestrian_moving) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 0.8f, is_pedestrian_moving = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a vehicle tailgating from behind. Trigger a warning if the distance is less than 2 meters and the speed is over 30 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 2.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 30.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Tailgating detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 1.5f, radar_speed = 40.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and camera data to detect a vehicle with malfunctioning brake lights ahead. Trigger a warning if the vehicle's speed is over 60 km/h and brake lights are not detected.",
      "input": "Process real-time lidar and camera sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float SPEED_THRESHOLD = 60.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    bool is_brake_light_on = isBrakeLightOn();  // Real-time brake light detection\n    float vehicle_speed = getVehicleSpeed();  // Real-time speed from lidar data\n\n    if (vehicle_speed > SPEED_THRESHOLD && !is_brake_light_on) {\n        std::cout << \"Warning: Brake light malfunction detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 15.0f, is_brake_light_on = false, vehicle_speed = 65.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle approaching an intersection at a high speed. Trigger a warning if the vehicle is within 20 meters and traveling at over 80 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 80.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle approaching intersection at high speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 18.0f, gps_speed = 85.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a vehicle stopping abruptly in front. Trigger a warning if the distance is within 5 meters and deceleration exceeds 4 m/s\u00b2.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 4.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_deceleration = getLidarDeceleration();  // Real-time deceleration from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Sudden stop detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 3.0f, lidar_deceleration = 5.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle ahead that is braking heavily. Trigger a warning if the relative speed is less than -10 km/h and the distance is within 15 meters.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 15.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = -10.0f;  // km/h (relative speed)\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_relative_speed = getCameraRelativeSpeed();  // Real-time relative speed from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle braking heavily ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 12.0f, camera_relative_speed = -12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle with a malfunctioning brake light ahead. Trigger a warning if the vehicle is within 10 meters and its speed exceeds 50 km/h, but no brake light is detected.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 50.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    bool is_brake_light_on = isBrakeLightOn();  // Real-time brake light detection\n    float vehicle_speed = getVehicleSpeed();  // Real-time speed from radar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && vehicle_speed > COLLISION_THRESHOLD_SPEED && !is_brake_light_on) {\n        std::cout << \"Warning: Brake light malfunction detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, vehicle_speed = 55.0f, is_brake_light_on = false\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a vehicle with a large speed differential traveling in the same lane. Trigger a warning if the vehicle is within 5 meters and its speed is over 80 km/h faster than the ego vehicle.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED_DIFFERENCE = 80.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed_diff = getRadarSpeedDifference();  // Real-time speed difference from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed_diff > COLLISION_THRESHOLD_SPEED_DIFFERENCE) {\n        std::cout << \"Warning: High speed differential detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 4.5f, radar_speed_diff = 90.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and radar data to detect a vehicle that is making a sudden lane change into the same lane. Trigger a warning if the vehicle is within 10 meters and the relative speed is greater than 30 km/h.",
      "input": "Process real-time camera and radar sensor data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 30.0f;  // km/h\n\nint main() {\n    float camera_distance = getCameraDistance();  // Real-time camera distance\n    float radar_relative_speed = getRadarRelativeSpeed();  // Real-time relative speed from radar\n\n    if (camera_distance < COLLISION_THRESHOLD_DISTANCE && radar_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle making sudden lane change.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 9.0f, radar_relative_speed = 35.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a stopped vehicle ahead. Trigger a warning if the distance is less than 5 meters and the relative speed is close to zero.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 5.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float ultrasonic_relative_speed = getUltrasonicRelativeSpeed();  // Real-time relative speed from ultrasonic\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && ultrasonic_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Stopped vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.0f, ultrasonic_relative_speed = 0.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a vehicle ahead that is decelerating rapidly. Trigger a warning if the deceleration rate exceeds 4 m/s\u00b2 and the distance is within 20 meters.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 4.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_deceleration = getLidarDeceleration();  // Real-time deceleration from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Vehicle decelerating rapidly ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 15.0f, lidar_deceleration = 4.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and ultrasonic sensors to detect a pedestrian crossing the road ahead. Trigger a warning if the pedestrian is within 3 meters and moving toward the vehicle.",
      "input": "Process real-time camera and ultrasonic sensor data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\n\nint main() {\n    float camera_distance = getCameraDistance();  // Real-time camera distance\n    bool is_pedestrian_moving_towards_vehicle = isPedestrianMovingTowards();  // Pedestrian movement detection\n\n    if (camera_distance < COLLISION_THRESHOLD_DISTANCE && is_pedestrian_moving_towards_vehicle) {\n        std::cout << \"Warning: Pedestrian crossing ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 2.0f, is_pedestrian_moving_towards_vehicle = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle rapidly approaching a curve. Trigger a warning if the vehicle's speed exceeds 60 km/h and it is within 30 meters of the curve.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 30.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 60.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle approaching curve at high speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 25.0f, gps_speed = 65.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a vehicle that is too close and traveling at a high speed. Trigger a warning if the vehicle is within 10 meters and the relative speed exceeds 70 km/h.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 70.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_relative_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle too close and traveling at high speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, lidar_relative_speed = 75.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a vehicle abruptly stopping ahead. Trigger a warning if the relative speed drops below -5 km/h and the distance is within 5 meters.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = -5.0f;  // km/h (relative speed)\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float ultrasonic_relative_speed = getUltrasonicRelativeSpeed();  // Real-time relative speed from ultrasonic\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && ultrasonic_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Sudden stop detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.0f, ultrasonic_relative_speed = -6.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a stopped vehicle in the same lane ahead. Trigger a warning if the relative speed is less than 5 km/h and the vehicle is within 10 meters.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 5.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_relative_speed = getCameraRelativeSpeed();  // Real-time relative speed from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Stopped vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, camera_relative_speed = 3.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and lidar data to detect a vehicle merging into the lane. Trigger a warning if the vehicle is within 7 meters and the relative speed exceeds 20 km/h.",
      "input": "Process real-time ultrasonic and lidar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 7.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float lidar_relative_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && lidar_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle merging into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 6.5f, lidar_relative_speed = 25.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a pedestrian crossing the road ahead. Trigger a warning if the pedestrian is within 3 meters and moving towards the vehicle.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    bool is_pedestrian_moving_towards_vehicle = isPedestrianMovingTowards();  // Pedestrian movement detection\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && is_pedestrian_moving_towards_vehicle) {\n        std::cout << \"Warning: Pedestrian crossing ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.0f, is_pedestrian_moving_towards_vehicle = true\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle approaching a sharp curve at high speed. Trigger a warning if the vehicle is within 30 meters of the curve and its speed exceeds 80 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 30.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 80.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: High speed approaching sharp curve.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 25.0f, gps_speed = 85.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a tailgating vehicle. Trigger a warning if the vehicle is within 3 meters and its relative speed exceeds 40 km/h.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 40.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_relative_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Tailgating detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 2.5f, lidar_relative_speed = 45.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle braking abruptly ahead. Trigger a warning if the deceleration rate exceeds 3 m/s\u00b2 and the distance is within 15 meters.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 15.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 3.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time deceleration from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Vehicle braking abruptly ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 12.0f, camera_deceleration = 3.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a vehicle merging into the same lane. Trigger a warning if the vehicle is within 8 meters and its speed exceeds 60 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 8.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 60.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time vehicle speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle merging into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 7.5f, radar_speed = 65.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle ahead that is slowing down rapidly. Trigger a warning if the relative speed drops below -10 km/h and the distance is within 20 meters.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = -10.0f;  // km/h (relative speed)\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_relative_speed = getCameraRelativeSpeed();  // Real-time relative speed from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle slowing down rapidly ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 15.0f, camera_relative_speed = -12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle approaching a red light ahead. Trigger a warning if the vehicle is within 50 meters of the intersection and traveling at a speed above 50 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 50.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 50.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Approaching red light ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 40.0f, gps_speed = 55.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a motorcycle in the blind spot. Trigger a warning if the motorcycle is within 5 meters and the vehicle is moving at more than 50 km/h.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 50.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed = getRadarSpeed();  // Real-time vehicle speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Motorcycle in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 4.0f, radar_speed = 60.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a vehicle moving slowly in the same lane. Trigger a warning if the vehicle is within 10 meters and the relative speed is less than 10 km/h.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 10.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_relative_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Slow-moving vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, lidar_relative_speed = 5.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect an object on the road ahead. Trigger a warning if the object is within 15 meters and the relative speed exceeds 15 km/h.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 15.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_relative_speed = getCameraRelativeSpeed();  // Real-time relative speed from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Object detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 12.0f, camera_relative_speed = 20.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle approaching an intersection at high speed. Trigger a warning if the vehicle is within 100 meters and the speed exceeds 60 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 100.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 60.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: High speed approaching intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 90.0f, gps_speed = 70.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a cyclist in the blind spot. Trigger a warning if the cyclist is within 3 meters and the vehicle is moving at more than 50 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 50.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Cyclist in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.5f, radar_speed = 60.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle that suddenly stops ahead. Trigger a warning if the vehicle is within 10 meters and the relative speed decreases rapidly.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 3.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time deceleration from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Sudden stop detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, camera_deceleration = 4.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and lidar data to detect a vehicle coming from the opposite direction in a narrow lane. Trigger a warning if the vehicle is within 5 meters and moving faster than 40 km/h.",
      "input": "Process real-time ultrasonic and lidar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 40.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float lidar_speed = getLidarSpeed();  // Real-time speed from lidar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle approaching from opposite direction.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 3.0f, lidar_speed = 45.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle making an unexpected lane change. Trigger a warning if the vehicle is within 20 meters and the relative speed exceeds 30 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 30.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_relative_speed = getGPSRelativeSpeed();  // Real-time relative speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Unexpected lane change detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 15.0f, gps_relative_speed = 35.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle braking hard in front of the car. Trigger a warning if the vehicle is within 15 meters and the relative speed decreases by more than 30 km/h in the last 2 seconds.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 15.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 30.0f;  // km/h\nconst float TIME_WINDOW = 2.0f;  // seconds\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time deceleration from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Hard braking detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 12.0f, camera_deceleration = 35.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a slow-moving vehicle ahead. Trigger a warning if the vehicle is within 25 meters and the relative speed is less than 5 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 25.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 5.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_relative_speed = getGPSRelativeSpeed();  // Real-time relative speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_relative_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Slow-moving vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 20.0f, gps_relative_speed = 3.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a pedestrian stepping onto the road. Trigger a warning if the pedestrian is within 5 meters and the vehicle speed exceeds 20 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 4.0f, radar_speed = 25.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and GPS data to detect a vehicle merging into the same lane from the side. Trigger a warning if the vehicle is within 8 meters and the speed exceeds 40 km/h.",
      "input": "Process real-time lidar and GPS sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 8.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 40.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle merging into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 7.0f, gps_speed = 45.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle suddenly stopping. Trigger a warning if the vehicle is within 10 meters and the relative speed drops rapidly in a short time.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 20.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time deceleration from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Vehicle stopping suddenly.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, camera_deceleration = 22.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect an obstacle blocking the lane ahead. Trigger a warning if the object is within 20 meters and the relative speed is greater than 15 km/h.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_relative_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Obstacle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 18.0f, lidar_relative_speed = 16.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and camera data to detect a vehicle cutting in front. Trigger a warning if the vehicle is within 6 meters and the relative speed exceeds 20 km/h.",
      "input": "Process real-time ultrasonic and camera sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 6.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float camera_relative_speed = getCameraRelativeSpeed();  // Real-time relative speed from camera\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && camera_relative_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle cutting in front.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 5.0f, camera_relative_speed = 25.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar data to detect a vehicle rapidly decelerating. Trigger a warning if the vehicle is within 10 meters and the deceleration rate exceeds 10 km/h per second.",
      "input": "Process real-time GPS and radar sensor data.",
      "output": "#include <gps_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 10.0f;  // km/h per second\n\nint main() {\n    float gps_distance = getGPSDistance();  // Real-time GPS distance\n    float radar_deceleration = getRadarDeceleration();  // Real-time deceleration from radar\n\n    if (gps_distance < COLLISION_THRESHOLD_DISTANCE && radar_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Rapid deceleration detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 8.0f, radar_deceleration = 12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and lidar data to detect an animal crossing the road. Trigger a warning if the animal is within 5 meters and the vehicle speed is above 15 km/h.",
      "input": "Process real-time camera and lidar sensor data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float camera_distance = getCameraDistance();  // Real-time camera distance\n    float lidar_speed = getLidarSpeed();  // Real-time speed from lidar\n\n    if (camera_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Animal detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 4.0f, lidar_speed = 18.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a vehicle suddenly changing lanes in front of the car. Trigger a warning if the vehicle is within 12 meters and the relative speed difference exceeds 25 km/h.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 12.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED_DIFF = 25.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_speed_diff = getCameraSpeedDifference();  // Speed difference from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_speed_diff > COLLISION_THRESHOLD_SPEED_DIFF) {\n        std::cout << \"Warning: Vehicle changing lanes ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 10.0f, camera_speed_diff = 30.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a stationary object in the vehicle's path. Trigger a warning if the object is within 3 meters and the vehicle speed exceeds 5 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 5.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Stationary object detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.5f, radar_speed = 10.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and GPS data to detect a vehicle in front rapidly accelerating. Trigger a warning if the vehicle is within 20 meters and the relative speed increases by more than 15 km/h in the last 2 seconds.",
      "input": "Process real-time lidar and GPS sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED_INCREASE = 15.0f;  // km/h\nconst float TIME_WINDOW = 2.0f;  // seconds\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float gps_speed_increase = getGPSSpeedIncrease();  // Real-time speed increase from GPS\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed_increase > COLLISION_THRESHOLD_SPEED_INCREASE) {\n        std::cout << \"Warning: Vehicle accelerating rapidly ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 18.0f, gps_speed_increase = 17.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and ultrasonic data to detect a pedestrian stepping off the curb. Trigger a warning if the pedestrian is within 4 meters and the vehicle speed exceeds 10 km/h.",
      "input": "Process real-time camera and ultrasonic sensor data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 4.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 10.0f;  // km/h\n\nint main() {\n    float camera_distance = getCameraDistance();  // Real-time camera distance\n    float ultrasonic_speed = getUltrasonicSpeed();  // Real-time speed from ultrasonic sensor\n\n    if (camera_distance < COLLISION_THRESHOLD_DISTANCE && ultrasonic_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Pedestrian detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 3.5f, ultrasonic_speed = 12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a vehicle merging into the lane from the side. Trigger a warning if the vehicle is within 10 meters and the relative speed exceeds 20 km/h.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle merging into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, lidar_speed = 22.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and camera data to detect a vehicle making a sudden stop ahead. Trigger a warning if the vehicle is within 15 meters and the relative speed drops by more than 10 km/h in 1 second.",
      "input": "Process real-time GPS and camera sensor data.",
      "output": "#include <gps_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 15.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 10.0f;  // km/h\nconst float TIME_WINDOW = 1.0f;  // seconds\n\nint main() {\n    float gps_distance = getGPSDistance();  // Real-time GPS distance\n    float camera_deceleration = getCameraDeceleration();  // Real-time deceleration from camera\n\n    if (gps_distance < COLLISION_THRESHOLD_DISTANCE && camera_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Vehicle stopping ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 12.0f, camera_deceleration = 12.5f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a motorcycle in the blind spot. Trigger a warning if the motorcycle is within 5 meters and the relative speed exceeds 15 km/h.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed = getRadarRelativeSpeed();  // Real-time speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Motorcycle detected in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 4.5f, radar_speed = 18.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and GPS data to detect a vehicle that has suddenly slowed down. Trigger a warning if the vehicle is within 6 meters and the speed reduction exceeds 8 km/h in 3 seconds.",
      "input": "Process real-time ultrasonic and GPS sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 6.0f;  // meters\nconst float COLLISION_THRESHOLD_DECELERATION = 8.0f;  // km/h\nconst float TIME_WINDOW = 3.0f;  // seconds\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float gps_deceleration = getGPSDeceleration();  // Real-time deceleration from GPS\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && gps_deceleration > COLLISION_THRESHOLD_DECELERATION) {\n        std::cout << \"Warning: Vehicle slowing down rapidly ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 5.5f, gps_deceleration = 10.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera data to detect a cyclist ahead of the vehicle. Trigger a warning if the cyclist is within 8 meters and the vehicle speed is above 15 km/h.",
      "input": "Process real-time radar and camera sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 8.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float camera_speed = getCameraSpeed();  // Real-time speed from camera\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && camera_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Cyclist detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 7.0f, camera_speed = 18.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and lidar data to detect a vehicle approaching from an intersection. Trigger a warning if the vehicle is within 15 meters and the relative speed exceeds 30 km/h.",
      "input": "Process real-time camera and lidar sensor data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 15.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 30.0f;  // km/h\n\nint main() {\n    float camera_distance = getCameraDistance();  // Real-time camera distance\n    float lidar_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (camera_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle approaching from intersection.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 13.0f, lidar_speed = 32.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect an unexpected obstacle in the road. Trigger a warning if the object is within 5 meters and the vehicle speed exceeds 20 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Unexpected obstacle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.0f, gps_speed = 25.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a cyclist coming from behind. Trigger a warning if the cyclist is within 3 meters and the relative speed exceeds 20 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarRelativeSpeed();  // Real-time relative speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Cyclist approaching from behind.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.5f, radar_speed = 22.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar data to detect a motorcycle on the road ahead. Trigger a warning if the motorcycle is within 10 meters and the relative speed exceeds 15 km/h.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float lidar_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Motorcycle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 8.0f, lidar_speed = 16.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and camera data to detect a vehicle making a sharp turn. Trigger a warning if the vehicle is within 12 meters and the relative speed exceeds 10 km/h.",
      "input": "Process real-time GPS and camera sensor data.",
      "output": "#include <gps_sensor.hpp>  // Placeholder\n#include <camera_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 12.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 10.0f;  // km/h\n\nint main() {\n    float gps_distance = getGPSDistance();  // Real-time GPS distance\n    float camera_speed = getCameraSpeed();  // Real-time speed from camera\n\n    if (gps_distance < COLLISION_THRESHOLD_DISTANCE && camera_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle making sharp turn ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 10.0f, camera_speed = 12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic data to detect a vehicle that has suddenly slowed down on a highway. Trigger a warning if the vehicle is within 20 meters and the relative speed decreases by more than 15 km/h.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 20.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float ultrasonic_speed = getUltrasonicRelativeSpeed();  // Real-time speed from ultrasonic sensor\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && ultrasonic_speed < -COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle slowing down ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 18.0f, ultrasonic_speed = -16.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a vehicle tailgating. Trigger a warning if the vehicle is within 3 meters and the relative speed exceeds 10 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 3.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 10.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarRelativeSpeed();  // Real-time relative speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle tailgating detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 2.0f, radar_speed = 12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and lidar data to detect a stopped vehicle in the same lane. Trigger a warning if the vehicle is within 5 meters and the relative speed is below 10 km/h.",
      "input": "Process real-time camera and lidar sensor data.",
      "output": "#include <camera_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 5.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 10.0f;  // km/h\n\nint main() {\n    float camera_distance = getCameraDistance();  // Real-time camera distance\n    float lidar_speed = getLidarSpeed();  // Real-time speed from lidar\n\n    if (camera_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Stopped vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 4.0f, lidar_speed = 5.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle rapidly decelerating ahead. Trigger a warning if the vehicle is within 10 meters and the relative speed decreases by more than 20 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED_DECREASE = 20.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed_change = getGPSSpeedChange();  // Real-time change in speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed_change < -COLLISION_THRESHOLD_SPEED_DECREASE) {\n        std::cout << \"Warning: Vehicle rapidly decelerating ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 9.0f, gps_speed_change = -22.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic and radar data to detect a large animal crossing the road. Trigger a warning if the animal is within 6 meters and the vehicle speed exceeds 15 km/h.",
      "input": "Process real-time ultrasonic and radar sensor data.",
      "output": "#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 6.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 15.0f;  // km/h\n\nint main() {\n    float ultrasonic_distance = getUltrasonicDistance();  // Real-time ultrasonic distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (ultrasonic_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Large animal crossing the road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: ultrasonic_distance = 5.0f, radar_speed = 18.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and lidar data to detect a slow-moving vehicle in the same lane. Trigger a warning if the vehicle is within 8 meters and the relative speed is below 5 km/h.",
      "input": "Process real-time GPS and lidar sensor data.",
      "output": "#include <gps_sensor.hpp>  // Placeholder\n#include <lidar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 8.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 5.0f;  // km/h\n\nint main() {\n    float gps_distance = getGPSDistance();  // Real-time GPS distance\n    float lidar_speed = getLidarRelativeSpeed();  // Real-time relative speed from lidar\n\n    if (gps_distance < COLLISION_THRESHOLD_DISTANCE && lidar_speed < COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Slow-moving vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 7.0f, lidar_speed = 4.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and GPS data to detect a vehicle suddenly swerving into the lane. Trigger a warning if the vehicle is within 12 meters and the relative speed exceeds 20 km/h.",
      "input": "Process real-time radar and GPS sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <gps_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 12.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 20.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float gps_speed = getGPSSpeed();  // Real-time speed from GPS\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && gps_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Vehicle swerving into lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 10.0f, gps_speed = 22.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar data to detect a stationary object on the road ahead. Trigger a warning if the object is within 4 meters and the vehicle speed exceeds 12 km/h.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>  // Placeholder\n#include <radar_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 4.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED = 12.0f;  // km/h\n\nint main() {\n    float lidar_distance = getLidarDistance();  // Real-time lidar distance\n    float radar_speed = getRadarSpeed();  // Real-time speed from radar\n\n    if (lidar_distance < COLLISION_THRESHOLD_DISTANCE && radar_speed > COLLISION_THRESHOLD_SPEED) {\n        std::cout << \"Warning: Stationary object detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 3.0f, radar_speed = 15.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic data to detect a vehicle ahead that suddenly changes its speed. Trigger a warning if the vehicle is within 10 meters and the relative speed changes by more than 10 km/h.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>  // Placeholder\n#include <ultrasonic_sensor.hpp>  // Placeholder\n#include <iostream>\n\nconst float COLLISION_THRESHOLD_DISTANCE = 10.0f;  // meters\nconst float COLLISION_THRESHOLD_SPEED_CHANGE = 10.0f;  // km/h\n\nint main() {\n    float radar_distance = getRadarDistance();  // Real-time radar distance\n    float ultrasonic_speed_change = getUltrasonicSpeedChange();  // Real-time speed change from ultrasonic sensor\n\n    if (radar_distance < COLLISION_THRESHOLD_DISTANCE && ultrasonic_speed_change > COLLISION_THRESHOLD_SPEED_CHANGE) {\n        std::cout << \"Warning: Vehicle speed change detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 9.0f, ultrasonic_speed_change = 12.0f\n// Expected output: Warning message triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and lidar to detect a stopped vehicle in the same lane. Trigger a warning if the vehicle is within 7 meters.",
      "input": "Process real-time radar and lidar sensor data.",
      "output": "#include <radar_sensor.hpp>\n#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float COLLISION_DISTANCE = 7.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();\n    float lidar_distance = getLidarDistance();\n\n    if (radar_distance < COLLISION_DISTANCE && lidar_distance < COLLISION_DISTANCE) {\n        std::cout << \"Warning: Stopped vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 6.5f, lidar_distance = 6.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using camera and GPS to identify a vehicle decelerating sharply ahead. Trigger a warning if deceleration exceeds 15 m/s\u00b2 and distance is below 10 meters.",
      "input": "Process real-time camera and GPS data.",
      "output": "#include <camera_sensor.hpp>\n#include <gps_sensor.hpp>\n#include <iostream>\n\nconst float COLLISION_DISTANCE = 10.0f;  // meters\nconst float DECELERATION_THRESHOLD = 15.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    float camera_distance = getCameraDistance();\n    float gps_deceleration = getGPSDeceleration();\n\n    if (camera_distance < COLLISION_DISTANCE && gps_deceleration > DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sharp deceleration detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 8.0f, gps_deceleration = 16.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect a pedestrian crossing ahead. Trigger a warning if pedestrian distance is within 5 meters.",
      "input": "Process real-time radar and ultrasonic sensor data.",
      "output": "#include <radar_sensor.hpp>\n#include <ultrasonic_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();\n    float ultrasonic_distance = getUltrasonicDistance();\n\n    if (radar_distance < PEDESTRIAN_WARNING_DISTANCE || ultrasonic_distance < PEDESTRIAN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Pedestrian detected crossing the road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.5f, ultrasonic_distance = 5.2f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar and radar to detect an object in a blind spot. Trigger a warning if the object distance is within 4 meters.",
      "input": "Process real-time lidar and radar sensor data.",
      "output": "#include <lidar_sensor.hpp>\n#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float BLIND_SPOT_DISTANCE = 4.0f;  // meters\n\nint main() {\n    float lidar_distance = getLidarDistance();\n    float radar_distance = getRadarDistance();\n\n    if (lidar_distance < BLIND_SPOT_DISTANCE && radar_distance < BLIND_SPOT_DISTANCE) {\n        std::cout << \"Warning: Object detected in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 3.8f, radar_distance = 3.6f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar data to detect a stationary object on the road ahead. Trigger a warning if the object is within 6 meters.",
      "input": "Process real-time GPS and radar sensor data.",
      "output": "#include <gps_sensor.hpp>\n#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float OBJECT_WARNING_DISTANCE = 6.0f;  // meters\n\nint main() {\n    float gps_distance = getGPSDistance();\n    float radar_distance = getRadarDistance();\n\n    if (gps_distance < OBJECT_WARNING_DISTANCE && radar_distance < OBJECT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Stationary object detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 5.5f, radar_distance = 5.7f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar to detect multiple vehicles ahead. Trigger a warning if the closest vehicle is within 8 meters.",
      "input": "Process real-time radar data.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float MULTI_VEHICLE_WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float closest_vehicle_distance = getClosestRadarDistance();\n\n    if (closest_vehicle_distance < MULTI_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Vehicle detected within range.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: closest_vehicle_distance = 7.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar data to detect a fast-approaching vehicle. Trigger a warning if the relative speed exceeds 20 m/s and the distance is less than 15 meters.",
      "input": "Process real-time radar data for relative speed and distance.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float COLLISION_DISTANCE = 15.0f;  // meters\nconst float RELATIVE_SPEED_THRESHOLD = 20.0f;  // m/s\n\nint main() {\n    float distance = getRadarDistance();\n    float relative_speed = getRadarRelativeSpeed();\n\n    if (distance < COLLISION_DISTANCE && relative_speed > RELATIVE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Fast-approaching vehicle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: distance = 12.5f, relative_speed = 22.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar data to detect a motorcycle in the same lane. Trigger a warning if the motorcycle is within 10 meters.",
      "input": "Process real-time lidar data for lane objects.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float MOTORCYCLE_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float motorcycle_distance = getLidarMotorcycleDistance();\n\n    if (motorcycle_distance < MOTORCYCLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Motorcycle detected within range.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: motorcycle_distance = 9.2f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect nearby objects during parking. Trigger a warning if any object is within 2 meters.",
      "input": "Process real-time ultrasonic sensor data for object detection.",
      "output": "#include <ultrasonic_sensor.hpp>\n#include <iostream>\n\nconst float PARKING_WARNING_DISTANCE = 2.0f;  // meters\n\nint main() {\n    float object_distance = getUltrasonicDistance();\n\n    if (object_distance < PARKING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Object too close during parking.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: object_distance = 1.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera to detect merging traffic. Trigger a warning if merging vehicle distance is below 12 meters.",
      "input": "Process real-time radar and camera data.",
      "output": "#include <radar_sensor.hpp>\n#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float MERGING_WARNING_DISTANCE = 12.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();\n    float camera_distance = getCameraDistance();\n\n    if (radar_distance < MERGING_WARNING_DISTANCE && camera_distance < MERGING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Merging traffic detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 10.5f, camera_distance = 11.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using GPS and radar to detect stopped traffic ahead. Trigger a warning if traffic is within 8 meters.",
      "input": "Process real-time GPS and radar data.",
      "output": "#include <gps_sensor.hpp>\n#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float STOPPED_TRAFFIC_WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float gps_distance = getGPSDistance();\n    float radar_distance = getRadarDistance();\n\n    if (gps_distance < STOPPED_TRAFFIC_WARNING_DISTANCE && radar_distance < STOPPED_TRAFFIC_WARNING_DISTANCE) {\n        std::cout << \"Warning: Stopped traffic detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gps_distance = 7.5f, radar_distance = 7.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and ultrasonic sensors to detect cyclists. Trigger a warning if a cyclist is within 5 meters.",
      "input": "Process real-time radar and ultrasonic data for cyclist detection.",
      "output": "#include <radar_sensor.hpp>\n#include <ultrasonic_sensor.hpp>\n#include <iostream>\n\nconst float CYCLIST_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarCyclistDistance();\n    float ultrasonic_distance = getUltrasonicDistance();\n\n    if (radar_distance < CYCLIST_WARNING_DISTANCE || ultrasonic_distance < CYCLIST_WARNING_DISTANCE) {\n        std::cout << \"Warning: Cyclist detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 4.5f, ultrasonic_distance = 5.1f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar to detect objects at night. Trigger a warning if the distance is below 6 meters.",
      "input": "Process real-time lidar data for nighttime object detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float NIGHT_OBJECT_WARNING_DISTANCE = 6.0f;  // meters\n\nint main() {\n    float lidar_distance = getLidarDistance();\n\n    if (lidar_distance < NIGHT_OBJECT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Object detected at night.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lidar_distance = 5.9f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar to detect obstacles during high-speed driving. Trigger a warning if the distance is less than 20 meters.",
      "input": "Process real-time radar data for obstacle detection at high speed.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float HIGH_SPEED_WARNING_DISTANCE = 20.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();\n\n    if (radar_distance < HIGH_SPEED_WARNING_DISTANCE) {\n        std::cout << \"Warning: Obstacle detected during high-speed driving.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 19.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar and camera to detect large vehicles (e.g., trucks). Trigger a warning if the distance is less than 18 meters.",
      "input": "Process real-time radar and camera data for large vehicle detection.",
      "output": "#include <radar_sensor.hpp>\n#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float LARGE_VEHICLE_WARNING_DISTANCE = 18.0f;  // meters\n\nint main() {\n    float radar_distance = getRadarDistance();\n    float camera_distance = getCameraDistance();\n\n    if (radar_distance < LARGE_VEHICLE_WARNING_DISTANCE && camera_distance < LARGE_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Large vehicle detected ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: radar_distance = 17.8f, camera_distance = 17.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects vehicles stopping suddenly using radar data. Trigger a warning if the relative deceleration exceeds 5 m/s\u00b2 and the distance is below 12 meters.",
      "input": "Process real-time radar data for deceleration and distance.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 5.0f;  // m/s\u00c2\u00b2\nconst float STOPPING_WARNING_DISTANCE = 12.0f;  // meters\n\nint main() {\n    float relative_deceleration = getRadarRelativeDeceleration();\n    float distance = getRadarDistance();\n\n    if (relative_deceleration > DECELERATION_THRESHOLD && distance < STOPPING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Vehicle stopping suddenly detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: relative_deceleration = 6.0f, distance = 11.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects pedestrians crossing using lidar data. Trigger a warning if a pedestrian is within 5 meters.",
      "input": "Process real-time lidar data for pedestrian detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float pedestrian_distance = getLidarPedestrianDistance();\n\n    if (pedestrian_distance < PEDESTRIAN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Pedestrian detected crossing.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_distance = 4.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects sudden traffic slowdown using radar and GPS data. Trigger a warning if the average speed drops below 20 km/h and the distance to the vehicle ahead is under 10 meters.",
      "input": "Process real-time radar and GPS data.",
      "output": "#include <radar_sensor.hpp>\n#include <gps_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_THRESHOLD = 20.0f;  // km/h\nconst float SLOWDOWN_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float average_speed = getGPSSpeed();\n    float distance_to_vehicle = getRadarDistance();\n\n    if (average_speed < SPEED_THRESHOLD && distance_to_vehicle < SLOWDOWN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Sudden traffic slowdown detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: average_speed = 18.0f, distance_to_vehicle = 9.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using radar data to detect stationary obstacles. Trigger a warning if the obstacle is within 6 meters.",
      "input": "Process real-time radar data for stationary object detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float OBSTACLE_WARNING_DISTANCE = 6.0f;  // meters\n\nint main() {\n    float obstacle_distance = getRadarObstacleDistance();\n\n    if (obstacle_distance < OBSTACLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Stationary obstacle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: obstacle_distance = 5.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that uses camera data to detect a merging truck. Trigger a warning if the truck's distance is less than 15 meters.",
      "input": "Process real-time camera data for large vehicle detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float TRUCK_MERGING_WARNING_DISTANCE = 15.0f;  // meters\n\nint main() {\n    float truck_distance = getCameraTruckDistance();\n\n    if (truck_distance < TRUCK_MERGING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Merging truck detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: truck_distance = 14.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using ultrasonic sensors to detect small animals crossing the road. Trigger a warning if the animal is within 3 meters.",
      "input": "Process real-time ultrasonic sensor data for animal detection.",
      "output": "#include <ultrasonic_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_WARNING_DISTANCE = 3.0f;  // meters\n\nint main() {\n    float animal_distance = getUltrasonicAnimalDistance();\n\n    if (animal_distance < ANIMAL_WARNING_DISTANCE) {\n        std::cout << \"Warning: Small animal detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: animal_distance = 2.7f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects traffic signals using camera data. Trigger a warning if the vehicle is approaching a red light within 10 meters.",
      "input": "Process real-time camera data for traffic signal detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float RED_LIGHT_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float red_light_distance = getCameraTrafficLightDistance();\n\n    if (red_light_distance < RED_LIGHT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Approaching red light.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: red_light_distance = 9.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system using lidar data to detect road debris. Trigger a warning if the debris is within 4 meters.",
      "input": "Process real-time lidar data for debris detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float DEBRIS_WARNING_DISTANCE = 4.0f;  // meters\n\nint main() {\n    float debris_distance = getLidarDebrisDistance();\n\n    if (debris_distance < DEBRIS_WARNING_DISTANCE) {\n        std::cout << \"Warning: Road debris detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: debris_distance = 3.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects emergency vehicles using camera and audio data. Trigger a warning if the emergency vehicle is within 20 meters.",
      "input": "Process real-time camera and audio data for emergency vehicle detection.",
      "output": "#include <camera_sensor.hpp>\n#include <audio_sensor.hpp>\n#include <iostream>\n\nconst float EMERGENCY_VEHICLE_WARNING_DISTANCE = 20.0f;  // meters\n\nint main() {\n    float camera_distance = getCameraEmergencyVehicleDistance();\n    float audio_distance = getAudioEmergencyVehicleDistance();\n\n    if (camera_distance < EMERGENCY_VEHICLE_WARNING_DISTANCE || audio_distance < EMERGENCY_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Emergency vehicle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: camera_distance = 19.8f, audio_distance = 21.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that monitors vehicle ahead acceleration using radar data. Trigger a warning if the vehicle is decelerating at more than 4 m/s\u00b2 and the distance is less than 8 meters.",
      "input": "Process radar data for acceleration and distance.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = -4.0f;  // m/s\u00c2\u00b2\nconst float WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float vehicle_acceleration = getRadarAcceleration();\n    float vehicle_distance = getRadarDistance();\n\n    if (vehicle_acceleration < DECELERATION_THRESHOLD && vehicle_distance < WARNING_DISTANCE) {\n        std::cout << \"Warning: Rapid deceleration detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_acceleration = -4.5f, vehicle_distance = 7.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects stopped vehicles using lidar data. Trigger a warning if the distance is under 6 meters.",
      "input": "Process lidar data to determine vehicle status.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float STOPPED_WARNING_DISTANCE = 6.0f;  // meters\n\nint main() {\n    float stopped_vehicle_distance = getLidarDistance();\n\n    if (stopped_vehicle_distance < STOPPED_WARNING_DISTANCE) {\n        std::cout << \"Warning: Stopped vehicle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: stopped_vehicle_distance = 5.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that identifies slow-moving vehicles using GPS and radar data. Trigger a warning if the speed difference exceeds 15 km/h and the distance is below 10 meters.",
      "input": "Process GPS and radar data for speed and distance.",
      "output": "#include <gps_sensor.hpp>\n#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_DIFFERENCE_THRESHOLD = 15.0f;  // km/h\nconst float WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float speed_difference = getGPSSpeedDifference();\n    float vehicle_distance = getRadarDistance();\n\n    if (speed_difference > SPEED_DIFFERENCE_THRESHOLD && vehicle_distance < WARNING_DISTANCE) {\n        std::cout << \"Warning: Slow-moving vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: speed_difference = 16.0f, vehicle_distance = 9.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects construction zones using camera data. Trigger a warning if the camera identifies a construction sign and the vehicle is within 15 meters.",
      "input": "Process camera data for construction zone detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float CONSTRUCTION_ZONE_WARNING_DISTANCE = 15.0f;  // meters\n\nint main() {\n    float construction_sign_distance = getCameraConstructionSignDistance();\n\n    if (construction_sign_distance < CONSTRUCTION_ZONE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Approaching construction zone.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: construction_sign_distance = 14.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects merging traffic using radar data. Trigger a warning if a vehicle is detected at a relative speed above 10 km/h within 20 meters.",
      "input": "Process radar data for merging traffic detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float MERGING_SPEED_THRESHOLD = 10.0f;  // km/h\nconst float MERGING_WARNING_DISTANCE = 20.0f;  // meters\n\nint main() {\n    float relative_speed = getRadarRelativeSpeed();\n    float merging_distance = getRadarDistance();\n\n    if (relative_speed > MERGING_SPEED_THRESHOLD && merging_distance < MERGING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Merging traffic detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: relative_speed = 12.0f, merging_distance = 18.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects sharp curves using GPS and camera data. Trigger a warning if a curve is detected within 30 meters and the speed exceeds 50 km/h.",
      "input": "Process GPS and camera data for curve detection.",
      "output": "#include <gps_sensor.hpp>\n#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float CURVE_WARNING_DISTANCE = 30.0f;  // meters\nconst float CURVE_SPEED_THRESHOLD = 50.0f;  // km/h\n\nint main() {\n    float curve_distance = getCameraCurveDistance();\n    float vehicle_speed = getGPSSpeed();\n\n    if (curve_distance < CURVE_WARNING_DISTANCE && vehicle_speed > CURVE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Sharp curve ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: curve_distance = 28.0f, vehicle_speed = 55.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects lane encroachment using camera data. Trigger a warning if another vehicle crosses into the lane within 8 meters.",
      "input": "Process camera data for lane encroachment detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float LANE_ENCROACHMENT_WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float encroaching_vehicle_distance = getCameraEncroachmentDistance();\n\n    if (encroaching_vehicle_distance < LANE_ENCROACHMENT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Lane encroachment detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: encroaching_vehicle_distance = 7.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects tailgating using radar data. Trigger a warning if a vehicle follows within 5 meters at a speed above 40 km/h.",
      "input": "Process radar data for tailgating detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float TAILGATING_WARNING_DISTANCE = 5.0f;  // meters\nconst float TAILGATING_SPEED_THRESHOLD = 40.0f;  // km/h\n\nint main() {\n    float following_vehicle_distance = getRadarDistance();\n    float vehicle_speed = getRadarSpeed();\n\n    if (following_vehicle_distance < TAILGATING_WARNING_DISTANCE && vehicle_speed > TAILGATING_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Tailgating detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: following_vehicle_distance = 4.5f, vehicle_speed = 42.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects abrupt lane changes using camera data. Trigger a warning if a vehicle switches lanes within 5 meters at a relative speed exceeding 15 km/h.",
      "input": "Process camera data for lane change detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float LANE_CHANGE_WARNING_DISTANCE = 5.0f;  // meters\nconst float LANE_CHANGE_SPEED_THRESHOLD = 15.0f;  // km/h\n\nint main() {\n    float lane_change_distance = getCameraLaneChangeDistance();\n    float relative_speed = getCameraRelativeSpeed();\n\n    if (lane_change_distance < LANE_CHANGE_WARNING_DISTANCE && relative_speed > LANE_CHANGE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Abrupt lane change detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lane_change_distance = 4.8f, relative_speed = 16.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects steep inclines using GPS elevation data. Trigger a warning if the incline exceeds 15 degrees and the vehicle is within 20 meters.",
      "input": "Process GPS elevation data for incline detection.",
      "output": "#include <gps_sensor.hpp>\n#include <iostream>\n\nconst float INCLINE_WARNING_ANGLE = 15.0f;  // degrees\nconst float INCLINE_WARNING_DISTANCE = 20.0f;  // meters\n\nint main() {\n    float incline_angle = getGPSElevationAngle();\n    float incline_distance = getGPSElevationDistance();\n\n    if (incline_angle > INCLINE_WARNING_ANGLE && incline_distance < INCLINE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Steep incline ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: incline_angle = 16.0f, incline_distance = 19.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects sudden braking using radar and speed sensors. Trigger a warning if deceleration exceeds 6 m/s\u00b2 and the distance to the vehicle ahead is less than 10 meters.",
      "input": "Process radar and speed sensor data.",
      "output": "#include <radar_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float BRAKING_DECELERATION_THRESHOLD = -6.0f;  // m/s\u00c2\u00b2\nconst float BRAKING_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float deceleration = getRadarDeceleration();\n    float vehicle_distance = getRadarDistance();\n\n    if (deceleration < BRAKING_DECELERATION_THRESHOLD && vehicle_distance < BRAKING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Sudden braking detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: deceleration = -6.5f, vehicle_distance = 9.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects fog conditions using camera and light sensors. Trigger a warning if visibility is below 50 meters and headlights are not activated.",
      "input": "Process camera visibility data and light sensor status.",
      "output": "#include <camera_sensor.hpp>\n#include <light_sensor.hpp>\n#include <iostream>\n\nconst float FOG_VISIBILITY_THRESHOLD = 50.0f;  // meters\n\nint main() {\n    float visibility = getCameraVisibility();\n    bool headlights_active = isLightSensorHeadlightsOn();\n\n    if (visibility < FOG_VISIBILITY_THRESHOLD && !headlights_active) {\n        std::cout << \"Warning: Low visibility detected. Activate headlights.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: visibility = 45.0f, headlights_active = false\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects animals on the road using thermal cameras. Trigger a warning if an animal is detected within 15 meters.",
      "input": "Process thermal camera data for animal detection.",
      "output": "#include <thermal_camera.hpp>\n#include <iostream>\n\nconst float ANIMAL_WARNING_DISTANCE = 15.0f;  // meters\n\nint main() {\n    float animal_distance = getThermalCameraAnimalDistance();\n\n    if (animal_distance < ANIMAL_WARNING_DISTANCE) {\n        std::cout << \"Warning: Animal detected on the road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: animal_distance = 14.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects red-light violations using camera data. Trigger a warning if the traffic light is red and the vehicle is within 5 meters.",
      "input": "Process camera data for traffic light detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float RED_LIGHT_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    bool is_red_light = isCameraRedLightDetected();\n    float vehicle_distance = getCameraDistance();\n\n    if (is_red_light && vehicle_distance < RED_LIGHT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Red light violation risk.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: is_red_light = true, vehicle_distance = 4.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code for an FCW system that detects crosswalk pedestrians using radar and camera data. Trigger a warning if pedestrians are detected within 10 meters.",
      "input": "Process radar and camera data for pedestrian detection.",
      "output": "#include <radar_sensor.hpp>\n#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    bool pedestrian_detected = isRadarOrCameraPedestrianDetected();\n    float pedestrian_distance = getRadarOrCameraDistance();\n\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Pedestrian detected at crosswalk.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_detected = true, pedestrian_distance = 9.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns the driver about stationary objects detected ahead using radar data. Trigger the warning if the object is within 12 meters and the relative speed is greater than 10 km/h.",
      "input": "Process radar data for stationary object detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float STATIONARY_OBJECT_WARNING_DISTANCE = 12.0f;  // meters\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // km/h\n\nint main() {\n    float object_distance = getRadarObjectDistance();\n    float relative_speed = getRadarRelativeSpeed();\n\n    if (object_distance < STATIONARY_OBJECT_WARNING_DISTANCE && relative_speed > RELATIVE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Stationary object ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: object_distance = 10.5f, relative_speed = 12.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that alerts the driver about vehicles merging onto the road from the sides using lidar data. Trigger the warning if the merging vehicle is within 8 meters.",
      "input": "Process lidar data for side vehicle detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float MERGING_VEHICLE_WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float merging_vehicle_distance = getLidarSideVehicleDistance();\n\n    if (merging_vehicle_distance < MERGING_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Merging vehicle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: merging_vehicle_distance = 7.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns of roadblocks detected ahead using radar and GPS data. Trigger the warning if a roadblock is detected within 20 meters.",
      "input": "Process radar and GPS data for roadblock detection.",
      "output": "#include <radar_sensor.hpp>\n#include <gps_sensor.hpp>\n#include <iostream>\n\nconst float ROADBLOCK_WARNING_DISTANCE = 20.0f;  // meters\n\nint main() {\n    bool roadblock_detected = isRoadblockDetected();\n    float roadblock_distance = getRoadblockDistance();\n\n    if (roadblock_detected && roadblock_distance < ROADBLOCK_WARNING_DISTANCE) {\n        std::cout << \"Warning: Roadblock ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: roadblock_detected = true, roadblock_distance = 19.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sharp curves ahead using GPS data. Trigger a warning if the curve radius is less than 50 meters and the vehicle speed exceeds 40 km/h.",
      "input": "Process GPS data for sharp curve detection.",
      "output": "#include <gps_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float CURVE_RADIUS_WARNING_THRESHOLD = 50.0f;  // meters\nconst float CURVE_SPEED_WARNING_THRESHOLD = 40.0f;  // km/h\n\nint main() {\n    float curve_radius = getGPSCurveRadius();\n    float vehicle_speed = getSpeed();\n\n    if (curve_radius < CURVE_RADIUS_WARNING_THRESHOLD && vehicle_speed > CURVE_SPEED_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Sharp curve ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: curve_radius = 45.0f, vehicle_speed = 42.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that alerts drivers of vehicles overtaking on either side using camera data. Trigger the warning if the overtaking vehicle is within 3 meters.",
      "input": "Process camera data for overtaking vehicle detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float OVERTAKING_WARNING_DISTANCE = 3.0f;  // meters\n\nint main() {\n    float overtaking_vehicle_distance = getCameraOvertakingVehicleDistance();\n\n    if (overtaking_vehicle_distance < OVERTAKING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Overtaking vehicle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: overtaking_vehicle_distance = 2.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects icy road conditions using temperature sensors. Trigger the warning if the road temperature is below -5\u00b0C.",
      "input": "Process temperature sensor data for icy road detection.",
      "output": "#include <temperature_sensor.hpp>\n#include <iostream>\n\nconst float ICY_ROAD_WARNING_TEMPERATURE = -5.0f;  // degrees Celsius\n\nint main() {\n    float road_temperature = getRoadTemperature();\n\n    if (road_temperature < ICY_ROAD_WARNING_TEMPERATURE) {\n        std::cout << \"Warning: Icy road detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: road_temperature = -6.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns of construction zones ahead using GPS data. Trigger the warning if the construction zone is within 100 meters.",
      "input": "Process GPS data for construction zone detection.",
      "output": "#include <gps_sensor.hpp>\n#include <iostream>\n\nconst float CONSTRUCTION_ZONE_WARNING_DISTANCE = 100.0f;  // meters\n\nint main() {\n    float construction_zone_distance = getGPSConstructionZoneDistance();\n\n    if (construction_zone_distance < CONSTRUCTION_ZONE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Construction zone ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: construction_zone_distance = 98.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects animals crossing the road using infrared sensors. Trigger the warning if an animal is within 15 meters.",
      "input": "Process infrared sensor data for animal detection.",
      "output": "#include <infrared_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_WARNING_DISTANCE = 15.0f;  // meters\n\nint main() {\n    float animal_distance = getInfraredAnimalDistance();\n\n    if (animal_distance < ANIMAL_WARNING_DISTANCE) {\n        std::cout << \"Warning: Animal detected on the road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: animal_distance = 12.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that alerts the driver about vehicles suddenly braking ahead using radar data. Trigger the warning if the relative speed is negative and the distance is within 10 meters.",
      "input": "Process radar data for sudden braking detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float SUDDEN_BRAKING_WARNING_DISTANCE = 10.0f;  // meters\nconst float RELATIVE_SPEED_WARNING_THRESHOLD = -1.0f; // km/h\n\nint main() {\n    float object_distance = getRadarObjectDistance();\n    float relative_speed = getRadarRelativeSpeed();\n\n    if (object_distance < SUDDEN_BRAKING_WARNING_DISTANCE && relative_speed < RELATIVE_SPEED_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Sudden braking vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: object_distance = 8.5f, relative_speed = -3.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns drivers about heavy rain conditions detected using rain sensors. Trigger the warning if the rain intensity exceeds 80%.",
      "input": "Process rain sensor data for rain intensity detection.",
      "output": "#include <rain_sensor.hpp>\n#include <iostream>\n\nconst float HEAVY_RAIN_WARNING_THRESHOLD = 80.0f;  // percentage\n\nint main() {\n    float rain_intensity = getRainIntensity();\n\n    if (rain_intensity > HEAVY_RAIN_WARNING_THRESHOLD) {\n        std::cout << \"Warning: Heavy rain detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: rain_intensity = 85.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects black ice on the road using temperature and humidity sensors. Trigger the warning if the temperature is below -2\u00b0C and humidity is above 90%.",
      "input": "Process temperature and humidity sensor data for black ice detection.",
      "output": "#include <temperature_sensor.hpp>\n#include <humidity_sensor.hpp>\n#include <iostream>\n\nconst float BLACK_ICE_TEMPERATURE_THRESHOLD = -2.0f;  // degrees Celsius\nconst float BLACK_ICE_HUMIDITY_THRESHOLD = 90.0f;     // percentage\n\nint main() {\n    float road_temperature = getRoadTemperature();\n    float road_humidity = getRoadHumidity();\n\n    if (road_temperature < BLACK_ICE_TEMPERATURE_THRESHOLD && road_humidity > BLACK_ICE_HUMIDITY_THRESHOLD) {\n        std::cout << \"Warning: Black ice detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: road_temperature = -3.0f, road_humidity = 92.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns of traffic jams ahead using real-time traffic data. Trigger the warning if the average speed of vehicles within 1 km is below 10 km/h.",
      "input": "Process real-time traffic data for jam detection.",
      "output": "#include <traffic_sensor.hpp>\n#include <iostream>\n\nconst float TRAFFIC_JAM_SPEED_THRESHOLD = 10.0f;  // km/h\nconst float TRAFFIC_JAM_RADIUS = 1000.0f;         // meters\n\nint main() {\n    float average_speed = getAverageTrafficSpeed(TRAFFIC_JAM_RADIUS);\n\n    if (average_speed < TRAFFIC_JAM_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Traffic jam ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: average_speed = 8.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that alerts drivers about pedestrians detected on crosswalks using camera data. Trigger the warning if pedestrians are within 5 meters.",
      "input": "Process camera data for pedestrian detection.",
      "output": "#include <camera_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float pedestrian_distance = getCameraPedestrianDistance();\n\n    if (pedestrian_distance < PEDESTRIAN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Pedestrian detected on crosswalk.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_distance = 4.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns drivers about potholes detected using lidar data. Trigger the warning if the pothole depth exceeds 15 cm.",
      "input": "Process lidar data for pothole detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float POTHOLE_WARNING_DEPTH = 15.0f;  // centimeters\n\nint main() {\n    float pothole_depth = getLidarPotholeDepth();\n\n    if (pothole_depth > POTHOLE_WARNING_DEPTH) {\n        std::cout << \"Warning: Pothole detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pothole_depth = 18.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that warns drivers about low visibility due to fog using visibility sensors. Trigger the warning if visibility is below 100 meters.",
      "input": "Process visibility sensor data for fog detection.",
      "output": "#include <visibility_sensor.hpp>\n#include <iostream>\n\nconst float LOW_VISIBILITY_THRESHOLD = 100.0f;  // meters\n\nint main() {\n    float visibility_distance = getVisibilityDistance();\n\n    if (visibility_distance < LOW_VISIBILITY_THRESHOLD) {\n        std::cout << \"Warning: Low visibility detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: visibility_distance = 80.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect approaching vehicles using ultrasonic sensors. Trigger the warning if a vehicle is detected within 3 meters.",
      "input": "Process ultrasonic sensor data to identify objects within a short range.",
      "output": "#include <ultrasonic_sensor.hpp>\n#include <iostream>\n\nconst float VEHICLE_WARNING_DISTANCE = 3.0f;  // meters\n\nint main() {\n    float vehicle_distance = getUltrasonicVehicleDistance();\n\n    if (vehicle_distance < VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Vehicle detected too close.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_distance = 2.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect cyclists in blind spots using side radar sensors. Trigger the warning if a cyclist is detected within 2 meters.",
      "input": "Process side radar data for cyclist detection.",
      "output": "#include <side_radar_sensor.hpp>\n#include <iostream>\n\nconst float CYCLIST_WARNING_DISTANCE = 2.0f;  // meters\n\nint main() {\n    float cyclist_distance = getSideRadarCyclistDistance();\n\n    if (cyclist_distance < CYCLIST_WARNING_DISTANCE) {\n        std::cout << \"Warning: Cyclist in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: cyclist_distance = 1.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect falling rocks using lidar sensors. Trigger the warning if the rock is within 20 meters.",
      "input": "Process lidar data for falling rock detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float ROCK_WARNING_DISTANCE = 20.0f;  // meters\n\nint main() {\n    float rock_distance = getLidarRockDistance();\n\n    if (rock_distance < ROCK_WARNING_DISTANCE) {\n        std::cout << \"Warning: Falling rock detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: rock_distance = 15.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect stationary objects using radar sensors. Trigger the warning if the object is within 5 meters.",
      "input": "Process radar data for stationary object detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float OBJECT_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float object_distance = getRadarObjectDistance();\n\n    if (object_distance < OBJECT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Stationary object detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: object_distance = 4.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect road barriers using proximity sensors. Trigger the warning if the barrier is within 1 meter.",
      "input": "Process proximity sensor data for barrier detection.",
      "output": "#include <proximity_sensor.hpp>\n#include <iostream>\n\nconst float BARRIER_WARNING_DISTANCE = 1.0f;  // meters\n\nint main() {\n    float barrier_distance = getProximityBarrierDistance();\n\n    if (barrier_distance < BARRIER_WARNING_DISTANCE) {\n        std::cout << \"Warning: Road barrier detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: barrier_distance = 0.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect animals near forest roads using night vision cameras. Trigger the warning if an animal is detected within 10 meters.",
      "input": "Process night vision camera data for animal detection.",
      "output": "#include <night_vision_camera.hpp>\n#include <iostream>\n\nconst float ANIMAL_DETECTION_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float animal_distance = getNightVisionAnimalDistance();\n\n    if (animal_distance < ANIMAL_DETECTION_DISTANCE) {\n        std::cout << \"Warning: Animal detected near road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: animal_distance = 9.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect oncoming vehicles on a curve using radar sensors. Trigger the warning if the vehicle is detected within 15 meters.",
      "input": "Process radar data for oncoming vehicle detection on curves.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float ONCOMING_VEHICLE_DISTANCE = 15.0f;  // meters\n\nint main() {\n    float vehicle_distance = getRadarOncomingVehicleDistance();\n\n    if (vehicle_distance < ONCOMING_VEHICLE_DISTANCE) {\n        std::cout << \"Warning: Oncoming vehicle detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_distance = 14.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect drifting cars on highways using lidar sensors. Trigger the warning if a drifting car is within 8 meters.",
      "input": "Process lidar data for drifting car detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float DRIFTING_CAR_WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float car_distance = getLidarDriftingCarDistance();\n\n    if (car_distance < DRIFTING_CAR_WARNING_DISTANCE) {\n        std::cout << \"Warning: Drifting car detected.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_distance = 7.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system to detect construction zones using image recognition. Trigger the warning if a construction zone sign is detected within 20 meters.",
      "input": "Process image recognition data for construction zone detection.",
      "output": "#include <image_recognition.hpp>\n#include <iostream>\n\nconst float CONSTRUCTION_ZONE_DISTANCE = 20.0f;  // meters\n\nint main() {\n    float construction_zone_distance = getImageRecognitionConstructionZoneDistance();\n\n    if (construction_zone_distance < CONSTRUCTION_ZONE_DISTANCE) {\n        std::cout << \"Warning: Construction zone ahead.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: construction_zone_distance = 18.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect sudden braking of the vehicle ahead using real-time radar data. Trigger a warning if the speed difference exceeds 15 m/s.",
      "input": "Process radar speed data for sudden braking detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_DIFFERENCE_THRESHOLD = 15.0f;  // m/s\n\nint main() {\n    float current_speed = getCurrentSpeed();  // Current vehicle speed\n    float front_vehicle_speed = getRadarFrontVehicleSpeed();  // Speed of the vehicle ahead\n\n    if ((current_speed - front_vehicle_speed) > SPEED_DIFFERENCE_THRESHOLD) {\n        std::cout << \"Warning: Sudden braking detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: current_speed = 30.0f, front_vehicle_speed = 10.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect pedestrians in crosswalks using lidar data. Trigger a warning if a pedestrian is within 5 meters.",
      "input": "Process lidar data for pedestrian detection.",
      "output": "#include <lidar_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float pedestrian_distance = getLidarPedestrianDistance();\n\n    if (pedestrian_distance < PEDESTRIAN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Pedestrian in crosswalk!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_distance = 4.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect stopped vehicles on highways using radar data. Trigger a warning if a vehicle is detected within 10 meters.",
      "input": "Process radar data for stopped vehicle detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float STOPPED_VEHICLE_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float stopped_vehicle_distance = getRadarStoppedVehicleDistance();\n\n    if (stopped_vehicle_distance < STOPPED_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Stopped vehicle detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: stopped_vehicle_distance = 8.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect motorcycles in blind spots using side cameras. Trigger a warning if a motorcycle is detected within 3 meters.",
      "input": "Process side camera data for motorcycle detection.",
      "output": "#include <side_camera.hpp>\n#include <iostream>\n\nconst float MOTORCYCLE_WARNING_DISTANCE = 3.0f;  // meters\n\nint main() {\n    float motorcycle_distance = getSideCameraMotorcycleDistance();\n\n    if (motorcycle_distance < MOTORCYCLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Motorcycle in blind spot!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: motorcycle_distance = 2.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect rear-end collisions using rear radar. Trigger a warning if the closing vehicle is within 2 meters and its speed exceeds 10 m/s.",
      "input": "Process rear radar data for rear-end collision detection.",
      "output": "#include <rear_radar_sensor.hpp>\n#include <iostream>\n\nconst float REAR_VEHICLE_WARNING_DISTANCE = 2.0f;  // meters\nconst float REAR_VEHICLE_SPEED_THRESHOLD = 10.0f; // m/s\n\nint main() {\n    float rear_vehicle_distance = getRearRadarVehicleDistance();\n    float rear_vehicle_speed = getRearRadarVehicleSpeed();\n\n    if (rear_vehicle_distance < REAR_VEHICLE_WARNING_DISTANCE &&\n        rear_vehicle_speed > REAR_VEHICLE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Potential rear-end collision!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: rear_vehicle_distance = 1.8f, rear_vehicle_speed = 12.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect heavy vehicles ahead using radar. Trigger a warning if the heavy vehicle is within 8 meters.",
      "input": "Process radar data for heavy vehicle detection.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float HEAVY_VEHICLE_WARNING_DISTANCE = 8.0f;  // meters\n\nint main() {\n    float heavy_vehicle_distance = getRadarHeavyVehicleDistance();\n\n    if (heavy_vehicle_distance < HEAVY_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Heavy vehicle ahead!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: heavy_vehicle_distance = 7.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect construction vehicles using proximity sensors. Trigger a warning if a vehicle is within 5 meters.",
      "input": "Process proximity sensor data for construction vehicle detection.",
      "output": "#include <proximity_sensor.hpp>\n#include <iostream>\n\nconst float CONSTRUCTION_VEHICLE_WARNING_DISTANCE = 5.0f;  // meters\n\nint main() {\n    float construction_vehicle_distance = getProximityConstructionVehicleDistance();\n\n    if (construction_vehicle_distance < CONSTRUCTION_VEHICLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Construction vehicle detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: construction_vehicle_distance = 4.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect children running near the road using vision systems. Trigger a warning if a child is detected within 10 meters.",
      "input": "Process vision system data for child detection.",
      "output": "#include <vision_system.hpp>\n#include <iostream>\n\nconst float CHILD_WARNING_DISTANCE = 10.0f;  // meters\n\nint main() {\n    float child_distance = getVisionChildDistance();\n\n    if (child_distance < CHILD_WARNING_DISTANCE) {\n        std::cout << \"Warning: Child near the road!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: child_distance = 9.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect animals crossing rural roads using thermal cameras. Trigger a warning if an animal is detected within 12 meters.",
      "input": "Process thermal camera data for animal detection.",
      "output": "#include <thermal_camera.hpp>\n#include <iostream>\n\nconst float ANIMAL_CROSSING_WARNING_DISTANCE = 12.0f;  // meters\n\nint main() {\n    float animal_distance = getThermalCameraAnimalDistance();\n\n    if (animal_distance < ANIMAL_CROSSING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Animal crossing detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: animal_distance = 10.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect sudden lane departure using camera system data. Trigger a warning if the car deviates by more than 0.5 meters from its lane.",
      "input": "Process lane departure data from camera system.",
      "output": "#include <lane_departure_camera.hpp>\n#include <iostream>\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f;  // meters\n\nint main() {\n    float lane_deviation = getLaneDeviation();  // Distance of car from lane center\n\n    if (lane_deviation > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lane_deviation = 0.6f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect fog conditions using weather sensor data. Trigger a warning if visibility drops below 100 meters.",
      "input": "Process weather sensor data for visibility measurement.",
      "output": "#include <weather_sensor.hpp>\n#include <iostream>\n\nconst float VISIBILITY_THRESHOLD = 100.0f;  // meters\n\nint main() {\n    float visibility = getVisibilityData();\n\n    if (visibility < VISIBILITY_THRESHOLD) {\n        std::cout << \"Warning: Low visibility detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: visibility = 90.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect excessive vehicle speed ahead using radar data. Trigger a warning if the vehicle ahead exceeds 120 km/h.",
      "input": "Process radar data for speed measurement of the vehicle ahead.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_LIMIT = 120.0f;  // km/h\n\nint main() {\n    float vehicle_speed = getRadarVehicleSpeed();\n\n    if (vehicle_speed > SPEED_LIMIT) {\n        std::cout << \"Warning: Vehicle ahead is speeding!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_speed = 130.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect potential front collision with a stationary object using camera data. Trigger a warning if the object is within 1.5 meters and the vehicle is approaching.",
      "input": "Process front camera data for object proximity detection.",
      "output": "#include <front_camera.hpp>\n#include <iostream>\n\nconst float OBJECT_WARNING_DISTANCE = 1.5f;  // meters\n\nint main() {\n    float object_distance = getFrontCameraObjectDistance();\n\n    if (object_distance < OBJECT_WARNING_DISTANCE) {\n        std::cout << \"Warning: Potential front collision!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: object_distance = 1.2f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect sharp turns ahead using GPS data. Trigger a warning if a sharp turn (more than 30 degrees) is detected within the next 500 meters.",
      "input": "Process GPS data for turn angle detection.",
      "output": "#include <gps_sensor.hpp>\n#include <iostream>\n\nconst float SHARP_TURN_ANGLE_THRESHOLD = 30.0f;  // degrees\nconst float TURN_WARNING_DISTANCE = 500.0f;  // meters\n\nint main() {\n    float turn_angle = getGpsTurnAngle();\n    float distance_to_turn = getGpsDistanceToTurn();\n\n    if (turn_angle > SHARP_TURN_ANGLE_THRESHOLD && distance_to_turn < TURN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Sharp turn ahead!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: turn_angle = 35.0f, distance_to_turn = 400.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect a potential side impact collision using side radar data. Trigger a warning if another vehicle is detected within 2 meters on either side.",
      "input": "Process side radar data for vehicle proximity.",
      "output": "#include <side_radar_sensor.hpp>\n#include <iostream>\n\nconst float SIDE_COLLISION_WARNING_DISTANCE = 2.0f;  // meters\n\nint main() {\n    float left_vehicle_distance = getSideRadarLeftVehicleDistance();\n    float right_vehicle_distance = getSideRadarRightVehicleDistance();\n\n    if (left_vehicle_distance < SIDE_COLLISION_WARNING_DISTANCE || right_vehicle_distance < SIDE_COLLISION_WARNING_DISTANCE) {\n        std::cout << \"Warning: Potential side collision detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: left_vehicle_distance = 1.8f, right_vehicle_distance = 2.1f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect rear-end collision risk using radar data. Trigger a warning if the closing speed exceeds 20 m/s.",
      "input": "Process rear radar data for closing speed detection.",
      "output": "#include <rear_radar_sensor.hpp>\n#include <iostream>\n\nconst float CLOSING_SPEED_THRESHOLD = 20.0f;  // m/s\n\nint main() {\n    float closing_speed = getRearRadarClosingSpeed();\n\n    if (closing_speed > CLOSING_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Rear-end collision risk detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: closing_speed = 22.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect low tire pressure using the vehicle's onboard sensors. Trigger a warning if any tire pressure drops below 25 PSI.",
      "input": "Process onboard tire pressure sensor data.",
      "output": "#include <tire_pressure_sensor.hpp>\n#include <iostream>\n\nconst float TIRE_PRESSURE_THRESHOLD = 25.0f;  // PSI\n\nint main() {\n    float tire_pressure = getTirePressureData();\n\n    if (tire_pressure < TIRE_PRESSURE_THRESHOLD) {\n        std::cout << \"Warning: Low tire pressure detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: tire_pressure = 20.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect obstacles in the parking lot using ultrasonic sensors. Trigger a warning if an object is within 0.8 meters.",
      "input": "Process ultrasonic sensor data for parking obstacle detection.",
      "output": "#include <ultrasonic_sensor.hpp>\n#include <iostream>\n\nconst float PARKING_OBSTACLE_WARNING_DISTANCE = 0.8f;  // meters\n\nint main() {\n    float obstacle_distance = getUltrasonicObstacleDistance();\n\n    if (obstacle_distance < PARKING_OBSTACLE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Obstacle detected in parking lot!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: obstacle_distance = 0.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect sudden deceleration of the lead vehicle using radar. Trigger a warning if the deceleration exceeds 5 m/s^2.",
      "input": "Process radar data for lead vehicle deceleration.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 5.0f;  // m/s^2\n\nint main() {\n    float lead_vehicle_deceleration = getRadarLeadVehicleDeceleration();\n\n    if (lead_vehicle_deceleration > DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Sudden deceleration of lead vehicle!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lead_vehicle_deceleration = 6.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect if the lead vehicle has abruptly stopped using radar data. Trigger a warning if the detected speed of the lead vehicle drops to 0 km/h within 1 second.",
      "input": "Process radar data for lead vehicle speed.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\nconst float LEAD_VEHICLE_STOPPED_THRESHOLD = 0.0f;  // km/h\nconst float TIME_WINDOW = 1.0f;  // seconds\n\nint main() {\n    float lead_vehicle_speed = getLeadVehicleSpeed();\n    float detection_time = getDetectionTime();\n\n    if (lead_vehicle_speed <= LEAD_VEHICLE_STOPPED_THRESHOLD && detection_time <= TIME_WINDOW) {\n        std::cout << \"Warning: Lead vehicle has abruptly stopped!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lead_vehicle_speed = 0.0f, detection_time = 0.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect drowsy driving using steering wheel input data. Trigger a warning if erratic steering corrections occur more than 3 times in 30 seconds.",
      "input": "Process steering wheel input data for erratic corrections.",
      "output": "#include <steering_sensor.hpp>\n#include <iostream>\n\nconst int ERRATIC_STEERING_THRESHOLD = 3;  // count\nconst float MONITORING_WINDOW = 30.0f;  // seconds\n\nint main() {\n    int erratic_corrections = getErraticSteeringCorrections();\n    float elapsed_time = getMonitoringElapsedTime();\n\n    if (erratic_corrections > ERRATIC_STEERING_THRESHOLD && elapsed_time <= MONITORING_WINDOW) {\n        std::cout << \"Warning: Drowsy driving detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: erratic_corrections = 4, elapsed_time = 25.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect sudden acceleration of the host vehicle using onboard speed sensors. Trigger a warning if acceleration exceeds 4 m/s\u00b2 within 2 seconds.",
      "input": "Process onboard speed sensor data for acceleration detection.",
      "output": "#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float ACCELERATION_THRESHOLD = 4.0f;  // m/s\u00c2\u00b2\nconst float TIME_WINDOW = 2.0f;  // seconds\n\nint main() {\n    float vehicle_acceleration = getVehicleAcceleration();\n    float detection_time = getAccelerationDetectionTime();\n\n    if (vehicle_acceleration > ACCELERATION_THRESHOLD && detection_time <= TIME_WINDOW) {\n        std::cout << \"Warning: Sudden acceleration detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_acceleration = 4.5f, detection_time = 1.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect icy road conditions using tire traction sensor data. Trigger a warning if traction drops below 0.3 within 10 seconds.",
      "input": "Process tire traction sensor data for road condition assessment.",
      "output": "#include <traction_sensor.hpp>\n#include <iostream>\n\nconst float TRACTION_THRESHOLD = 0.3f;  // unitless coefficient\nconst float MONITORING_DURATION = 10.0f;  // seconds\n\nint main() {\n    float traction_value = getTireTraction();\n    float elapsed_time = getMonitoringElapsedTime();\n\n    if (traction_value < TRACTION_THRESHOLD && elapsed_time <= MONITORING_DURATION) {\n        std::cout << \"Warning: Icy road detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: traction_value = 0.2f, elapsed_time = 8.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect lane overcrowding using traffic density data from sensors. Trigger a warning if traffic density exceeds 50 vehicles per kilometer.",
      "input": "Process traffic density data from sensors.",
      "output": "#include <traffic_density_sensor.hpp>\n#include <iostream>\n\nconst float DENSITY_THRESHOLD = 50.0f;  // vehicles per kilometer\n\nint main() {\n    float traffic_density = getTrafficDensity();\n\n    if (traffic_density > DENSITY_THRESHOLD) {\n        std::cout << \"Warning: Lane overcrowding detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: traffic_density = 55.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect a car drifting backward using speed and gradient sensor data. Trigger a warning if reverse movement occurs on an incline greater than 10 degrees.",
      "input": "Process speed and gradient sensor data.",
      "output": "#include <gradient_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float INCLINE_THRESHOLD = 10.0f;  // degrees\nconst float REVERSE_SPEED_THRESHOLD = -0.1f;  // m/s\n\nint main() {\n    float gradient = getRoadGradient();\n    float speed = getVehicleSpeed();\n\n    if (gradient > INCLINE_THRESHOLD && speed < REVERSE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Vehicle drifting backward!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: gradient = 12.0f, speed = -0.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect distracted driving using head position data from the driver monitoring system. Trigger a warning if the driver looks away for more than 3 seconds.",
      "input": "Process head position data from driver monitoring system.",
      "output": "#include <driver_monitoring_system.hpp>\n#include <iostream>\n\nconst float DISTRACTION_TIME_THRESHOLD = 3.0f;  // seconds\n\nint main() {\n    float time_distracted = getDriverDistractionTime();\n\n    if (time_distracted > DISTRACTION_TIME_THRESHOLD) {\n        std::cout << \"Warning: Distracted driving detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: time_distracted = 3.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect tire blowouts using pressure drop data. Trigger a warning if tire pressure drops below 15 PSI in less than 2 seconds.",
      "input": "Process tire pressure drop data for blowout detection.",
      "output": "#include <tire_pressure_sensor.hpp>\n#include <iostream>\n\nconst float BLOWOUT_PRESSURE_THRESHOLD = 15.0f;  // PSI\nconst float TIME_WINDOW = 2.0f;  // seconds\n\nint main() {\n    float current_pressure = getCurrentTirePressure();\n    float drop_time = getPressureDropTime();\n\n    if (current_pressure < BLOWOUT_PRESSURE_THRESHOLD && drop_time <= TIME_WINDOW) {\n        std::cout << \"Warning: Tire blowout detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: current_pressure = 10.0f, drop_time = 1.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect if the lead vehicle is moving dangerously slow relative to the host vehicle. Trigger a warning if the relative speed difference exceeds 20 km/h within 1 second.",
      "input": "Process radar data to calculate relative speed difference.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\n// Constants for the threshold values\nconst float RELATIVE_SPEED_THRESHOLD = 20.0f;  // km/h\nconst float TIME_WINDOW = 1.0f;               // seconds\n\nint main() {\n    // Step 1: Retrieve the relative speed between the lead and host vehicles\n    float relative_speed = getRelativeSpeed();\n    \n    // Step 2: Get the time elapsed since the speed data was captured\n    float detection_time = getDetectionTime();\n\n    // Step 3: Check if the relative speed exceeds the threshold within the time window\n    if (relative_speed > RELATIVE_SPEED_THRESHOLD && detection_time <= TIME_WINDOW) {\n        std::cout << \"Warning: Lead vehicle is moving dangerously slow!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: relative_speed = 22.0f, detection_time = 0.9f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect lane departure events using lateral position data. Trigger a warning if the host vehicle moves out of its lane by more than 1 meter.",
      "input": "Process lateral position data from lane detection system.",
      "output": "#include <lane_detection_system.hpp>\n#include <iostream>\n\n// Threshold for lane departure in meters\nconst float LANE_DEPARTURE_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    // Step 1: Retrieve the lateral position of the host vehicle\n    float lateral_position = getLateralPosition();\n\n    // Step 2: Check if the lateral position exceeds the lane departure threshold\n    if (lateral_position > LANE_DEPARTURE_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lateral_position = 1.2f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect if the host vehicle is tailgating. Trigger a warning if the time gap to the lead vehicle is less than 2 seconds.",
      "input": "Process radar data for time gap calculation.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\n// Minimum safe time gap in seconds\nconst float MINIMUM_TIME_GAP = 2.0f;  // seconds\n\nint main() {\n    // Step 1: Retrieve the time gap to the lead vehicle\n    float time_gap = getTimeGapToLeadVehicle();\n\n    // Step 2: Check if the time gap is below the minimum safe limit\n    if (time_gap < MINIMUM_TIME_GAP) {\n        std::cout << \"Warning: Tailgating detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: time_gap = 1.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect brake malfunction using brake pressure sensor data. Trigger a warning if brake pressure exceeds 100 PSI for more than 5 seconds.",
      "input": "Process brake pressure sensor data.",
      "output": "#include <brake_pressure_sensor.hpp>\n#include <iostream>\n\n// Constants for brake pressure thresholds\nconst float MAX_BRAKE_PRESSURE = 100.0f;  // PSI\nconst float DURATION_THRESHOLD = 5.0f;   // seconds\n\nint main() {\n    // Step 1: Retrieve the current brake pressure\n    float brake_pressure = getBrakePressure();\n\n    // Step 2: Get the duration of high-pressure condition\n    float high_pressure_duration = getHighPressureDuration();\n\n    // Step 3: Check if the pressure exceeds the threshold for the specified duration\n    if (brake_pressure > MAX_BRAKE_PRESSURE && high_pressure_duration > DURATION_THRESHOLD) {\n        std::cout << \"Warning: Brake malfunction detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: brake_pressure = 105.0f, high_pressure_duration = 6.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect over-speeding using GPS data. Trigger a warning if the host vehicle speed exceeds 120 km/h.",
      "input": "Process GPS speed data.",
      "output": "#include <gps_sensor.hpp>\n#include <iostream>\n\n// Maximum allowable speed in km/h\nconst float MAX_SPEED_LIMIT = 120.0f;  // km/h\n\nint main() {\n    // Step 1: Retrieve the current speed from GPS data\n    float vehicle_speed = getGPSSpeed();\n\n    // Step 2: Check if the speed exceeds the maximum limit\n    if (vehicle_speed > MAX_SPEED_LIMIT) {\n        std::cout << \"Warning: Over-speeding detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_speed = 125.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect sudden deceleration of the lead vehicle using radar data. Trigger a warning if the lead vehicle's deceleration exceeds 8 m/s\u00b2.",
      "input": "Process radar data for lead vehicle's acceleration profile.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\n// Threshold for lead vehicle's deceleration in m/s\u00c2\u00b2\nconst float LEAD_DECELERATION_THRESHOLD = 8.0f;  // m/s\u00c2\u00b2\n\nint main() {\n    // Step 1: Retrieve the deceleration of the lead vehicle\n    float lead_deceleration = getLeadVehicleDeceleration();\n\n    // Step 2: Check if the deceleration exceeds the threshold\n    if (lead_deceleration > LEAD_DECELERATION_THRESHOLD) {\n        std::cout << \"Warning: Lead vehicle is decelerating rapidly!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lead_deceleration = 9.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect insufficient distance to the lead vehicle using radar. Trigger a warning if the gap is less than 10 meters.",
      "input": "Process radar data for lead vehicle distance.",
      "output": "#include <radar_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance to the lead vehicle in meters\nconst float MIN_SAFE_DISTANCE = 10.0f;  // meters\n\nint main() {\n    // Step 1: Retrieve the distance to the lead vehicle\n    float distance_to_lead = getDistanceToLeadVehicle();\n\n    // Step 2: Check if the distance is below the minimum safe limit\n    if (distance_to_lead < MIN_SAFE_DISTANCE) {\n        std::cout << \"Warning: Insufficient distance to lead vehicle!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: distance_to_lead = 8.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect potential side collisions using side radar sensors. Trigger a warning if a nearby vehicle is within 1 meter.",
      "input": "Process side radar data for nearby vehicle detection.",
      "output": "#include <side_radar_sensor.hpp>\n#include <iostream>\n\n// Minimum distance for side collision warning in meters\nconst float SIDE_COLLISION_THRESHOLD = 1.0f;  // meters\n\nint main() {\n    // Step 1: Retrieve the distance to the nearest side object\n    float side_distance = getSideObjectDistance();\n\n    // Step 2: Check if the side object is within the collision threshold\n    if (side_distance < SIDE_COLLISION_THRESHOLD) {\n        std::cout << \"Warning: Potential side collision detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: side_distance = 0.8f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor driver alertness using steering wheel data. Trigger a warning if there is no steering activity for 15 seconds.",
      "input": "Process steering wheel movement data.",
      "output": "#include <steering_sensor.hpp>\n#include <iostream>\n\n// Maximum allowable inactivity duration for steering in seconds\nconst float MAX_INACTIVITY_DURATION = 15.0f;  // seconds\n\nint main() {\n    // Step 1: Retrieve the duration of steering inactivity\n    float steering_inactivity = getSteeringInactivityDuration();\n\n    // Step 2: Check if the inactivity duration exceeds the threshold\n    if (steering_inactivity > MAX_INACTIVITY_DURATION) {\n        std::cout << \"Warning: Driver alertness issue detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: steering_inactivity = 16.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect slippery road conditions using ABS data. Trigger a warning if the ABS activates more than 3 times in 10 seconds.",
      "input": "Process ABS activation data.",
      "output": "#include <abs_sensor.hpp>\n#include <iostream>\n\n// Threshold for slippery road detection\nconst int MAX_ABS_ACTIVATIONS = 3;\nconst float TIME_WINDOW = 10.0f;  // seconds\n\nint main() {\n    // Step 1: Retrieve the number of ABS activations in the time window\n    int abs_activations = getABSActivations(TIME_WINDOW);\n\n    // Step 2: Check if the ABS activations exceed the threshold\n    if (abs_activations > MAX_ABS_ACTIVATIONS) {\n        std::cout << \"Warning: Slippery road conditions detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: abs_activations = 4\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect low fuel levels using fuel gauge data. Trigger a warning if the fuel level is below 5%.",
      "input": "Process fuel gauge sensor data.",
      "output": "#include <fuel_sensor.hpp>\n#include <iostream>\n\n// Minimum fuel level threshold in percentage\nconst float MIN_FUEL_LEVEL = 5.0f;  // percent\n\nint main() {\n    // Step 1: Retrieve the current fuel level\n    float fuel_level = getFuelLevel();\n\n    // Step 2: Check if the fuel level is below the minimum threshold\n    if (fuel_level < MIN_FUEL_LEVEL) {\n        std::cout << \"Warning: Low fuel level detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: fuel_level = 3.5f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect headlight malfunction using headlight sensor data. Trigger a warning if any headlight is off at night.",
      "input": "Process headlight sensor and ambient light data.",
      "output": "#include <headlight_sensor.hpp>\n#include <ambient_light_sensor.hpp>\n#include <iostream>\n\nint main() {\n    // Step 1: Retrieve the status of the headlights\n    bool are_headlights_on = getHeadlightStatus();\n\n    // Step 2: Retrieve the ambient light level\n    bool is_night = isNightTime();\n\n    // Step 3: Check if the headlights are off at night\n    if (!are_headlights_on && is_night) {\n        std::cout << \"Warning: Headlight malfunction detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: are_headlights_on = false, is_night = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor brake pedal response time. Trigger a warning if the driver\u2019s brake response time exceeds 2.5 seconds after obstacle detection.",
      "input": "Process obstacle detection and driver brake response data.",
      "output": "#include <brake_sensor.hpp>\n#include <obstacle_detection.hpp>\n#include <iostream>\n\n// Maximum allowable response time for braking in seconds\nconst float MAX_BRAKE_RESPONSE_TIME = 2.5f;  // seconds\n\nint main() {\n    // Step 1: Retrieve the obstacle detection time\n    float obstacle_time = getObstacleDetectionTime();\n\n    // Step 2: Retrieve the driver brake response time\n    float brake_response_time = getBrakeResponseTime();\n\n    // Step 3: Calculate the total response time\n    float response_time = brake_response_time - obstacle_time;\n\n    // Step 4: Check if the response time exceeds the threshold\n    if (response_time > MAX_BRAKE_RESPONSE_TIME) {\n        std::cout << \"Warning: Delayed brake response detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: obstacle_time = 10.0f, brake_response_time = 13.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect frequent lane departures using lane detection data. Trigger a warning if more than 3 departures occur within 60 seconds.",
      "input": "Process lane departure events data.",
      "output": "#include <lane_detection.hpp>\n#include <iostream>\n\n// Threshold for maximum lane departures in a minute\nconst int MAX_LANE_DEPARTURES = 3;\nconst int TIME_WINDOW = 60;  // seconds\n\nint main() {\n    // Step 1: Retrieve the number of lane departure events\n    int lane_departures = getLaneDepartureCount(TIME_WINDOW);\n\n    // Step 2: Check if the lane departures exceed the threshold\n    if (lane_departures > MAX_LANE_DEPARTURES) {\n        std::cout << \"Warning: Frequent lane departures detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lane_departures = 4\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect high-speed turns using gyroscope data. Trigger a warning if the lateral G-force exceeds 0.9 g during a turn.",
      "input": "Process gyroscope data for lateral G-force measurement.",
      "output": "#include <gyroscope.hpp>\n#include <iostream>\n\n// Threshold for lateral G-force during turns\nconst float MAX_LATERAL_G_FORCE = 0.9f;  // g\n\nint main() {\n    // Step 1: Retrieve the lateral G-force during the turn\n    float lateral_g_force = getLateralGForce();\n\n    // Step 2: Check if the G-force exceeds the threshold\n    if (lateral_g_force > MAX_LATERAL_G_FORCE) {\n        std::cout << \"Warning: High-speed turn detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lateral_g_force = 1.2f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor windshield wiper usage. Trigger a warning if wipers are not used during rain detection.",
      "input": "Process rain sensor and wiper activation data.",
      "output": "#include <rain_sensor.hpp>\n#include <wiper_sensor.hpp>\n#include <iostream>\n\nint main() {\n    // Step 1: Check if rain is detected\n    bool is_raining = isRainDetected();\n\n    // Step 2: Check if windshield wipers are active\n    bool are_wipers_active = getWiperStatus();\n\n    // Step 3: Trigger a warning if wipers are not active during rain\n    if (is_raining && !are_wipers_active) {\n        std::cout << \"Warning: Windshield wipers are off during rain!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: is_raining = true, are_wipers_active = false\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect over-speeding based on GPS speed data. Trigger a warning if the vehicle exceeds 120 km/h.",
      "input": "Process GPS-based speed data.",
      "output": "#include <gps_sensor.hpp>\n#include <iostream>\n\n// Maximum speed limit in km/h\nconst float MAX_SPEED_LIMIT = 120.0f;  // km/h\n\nint main() {\n    // Step 1: Retrieve the vehicle's current speed\n    float current_speed = getVehicleSpeed();\n\n    // Step 2: Check if the speed exceeds the maximum limit\n    if (current_speed > MAX_SPEED_LIMIT) {\n        std::cout << \"Warning: Over-speeding detected!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: current_speed = 130.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to check the distance to the car ahead and trigger an FCW if the distance is less than 10 meters at a speed above 60 km/h.",
      "input": "Distance: 8 meters, Speed: 70 km/h",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold values for FCW\nconst float MIN_SAFE_DISTANCE = 10.0f;  // meters\nconst float MIN_FCW_SPEED = 60.0f;      // km/h\n\nint main() {\n    // Step 1: Retrieve the vehicle speed\n    float speed = getVehicleSpeed();\n\n    // Step 2: Retrieve the distance to the car ahead\n    float distance = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (speed > MIN_FCW_SPEED && distance < MIN_SAFE_DISTANCE) {\n        std::cout << \"Warning: Forward Collision Risk!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: distance = 8.0f, speed = 70.0f\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to calculate the time-to-collision (TTC) and trigger an FCW if TTC is less than 2.5 seconds.",
      "input": "Speed: 80 km/h, Relative Speed: 20 km/h, Distance: 50 meters",
      "output": "#include <iostream>\n#include <cmath>\n\n// Threshold value for TTC warning\nconst float MIN_TTC = 2.5f;  // seconds\n\nint main() {\n    // Step 1: Define the speed and distance values\n    float speed = 80.0f;            // km/h\n    float relative_speed = 20.0f;   // km/h\n    float distance = 50.0f;         // meters\n\n    // Step 2: Convert speeds from km/h to m/s\n    float speed_m_s = speed * 1000 / 3600;\n    float relative_speed_m_s = relative_speed * 1000 / 3600;\n\n    // Step 3: Calculate the Time-to-Collision (TTC)\n    float ttc = distance / relative_speed_m_s;\n\n    // Step 4: Trigger warning if TTC is less than threshold\n    if (ttc < MIN_TTC) {\n        std::cout << \"Warning: Time-to-Collision below safe threshold!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: speed = 80 km/h, relative_speed = 20 km/h, distance = 50 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor brake force and distance. Trigger an FCW if emergency braking is required.",
      "input": "Brake Force: 0.4g, Distance: 6 meters, Speed: 70 km/h",
      "output": "#include <distance_sensor.hpp>\n#include <brake_force_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Thresholds for emergency braking\nconst float MIN_DISTANCE = 5.0f;    // meters\nconst float MIN_BRAKE_FORCE = 0.3f; // g\n\nint main() {\n    // Step 1: Retrieve the speed, brake force, and distance\n    float speed = getVehicleSpeed();\n    float brake_force = getBrakeForce();\n    float distance = getDistanceToCarAhead();\n\n    // Step 2: Check if emergency braking is required\n    if (distance < MIN_DISTANCE && brake_force > MIN_BRAKE_FORCE) {\n        std::cout << \"Warning: Emergency Braking Needed!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: distance = 6 m, brake_force = 0.4 g, speed = 70 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an FCW when vehicle deceleration exceeds 0.8g.",
      "input": "Deceleration: 0.85g",
      "output": "#include <deceleration_sensor.hpp>\n#include <iostream>\n\n// Threshold for deceleration-based FCW\nconst float MAX_DECELERATION = 0.8f;  // g\n\nint main() {\n    // Step 1: Retrieve the deceleration value\n    float deceleration = getVehicleDeceleration();\n\n    // Step 2: Trigger FCW if deceleration exceeds threshold\n    if (deceleration > MAX_DECELERATION) {\n        std::cout << \"Warning: Hard braking detected! Collision risk!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: deceleration = 0.85 g\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect objects within 5 meters in front of the car and trigger an FCW.",
      "input": "Detected Object Distance: 4.5 meters",
      "output": "#include <object_detection.hpp>\n#include <iostream>\n\n// Minimum safe distance for objects\nconst float SAFE_OBJECT_DISTANCE = 5.0f;  // meters\n\nint main() {\n    // Step 1: Get the distance to the nearest object\n    float object_distance = getObjectDistance();\n\n    // Step 2: Trigger FCW if object is within unsafe range\n    if (object_distance < SAFE_OBJECT_DISTANCE) {\n        std::cout << \"Warning: Object too close! Collision risk!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: object_distance = 4.5 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the relative speed to the vehicle ahead is above 30 km/h and the distance is less than 15 meters.",
      "input": "Relative Speed: 35 km/h, Distance: 10 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Thresholds for FCW\nconst float MIN_DISTANCE = 15.0f;   // meters\nconst float RELATIVE_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve relative speed and distance to the car ahead\n    float relative_speed = getRelativeSpeed();\n    float distance = getDistanceToCarAhead();\n\n    // Step 2: Check conditions for triggering FCW\n    if (relative_speed > RELATIVE_SPEED_THRESHOLD && distance < MIN_DISTANCE) {\n        std::cout << \"Warning: High relative speed with reduced distance!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: relative_speed = 35 km/h, distance = 10 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to calculate stopping distance and issue an FCW if stopping distance exceeds the distance to the car ahead.",
      "input": "Speed: 90 km/h, Distance: 40 meters, Deceleration: 0.8g",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Constants for calculation\nconst float GRAVITY = 9.8f;  // m/s^2\n\nint main() {\n    // Step 1: Retrieve inputs\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToCarAhead();\n    float deceleration = 0.8f * GRAVITY; // Convert g to m/s^2\n\n    // Step 2: Convert speed to m/s\n    float speed_m_s = speed * 1000.0f / 3600.0f;\n\n    // Step 3: Calculate stopping distance\n    float stopping_distance = (speed_m_s * speed_m_s) / (2 * deceleration);\n\n    // Step 4: Trigger FCW if stopping distance exceeds current distance\n    if (stopping_distance > distance) {\n        std::cout << \"Warning: Stopping distance exceeds safe limit!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: speed = 90 km/h, distance = 40 m, deceleration = 0.8 g\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor the lane and issue an FCW if the car ahead is detected in the same lane within a 10-meter range.",
      "input": "Lane Status: True, Distance: 8 meters",
      "output": "#include <lane_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold distance for FCW in the same lane\nconst float LANE_WARNING_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Step 1: Detect if car ahead is in the same lane\n    bool same_lane = isCarInSameLane();\n\n    // Step 2: Retrieve distance to the car ahead\n    float distance = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (same_lane && distance < LANE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Vehicle in the same lane is too close!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: same_lane = true, distance = 8 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an FCW when the relative speed to a pedestrian is above 5 km/h within 3 meters.",
      "input": "Relative Speed: 6 km/h, Distance: 2 meters",
      "output": "#include <object_detection.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Thresholds for FCW with pedestrians\nconst float PEDESTRIAN_DISTANCE = 3.0f; // meters\nconst float PEDESTRIAN_SPEED = 5.0f;   // km/h\n\nint main() {\n    // Step 1: Retrieve the relative speed and distance to pedestrian\n    float relative_speed = getRelativeSpeedToPedestrian();\n    float distance = getDistanceToPedestrian();\n\n    // Step 2: Check conditions for triggering FCW\n    if (relative_speed > PEDESTRIAN_SPEED && distance < PEDESTRIAN_DISTANCE) {\n        std::cout << \"Warning: Pedestrian collision risk!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: relative_speed = 6 km/h, distance = 2 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an FCW when weather conditions reduce safe distance by 30%.",
      "input": "Weather: Rainy, Speed: 60 km/h, Distance: 8 meters",
      "output": "#include <weather_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Thresholds for FCW\nconst float BASE_SAFE_DISTANCE = 10.0f; // meters\nconst float WEATHER_REDUCTION = 0.3f;   // 30%\n\nint main() {\n    // Step 1: Retrieve inputs\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToCarAhead();\n    bool rainy_weather = isRainyWeather();\n\n    // Step 2: Adjust safe distance based on weather\n    float adjusted_safe_distance = BASE_SAFE_DISTANCE;\n    if (rainy_weather) {\n        adjusted_safe_distance -= BASE_SAFE_DISTANCE * WEATHER_REDUCTION;\n    }\n\n    // Step 3: Trigger FCW if unsafe\n    if (distance < adjusted_safe_distance) {\n        std::cout << \"Warning: Reduced visibility! Maintain safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: weather = rainy, speed = 60 km/h, distance = 8 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an FCW if the lead car's acceleration is negative and the following car's distance is below 12 meters.",
      "input": "Lead Car Acceleration: -3.0 m/s^2, Following Car Distance: 10 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <acceleration_sensor.hpp>\n#include <iostream>\n\n// Thresholds for FCW\nconst float MIN_SAFE_DISTANCE = 12.0f; // meters\nconst float NEGATIVE_ACCELERATION = 0.0f; // m/s^2\n\nint main() {\n    // Step 1: Retrieve the acceleration of the lead car\n    float lead_car_acceleration = getLeadCarAcceleration();\n\n    // Step 2: Retrieve the distance to the car ahead\n    float following_distance = getDistanceToCarAhead();\n\n    // Step 3: Check FCW conditions\n    if (lead_car_acceleration < NEGATIVE_ACCELERATION && following_distance < MIN_SAFE_DISTANCE) {\n        std::cout << \"Warning: Lead car decelerating! Maintain safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lead_car_acceleration = -3.0 m/s^2, following_distance = 10 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when a stationary object is detected within 5 meters of the car's front bumper.",
      "input": "Object Type: Stationary, Distance: 4 meters",
      "output": "#include <object_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Thresholds for FCW\nconst float STATIONARY_OBJECT_DISTANCE = 5.0f; // meters\n\nint main() {\n    // Step 1: Check for a stationary object in front of the car\n    bool is_stationary_object = detectStationaryObject();\n\n    // Step 2: Retrieve distance to the stationary object\n    float distance = getDistanceToStationaryObject();\n\n    // Step 3: Trigger FCW if the stationary object is too close\n    if (is_stationary_object && distance < STATIONARY_OBJECT_DISTANCE) {\n        std::cout << \"Warning: Stationary object ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: is_stationary_object = true, distance = 4 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when a moving vehicle ahead is detected at a distance proportional to the current speed of the car.",
      "input": "Speed: 70 km/h, Vehicle Distance: 20 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Distance proportionality constant\nconst float SAFETY_DISTANCE_FACTOR = 0.5f; // meters per km/h\n\nint main() {\n    // Step 1: Retrieve car speed and distance to vehicle ahead\n    float speed = getVehicleSpeed(); // in km/h\n    float distance = getDistanceToCarAhead(); // in meters\n\n    // Step 2: Calculate minimum safe distance\n    float safe_distance = speed * SAFETY_DISTANCE_FACTOR;\n\n    // Step 3: Trigger FCW if unsafe\n    if (distance < safe_distance) {\n        std::cout << \"Warning: Unsafe distance! Increase following gap.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: speed = 70 km/h, distance = 20 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an FCW when the vehicle ahead changes lanes but remains within 8 meters.",
      "input": "Lane Change Detected: True, Distance: 7 meters",
      "output": "#include <lane_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for FCW after lane change\nconst float LANE_CHANGE_WARNING_DISTANCE = 8.0f; // meters\n\nint main() {\n    // Step 1: Detect if the vehicle ahead has changed lanes\n    bool lane_change = isLaneChangeDetected();\n\n    // Step 2: Retrieve the distance to the vehicle after lane change\n    float distance = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (lane_change && distance < LANE_CHANGE_WARNING_DISTANCE) {\n        std::cout << \"Warning: Vehicle ahead changed lanes but remains close!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lane_change = true, distance = 7 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the average closing speed over 3 seconds exceeds 20 km/h.",
      "input": "Speed Change: +25 km/h in 3 seconds, Distance: 10 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Closing speed threshold\nconst float CLOSING_SPEED_THRESHOLD = 20.0f; // km/h\nconst float TIME_INTERVAL = 3.0f;            // seconds\n\nint main() {\n    // Step 1: Retrieve speed change over the interval\n    float speed_change = getSpeedChangeOverTime(TIME_INTERVAL);\n\n    // Step 2: Retrieve distance to the car ahead\n    float distance = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if closing speed exceeds threshold\n    if (speed_change > CLOSING_SPEED_THRESHOLD && distance < 15.0f) {\n        std::cout << \"Warning: Rapidly closing gap! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: speed_change = +25 km/h, distance = 10 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when the relative velocity between the car and the vehicle ahead exceeds 30 km/h and the distance is below 10 meters.",
      "input": "Relative Velocity: 35 km/h, Distance: 8 meters",
      "output": "#include <velocity_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold values\nconst float MAX_RELATIVE_VELOCITY = 30.0f; // km/h\nconst float MIN_SAFE_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Step 1: Retrieve relative velocity between vehicles\n    float relative_velocity = getRelativeVelocity(); // in km/h\n\n    // Step 2: Retrieve the current distance to the vehicle ahead\n    float distance = getDistanceToCarAhead(); // in meters\n\n    // Step 3: Check FCW conditions\n    if (relative_velocity > MAX_RELATIVE_VELOCITY && distance < MIN_SAFE_DISTANCE) {\n        std::cout << \"Warning: High relative velocity and short distance detected! Apply brakes.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: relative_velocity = 35 km/h, distance = 8 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a pedestrian is detected within 6 meters of the car's path.",
      "input": "Pedestrian Detected: True, Distance: 5 meters",
      "output": "#include <pedestrian_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for pedestrian FCW\nconst float PEDESTRIAN_WARNING_DISTANCE = 6.0f; // meters\n\nint main() {\n    // Step 1: Detect if a pedestrian is in the car's path\n    bool pedestrian_detected = isPedestrianDetected();\n\n    // Step 2: Retrieve distance to the pedestrian\n    float pedestrian_distance = getDistanceToPedestrian();\n\n    // Step 3: Trigger FCW if pedestrian is too close\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_WARNING_DISTANCE) {\n        std::cout << \"Warning: Pedestrian ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_detected = true, pedestrian_distance = 5 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when the lead car is braking suddenly and the gap is less than 15 meters.",
      "input": "Lead Car Braking: True, Following Distance: 12 meters",
      "output": "#include <brake_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Thresholds for FCW\nconst float SUDDEN_BRAKE_DISTANCE = 15.0f; // meters\n\nint main() {\n    // Step 1: Check if the lead car is braking suddenly\n    bool lead_car_braking = isLeadCarBraking();\n\n    // Step 2: Retrieve distance to the lead car\n    float distance_to_lead_car = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (lead_car_braking && distance_to_lead_car < SUDDEN_BRAKE_DISTANCE) {\n        std::cout << \"Warning: Lead car braking suddenly! Maintain safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lead_car_braking = true, distance_to_lead_car = 12 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a road hazard is detected within 5 meters of the car's trajectory.",
      "input": "Hazard Detected: True, Hazard Distance: 3 meters",
      "output": "#include <hazard_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Hazard detection threshold\nconst float HAZARD_WARNING_DISTANCE = 5.0f; // meters\n\nint main() {\n    // Step 1: Detect a road hazard\n    bool hazard_detected = isRoadHazardDetected();\n\n    // Step 2: Retrieve distance to the hazard\n    float hazard_distance = getDistanceToHazard();\n\n    // Step 3: Trigger FCW if hazard is too close\n    if (hazard_detected && hazard_distance < HAZARD_WARNING_DISTANCE) {\n        std::cout << \"Warning: Road hazard ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: hazard_detected = true, hazard_distance = 3 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car ahead is reversing within a 10-meter distance.",
      "input": "Reversing Vehicle Detected: True, Distance: 8 meters",
      "output": "#include <vehicle_detection.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for reversing vehicle FCW\nconst float REVERSING_WARNING_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Step 1: Detect if the car ahead is reversing\n    bool reversing_detected = isReversingCarDetected();\n\n    // Step 2: Retrieve the distance to the reversing car\n    float distance_to_reversing_car = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if reversing car is within unsafe distance\n    if (reversing_detected && distance_to_reversing_car < REVERSING_WARNING_DISTANCE) {\n        std::cout << \"Warning: Car ahead is reversing! Maintain safe gap.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: reversing_detected = true, distance_to_reversing_car = 8 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car's speed exceeds 80 km/h and there is a vehicle within 20 meters ahead.",
      "input": "Car Speed: 85 km/h, Distance to Vehicle: 18 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold values\nconst float MAX_SPEED = 80.0f; // km/h\nconst float MIN_SAFE_DISTANCE = 20.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Retrieve the distance to the vehicle ahead\n    float distance_to_vehicle = getDistanceToCarAhead();\n\n    // Step 3: Check conditions for FCW\n    if (car_speed > MAX_SPEED && distance_to_vehicle < MIN_SAFE_DISTANCE) {\n        std::cout << \"Warning: Speed too high and vehicle detected ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 85 km/h, distance_to_vehicle = 18 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a stationary object within 10 meters at a speed over 50 km/h.",
      "input": "Car Speed: 55 km/h, Distance to Object: 8 meters",
      "output": "#include <speed_sensor.hpp>\n#include <object_detection.hpp>\n#include <iostream>\n\n// Thresholds for stationary object detection\nconst float STATIONARY_OBJECT_SPEED_THRESHOLD = 50.0f; // km/h\nconst float STATIONARY_OBJECT_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Step 1: Detect if there is a stationary object ahead\n    bool stationary_object_detected = isStationaryObjectAhead();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Retrieve the distance to the stationary object\n    float distance_to_object = getDistanceToStationaryObject();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (stationary_object_detected && car_speed > STATIONARY_OBJECT_SPEED_THRESHOLD && distance_to_object < STATIONARY_OBJECT_DISTANCE) {\n        std::cout << \"Warning: Stationary object ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: stationary_object_detected = true, car_speed = 55 km/h, distance_to_object = 8 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a sudden turn ahead within 30 meters.",
      "input": "Turn Detected: True, Turn Distance: 25 meters",
      "output": "#include <road_curvature_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Thresholds for detecting sudden turns\nconst float SUDDEN_TURN_DISTANCE = 30.0f; // meters\n\nint main() {\n    // Step 1: Detect a sudden turn on the road\n    bool sudden_turn_detected = isSuddenTurnAhead();\n\n    // Step 2: Retrieve the distance to the turn\n    float distance_to_turn = getDistanceToTurn();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (sudden_turn_detected && distance_to_turn < SUDDEN_TURN_DISTANCE) {\n        std::cout << \"Warning: Sudden turn ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: sudden_turn_detected = true, distance_to_turn = 25 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when the driver is distracted, and a vehicle is within 15 meters ahead.",
      "input": "Driver Attention: Distracted, Distance to Vehicle: 12 meters",
      "output": "#include <driver_monitoring.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for distracted driver warning\nconst float DISTRACTED_DRIVER_DISTANCE = 15.0f; // meters\n\nint main() {\n    // Step 1: Check the driver's attention status\n    bool is_distracted = isDriverDistracted();\n\n    // Step 2: Retrieve distance to the vehicle ahead\n    float distance_to_vehicle = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if driver is distracted and vehicle is too close\n    if (is_distracted && distance_to_vehicle < DISTRACTED_DRIVER_DISTANCE) {\n        std::cout << \"Warning: Distracted driver and close vehicle ahead! Focus on the road.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: is_distracted = true, distance_to_vehicle = 12 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if icy road conditions are detected and the vehicle ahead is within 10 meters.",
      "input": "Road Condition: Icy, Distance to Vehicle: 9 meters",
      "output": "#include <road_condition_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Thresholds for icy road FCW\nconst float ICY_ROAD_DISTANCE_THRESHOLD = 10.0f; // meters\n\nint main() {\n    // Step 1: Check if road conditions are icy\n    bool icy_road_detected = isIcyRoadCondition();\n\n    // Step 2: Retrieve the distance to the vehicle ahead\n    float distance_to_vehicle = getDistanceToCarAhead();\n\n    // Step 3: Trigger FCW if icy road and vehicle is too close\n    if (icy_road_detected && distance_to_vehicle < ICY_ROAD_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Icy road detected! Maintain a greater distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: icy_road_detected = true, distance_to_vehicle = 9 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a pedestrian is detected within 5 meters and the car's speed exceeds 30 km/h.",
      "input": "Pedestrian Detected: Yes, Distance to Pedestrian: 4 meters, Car Speed: 35 km/h",
      "output": "#include <pedestrian_detection.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Thresholds for pedestrian FCW\nconst float PEDESTRIAN_DISTANCE_THRESHOLD = 5.0f; // meters\nconst float PEDESTRIAN_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Detect if a pedestrian is nearby\n    bool pedestrian_detected = isPedestrianDetected();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Retrieve the distance to the pedestrian\n    float distance_to_pedestrian = getDistanceToPedestrian();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (pedestrian_detected && car_speed > PEDESTRIAN_SPEED_THRESHOLD && distance_to_pedestrian < PEDESTRIAN_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian detected nearby! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: pedestrian_detected = true, car_speed = 35 km/h, distance_to_pedestrian = 4 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car's speed exceeds 60 km/h and the following distance to the vehicle ahead is less than 2 seconds.",
      "input": "Car Speed: 65 km/h, Time Gap: 1.8 seconds",
      "output": "#include <speed_sensor.hpp>\n#include <time_gap_calculator.hpp>\n#include <iostream>\n\n// Thresholds for following distance FCW\nconst float TIME_GAP_THRESHOLD = 2.0f; // seconds\nconst float SPEED_THRESHOLD = 60.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Calculate the time gap to the vehicle ahead\n    float time_gap = getTimeGapToVehicleAhead();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed > SPEED_THRESHOLD && time_gap < TIME_GAP_THRESHOLD) {\n        std::cout << \"Warning: Insufficient following distance! Maintain a safe gap.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 65 km/h, time_gap = 1.8 seconds\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if there is a moving object in the car's blind spot and a turn signal is active.",
      "input": "Blind Spot Object Detected: Yes, Turn Signal: Active",
      "output": "#include <blind_spot_monitor.hpp>\n#include <turn_signal_sensor.hpp>\n#include <iostream>\n\nint main() {\n    // Step 1: Check for an object in the blind spot\n    bool blind_spot_object_detected = isBlindSpotObjectDetected();\n\n    // Step 2: Check if a turn signal is active\n    bool turn_signal_active = isTurnSignalActive();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (blind_spot_object_detected && turn_signal_active) {\n        std::cout << \"Warning: Object in blind spot! Check surroundings before turning.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: blind_spot_object_detected = true, turn_signal_active = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a sharp curve at a speed over 40 km/h.",
      "input": "Car Speed: 50 km/h, Curve Detected: Sharp",
      "output": "#include <road_curvature_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Thresholds for sharp curve warning\nconst float CURVE_SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Detect the sharp curve ahead\n    bool sharp_curve_detected = isSharpCurveAhead();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (sharp_curve_detected && car_speed > CURVE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Sharp curve ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: sharp_curve_detected = true, car_speed = 50 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is accelerating rapidly toward a stopped vehicle.",
      "input": "Car Acceleration: 5 m/s^2, Distance to Stopped Vehicle: 15 meters",
      "output": "#include <acceleration_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Thresholds for rapid acceleration FCW\nconst float MAX_ACCELERATION = 4.0f; // m/s^2\nconst float STOPPED_VEHICLE_DISTANCE_THRESHOLD = 20.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's acceleration\n    float car_acceleration = getCarAcceleration();\n\n    // Step 2: Retrieve the distance to the stopped vehicle\n    float distance_to_stopped_vehicle = getDistanceToStoppedVehicle();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_acceleration > MAX_ACCELERATION && distance_to_stopped_vehicle < STOPPED_VEHICLE_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Rapid acceleration toward a stopped vehicle! Apply brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_acceleration = 5 m/s^2, distance_to_stopped_vehicle = 15 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car's speed exceeds 80 km/h and a vehicle is detected in the same lane.",
      "input": "Car Speed: 85 km/h, Lane Vehicle Detected: Yes",
      "output": "#include <speed_sensor.hpp>\n#include <lane_vehicle_detector.hpp>\n#include <iostream>\n\n// Threshold for high-speed FCW\nconst float SPEED_THRESHOLD = 80.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Detect if there is a vehicle in the same lane\n    bool lane_vehicle_detected = isVehicleInSameLane();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed > SPEED_THRESHOLD && lane_vehicle_detected) {\n        std::cout << \"Warning: High speed with vehicle in the same lane! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 85 km/h, lane_vehicle_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a red light and the speed exceeds 50 km/h.",
      "input": "Car Speed: 60 km/h, Traffic Light: Red",
      "output": "#include <traffic_light_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for approaching red light FCW\nconst float SPEED_THRESHOLD = 50.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the traffic light is red\n    bool red_light_detected = isRedLightDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed > SPEED_THRESHOLD && red_light_detected) {\n        std::cout << \"Warning: Approaching red light at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, red_light_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is too close to a stopped vehicle in the adjacent lane.",
      "input": "Distance to Adjacent Vehicle: 2 meters, Vehicle in Adjacent Lane: Stopped",
      "output": "#include <lane_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for safe distance to adjacent vehicle\nconst float ADJACENT_VEHICLE_DISTANCE_THRESHOLD = 3.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the distance to the vehicle in the adjacent lane\n    float distance_to_adjacent_vehicle = getDistanceToAdjacentVehicle();\n\n    // Step 2: Check if the vehicle in the adjacent lane is stopped\n    bool adjacent_vehicle_stopped = isVehicleInAdjacentLaneStopped();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (adjacent_vehicle_stopped && distance_to_adjacent_vehicle < ADJACENT_VEHICLE_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Too close to a stopped vehicle in the adjacent lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: distance_to_adjacent_vehicle = 2 m, adjacent_vehicle_stopped = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a cyclist is detected in front of the car and the car's speed exceeds 40 km/h.",
      "input": "Cyclist Detected: Yes, Car Speed: 45 km/h",
      "output": "#include <cyclist_detection.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for cyclist FCW\nconst float SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Check if a cyclist is detected in front of the car\n    bool cyclist_detected = isCyclistDetected();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (cyclist_detected && car_speed > SPEED_THRESHOLD) {\n        std::cout << \"Warning: Cyclist detected ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: cyclist_detected = true, car_speed = 45 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car's brakes are applied and the car is too close to a preceding vehicle.",
      "input": "Brakes Applied: Yes, Distance to Preceding Vehicle: 5 meters",
      "output": "#include <brake_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for distance to preceding vehicle\nconst float DISTANCE_THRESHOLD = 6.0f; // meters\n\nint main() {\n    // Step 1: Check if the brakes are applied\n    bool brakes_applied = areBrakesApplied();\n\n    // Step 2: Retrieve the distance to the preceding vehicle\n    float distance_to_preceding_vehicle = getDistanceToPrecedingVehicle();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (brakes_applied && distance_to_preceding_vehicle < DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Too close to preceding vehicle with brakes applied!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: brakes_applied = true, distance_to_preceding_vehicle = 5 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a vehicle is detected in the wrong lane and the car is moving toward it.",
      "input": "Wrong Lane Vehicle Detected: Yes, Car Speed: 50 km/h",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for FCW when wrong lane vehicle detected\nconst float WRONG_LANE_SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Check if a vehicle is detected in the wrong lane\n    bool wrong_lane_vehicle_detected = isWrongLaneVehicleDetected();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (wrong_lane_vehicle_detected && car_speed > WRONG_LANE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Vehicle detected in the wrong lane! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: wrong_lane_vehicle_detected = true, car_speed = 50 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a vehicle is detected crossing in front of the car at high speed.",
      "input": "Vehicle Crossing Detected: Yes, Vehicle Speed: 70 km/h",
      "output": "#include <vehicle_detection.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for vehicle crossing warning\nconst float CROSSING_VEHICLE_SPEED_THRESHOLD = 60.0f; // km/h\n\nint main() {\n    // Step 1: Check if a vehicle is crossing in front of the car\n    bool vehicle_crossing_detected = isVehicleCrossingFront();\n\n    // Step 2: Retrieve the vehicle's speed\n    float vehicle_speed = getVehicleSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (vehicle_crossing_detected && vehicle_speed > CROSSING_VEHICLE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Vehicle crossing in front at high speed!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: vehicle_crossing_detected = true, vehicle_speed = 70 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car approaches an intersection too quickly.",
      "input": "Car Speed: 45 km/h, Intersection Ahead: Yes",
      "output": "#include <intersection_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for approaching intersection too quickly\nconst float INTERSECTION_SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Check if the car is approaching an intersection\n    bool intersection_ahead = isIntersectionAhead();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (intersection_ahead && car_speed > INTERSECTION_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Approaching intersection at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: intersection_ahead = true, car_speed = 45 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is drifting out of its lane.",
      "input": "Lane Departure Detected: Yes, Car Speed: 30 km/h",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for lane departure FCW\nconst float LANE_DEPARTURE_SPEED_THRESHOLD = 25.0f; // km/h\n\nint main() {\n    // Step 1: Check if lane departure is detected\n    bool lane_departure_detected = isLaneDepartureDetected();\n\n    // Step 2: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (lane_departure_detected && car_speed > LANE_DEPARTURE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected! Correct steering.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lane_departure_detected = true, car_speed = 30 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a stop sign at a speed greater than 30 km/h.",
      "input": "Car Speed: 40 km/h, Stop Sign: Detected",
      "output": "#include <stop_sign_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for approaching stop sign FCW\nconst float STOP_SIGN_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if a stop sign is detected\n    bool stop_sign_detected = isStopSignDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed > STOP_SIGN_SPEED_THRESHOLD && stop_sign_detected) {\n        std::cout << \"Warning: Approaching stop sign at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 40 km/h, stop_sign_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car's speed is too high while driving in a school zone.",
      "input": "Car Speed: 60 km/h, School Zone: Yes",
      "output": "#include <zone_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speeding in school zones\nconst float SCHOOL_ZONE_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the car is in a school zone\n    bool school_zone_detected = isSchoolZoneDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (school_zone_detected && car_speed > SCHOOL_ZONE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Speeding in school zone! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, school_zone_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects an obstacle and the car is in reverse gear.",
      "input": "Car Gear: Reverse, Obstacle Detected: Yes",
      "output": "#include <gear_sensor.hpp>\n#include <obstacle_sensor.hpp>\n#include <iostream>\n\n// Threshold for reverse gear obstacle FCW\nconst bool IS_REVERSE_GEAR = true;\n\nint main() {\n    // Step 1: Check if the car is in reverse gear\n    bool car_in_reverse = isCarInReverseGear();\n\n    // Step 2: Detect obstacle\n    bool obstacle_detected = isObstacleDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_in_reverse && obstacle_detected) {\n        std::cout << \"Warning: Obstacle detected while in reverse gear!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_in_reverse = true, obstacle_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a vehicle in front of the car suddenly brakes while the car is traveling at high speed.",
      "input": "Car Speed: 100 km/h, Front Vehicle Brakes Applied: Yes",
      "output": "#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <brake_sensor.hpp>\n#include <iostream>\n\n// Threshold for high-speed braking FCW\nconst float HIGH_SPEED_THRESHOLD = 90.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the front vehicle has applied brakes\n    bool front_vehicle_brakes = isFrontVehicleBraking();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed > HIGH_SPEED_THRESHOLD && front_vehicle_brakes) {\n        std::cout << \"Warning: Front vehicle is braking at high speed!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 100 km/h, front_vehicle_brakes = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is too close to the curb while parallel parking.",
      "input": "Distance to Curb: 0.5 meters, Parallel Parking Mode: Active",
      "output": "#include <parking_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for safe parking distance\nconst float CURB_DISTANCE_THRESHOLD = 1.0f; // meters\n\nint main() {\n    // Step 1: Check if the car is in parallel parking mode\n    bool parking_mode_active = isParallelParkingModeActive();\n\n    // Step 2: Get the distance to the curb\n    float distance_to_curb = getDistanceToCurb();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (parking_mode_active && distance_to_curb < CURB_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Too close to the curb! Adjust position.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: parking_mode_active = true, distance_to_curb = 0.5 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is moving into an intersection while the light is green and a vehicle in the opposite lane is approaching at high speed.",
      "input": "Car Speed: 50 km/h, Intersection Light: Green, Opposite Lane Vehicle Speed: 90 km/h",
      "output": "#include <intersection_sensor.hpp>\n#include <light_sensor.hpp>\n#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for vehicle approaching from opposite lane\nconst float OPPOSITE_VEHICLE_SPEED_THRESHOLD = 80.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the intersection light is green\n    bool green_light_detected = isGreenLightDetected();\n\n    // Step 3: Check the speed of the vehicle in the opposite lane\n    float opposite_vehicle_speed = getOppositeLaneVehicleSpeed();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (green_light_detected && car_speed > OPPOSITE_VEHICLE_SPEED_THRESHOLD && opposite_vehicle_speed > OPPOSITE_VEHICLE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: High-speed vehicle approaching in opposite lane!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, green_light_detected = true, opposite_vehicle_speed = 90 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is too close to a pedestrian while driving in a residential area.",
      "input": "Distance to Pedestrian: 1 meter, Residential Area: Yes",
      "output": "#include <pedestrian_sensor.hpp>\n#include <zone_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Threshold for safe distance to pedestrian\nconst float PEDESTRIAN_DISTANCE_THRESHOLD = 2.0f; // meters\n\nint main() {\n    // Step 1: Check if the car is in a residential area\n    bool residential_area_detected = isResidentialAreaDetected();\n\n    // Step 2: Get the distance to the pedestrian\n    float distance_to_pedestrian = getDistanceToPedestrian();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (residential_area_detected && distance_to_pedestrian < PEDESTRIAN_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian too close! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: residential_area_detected = true, distance_to_pedestrian = 1 m\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a sharp curve too quickly.",
      "input": "Car Speed: 60 km/h, Sharp Curve: Detected",
      "output": "#include <curve_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for sharp curve approach FCW\nconst float SHARP_CURVE_SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if a sharp curve is detected\n    bool sharp_curve_detected = isSharpCurveDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (sharp_curve_detected && car_speed > SHARP_CURVE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Approaching sharp curve at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, sharp_curve_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects ice or slippery conditions while driving.",
      "input": "Road Condition: Slippery, Car Speed: 50 km/h",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for slippery road condition FCW\nconst float SLIPPERY_ROAD_SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for slippery road conditions\n    bool slippery_road_condition = isSlipperyRoadDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (slippery_road_condition && car_speed > SLIPPERY_ROAD_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Slippery road detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: slippery_road_condition = true, car_speed = 50 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a pedestrian crosswalk and the car's speed is too high.",
      "input": "Car Speed: 45 km/h, Pedestrian Crosswalk: Detected",
      "output": "#include <crosswalk_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed near pedestrian crosswalk\nconst float CROSSWALK_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if a pedestrian crosswalk is detected\n    bool crosswalk_detected = isCrosswalkDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (crosswalk_detected && car_speed > CROSSWALK_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Approaching pedestrian crosswalk at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 45 km/h, crosswalk_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a car is detected in the blind spot while the car is changing lanes.",
      "input": "Blind Spot Vehicle: Detected, Car Lane Change: Initiated",
      "output": "#include <blind_spot_sensor.hpp>\n#include <lane_sensor.hpp>\n#include <iostream>\n\n// Threshold for lane change collision warning\nconst bool LANE_CHANGE_INITIATED = true;\n\nint main() {\n    // Step 1: Check if the car is changing lanes\n    bool lane_change_initiated = isLaneChangeInitiated();\n\n    // Step 2: Detect vehicle in blind spot\n    bool vehicle_in_blind_spot = isVehicleInBlindSpot();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (lane_change_initiated && vehicle_in_blind_spot) {\n        std::cout << \"Warning: Vehicle detected in blind spot while changing lanes!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: lane_change_initiated = true, vehicle_in_blind_spot = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is too close to the vehicle in front while driving in stop-and-go traffic.",
      "input": "Car Speed: 10 km/h, Front Vehicle Distance: 0.8 meters",
      "output": "#include <vehicle_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for following distance in stop-and-go traffic\nconst float FOLLOWING_DISTANCE_THRESHOLD = 1.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Get the distance to the front vehicle\n    float distance_to_front_vehicle = getDistanceToFrontVehicle();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed < 15.0f && distance_to_front_vehicle < FOLLOWING_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Too close to front vehicle! Maintain a safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 10 km/h, distance_to_front_vehicle = 0.8 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a red light while the car is too close to the intersection.",
      "input": "Car Speed: 30 km/h, Intersection Distance: 5 meters, Traffic Light: Red",
      "output": "#include <intersection_sensor.hpp>\n#include <light_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for safe distance to intersection\nconst float INTERSECTION_DISTANCE_THRESHOLD = 10.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the traffic light is red\n    bool red_light_detected = isRedLightDetected();\n\n    // Step 3: Get the distance to the intersection\n    float intersection_distance = getIntersectionDistance();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (red_light_detected && intersection_distance < INTERSECTION_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Red light detected and too close to intersection! Stop safely.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 30 km/h, red_light_detected = true, intersection_distance = 5 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is approaching a toll booth at high speed.",
      "input": "Car Speed: 80 km/h, Toll Booth: Detected",
      "output": "#include <toll_booth_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for approaching toll booth at high speed\nconst float TOLL_BOOTH_SPEED_THRESHOLD = 60.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the toll booth is detected\n    bool toll_booth_detected = isTollBoothDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (toll_booth_detected && car_speed > TOLL_BOOTH_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Approaching toll booth at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, toll_booth_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects heavy rain and the car's speed is too high.",
      "input": "Car Speed: 70 km/h, Weather: Heavy Rain",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for high speed in heavy rain\nconst float RAIN_SPEED_THRESHOLD = 50.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if there is heavy rain\n    bool heavy_rain_detected = isHeavyRainDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (heavy_rain_detected && car_speed > RAIN_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Heavy rain detected! Reduce speed for safety.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 70 km/h, heavy_rain_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a nearby vehicle in the blind spot while making a right turn.",
      "input": "Right Turn: In Progress, Blind Spot Vehicle: Detected",
      "output": "#include <turn_signal_sensor.hpp>\n#include <blind_spot_sensor.hpp>\n#include <iostream>\n\n// Threshold for blind spot vehicle detection during right turn\nconst bool RIGHT_TURN_ACTIVE = true;\n\nint main() {\n    // Step 1: Check if the car is making a right turn\n    bool right_turn_active = isRightTurnActive();\n\n    // Step 2: Detect vehicle in blind spot\n    bool vehicle_in_blind_spot = isVehicleInBlindSpot();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (right_turn_active && vehicle_in_blind_spot) {\n        std::cout << \"Warning: Vehicle detected in blind spot while making right turn!\" << std::endl\n\n;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: right_turn_active = true, vehicle_in_blind_spot = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects low tire pressure while driving at high speed.",
      "input": "Car Speed: 90 km/h, Tire Pressure: Low",
      "output": "#include <tire_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for low tire pressure while driving at high speed\nconst float HIGH_SPEED_THRESHOLD = 80.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if tire pressure is low\n    bool low_tire_pressure = isLowTirePressureDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (car_speed > HIGH_SPEED_THRESHOLD && low_tire_pressure) {\n        std::cout << \"Warning: Low tire pressure detected at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 90 km/h, low_tire_pressure = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car is driving through a school zone at a speed higher than the limit.",
      "input": "Car Speed: 50 km/h, School Zone: Detected",
      "output": "#include <school_zone_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed in school zones\nconst float SCHOOL_ZONE_SPEED_LIMIT = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the car is in a school zone\n    bool school_zone_detected = isSchoolZoneDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (school_zone_detected && car_speed > SCHOOL_ZONE_SPEED_LIMIT) {\n        std::cout << \"Warning: Speeding in school zone! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, school_zone_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a sudden braking of the vehicle in front.",
      "input": "Front Vehicle Braking: Detected, Car Speed: 60 km/h",
      "output": "#include <brake_sensor.hpp>\n#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for sudden braking detection\nconst float BRAKE_FORCE_THRESHOLD = 0.5f; // Braking force\n\nint main() {\n    // Step 1: Retrieve the front vehicle's braking status\n    bool front_vehicle_braking = isFrontVehicleBraking();\n\n    // Step 2: Get the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (front_vehicle_braking && car_speed > BRAKE_FORCE_THRESHOLD) {\n        std::cout << \"Warning: Front vehicle is braking suddenly! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: front_vehicle_braking = true, car_speed = 60 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects fog while driving at high speed.",
      "input": "Car Speed: 100 km/h, Weather: Fog",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for high speed in foggy conditions\nconst float FOG_SPEED_THRESHOLD = 60.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if there is fog\n    bool fog_detected = isFogDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (fog_detected && car_speed > FOG_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Fog detected! Slow down for safety.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 100 km/h, fog_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a steep incline and the car\\u2019s speed exceeds a safe threshold.",
      "input": "Car Speed: 50 km/h, Incline: 15 degrees",
      "output": "#include <incline_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed on a steep incline\nconst float INCLINE_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the incline is steep\n    float incline_angle = getInclineAngle();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (incline_angle > 10.0f && car_speed > INCLINE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Steep incline detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, incline_angle = 15 degrees\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects an obstacle while reversing at high speed.",
      "input": "Car Speed: 20 km/h, Obstacle: Detected, Reversing: True",
      "output": "#include <reverse_sensor.hpp>\n#include <obstacle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed while reversing\nconst float REVERSE_SPEED_THRESHOLD = 5.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the car is reversing\n    bool car_reversing = isCarReversing();\n\n    // Step 3: Detect obstacle while reversing\n    bool obstacle_detected = isObstacleDetected();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (car_reversing && obstacle_detected && car_speed > REVERSE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Obstacle detected while reversing at high speed!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 20 km/h, car_reversing = true, obstacle_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a sharp curve ahead while driving at high speed.",
      "input": "Car Speed: 80 km/h, Curve: Sharp",
      "output": "#include <curve_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed in sharp curves\nconst float SHARP_CURVE_SPEED_THRESHOLD = 50.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the curve is sharp\n    bool sharp_curve_detected = isSharpCurveDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (sharp_curve_detected && car_speed > SHARP_CURVE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Sharp curve detected! Slow down for safety.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, sharp_curve_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a vehicle merging into its lane from the right.",
      "input": "Car Speed: 60 km/h, Vehicle Merging: Right",
      "output": "#include <lane_change_sensor.hpp>\n#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for vehicle merging into the lane\nconst bool VEHICLE_MERGING_RIGHT = true;\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Detect vehicle merging from the right\n    bool vehicle_merging = isVehicleMergingRight();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (vehicle_merging && car_speed > 50.0f) {\n        std::cout << \"Warning: Vehicle merging into your lane from the right!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, vehicle_merging_right = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a sharp drop in road surface while driving.",
      "input": "Car Speed: 40 km/h, Road Surface: Drop Detected",
      "output": "#include <road_surface_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed when encountering road surface drop\nconst float ROAD_DROP_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Detect road surface drop\n    bool road_surface_drop = isRoadSurfaceDropDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (road_surface_drop && car_speed > ROAD_DROP_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Sharp drop detected in road surface! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 40 km/h, road_surface_drop = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ \\n\\n2023-compliant code to issue an FCW if the car detects excessive lateral acceleration.",
      "input": "Car Speed: 70 km/h, Lateral Acceleration: 0.6g",
      "output": "#include <acceleration_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for lateral acceleration\nconst float LATERAL_ACCEL_THRESHOLD = 0.5f; // g\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Retrieve the lateral acceleration\n    float lateral_acceleration = getLateralAcceleration();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (lateral_acceleration > LATERAL_ACCEL_THRESHOLD) {\n        std::cout << \"Warning: Excessive lateral acceleration detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 70 km/h, lateral_acceleration = 0.6g\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a pedestrian crossing the road.",
      "input": "Car Speed: 20 km/h, Pedestrian: Crossing",
      "output": "#include <pedestrian_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for pedestrian detection speed\nconst float PEDESTRIAN_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for pedestrian presence\n    bool pedestrian_crossing = isPedestrianCrossing();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (pedestrian_crossing && car_speed < PEDESTRIAN_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Pedestrian crossing! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 20 km/h, pedestrian_crossing = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects an abrupt lane departure without signaling.",
      "input": "Car Speed: 50 km/h, Lane Departure: Detected, Signal: Off",
      "output": "#include <lane_departure_sensor.hpp>\n#include <signal_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for lane departure warning\nconst float LANE_DEPARTURE_SPEED_THRESHOLD = 40.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for lane departure\n    bool lane_departure_detected = isLaneDepartureDetected();\n\n    // Step 3: Check if signal is off\n    bool signal_off = isSignalOff();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (lane_departure_detected && signal_off && car_speed > LANE_DEPARTURE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Lane departure detected without signaling!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, lane_departure_detected = true, signal_off = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a sharp increase in road elevation ahead.",
      "input": "Car Speed: 60 km/h, Road Elevation: Sharp Increase",
      "output": "#include <road_elevation_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for sharp elevation change\nconst float ELEVATION_CHANGE_THRESHOLD = 10.0f; // degrees\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for sharp elevation change\n    float elevation_angle = getElevationChange();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (elevation_angle > ELEVATION_CHANGE_THRESHOLD && car_speed > 40.0f) {\n        std::cout << \"Warning: Sharp increase in road elevation ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, elevation_angle = 15 degrees\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects heavy rain while driving at high speed.",
      "input": "Car Speed: 100 km/h, Weather: Heavy Rain",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed in heavy rain\nconst float HEAVY_RAIN_SPEED_THRESHOLD = 80.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if heavy rain is detected\n    bool heavy_rain_detected = isHeavyRainDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (heavy_rain_detected && car_speed > HEAVY_RAIN_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Heavy rain detected! Slow down for safety.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 100 km/h, heavy_rain_detected = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects sudden deceleration in a preceding vehicle while driving.",
      "input": "Car Speed: 80 km/h, Preceding Vehicle Deceleration: Sudden",
      "output": "#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for detecting sudden deceleration in front vehicle\nconst float DECELERATION_THRESHOLD = 1.5f; // m/s^2\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Get the deceleration of the preceding vehicle\n    float deceleration = getPrecedingVehicleDeceleration();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (deceleration > DECELERATION_THRESHOLD && car_speed > 70.0f) {\n        std::cout << \"Warning: Sudden deceleration in the preceding vehicle! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, deceleration = 2.0 m/s^2\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a large animal crossing the road.",
      "input": "Car Speed: 40 km/h, Animal: Large Animal Crossing",
      "output": "#include <animal_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for animal detection at low speed\nconst float ANIMAL_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for animal crossing\n    bool animal_crossing = isLargeAnimalCrossing();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (animal_crossing && car_speed < ANIMAL_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Large animal crossing! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 40 km/h, animal_crossing = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects that the front collision risk is increasing based on the speed of the vehicle ahead.",
      "input": "Car Speed: 50 km/h, Front Vehicle Speed: 30 km/h",
      "output": "#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for front collision risk\nconst float FRONT_VEHICLE_SPEED_THRESHOLD = 20.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Retrieve the front vehicle's speed\n    float front_vehicle_speed = getFrontVehicleSpeed();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (front_vehicle_speed < FRONT_VEHICLE_SPEED_THRESHOLD && car_speed > 40.0f) {\n        std::cout << \"Warning: Increasing collision risk due to slow vehicle ahead!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, front_vehicle_speed = 30 km/h\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects an incoming vehicle from the opposite lane while driving.",
      "input": "Car Speed: 70 km/h, Opposite Lane Vehicle: Incoming",
      "output": "#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <lane_sensor.hpp>\n#include <iostream>\n\n// Threshold for incoming vehicle detection\nconst float INCOMING_VEHICLE_SPEED_THRESHOLD = 50.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for incoming vehicle in the opposite lane\n    bool incoming_vehicle = isIncomingVehicleDetected();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (incoming_vehicle && car_speed > INCOMING_VEHICLE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Incoming vehicle detected from the opposite lane!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 70 km/h, incoming_vehicle = true\n\n\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects the front sensor malfunctioning while driving at high speed.",
      "input": "Car Speed: 90 km/h, Front Sensor: Malfunctioning",
      "output": "#include <sensor_diagnostic.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for speed with malfunctioning sensor\nconst float SENSOR_MALFUNCTION_SPEED_THRESHOLD = 80.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for sensor malfunction\n    bool sensor_malfunction = isFrontSensorMalfunctioning();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (sensor_malfunction && car_speed > SENSOR_MALFUNCTION_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Front sensor malfunctioning! Proceed with caution.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 90 km/h, sensor_malfunction = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a cyclist entering the vehicle's path.",
      "input": "Car Speed: 25 km/h, Cyclist: Entering Path",
      "output": "#include <cyclist_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for cyclist detection\nconst float CYCLIST_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if cyclist is entering the path\n    bool cyclist_entering_path = isCyclistEnteringPath();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (cyclist_entering_path && car_speed < CYCLIST_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Cyclist entering your path!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 25 km/h, cyclist_entering_path = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects the lead vehicle stopping abruptly.",
      "input": "Car Speed: 60 km/h, Lead Vehicle Speed: 0 km/h",
      "output": "#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for issuing FCW when lead vehicle stops\nconst float MIN_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Get the distance to the lead vehicle\n    float lead_vehicle_distance = getLeadVehicleDistance();\n\n    // Step 3: Check if lead vehicle speed is zero\n    bool lead_vehicle_stopped = isLeadVehicleStopped();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (lead_vehicle_stopped && lead_vehicle_distance < MIN_DISTANCE) {\n        std::cout << \"Warning: Lead vehicle stopped abruptly! Prepare to brake.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, lead_vehicle_distance = 8 meters, lead_vehicle_stopped = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a pedestrian enters the car's path unexpectedly.",
      "input": "Car Speed: 40 km/h, Pedestrian: Detected in Path",
      "output": "#include <pedestrian_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe stopping distance threshold for pedestrians\nconst float PEDESTRIAN_THRESHOLD_DISTANCE = 15.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if a pedestrian is detected in the path\n    bool pedestrian_in_path = isPedestrianInPath();\n\n    // Step 3: Get distance to the pedestrian\n    float pedestrian_distance = getPedestrianDistance();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (pedestrian_in_path && pedestrian_distance < PEDESTRIAN_THRESHOLD_DISTANCE) {\n        std::cout << \"Warning: Pedestrian detected in the path! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 40 km/h, pedestrian_distance = 10 meters, pedestrian_in_path = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects an oncoming vehicle in a no-passing zone.",
      "input": "Car Speed: 50 km/h, Oncoming Vehicle: Detected",
      "output": "#include <oncoming_vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <zone_detector.hpp>\n#include <iostream>\n\n// Speed threshold for issuing FCW in a no-passing zone\nconst float NO_PASSING_ZONE_SPEED_THRESHOLD = 30.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check for oncoming vehicle\n    bool oncoming_vehicle_detected = isOncomingVehicleDetected();\n\n    // Step 3: Verify if the car is in a no-passing zone\n    bool in_no_passing_zone = isInNoPassingZone();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (oncoming_vehicle_detected && in_no_passing_zone && car_speed > NO_PASSING_ZONE_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Oncoming vehicle detected in a no-passing zone!\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, oncoming_vehicle_detected = true, in_no_passing_zone = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects low visibility conditions due to fog.",
      "input": "Car Speed: 80 km/h, Visibility: Low",
      "output": "#include <visibility_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Visibility threshold for FCW in foggy conditions\nconst float VISIBILITY_THRESHOLD = 30.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Get the current visibility level\n    float visibility_level = getVisibilityLevel();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (visibility_level < VISIBILITY_THRESHOLD && car_speed > 60.0f) {\n        std::cout << \"Warning: Low visibility detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, visibility_level = 25 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a slippery road condition.",
      "input": "Car Speed: 70 km/h, Road Condition: Slippery",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Speed threshold for slippery road condition\nconst float SLIPPERY_ROAD_SPEED_THRESHOLD = 50.0f; // km/h\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if the road is slippery\n    bool road_slippery = isRoadSlippery();\n\n    // Step 3: Trigger FCW if conditions are met\n    if (road_slippery && car_speed > SLIPPERY_ROAD_SPEED_THRESHOLD) {\n        std::cout << \"Warning: Slippery road detected! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 70 km/h, road_slippery = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects a child running onto the road.",
      "input": "Car Speed: 30 km/h, Child: Running",
      "output": "#include <child_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold for detecting children in the road\nconst float CHILD_THRESHOLD_DISTANCE = 12.0f; // meters\n\nint main() {\n    // Step 1: Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Step 2: Check if a child is detected running onto the road\n    bool child_running = isChildRunningOntoRoad();\n\n    // Step 3: Get the distance to the child\n    float child_distance = getChildDistance();\n\n    // Step 4: Trigger FCW if conditions are met\n    if (child_running && child_distance < CHILD_THRESHOLD_DISTANCE) {\n        std::cout << \"Warning: Child detected running onto the road! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 30 km/h, child_distance = 8 meters, child_running = true\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when an animal is detected crossing the road ahead.",
      "input": "Car Speed: 45 km/h, Animal Distance: 10 meters",
      "output": "#include <animal_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold distance for issuing an FCW due to animals\nconst float ANIMAL_ALERT_DISTANCE = 15.0f; // meters\n\nint main() {\n    // Retrieve the current speed of the car\n    float car_speed = getCarSpeed();\n\n    // Check if an animal is detected crossing the road\n    bool animal_detected = isAnimalCrossing();\n\n    // Get the distance to the detected animal\n    float animal_distance = getAnimalDistance();\n\n    // Trigger an FCW if the animal is within the critical distance threshold\n    if (animal_detected && animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"Warning: Animal detected on the road! Prepare to brake.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 45 km/h, animal_detected = true, animal_distance = 10 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car approaches a stationary vehicle at a high speed.",
      "input": "Car Speed: 90 km/h, Stationary Vehicle Distance: 20 meters",
      "output": "#include <stationary_vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe distance threshold for stationary vehicles\nconst float STATIONARY_VEHICLE_DISTANCE_THRESHOLD = 25.0f; // meters\n\nint main() {\n    // Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Check if a stationary vehicle is detected\n    bool stationary_vehicle_detected = isStationaryVehicleDetected();\n\n    // Get the distance to the stationary vehicle\n    float stationary_vehicle_distance = getStationaryVehicleDistance();\n\n    // Trigger FCW if conditions are met\n    if (stationary_vehicle_detected && stationary_vehicle_distance < STATIONARY_VEHICLE_DISTANCE_THRESHOLD) {\n        std::cout << \"Warning: Stationary vehicle ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 90 km/h, stationary_vehicle_detected = true, stationary_vehicle_distance = 20 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when a cyclist is detected in close proximity to the car.",
      "input": "Car Speed: 35 km/h, Cyclist Distance: 5 meters",
      "output": "#include <cyclist_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance threshold for cyclists\nconst float CYCLIST_ALERT_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Retrieve the car's speed\n    float car_speed = getCarSpeed();\n\n    // Check if a cyclist is detected\n    bool cyclist_detected = isCyclistDetected();\n\n    // Get the distance to the cyclist\n    float cyclist_distance = getCyclistDistance();\n\n    // Trigger FCW if the cyclist is within the alert distance\n    if (cyclist_detected && cyclist_distance < CYCLIST_ALERT_DISTANCE) {\n        std::cout << \"Warning: Cyclist detected nearby! Drive with caution.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 35 km/h, cyclist_detected = true, cyclist_distance = 5 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW during sudden braking of the lead vehicle.",
      "input": "Car Speed: 80 km/h, Lead Vehicle Deceleration: -6.0 m/s\\u00b2",
      "output": "#include <lead_vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Deceleration threshold for issuing FCW\nconst float LEAD_VEHICLE_DECEL_THRESHOLD = -5.0f; // m/s\u00c2\u00b2\n\nint main() {\n    // Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Check the lead vehicle's deceleration rate\n    float lead_vehicle_deceleration = getLeadVehicleDeceleration();\n\n    // Trigger FCW if the lead vehicle decelerates suddenly\n    if (lead_vehicle_deceleration < LEAD_VEHICLE_DECEL_THRESHOLD) {\n        std::cout << \"Warning: Lead vehicle braking suddenly! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, lead_vehicle_deceleration = -6.0 m/s\u00c2\u00b2\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if the car detects an obstacle on a highway at high speed.",
      "input": "Car Speed: 120 km/h, Obstacle Distance: 50 meters",
      "output": "#include <obstacle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe distance for obstacles at high speed\nconst float HIGHWAY_OBSTACLE_DISTANCE = 60.0f; // meters\n\nint main() {\n    // Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Check if an obstacle is detected\n    bool obstacle_detected = isObstacleDetected();\n\n    // Get the distance to the obstacle\n    float obstacle_distance = getObstacleDistance();\n\n    // Trigger FCW if the obstacle is too close\n    if (obstacle_detected && obstacle_distance < HIGHWAY_OBSTACLE_DISTANCE) {\n        std::cout << \"Warning: Obstacle detected ahead! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 120 km/h, obstacle_detected = true, obstacle_distance = 50 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a pedestrian is detected in front of the car.",
      "input": "Car Speed: 40 km/h, Pedestrian Distance: 8 meters",
      "output": "#include <pedestrian_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold distance for pedestrian alerts\nconst float PEDESTRIAN_ALERT_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Retrieve current car speed\n    float car_speed = getCarSpeed();\n\n    // Check if a pedestrian is detected\n    bool pedestrian_detected = isPedestrianDetected();\n\n    // Get the distance to the pedestrian\n    float pedestrian_distance = getPedestrianDistance();\n\n    // Issue FCW if pedestrian is within the alert distance\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"Warning: Pedestrian ahead! Slow down immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 40 km/h, pedestrian_detected = true, pedestrian_distance = 8 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when a vehicle suddenly changes lanes in close proximity.",
      "input": "Car Speed: 70 km/h, Lane Change Vehicle Distance: 12 meters",
      "output": "#include <lane_change_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe distance for lane change alerts\nconst float LANE_CHANGE_ALERT_DISTANCE = 15.0f; // meters\n\nint main() {\n    // Retrieve current car speed\n    float car_speed = getCarSpeed();\n\n    // Check if a vehicle is changing lanes\n    bool lane_change_detected = isLaneChangeDetected();\n\n    // Get the distance to the lane-changing vehicle\n    float lane_change_vehicle_distance = getLaneChangeVehicleDistance();\n\n    // Trigger FCW if the lane-changing vehicle is too close\n    if (lane_change_detected && lane_change_vehicle_distance < LANE_CHANGE_ALERT_DISTANCE) {\n        std::cout << \"Warning: Vehicle changing lanes close to your car! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 70 km/h, lane_change_detected = true, lane_change_vehicle_distance = 12 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW if a road construction barrier is detected.",
      "input": "Car Speed: 50 km/h, Barrier Distance: 15 meters",
      "output": "#include <barrier_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe distance threshold for barriers\nconst float BARRIER_ALERT_DISTANCE = 20.0f; // meters\n\nint main() {\n    // Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Check if a road construction barrier is detected\n    bool barrier_detected = isBarrierDetected();\n\n    // Get the distance to the barrier\n    float barrier_distance = getBarrierDistance();\n\n    // Trigger FCW if the barrier is too close\n    if (barrier_detected && barrier_distance < BARRIER_ALERT_DISTANCE) {\n        std::cout << \"Warning: Road construction barrier ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, barrier_detected = true, barrier_distance = 15 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when a school zone is detected with children crossing the road.",
      "input": "Car Speed: 30 km/h, Child Crossing Distance: 5 meters",
      "output": "#include <child_crossing_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance threshold for children crossing\nconst float CHILD_CROSSING_ALERT_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Check if a child is detected crossing the road\n    bool child_crossing_detected = isChildCrossingDetected();\n\n    // Get the distance to the child crossing\n    float child_crossing_distance = getChildCrossingDistance();\n\n    // Issue FCW if the child is within the alert distance\n    if (child_crossing_detected && child_crossing_distance < CHILD_CROSSING_ALERT_DISTANCE) {\n        std::cout << \"Warning: Child crossing ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 30 km/h, child_crossing_detected = true, child_crossing_distance = 5 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue an FCW when approaching a sharp curve at high speed.",
      "input": "Car Speed: 80 km/h, Curve Distance: 25 meters",
      "output": "#include <curve_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe distance for sharp curve alerts\nconst float CURVE_ALERT_DISTANCE = 30.0f; // meters\n\nint main() {\n    // Retrieve the car's current speed\n    float car_speed = getCarSpeed();\n\n    // Check if a sharp curve is detected\n    bool sharp_curve_detected = isSharpCurveDetected();\n\n    // Get the distance to the sharp curve\n    float curve_distance = getSharpCurveDistance();\n\n    // Trigger FCW if approaching the sharp curve too quickly\n    if (sharp_curve_detected && curve_distance < CURVE_ALERT_DISTANCE) {\n        std::cout << \"Warning: Sharp curve ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, sharp_curve_detected = true, curve_distance = 25 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger FCW if the vehicle ahead suddenly decelerates.",
      "input": "Car Speed: 60 km/h, Lead Vehicle Distance: 12 meters, Lead Vehicle Deceleration: 3.5 m/s\\u00b2",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <deceleration_sensor.hpp>\n#include <iostream>\n\n// Thresholds for triggering FCW\nconst float SAFE_DISTANCE = 15.0f; // meters\nconst float MAX_DECELERATION = 3.0f; // m/s\u00c2\u00b2\n\nint main() {\n    // Get the car's speed\n    float car_speed = getCarSpeed();\n\n    // Get distance to the vehicle ahead\n    float lead_vehicle_distance = getLeadVehicleDistance();\n\n    // Get the lead vehicle's deceleration\n    float lead_vehicle_deceleration = getLeadVehicleDeceleration();\n\n    // Check if an FCW is needed\n    if (lead_vehicle_distance < SAFE_DISTANCE && lead_vehicle_deceleration > MAX_DECELERATION) {\n        std::cout << \"Warning: Sudden deceleration of lead vehicle! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, lead_vehicle_distance = 12 m, lead_vehicle_deceleration = 3.5 m/s\u00c2\u00b2\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue FCW if a vehicle enters from a side road within a close range.",
      "input": "Car Speed: 50 km/h, Side Vehicle Distance: 8 meters",
      "output": "#include <side_road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance for side vehicle entry\nconst float SIDE_VEHICLE_ALERT_DISTANCE = 10.0f; // meters\n\nint main() {\n    // Get the car's speed\n    float car_speed = getCarSpeed();\n\n    // Check if a vehicle is entering from the side road\n    bool side_vehicle_detected = isSideVehicleDetected();\n\n    // Get the distance of the side vehicle\n    float side_vehicle_distance = getSideVehicleDistance();\n\n    // Trigger FCW if the side vehicle is too close\n    if (side_vehicle_detected && side_vehicle_distance < SIDE_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"Warning: Vehicle entering from the side! Slow down immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 50 km/h, side_vehicle_detected = true, side_vehicle_distance = 8 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue FCW when a cyclist is detected within critical distance.",
      "input": "Car Speed: 45 km/h, Cyclist Distance: 6 meters",
      "output": "#include <cyclist_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance for cyclist detection\nconst float CYCLIST_ALERT_DISTANCE = 8.0f; // meters\n\nint main() {\n    // Get car speed\n    float car_speed = getCarSpeed();\n\n    // Check if a cyclist is detected\n    bool cyclist_detected = isCyclistDetected();\n\n    // Get the distance to the cyclist\n    float cyclist_distance = getCyclistDistance();\n\n    // Trigger FCW if cyclist is too close\n    if (cyclist_detected && cyclist_distance < CYCLIST_ALERT_DISTANCE) {\n        std::cout << \"Warning: Cyclist ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 45 km/h, cyclist_detected = true, cyclist_distance = 6 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn if a stopped vehicle is detected in the lane.",
      "input": "Car Speed: 80 km/h, Stopped Vehicle Distance: 20 meters",
      "output": "#include <vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Safe distance for stopped vehicle alert\nconst float STOPPED_VEHICLE_ALERT_DISTANCE = 25.0f; // meters\n\nint main() {\n    // Get current car speed\n    float car_speed = getCarSpeed();\n\n    // Check if a stopped vehicle is detected\n    bool stopped_vehicle_detected = isStoppedVehicleDetected();\n\n    // Get the distance to the stopped vehicle\n    float stopped_vehicle_distance = getStoppedVehicleDistance();\n\n    // Issue FCW if the stopped vehicle is too close\n    if (stopped_vehicle_detected && stopped_vehicle_distance < STOPPED_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"Warning: Stopped vehicle ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 80 km/h, stopped_vehicle_detected = true, stopped_vehicle_distance = 20 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue FCW when a large animal is detected ahead.",
      "input": "Car Speed: 60 km/h, Animal Distance: 15 meters",
      "output": "#include <animal_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance for large animal detection\nconst float ANIMAL_ALERT_DISTANCE = 20.0f; // meters\n\nint main() {\n    // Get current car speed\n    float car_speed = getCarSpeed();\n\n    // Check if a large animal is detected\n    bool animal_detected = isAnimalDetected();\n\n    // Get the distance to the animal\n    float animal_distance = getAnimalDistance();\n\n    // Trigger FCW if the animal is too close\n    if (animal_detected && animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"Warning: Large animal detected ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test case\n// Input: car_speed = 60 km/h, animal_detected = true, animal_distance = 15 meters\n// Expected output: Warning triggered."
    },
    {
      "instruction": "Write MISRA C++ code to trigger FCW if a stalled vehicle is detected within critical distance.",
      "input": "Car Speed: 70 km/h, Stalled Vehicle Distance: 18 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\n// Critical distance for stalled vehicle detection\nconst float CRITICAL_DISTANCE = 20.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float stalled_vehicle_distance = getVehicleDistance(); // Retrieve distance to stalled vehicle\n\n    // Check if distance is below critical threshold\n    if (stalled_vehicle_distance < CRITICAL_DISTANCE) {\n        std::cout << \"FCW: Stalled vehicle ahead! Slow down immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, stalled_vehicle_distance = 18 m\n// Expected output: \"FCW: Stalled vehicle ahead! Slow down immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to issue FCW if a pedestrian enters the lane.",
      "input": "Car Speed: 40 km/h, Pedestrian Distance: 8 meters",
      "output": "#include <pedestrian_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance for pedestrian detection\nconst float PEDESTRIAN_ALERT_DISTANCE = 10.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    bool pedestrian_detected = isPedestrianDetected(); // Detect pedestrian\n    float pedestrian_distance = getPedestrianDistance(); // Get distance to pedestrian\n\n    // Check if FCW should be triggered\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, pedestrian_detected = true, pedestrian_distance = 8 m\n// Expected output: \"FCW: Pedestrian detected! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if vehicles in traffic ahead slow suddenly.",
      "input": "Car Speed: 60 km/h, Traffic Deceleration: 4 m/s\\u00b2",
      "output": "#include <deceleration_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Maximum safe traffic deceleration threshold\nconst float MAX_DECELERATION = 3.5f; // m/s\u00c2\u00b2\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float traffic_deceleration = getTrafficDeceleration(); // Get traffic deceleration rate\n\n    // Check if deceleration exceeds threshold\n    if (traffic_deceleration > MAX_DECELERATION) {\n        std::cout << \"FCW: Sudden traffic slowdown ahead! Apply brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, traffic_deceleration = 4 m/s\u00c2\u00b2\n// Expected output: \"FCW: Sudden traffic slowdown ahead! Apply brakes immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a stationary object in the lane.",
      "input": "Car Speed: 90 km/h, Stationary Object Distance: 25 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance for stationary object warning\nconst float STATIONARY_OBJECT_THRESHOLD = 30.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    bool object_detected = isObjectDetected(); // Detect object\n    float object_distance = getObjectDistance(); // Get distance to object\n\n    // Trigger FCW if object is within unsafe distance\n    if (object_detected && object_distance < STATIONARY_OBJECT_THRESHOLD) {\n        std::cout << \"FCW: Stationary object detected! Brake immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, object_detected = true, object_distance = 25 m\n// Expected output: \"FCW: Stationary object detected! Brake immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn when the lead vehicle activates brake lights.",
      "input": "Car Speed: 50 km/h, Lead Vehicle Brake Status: Active",
      "output": "#include <brake_light_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Threshold speed to issue FCW for lead vehicle braking\nconst float FCW_THRESHOLD_SPEED = 30.0f; // km/h\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    bool brake_light_active = isBrakeLightActive(); // Check brake light status\n\n    // Issue FCW if speed is above threshold and brake light is active\n    if (car_speed > FCW_THRESHOLD_SPEED && brake_light_active) {\n        std::cout << \"FCW: Lead vehicle braking! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, brake_light_active = true\n// Expected output: \"FCW: Lead vehicle braking! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to trigger FCW when a vehicle ahead brakes hard.",
      "input": "Car Speed: 80 km/h, Lead Vehicle Deceleration: 5.5 m/s\\u00b2",
      "output": "#include <speed_sensor.hpp>\n#include <deceleration_sensor.hpp>\n#include <iostream>\n\n// Critical deceleration threshold for lead vehicle\nconst float HARD_BRAKE_THRESHOLD = 4.5f; // m/s\u00c2\u00b2\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the current car speed\n    float lead_vehicle_deceleration = getLeadVehicleDeceleration(); // Deceleration of the lead vehicle\n\n    // Check for hard braking by lead vehicle\n    if (lead_vehicle_deceleration > HARD_BRAKE_THRESHOLD) {\n        std::cout << \"FCW: Hard braking detected in vehicle ahead! Apply brakes.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, lead_vehicle_deceleration = 5.5 m/s\u00c2\u00b2\n// Expected Output: \"FCW: Hard braking detected in vehicle ahead! Apply brakes.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver of sudden traffic congestion.",
      "input": "Car Speed: 70 km/h, Distance to Congestion: 15 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance before issuing FCW for congestion\nconst float CONGESTION_DISTANCE_THRESHOLD = 20.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float congestion_distance = getCongestionDistance(); // Distance to traffic congestion\n\n    // Check if congestion is dangerously close\n    if (congestion_distance < CONGESTION_DISTANCE_THRESHOLD) {\n        std::cout << \"FCW: Traffic congestion ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, congestion_distance = 15 m\n// Expected Output: \"FCW: Traffic congestion ahead! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to detect possible collisions at an intersection.",
      "input": "Car Speed: 60 km/h, Cross-Traffic Vehicle Distance: 12 meters",
      "output": "#include <cross_traffic_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance for cross-traffic alert\nconst float CROSS_TRAFFIC_DISTANCE = 15.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve current car speed\n    float cross_traffic_distance = getCrossTrafficDistance(); // Distance to cross-traffic vehicle\n\n    // Issue FCW for cross-traffic collision risk\n    if (cross_traffic_distance < CROSS_TRAFFIC_DISTANCE) {\n        std::cout << \"FCW: Cross-traffic collision risk! Brake immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, cross_traffic_distance = 12 m\n// Expected Output: \"FCW: Cross-traffic collision risk! Brake immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to issue FCW for road hazards such as fallen debris.",
      "input": "Car Speed: 50 km/h, Hazard Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance for road hazard alert\nconst float HAZARD_ALERT_DISTANCE = 12.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float hazard_distance = getHazardDistance(); // Distance to road hazard\n\n    // Trigger FCW if hazard is too close\n    if (hazard_distance < HAZARD_ALERT_DISTANCE) {\n        std::cout << \"FCW: Road hazard detected! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, hazard_distance = 10 m\n// Expected Output: \"FCW: Road hazard detected! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn if a vehicle overtaking is too close.",
      "input": "Car Speed: 80 km/h, Overtaking Vehicle Distance: 6 meters",
      "output": "#include <proximity_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance for overtaking vehicle warning\nconst float OVERTAKE_ALERT_DISTANCE = 7.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float overtaking_vehicle_distance = getOvertakingVehicleDistance(); // Distance to overtaking vehicle\n\n    // Issue warning if overtaking vehicle is too close\n    if (overtaking_vehicle_distance < OVERTAKE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Overtaking vehicle dangerously close! Maintain lane discipline.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, overtaking_vehicle_distance = 6 m\n// Expected Output: \"FCW: Overtaking vehicle dangerously close! Maintain lane discipline.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about an animal crossing ahead.",
      "input": "Car Speed: 60 km/h, Animal Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance to issue an animal crossing alert\nconst float ANIMAL_ALERT_DISTANCE = 10.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the current car speed\n    float animal_distance = getAnimalDistance(); // Distance to the animal crossing ahead\n\n    // Trigger FCW if animal is too close\n    if (animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal crossing ahead! Reduce speed and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, animal_distance = 8 m\n// Expected Output: \"FCW: Animal crossing ahead! Reduce speed and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn about a vehicle merging into your lane.",
      "input": "Car Speed: 70 km/h, Merging Vehicle Distance: 5 meters",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Critical distance for merging vehicle alert\nconst float MERGE_ALERT_DISTANCE = 6.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float merging_vehicle_distance = getMergingVehicleDistance(); // Distance to merging vehicle\n\n    // Issue FCW for merging vehicle collision risk\n    if (merging_vehicle_distance < MERGE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle merging into your lane! Adjust speed or change lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, merging_vehicle_distance = 5 m\n// Expected Output: \"FCW: Vehicle merging into your lane! Adjust speed or change lane.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about a potential rear-end collision.",
      "input": "Car Speed: 65 km/h, Following Vehicle Distance: 3 meters",
      "output": "#include <proximity_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum safe distance for rear-end collision warning\nconst float REAR_COLLISION_DISTANCE = 5.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve car speed\n    float following_vehicle_distance = getFollowingVehicleDistance(); // Distance to the vehicle following closely\n\n    // Trigger FCW if following vehicle is too close\n    if (following_vehicle_distance < REAR_COLLISION_DISTANCE) {\n        std::cout << \"FCW: Risk of rear-end collision! Increase distance or change lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 65 km/h, following_vehicle_distance = 3 m\n// Expected Output: \"FCW: Risk of rear-end collision! Increase distance or change lane.\""
    },
    {
      "instruction": "Write MISRA C++ code to issue FCW during reduced visibility conditions.",
      "input": "Car Speed: 50 km/h, Visibility Range: 15 meters",
      "output": "#include <visibility_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum visibility range before FCW is issued\nconst float VISIBILITY_THRESHOLD = 20.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve current car speed\n    float visibility_range = getVisibilityRange(); // Current visibility range\n\n    // Issue FCW if visibility is too low\n    if (visibility_range < VISIBILITY_THRESHOLD) {\n        std::cout << \"FCW: Reduced visibility detected! Drive cautiously.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, visibility_range = 15 m\n// Expected Output: \"FCW: Reduced visibility detected! Drive cautiously.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about an upcoming sharp curve.",
      "input": "Car Speed: 80 km/h, Curve Radius: 30 meters",
      "output": "#include <road_curve_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\n// Minimum curve radius for sharp curve warning\nconst float SHARP_CURVE_RADIUS = 40.0f; // meters\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve current car speed\n    float curve_radius = getCurveRadius(); // Radius of the upcoming curve\n\n    // Trigger FCW for sharp curve\n    if (curve_radius < SHARP_CURVE_RADIUS) {\n        std::cout << \"FCW: Sharp curve ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, curve_radius = 30 m\n// Expected Output: \"FCW: Sharp curve ahead! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to trigger FCW when a pedestrian suddenly appears in front.",
      "input": "Car Speed: 40 km/h, Pedestrian Distance: 5 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 7.0f; // Safe braking distance for pedestrians\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian\n\n    if (pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian ahead! Apply emergency brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, pedestrian_distance = 5 m\n// Expected Output: \"FCW: Pedestrian ahead! Apply emergency brakes immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about an upcoming red traffic light.",
      "input": "Car Speed: 60 km/h, Traffic Light Distance: 10 meters",
      "output": "#include <traffic_light_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float TRAFFIC_SIGNAL_ALERT_DISTANCE = 15.0f; // Safe alert distance\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float traffic_light_distance = getTrafficLightDistance(); // Distance to the traffic light\n    bool is_red_light = isTrafficLightRed(); // Check if the light is red\n\n    if (is_red_light && traffic_light_distance < TRAFFIC_SIGNAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Red light ahead! Reduce speed and stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, traffic_light_distance = 10 m, is_red_light = true\n// Expected Output: \"FCW: Red light ahead! Reduce speed and stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to detect a stationary vehicle blocking the lane.",
      "input": "Car Speed: 50 km/h, Obstacle Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float STATIONARY_OBSTACLE_ALERT_DISTANCE = 10.0f; // Safe braking distance\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float obstacle_distance = getStationaryObstacleDistance(); // Distance to the stationary obstacle\n\n    if (obstacle_distance < STATIONARY_OBSTACLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Stationary vehicle ahead! Apply brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, obstacle_distance = 8 m\n// Expected Output: \"FCW: Stationary vehicle ahead! Apply brakes immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about upcoming roadwork.",
      "input": "Car Speed: 70 km/h, Roadwork Distance: 12 meters",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float ROADWORK_ALERT_DISTANCE = 15.0f; // Safe alert distance\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float roadwork_distance = getRoadworkDistance(); // Distance to roadwork\n\n    if (roadwork_distance < ROADWORK_ALERT_DISTANCE) {\n        std::cout << \"FCW: Roadwork ahead! Slow down and proceed with caution.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, roadwork_distance = 12 m\n// Expected Output: \"FCW: Roadwork ahead! Slow down and proceed with caution.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a steep downhill slope.",
      "input": "Car Speed: 90 km/h, Slope Gradient: 12 degrees",
      "output": "#include <gradient_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float STEEP_SLOPE_GRADIENT = 10.0f; // Gradient threshold for steep slopes\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float slope_gradient = getSlopeGradient(); // Gradient of the slope ahead\n\n    if (slope_gradient > STEEP_SLOPE_GRADIENT) {\n        std::cout << \"FCW: Steep downhill ahead! Reduce speed and use engine braking.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, slope_gradient = 12 degrees\n// Expected Output: \"FCW: Steep downhill ahead! Reduce speed and use engine braking.\""
    },
    {
      "instruction": "Write MISRA C++ code to issue a fog alert.",
      "input": "Car Speed: 60 km/h, Visibility Distance: 20 meters",
      "output": "#include <visibility_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float FOG_VISIBILITY_THRESHOLD = 30.0f; // Minimum visibility threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float visibility_distance = getVisibilityDistance(); // Current visibility\n\n    if (visibility_distance < FOG_VISIBILITY_THRESHOLD) {\n        std::cout << \"FCW: Fog detected! Drive cautiously and reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, visibility_distance = 20 m\n// Expected Output: \"FCW: Fog detected! Drive cautiously and reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about strong crosswinds.",
      "input": "Car Speed: 80 km/h, Wind Speed: 40 km/h",
      "output": "#include <wind_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float CROSSWIND_SPEED_THRESHOLD = 35.0f; // Crosswind threshold in km/h\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float wind_speed = getWindSpeed(); // Speed of crosswind\n\n    if (wind_speed > CROSSWIND_SPEED_THRESHOLD) {\n        std::cout << \"FCW: Strong crosswinds detected! Hold the steering wheel firmly.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, wind_speed = 40 km/h\n// Expected Output: \"FCW: Strong crosswinds detected! Hold the steering wheel firmly.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about a narrow bridge ahead.",
      "input": "Car Speed: 50 km/h, Bridge Width: 3 meters",
      "output": "#include <bridge_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float MIN_BRIDGE_WIDTH = 3.5f; // Minimum width for safe passage\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float bridge_width = getBridgeWidth(); // Width of the upcoming bridge\n\n    if (bridge_width < MIN_BRIDGE_WIDTH) {\n        std::cout << \"FCW: Narrow bridge ahead! Proceed with caution.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, bridge_width = 3 m\n// Expected Output: \"FCW: Narrow bridge ahead! Proceed with caution.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn about slippery road conditions.",
      "input": "Car Speed: 60 km/h, Road Friction Coefficient: 0.3",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed\n\n_sensor.hpp>\n#include <iostream>\n\nconst float MIN_ROAD_FRICTION = 0.4f; // Minimum safe friction coefficient\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float road_friction = getRoadFrictionCoefficient(); // Current road friction\n\n    if (road_friction < MIN_ROAD_FRICTION) {\n        std::cout << \"FCW: Slippery road ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, road_friction = 0.3\n// Expected Output: \"FCW: Slippery road ahead! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a low overpass.",
      "input": "Car Speed: 45 km/h, Overpass Height: 3 meters",
      "output": "#include <overpass_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float MIN_OVERPASS_HEIGHT = 3.5f; // Minimum height for safe clearance\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float overpass_height = getOverpassHeight(); // Height of the overpass\n\n    if (overpass_height < MIN_OVERPASS_HEIGHT) {\n        std::cout << \"FCW: Low overpass ahead! Check vehicle height and proceed carefully.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, overpass_height = 3 m\n// Expected Output: \"FCW: Low overpass ahead! Check vehicle height and proceed carefully.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when following another vehicle too closely.",
      "input": "Car Speed: 80 km/h, Distance to Front Vehicle: 10 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float MIN_SAFE_DISTANCE_MULTIPLIER = 1.5f; // Safe distance multiplier based on speed\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed in km/h\n    float distance_to_vehicle = getFrontVehicleDistance(); // Distance to the front vehicle in meters\n\n    float safe_distance = (car_speed / 10) * MIN_SAFE_DISTANCE_MULTIPLIER;\n\n    if (distance_to_vehicle < safe_distance) {\n        std::cout << \"FCW: Too close to the vehicle ahead! Maintain a safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, distance_to_vehicle = 10 m\n// Expected Output: \"FCW: Too close to the vehicle ahead! Maintain a safe distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to detect animals crossing the road and alert the driver.",
      "input": "Car Speed: 50 km/h, Animal Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_ALERT_DISTANCE = 10.0f; // Safe braking distance for animals\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float animal_distance = getAnimalDistance(); // Distance to the animal\n\n    if (animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal detected ahead! Apply brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, animal_distance = 8 m\n// Expected Output: \"FCW: Animal detected ahead! Apply brakes immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a sudden stop by the vehicle ahead.",
      "input": "Car Speed: 90 km/h, Front Vehicle Deceleration: -5 m/s\\u00b2, Distance: 15 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <deceleration_sensor.hpp>\n#include <iostream>\n\nconst float SUDDEN_STOP_ALERT_DISTANCE = 20.0f; // Threshold distance for sudden stop\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float front_vehicle_distance = getFrontVehicleDistance();\n    float front_vehicle_deceleration = getFrontVehicleDeceleration();\n\n    if (front_vehicle_deceleration < -4.0f && front_vehicle_distance < SUDDEN_STOP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle ahead suddenly stopped! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, front_vehicle_deceleration = -5 m/s\u00c2\u00b2, front_vehicle_distance = 15 m\n// Expected Output: \"FCW: Vehicle ahead suddenly stopped! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a vehicle crossing at an intersection.",
      "input": "Car Speed: 60 km/h, Intersection Distance: 20 meters, Crossing Vehicle Distance: 12 meters",
      "output": "#include <intersection_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_DISTANCE = 25.0f; // Safe alert distance for intersections\n\nint main() {\n    float car_speed = getCarSpeed();\n    float intersection_distance = getIntersectionDistance();\n    float crossing_vehicle_distance = getCrossingVehicleDistance();\n\n    if (intersection_distance < INTERSECTION_ALERT_DISTANCE && crossing_vehicle_distance < INTERSECTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle crossing at the intersection! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, intersection_distance = 20 m, crossing_vehicle_distance = 12 m\n// Expected Output: \"FCW: Vehicle crossing at the intersection! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a sharp curve at a highway exit.",
      "input": "Car Speed: 100 km/h, Curve Radius: 50 meters",
      "output": "#include <curve_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SAFE_CURVE_RADIUS = 60.0f; // Minimum radius for safe curve navigation\n\nint main() {\n    float car_speed = getCarSpeed();\n    float curve_radius = getCurveRadius();\n\n    if (curve_radius < SAFE_CURVE_RADIUS) {\n        std::cout << \"FCW: Sharp curve ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 100 km/h, curve_radius = 50 m\n// Expected Output: \"FCW: Sharp curve ahead! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when drifting out of the lane.",
      "input": "Car Speed: 70 km/h, Lane Offset: 0.6 meters",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float MAX_LANE_OFFSET = 0.5f; // Maximum allowable offset in meters\n\nint main() {\n    float car_speed = getCarSpeed();\n    float lane_offset = getLaneOffset();\n\n    if (lane_offset > MAX_LANE_OFFSET) {\n        std::cout << \"FCW: Lane departure detected! Steer back into the lane.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, lane_offset = 0.6 m\n// Expected Output: \"FCW: Lane departure detected! Steer back into the lane.\""
    },
    {
      "instruction": "Write MISRA C++ code to detect a roadblock ahead and alert the driver.",
      "input": "Car Speed: 40 km/h, Roadblock Distance: 15 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float ROADBLOCK_ALERT_DISTANCE = 20.0f;\n\nint main() {\n    float car_speed = getCarSpeed();\n    float roadblock_distance = getRoadblockDistance();\n\n    if (roadblock_distance < ROADBLOCK_ALERT_DISTANCE) {\n        std::cout << \"FCW: Roadblock ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, roadblock_distance = 15 m\n// Expected Output: \"FCW: Roadblock ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a cyclist in the blind spot.",
      "input": "Car Speed: 50 km/h, Cyclist Distance: 1.5 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float CYCLIST_ALERT_DISTANCE = 2.0f;\n\nint main() {\n    float car_speed = getCarSpeed();\n    float cyclist_distance = getCyclistDistance();\n\n    if (cyclist_distance < CYCLIST_ALERT_DISTANCE) {\n        std::cout << \"FCW: Cyclist in the blind spot! Check mirrors before changing lanes.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, cyclist_distance = 1.5 m\n// Expected Output: \"FCW: Cyclist in the blind spot! Check mirrors before changing lanes.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected on the road ahead.",
      "input": "Car Speed: 60 km/h, Pedestrian Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 10.0f; // Safe stopping distance for pedestrians\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian\n\n    if (pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected ahead! Apply brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, pedestrian_distance = 8 m\n// Expected Output: \"FCW: Pedestrian detected ahead! Apply brakes immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a sharp bend on the road.",
      "input": "Car Speed: 70 km/h, Curve Radius: 30 meters",
      "output": "#include <curve_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SHARP_BEND_ALERT_RADIUS = 40.0f; // Radius of the curve for warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float curve_radius = getCurveRadius(); // Radius of the upcoming curve\n\n    if (curve_radius < SHARP_BEND_ALERT_RADIUS) {\n        std::cout << \"FCW: Sharp bend ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, curve_radius = 30 m\n// Expected Output: \"FCW: Sharp bend ahead! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver of a potential rear-end collision due to a stopped vehicle.",
      "input": "Car Speed: 80 km/h, Stopped Vehicle Distance: 12 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float REAR_END_ALERT_DISTANCE = 15.0f; // Distance threshold for rear-end collision\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float vehicle_distance = getStoppedVehicleDistance(); // Distance to the stopped vehicle\n\n    if (vehicle_distance < REAR_END_ALERT_DISTANCE) {\n        std::cout << \"FCW: Potential rear-end collision! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, vehicle_distance = 12 m\n// Expected Output: \"FCW: Potential rear-end collision! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle is crossing at an intersection.",
      "input": "Car Speed: 60 km/h, Crossing Vehicle Distance: 10 meters, Intersection Distance: 15 meters",
      "output": "#include <intersection_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_DISTANCE = 20.0f; // Safe distance threshold for intersection crossings\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float crossing_vehicle_distance = getCrossingVehicleDistance(); // Distance to the crossing vehicle\n    float intersection_distance = getIntersectionDistance(); // Distance to the intersection\n\n    if (intersection_distance < INTERSECTION_ALERT_DISTANCE && crossing_vehicle_distance < INTERSECTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle crossing the intersection! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, crossing_vehicle_distance = 10 m, intersection_distance = 15 m\n// Expected Output: \"FCW: Vehicle crossing the intersection! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about an approaching speed bump.",
      "input": "Car Speed: 50 km/h, Speed Bump Distance: 12 meters",
      "output": "#include <road_feature_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_BUMP_ALERT_DISTANCE = 15.0f; // Distance for warning about speed bumps\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float speed_bump_distance = getSpeedBumpDistance(); // Distance to the speed bump\n\n    if (speed_bump_distance < SPEED_BUMP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Speed bump ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, speed_bump_distance = 12 m\n// Expected Output: \"FCW: Speed bump ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about a child pedestrian crossing the road.",
      "input": "Car Speed: 40 km/h, Child Pedestrian Distance: 5 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float CHILD_PEDESTRIAN_ALERT_DISTANCE = 8.0f; // Alert threshold for child pedestrians\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the child pedestrian\n\n    if (pedestrian_distance < CHILD_PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Child pedestrian detected ahead! Apply brakes immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, pedestrian_distance = 5 m\n// Expected Output: \"FCW: Child pedestrian detected ahead! Apply brakes immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about hazardous road conditions ahead (e.g., ice, rain).",
      "input": "Car Speed: 50 km/h, Road Condition: Ice",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst char* HAZARDOUS_CONDITION = \"Ice\"; // Hazardous road condition\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    const char* road_condition = getRoadCondition(); // Get the current road condition\n\n    if (strcmp(road_condition, HAZARDOUS_CONDITION) == 0) {\n        std::cout << \"FCW: Hazardous road condition ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, road_condition = \"Ice\"\n// Expected Output: \"FCW: Hazardous road condition ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if a vehicle is approaching too quickly from behind.",
      "input": "Car Speed: 90 km/h, Rear Vehicle Speed: 110 km/h, Distance: 30 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float REAR_VEHICLE_ALERT_DISTANCE = 50.0f; // Minimum distance for rear vehicle alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float rear_vehicle_speed = getRearVehicleSpeed(); // Speed of the approaching vehicle\n    float rear_vehicle_distance = getRearVehicleDistance(); // Distance to the rear vehicle\n\n    if (rear_vehicle_speed > car_speed && rear_vehicle_distance < REAR_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle approaching from behind at high speed! Keep safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, rear_vehicle_speed = 110 km/h, rear_vehicle_distance = 30 m\n\n\n// Expected Output: \"FCW: Vehicle approaching from behind at high speed! Keep safe distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver when approaching a stop sign.",
      "input": "Car Speed: 30 km/h, Stop Sign Distance: 20 meters",
      "output": "#include <road_feature_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float STOP_SIGN_ALERT_DISTANCE = 25.0f; // Distance to trigger stop sign alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float stop_sign_distance = getStopSignDistance(); // Distance to the stop sign\n\n    if (stop_sign_distance < STOP_SIGN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Stop sign ahead! Slow down and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 30 km/h, stop_sign_distance = 20 m\n// Expected Output: \"FCW: Stop sign ahead! Slow down and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if they are tailgating another vehicle.",
      "input": "Car Speed: 80 km/h, Lead Vehicle Distance: 10 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float TAILGATING_ALERT_DISTANCE = 15.0f; // Minimum safe distance for tailgating\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float lead_vehicle_distance = getLeadVehicleDistance(); // Distance to the lead vehicle\n\n    if (lead_vehicle_distance < TAILGATING_ALERT_DISTANCE) {\n        std::cout << \"FCW: You are tailgating! Increase your following distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, lead_vehicle_distance = 10 m\n// Expected Output: \"FCW: You are tailgating! Increase your following distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a stopped vehicle is detected ahead.",
      "input": "Car Speed: 70 km/h, Stopped Vehicle Distance: 15 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float STOPPED_VEHICLE_ALERT_DISTANCE = 20.0f; // Safe distance to avoid collision with stopped vehicle\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float vehicle_distance = getStoppedVehicleDistance(); // Distance to the stopped vehicle\n\n    if (vehicle_distance < STOPPED_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Stopped vehicle ahead! Reduce speed immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, vehicle_distance = 15 m\n// Expected Output: \"FCW: Stopped vehicle ahead! Reduce speed immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if a vehicle in an adjacent lane suddenly changes into the car's lane.",
      "input": "Car Speed: 80 km/h, Adjacent Vehicle Distance: 10 meters, Lane Change Speed: 30 km/h",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float LANE_CHANGE_ALERT_DISTANCE = 12.0f; // Distance threshold for sudden lane changes\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float adjacent_vehicle_distance = getAdjacentVehicleDistance(); // Distance to the adjacent vehicle\n    float lane_change_speed = getLaneChangeSpeed(); // Speed of the adjacent vehicle changing lanes\n\n    if (adjacent_vehicle_distance < LANE_CHANGE_ALERT_DISTANCE && lane_change_speed > car_speed) {\n        std::cout << \"FCW: Vehicle is changing lanes abruptly! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, adjacent_vehicle_distance = 10 m, lane_change_speed = 30 km/h\n// Expected Output: \"FCW: Vehicle is changing lanes abruptly! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if an animal is detected on the road ahead.",
      "input": "Car Speed: 50 km/h, Animal Distance: 15 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_ALERT_DISTANCE = 20.0f; // Safe stopping distance for animal detection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float animal_distance = getAnimalDistance(); // Distance to the animal\n\n    if (animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal detected ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, animal_distance = 15 m\n// Expected Output: \"FCW: Animal detected ahead! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if a pedestrian is detected crossing the road in front of the car.",
      "input": "Car Speed: 40 km/h, Pedestrian Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_CROSSING_ALERT_DISTANCE = 10.0f; // Alert threshold for pedestrian crossings\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian crossing\n\n    if (pedestrian_distance < PEDESTRIAN_CROSSING_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian crossing ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, pedestrian_distance = 8 m\n// Expected Output: \"FCW: Pedestrian crossing ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if they are approaching a red traffic light at a high speed.",
      "input": "Car Speed: 60 km/h, Traffic Light Distance: 25 meters, Traffic Light Status: Red",
      "output": "#include <traffic_light_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float TRAFFIC_LIGHT_ALERT_DISTANCE = 30.0f; // Safe distance to trigger alert for red light\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float traffic_light_distance = getTrafficLightDistance(); // Distance to the traffic light\n    bool traffic_light_status = getTrafficLightStatus(); // Traffic light status\n\n    if (traffic_light_status == RED && traffic_light_distance < TRAFFIC_LIGHT_ALERT_DISTANCE) {\n        std::cout << \"FCW: Red traffic light ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, traffic_light_distance = 25 m, traffic_light_status = RED\n// Expected Output: \"FCW: Red traffic light ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if a vehicle is approaching rapidly from behind.",
      "input": "Car Speed: 80 km/h, Rear Vehicle Speed: 110 km/h, Distance: 50 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float REAR_VEHICLE_ALERT_DISTANCE = 60.0f; // Minimum safe distance for rear-end alerts\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float rear_vehicle_speed = getRearVehicleSpeed(); // Speed of the vehicle behind\n    float rear_vehicle_distance = getRearVehicleDistance(); // Distance to the vehicle behind\n\n    if (rear_vehicle_speed > car_speed && rear_vehicle_distance < REAR_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle approaching from behind at high speed! Maintain safe distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, rear_vehicle_speed = 110 km/h, rear_vehicle_distance = 50 m\n// Expected Output: \"FCW: Vehicle approaching from behind at high speed! Maintain safe distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the road surface is detected as slippery (e.g., rain or ice).",
      "input": "Car Speed: 45 km/h, Road Condition: Wet",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst char* SLIPPERY_ROAD_CONDITION = \"Wet\"; // Condition to trigger alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    const char* road_condition = getRoadCondition(); // Get the current road condition\n\n    if (strcmp(road_condition, SLIPPERY_ROAD_CONDITION) == 0) {\n        std::cout << \"FCW: Slippery road ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, road_condition = \"Wet\"\n// Expected Output: \"FCW: Slippery road ahead! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver about hazardous debris detected on the road.",
      "input": "Car Speed: 50 km/h, Debris Distance: 20 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float DEBRIS_ALERT_DISTANCE = 25.0f; // Distance to hazardous debris threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float debris_distance = getDebrisDistance();\n\n // Distance to debris\n\n    if (debris_distance < DEBRIS_ALERT_DISTANCE) {\n        std::cout << \"FCW: Hazardous debris detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, debris_distance = 20 m\n// Expected Output: \"FCW: Hazardous debris detected! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if a pedestrian is detected crossing the road in front of the car.",
      "input": "Car Speed: 60 km/h, Pedestrian Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 12.0f; // Distance to pedestrian crossing threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian\n\n    if (pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, pedestrian_distance = 10 m\n// Expected Output: \"FCW: Pedestrian detected ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver when approaching slow-moving traffic on the highway.",
      "input": "Car Speed: 100 km/h, Traffic Speed: 30 km/h, Distance: 50 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SLOW_TRAFFIC_ALERT_DISTANCE = 60.0f; // Minimum safe distance to warn of slow traffic\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float traffic_speed = getTrafficSpeed(); // Speed of the traffic ahead\n    float traffic_distance = getTrafficDistance(); // Distance to the slow traffic\n\n    if (traffic_speed < car_speed && traffic_distance < SLOW_TRAFFIC_ALERT_DISTANCE) {\n        std::cout << \"FCW: Slow-moving traffic ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 100 km/h, traffic_speed = 30 km/h, traffic_distance = 50 m\n// Expected Output: \"FCW: Slow-moving traffic ahead! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a fast-moving vehicle is detected in front at a close distance.",
      "input": "Car Speed: 100 km/h, Front Vehicle Speed: 120 km/h, Distance: 30 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float FRONT_VEHICLE_ALERT_DISTANCE = 35.0f; // Alert threshold for fast-moving vehicles ahead\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float front_vehicle_speed = getFrontVehicleSpeed(); // Speed of the vehicle ahead\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the vehicle ahead\n\n    if (front_vehicle_speed > car_speed && front_vehicle_distance < FRONT_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Fast-moving vehicle detected ahead! Reduce speed.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 100 km/h, front_vehicle_speed = 120 km/h, front_vehicle_distance = 30 m\n// Expected Output: \"FCW: Fast-moving vehicle detected ahead! Reduce speed.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle in front suddenly brakes.",
      "input": "Car Speed: 80 km/h, Front Vehicle Speed: 60 km/h, Distance: 10 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <brake_sensor.hpp>\n#include <iostream>\n\nconst float FRONT_VEHICLE_BRAKING_ALERT_DISTANCE = 15.0f; // Distance threshold for sudden braking detection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float front_vehicle_speed = getFrontVehicleSpeed(); // Speed of the vehicle ahead\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the vehicle ahead\n    bool front_vehicle_braking = getFrontVehicleBrakingStatus(); // Front vehicle's braking status\n\n    if (front_vehicle_braking && front_vehicle_distance < FRONT_VEHICLE_BRAKING_ALERT_DISTANCE) {\n        std::cout << \"FCW: Front vehicle is braking! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, front_vehicle_speed = 60 km/h, front_vehicle_distance = 10 m, front_vehicle_braking = true\n// Expected Output: \"FCW: Front vehicle is braking! Prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected crossing the road at night.",
      "input": "Car Speed: 40 km/h, Pedestrian Distance: 15 meters, Night Mode: Active",
      "output": "#include <object_sensor.hpp>\n#include <night_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 20.0f; // Distance to pedestrian threshold for alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_distance = getPedestrianDistance(); // Distance to pedestrian\n    bool night_mode = getNightModeStatus(); // Night mode status\n\n    if (night_mode && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected in front! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, pedestrian_distance = 15 m, night_mode = true\n// Expected Output: \"FCW: Pedestrian detected in front! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an animal is detected on the road while traveling at high speed.",
      "input": "Car Speed: 90 km/h, Animal Distance: 25 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_ALERT_DISTANCE = 30.0f; // Alert threshold for animals on road\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float animal_distance = getAnimalDistance(); // Distance to the animal on road\n\n    if (animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal detected on the road! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, animal_distance = 25 m\n// Expected Output: \"FCW: Animal detected on the road! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if a car is approaching an intersection too quickly.",
      "input": "Car Speed: 70 km/h, Intersection Distance: 50 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <intersection_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_DISTANCE = 60.0f; // Safe distance from intersection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float intersection_distance = getIntersectionDistance(); // Distance to the intersection\n\n    if (intersection_distance < INTERSECTION_ALERT_DISTANCE && car_speed > 50) {\n        std::cout << \"FCW: Approaching intersection too fast! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, intersection_distance = 50 m\n// Expected Output: \"FCW: Approaching intersection too fast! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if fatigue is detected using eye-tracking sensors.",
      "input": "Car Speed: 60 km/h, Driver Fatigue Status: Detected",
      "output": "#include <driver_fatigue_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst int FATIGUE_ALERT_THRESHOLD = 1; // Threshold for fatigue detection\n\nint main() {\n    int fatigue_status = getDriverFatigueStatus(); // Get driver's fatigue status\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n\n    if (fatigue_status == FATIGUE_ALERT_THRESHOLD) {\n        std::cout << \"FCW: Driver fatigue detected! Take a break.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, fatigue_status = 1\n// Expected Output: \"FCW: Driver fatigue detected! Take a break.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a sudden obstacle is detected in the lane.",
      "input": "Car Speed: 75 km/h, Obstacle Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float OBSTACLE_ALERT_DISTANCE = 10.0f; // Distance to obstacle threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float obstacle_distance = getObstacleDistance(); // Distance to the obstacle\n\n    if (obstacle_distance < OBSTACLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Sudden obstacle ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 75 km/h, obstacle_distance = 8 m\n// Expected Output: \"FCW: Sudden obstacle ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle unintentionally departs from its lane.",
      "input": "Car Speed: 50 km/h, Lane Departure: True",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst bool LANE_DEPARTURE_ALERT = true; // Alert for lane departure\n\nint main() {\n    bool lane_departure = getLaneDepartureStatus(); // Get lane departure status\n    float car_speed = getCarSpeed(); // Retrieve\n\n the car's speed\n\n    if (lane_departure == LANE_DEPARTURE_ALERT) {\n        std::cout << \"FCW: Lane departure detected! Steer back.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, lane_departure = true\n// Expected Output: \"FCW: Lane departure detected! Steer back.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver when entering a highway at high speed.",
      "input": "Car Speed: 90 km/h, Highway Speed Limit: 120 km/h, Distance to Highway: 200 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float HIGHWAY_ENTRY_ALERT_SPEED = 100.0f; // Speed threshold for highway entry\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float highway_speed_limit = getHighwaySpeedLimit(); // Speed limit on the highway\n    float distance_to_highway = getDistanceToHighway(); // Distance to highway entry\n\n    if (car_speed > HIGHWAY_ENTRY_ALERT_SPEED && distance_to_highway < 100) {\n        std::cout << \"FCW: Entering highway at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, highway_speed_limit = 120 km/h, distance_to_highway = 200 m\n// Expected Output: \"FCW: Entering highway at high speed! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when approaching a dangerous intersection too fast.",
      "input": "Car Speed: 50 km/h, Intersection Distance: 40 meters, Traffic Signal: Red",
      "output": "#include <speed_sensor.hpp>\n#include <intersection_sensor.hpp>\n#include <traffic_signal_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_DISTANCE = 50.0f; // Alert threshold for dangerous intersection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float intersection_distance = getIntersectionDistance(); // Distance to intersection\n    bool red_light = getTrafficSignalStatus(); // Traffic signal status\n\n    if (intersection_distance < INTERSECTION_ALERT_DISTANCE && car_speed > 40 && red_light) {\n        std::cout << \"FCW: Dangerous intersection ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, intersection_distance = 40 m, red_light = true\n// Expected Output: \"FCW: Dangerous intersection ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the car is tailgating another vehicle.",
      "input": "Car Speed: 70 km/h, Following Vehicle Speed: 65 km/h, Distance: 5 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float TAILGATING_ALERT_DISTANCE = 6.0f; // Minimum safe following distance\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float following_vehicle_speed = getFollowingVehicleSpeed(); // Speed of the vehicle behind\n    float distance_to_vehicle = getDistanceToFollowingVehicle(); // Distance to vehicle behind\n\n    if (car_speed > following_vehicle_speed && distance_to_vehicle < TAILGATING_ALERT_DISTANCE) {\n        std::cout << \"FCW: Tailgating detected! Increase following distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, following_vehicle_speed = 65 km/h, distance_to_vehicle = 5 m\n// Expected Output: \"FCW: Tailgating detected! Increase following distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle is closing in rapidly on the vehicle in front.",
      "input": "Car Speed: 90 km/h, Front Vehicle Speed: 70 km/h, Distance: 15 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float CLOSING_SPEED_ALERT_THRESHOLD = 15.0f; // Distance threshold for closing speed alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float front_vehicle_speed = getFrontVehicleSpeed(); // Speed of the vehicle ahead\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the vehicle ahead\n\n    if ((car_speed - front_vehicle_speed) > 30.0f && front_vehicle_distance < CLOSING_SPEED_ALERT_THRESHOLD) {\n        std::cout << \"FCW: Rapid closing speed detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, front_vehicle_speed = 70 km/h, front_vehicle_distance = 15 m\n// Expected Output: \"FCW: Rapid closing speed detected! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if another vehicle is changing lanes into the car's path without a turn signal.",
      "input": "Car Speed: 80 km/h, Vehicle in Adjacent Lane: 5 meters away, Turn Signal: Off",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <signal_sensor.hpp>\n#include <iostream>\n\nconst float LANE_CHANGE_ALERT_DISTANCE = 6.0f; // Distance threshold for lane change alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float adjacent_vehicle_distance = getAdjacentVehicleDistance(); // Distance to the adjacent vehicle\n    bool turn_signal_on = getTurnSignalStatus(); // Turn signal status of adjacent vehicle\n\n    if (adjacent_vehicle_distance < LANE_CHANGE_ALERT_DISTANCE && !turn_signal_on) {\n        std::cout << \"FCW: Lane change detected without turn signal! Prepare to adjust.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, adjacent_vehicle_distance = 5 m, turn_signal_on = false\n// Expected Output: \"FCW: Lane change detected without turn signal! Prepare to adjust.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected crossing the road at high speed.",
      "input": "Car Speed: 60 km/h, Pedestrian Speed: 8 km/h, Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 15.0f; // Alert threshold for pedestrians crossing\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float pedestrian_speed = getPedestrianSpeed(); // Speed of the pedestrian\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian\n\n    if (pedestrian_speed > 5.0f && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: High-speed pedestrian crossing! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, pedestrian_speed = 8 km/h, pedestrian_distance = 10 m\n// Expected Output: \"FCW: High-speed pedestrian crossing! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle is stopped in the lane ahead.",
      "input": "Car Speed: 50 km/h, Front Vehicle Status: Stopped, Distance: 20 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float STOPPED_VEHICLE_ALERT_DISTANCE = 25.0f; // Distance to stopped vehicle threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool front_vehicle_stopped = getFrontVehicleStatus(); // Status of the front vehicle\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the front vehicle\n\n    if (front_vehicle_stopped && front_vehicle_distance < STOPPED_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Stopped vehicle detected ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, front_vehicle_status = true, front_vehicle_distance = 20 m\n// Expected Output: \"FCW: Stopped vehicle detected ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver when an emergency vehicle is approaching from behind with its sirens on.",
      "input": "Car Speed: 60 km/h, Emergency Vehicle Distance: 10 meters, Sirens On: True",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <sirens_sensor.hpp>\n#include <iostream>\n\nconst float EMERGENCY_VEHICLE_ALERT_DISTANCE = 15.0f; // Distance to emergency vehicle threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float emergency_vehicle_distance = getEmergencyVehicleDistance(); // Distance to the emergency vehicle\n    bool sirens_on = getSirensStatus(); // Emergency vehicle siren status\n\n    if (emergency_vehicle_distance < EMERGENCY_VEHICLE_ALERT_DISTANCE && sirens_on) {\n        std::cout << \"FCW: Emergency vehicle approaching! Move aside.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, emergency_vehicle_distance = 10 m, sirens_on = true\n// Expected Output: \"FCW: Emergency vehicle approaching! Move aside.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle is blocking the intersection.",
      "input": "Car Speed: 50 km/h, Intersection Status: Blocked by Vehicle, Distance: 20 meters",
      "output": "#include <speed_sensor.hpp>\n#include <intersection_sensor.hpp>\n#include <object_sensor.hpp>\n#include <iostream>\n\nconst float BLOCKED_INTERSECTION_ALERT_DISTANCE = 25.0f; // Threshold for intersection block detection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool intersection_blocked = getIntersectionStatus(); // Intersection blocking status\n    float intersection_distance = getIntersectionDistance(); // Distance to intersection\n\n    if (intersection_blocked && intersection_distance < BLOCKED_INTERSECTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Intersection blocked! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, intersection_status = true, intersection_distance = 20 m\n// Expected Output: \"\n\nFCW: Intersection blocked! Prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if debris is detected on the road.",
      "input": "Car Speed: 40 km/h, Object Type: Debris, Distance: 15 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float DEBRIS_ALERT_DISTANCE = 20.0f; // Distance threshold for debris alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool debris_detected = getObjectType() == DEBRIS; // Check if debris is detected\n    float debris_distance = getObjectDistance(); // Distance to the detected debris\n\n    if (debris_detected && debris_distance < DEBRIS_ALERT_DISTANCE) {\n        std::cout << \"FCW: Debris detected on the road! Slow down and avoid.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, object_type = DEBRIS, debris_distance = 15 m\n// Expected Output: \"FCW: Debris detected on the road! Slow down and avoid.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the front vehicle stops suddenly.",
      "input": "Car Speed: 60 km/h, Front Vehicle Status: Stopped, Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float FRONT_VEHICLE_STOP_ALERT_DISTANCE = 15.0f; // Threshold for front vehicle sudden stop\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool front_vehicle_stopped = getFrontVehicleStatus(); // Status of the front vehicle\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to front vehicle\n\n    if (front_vehicle_stopped && front_vehicle_distance < FRONT_VEHICLE_STOP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Front vehicle stopped suddenly! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, front_vehicle_status = true, front_vehicle_distance = 10 m\n// Expected Output: \"FCW: Front vehicle stopped suddenly! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about pedestrians crossing at night.",
      "input": "Car Speed: 30 km/h, Pedestrian Speed: 5 km/h, Distance: 12 meters, Night Mode: True",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <lighting_sensor.hpp>\n#include <iostream>\n\nconst float NIGHT_PEDESTRIAN_ALERT_DISTANCE = 15.0f; // Night pedestrian alert threshold\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool night_mode = getLightingStatus(); // Check if it's night mode\n    float pedestrian_distance = getPedestrianDistance(); // Distance to pedestrian\n\n    if (night_mode && pedestrian_distance < NIGHT_PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected at night! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 30 km/h, pedestrian_distance = 12 m, night_mode = true\n// Expected Output: \"FCW: Pedestrian detected at night! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected in the crosswalk ahead.",
      "input": "Car Speed: 50 km/h, Pedestrian Speed: 3 km/h, Distance: 10 meters, Crosswalk Detected: True",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_CROSSWALK_ALERT_DISTANCE = 15.0f; // Alert threshold for pedestrian in crosswalk\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool pedestrian_in_crosswalk = getCrosswalkStatus(); // Pedestrian detected in crosswalk\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian\n\n    if (pedestrian_in_crosswalk && pedestrian_distance < PEDESTRIAN_CROSSWALK_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected in crosswalk! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, pedestrian_distance = 10 m, pedestrian_in_crosswalk = true\n// Expected Output: \"FCW: Pedestrian detected in crosswalk! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an object is detected on the roadway ahead.",
      "input": "Car Speed: 40 km/h, Object Type: Obstacle, Distance: 12 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float OBSTACLE_ALERT_DISTANCE = 15.0f; // Distance threshold for obstacle detection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool object_detected = getObjectType() == OBSTACLE; // Check for obstacle detection\n    float object_distance = getObjectDistance(); // Distance to object\n\n    if (object_detected && object_distance < OBSTACLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Obstacle detected ahead! Slow down and avoid.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, object_type = OBSTACLE, object_distance = 12 m\n// Expected Output: \"FCW: Obstacle detected ahead! Slow down and avoid.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle makes a sudden lane change in front of the car.",
      "input": "Car Speed: 60 km/h, Front Vehicle Status: Lane Change Detected, Distance: 18 meters",
      "output": "#include <lane_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SUDDEN_LANE_CHANGE_ALERT_DISTANCE = 20.0f; // Threshold for lane change alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool lane_change_detected = getLaneChangeStatus(); // Status of the front vehicle's lane change\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the front vehicle\n\n    if (lane_change_detected && front_vehicle_distance < SUDDEN_LANE_CHANGE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Sudden lane change detected in front! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, lane_change_detected = true, front_vehicle_distance = 18 m\n// Expected Output: \"FCW: Sudden lane change detected in front! Prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle ahead suddenly stops.",
      "input": "Car Speed: 80 km/h, Front Vehicle Status: Stopped, Distance: 15 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SUDDEN_STOP_ALERT_DISTANCE = 20.0f; // Threshold for sudden stop warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool front_vehicle_stopped = getFrontVehicleStatus(); // Check if the front vehicle stopped\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to front vehicle\n\n    if (front_vehicle_stopped && front_vehicle_distance < SUDDEN_STOP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Front vehicle stopped suddenly! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, front_vehicle_status = true, front_vehicle_distance = 15 m\n// Expected Output: \"FCW: Front vehicle stopped suddenly! Prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to alert the driver if an emergency brake is applied by the vehicle ahead.",
      "input": "Car Speed: 60 km/h, Front Vehicle Status: Emergency Brake Applied, Distance: 12 meters",
      "output": "#include <braking_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float EMERGENCY_BRAKING_ALERT_DISTANCE = 15.0f; // Threshold for emergency braking alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool emergency_brake_applied = getEmergencyBrakeStatus(); // Check if emergency brake is applied\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the front vehicle\n\n    if (emergency_brake_applied && front_vehicle_distance < EMERGENCY_BRAKING_ALERT_DISTANCE) {\n        std::cout << \"FCW: Front vehicle applied emergency brake! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, emergency_brake_applied = true, front_vehicle_distance = 12 m\n// Expected Output: \"FCW: Front vehicle applied emergency brake! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a cyclist is detected in front of the car.",
      "input": "Car Speed: 50 km/h, Cyclist Speed: 15 km/h, Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float CYCLIST_ALERT_DISTANCE = 10.0f; // Distance threshold for cyclist alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float cyclist_speed = getCyclistSpeed(); // Speed of the cyclist\n    float cyclist_distance = getCyclistDistance(); // Distance to the cyclist\n\n    if (cyclist_distance < CYCLIST_ALERT_DISTANCE) {\n        std::cout << \"FCW: Cyclist detected ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, cyclist_speed = 15 km/h, cyclist_distance = 8 m\n// Expected Output: \"FCW: Cyclist detected ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the car is approaching a red traffic light too quickly.",
      "input": "Car Speed: 60 km/h, Traffic Light Status: Red, Distance: 25 meters",
      "output": "#include <traffic_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float RED_LIGHT_ALERT_DISTANCE = 30.0f; // Distance threshold for red light warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool red_light = getTrafficLightStatus() == RED; // Check if traffic light is red\n    float light_distance = getTrafficLightDistance(); // Distance to the traffic light\n\n    if (red_light && light_distance < RED_LIGHT_ALERT_DISTANCE) {\n        std::cout << \"FCW: Approaching red light too fast! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input\n\n: car_speed = 60 km/h, traffic_light_status = RED, light_distance = 25 m\n// Expected Output: \"FCW: Approaching red light too fast! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an animal crosses the road ahead.",
      "input": "Car Speed: 40 km/h, Animal Detected: True, Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_ALERT_DISTANCE = 15.0f; // Distance threshold for animal detection\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool animal_detected = getObjectType() == ANIMAL; // Check if an animal is detected\n    float animal_distance = getObjectDistance(); // Distance to the detected animal\n\n    if (animal_detected && animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal detected on the road! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, object_type = ANIMAL, animal_distance = 10 m\n// Expected Output: \"FCW: Animal detected on the road! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver about weather hazards, such as heavy rain.",
      "input": "Car Speed: 50 km/h, Weather: Heavy Rain, Distance: 100 meters",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float RAIN_ALERT_SPEED = 40.0f; // Speed threshold for heavy rain warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool heavy_rain = getWeatherStatus() == HEAVY_RAIN; // Check if it's heavy rain\n\n    if (heavy_rain && car_speed > RAIN_ALERT_SPEED) {\n        std::cout << \"FCW: Heavy rain detected! Slow down and drive safely.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, weather_status = HEAVY_RAIN\n// Expected Output: \"FCW: Heavy rain detected! Slow down and drive safely.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a sharp turn is ahead.",
      "input": "Car Speed: 45 km/h, Road Curvature: Sharp Turn, Distance: 50 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SHARP_TURN_ALERT_DISTANCE = 60.0f; // Distance threshold for sharp turn alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool sharp_turn_ahead = getRoadCurvature() == SHARP_TURN; // Check for sharp turn\n    float turn_distance = getTurnDistance(); // Distance to the sharp turn\n\n    if (sharp_turn_ahead && turn_distance < SHARP_TURN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Sharp turn ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, road_curvature = SHARP_TURN, turn_distance = 50 m\n// Expected Output: \"FCW: Sharp turn ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when approaching an intersection at high speed.",
      "input": "Car Speed: 80 km/h, Intersection Status: Approaching, Distance: 100 meters",
      "output": "#include <intersection_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_SPEED = 60.0f; // Speed threshold for intersection alert\nconst float INTERSECTION_ALERT_DISTANCE = 50.0f; // Distance threshold for intersection alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool intersection_approaching = getIntersectionStatus(); // Check if approaching intersection\n    float intersection_distance = getIntersectionDistance(); // Distance to intersection\n\n    if (intersection_approaching && car_speed > INTERSECTION_ALERT_SPEED && intersection_distance < INTERSECTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Approaching intersection at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, intersection_approaching = true, intersection_distance = 100 m\n// Expected Output: \"FCW: Approaching intersection at high speed! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is crossing the road suddenly ahead.",
      "input": "Car Speed: 50 km/h, Pedestrian Detected: True, Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 15.0f; // Distance threshold for pedestrian alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool pedestrian_detected = getObjectType() == PEDESTRIAN; // Check if pedestrian detected\n    float pedestrian_distance = getObjectDistance(); // Distance to pedestrian\n\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian detected ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, pedestrian_detected = true, pedestrian_distance = 10 m\n// Expected Output: \"FCW: Pedestrian detected ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the car is tailgating the vehicle ahead.",
      "input": "Car Speed: 60 km/h, Front Vehicle Distance: 8 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float TAILGATING_ALERT_DISTANCE = 10.0f; // Minimum safe following distance\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to the front vehicle\n\n    if (front_vehicle_distance < TAILGATING_ALERT_DISTANCE) {\n        std::cout << \"FCW: Tailgating detected! Increase distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, front_vehicle_distance = 8 m\n// Expected Output: \"FCW: Tailgating detected! Increase distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if approaching a stop sign at high speed.",
      "input": "Car Speed: 70 km/h, Stop Sign Detected: True, Distance: 120 meters",
      "output": "#include <traffic_sign_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float STOP_SIGN_ALERT_SPEED = 50.0f; // Speed threshold for stop sign warning\nconst float STOP_SIGN_ALERT_DISTANCE = 60.0f; // Distance threshold for stop sign warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool stop_sign_detected = getTrafficSignStatus() == STOP_SIGN; // Check if stop sign is detected\n    float stop_sign_distance = getTrafficSignDistance(); // Distance to the stop sign\n\n    if (stop_sign_detected && car_speed > STOP_SIGN_ALERT_SPEED && stop_sign_distance < STOP_SIGN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Approaching stop sign at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, stop_sign_detected = true, stop_sign_distance = 120 m\n// Expected Output: \"FCW: Approaching stop sign at high speed! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle ahead stops suddenly.",
      "input": "Car Speed: 90 km/h, Front Vehicle Status: Stopped, Distance: 30 meters",
      "output": "#include <braking_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SUDDEN_STOP_ALERT_DISTANCE = 40.0f; // Threshold for sudden stop warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool front_vehicle_stopped = getFrontVehicleStatus() == STOPPED; // Check if front vehicle is stopped\n\n    float front_vehicle_distance = getFrontVehicleDistance(); // Distance to front vehicle\n\n    if (front_vehicle_stopped && front_vehicle_distance < SUDDEN_STOP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Front vehicle stopped suddenly! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, front_vehicle_status = STOPPED, front_vehicle_distance = 30 m\n// Expected Output: \"FCW: Front vehicle stopped suddenly! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the car is at risk of a rear-end collision.",
      "input": "Car Speed: 80 km/h, Rear Vehicle Speed: 90 km/h, Distance: 10 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float REAR_END_ALERT_DISTANCE = 12.0f; // Distance threshold for rear-end collision risk\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float rear_vehicle_speed = getRearVehicleSpeed(); // Speed of the vehicle behind\n    float rear_vehicle_distance = getRearVehicleDistance(); // Distance to rear vehicle\n\n    if (rear_vehicle_speed > car_speed && rear_vehicle_distance < REAR_END_ALERT_DISTANCE) {\n        std::cout << \"FCW: Rear-end collision risk! Prepare to brake.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, rear_vehicle_speed = 90 km/h, rear_vehicle_distance = 10 m\n// Expected Output: \"FCW: Rear-end collision risk! Prepare to brake.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an animal crosses the road ahead.",
      "input": "Car Speed: 50 km/h, Animal Detected: True, Distance: 20 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_ALERT_DISTANCE = 25.0f; // Distance threshold for animal crossing alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool animal_detected = getObjectType() == ANIMAL; // Check if animal detected\n    float animal_distance = getObjectDistance(); // Distance to the animal\n\n    if (animal_detected && animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal detected crossing the road! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, animal_detected = true, animal_distance = 20 m\n// Expected Output: \"FCW: Animal detected crossing the road! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a cyclist is ahead and too close.",
      "input": "Car Speed: 60 km/h, Cyclist Detected: True, Distance: 5 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float CYCLIST_ALERT_DISTANCE = 8.0f; // Distance threshold for cyclist alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool cyclist_detected = getObjectType() == CYCLIST; // Check if cyclist detected\n    float cyclist_distance = getObjectDistance(); // Distance to the cyclist\n\n    if (cyclist_detected && cyclist_distance < CYCLIST_ALERT_DISTANCE) {\n        std::cout << \"FCW: Cyclist ahead! Slow down and be cautious.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, cyclist_detected = true, cyclist_distance = 5 m\n// Expected Output: \"FCW: Cyclist ahead! Slow down and be cautious.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver of slippery road conditions.",
      "input": "Car Speed: 45 km/h, Road Condition: Slippery, Distance: 50 meters",
      "output": "#include <road_condition_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SLIPPERY_ROAD_SPEED_THRESHOLD = 40.0f; // Speed threshold for slippery road warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool slippery_road = getRoadCondition() == SLIPPERY; // Check for slippery road\n\n    if (slippery_road && car_speed > SLIPPERY_ROAD_SPEED_THRESHOLD) {\n        std::cout << \"FCW: Slippery road detected! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, road_condition = SLIPPERY\n// Expected Output: \"FCW: Slippery road detected! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if there is a vehicle in the blind spot.",
      "input": "Car Speed: 60 km/h, Blind Spot Detected: True, Distance: 2 meters",
      "output": "#include <blind_spot_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float BLIND_SPOT_ALERT_DISTANCE = 3.0f; // Minimum distance for blind spot alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool blind_spot_detected = getBlindSpotStatus(); // Check if vehicle in blind spot\n    float blind_spot_distance = getBlindSpotDistance(); // Distance to object in blind spot\n\n    if (blind_spot_detected && blind_spot_distance < BLIND_SPOT_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle detected in the blind spot! Check before changing lanes.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, blind_spot_detected = true, blind_spot_distance = 2 m\n// Expected Output: \"FCW: Vehicle detected in the blind spot! Check before changing lanes.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when approaching a road construction zone at high speed.",
      "input": "Car Speed: 65 km/h, Construction Zone Detected: True, Distance: 200 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float CONSTRUCTION_ZONE_SPEED_THRESHOLD = 50.0f; // Speed threshold for construction zone warning\nconst float CONSTRUCTION_ZONE_ALERT_DISTANCE = 100.0f; // Distance threshold for construction zone alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool construction_zone_detected = getRoadType() == CONSTRUCTION_ZONE; // Check if construction zone detected\n    float construction_zone_distance = getRoadDistance(); // Distance to construction zone\n\n    if (construction_zone_detected && car_speed > CONSTRUCTION_ZONE_SPEED_THRESHOLD && construction_zone_distance < CONSTRUCTION_ZONE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Approaching construction zone at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 65 km/h, construction_zone_detected = true, construction_zone_distance = 200 m\n// Expected Output: \"FCW: Approaching construction zone at high speed! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are driving in the wrong direction on a one-way street.",
      "input": "Car Speed: 50 km/h, Direction: Wrong Way, Distance: 0 meters",
      "output": "#include <direction_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst int WRONG_WAY_ALERT_SPEED = 40; // Speed threshold for wrong way alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool wrong_way = getDirectionStatus() == WRONG_WAY; // Check if the car is driving in the wrong direction\n\n    if (wrong_way && car_speed > WRONG_WAY_ALERT_SPEED) {\n        std::cout << \"FCW: Wrong way detected! Turn around immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, wrong_way = true\n// Expected Output: \"FCW: Wrong way detected! Turn around immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are leaving the lane without signaling.",
      "input": "Car Speed: 55 km/h, Lane Departure Detected: True, Signal: Not On",
      "output": "#include <lane_sensor.hpp>\n#include <signal_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float LANE_DEPARTURE_ALERT_SPEED = 40.0f; // Speed threshold for lane departure warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool lane_departure_detected = getLaneDepartureStatus(); // Check if lane departure detected\n    bool signal_on = getSignalStatus() == SIGNAL_ON; // Check if signal is on\n\n    if (lane_departure_detected && !signal_on && car_speed > LANE_DEPARTURE_ALERT_SPEED) {\n        std::cout << \"FCW: Lane departure detected without signal! Correct your course.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 55 km/h, lane_departure_detected = true, signal_on = false\n// Expected Output: \"FCW: Lane departure detected without signal! Correct your course.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are over-speeding in a residential area.",
      "input": "Car Speed: 40 km/h, Zone Type: Residential, Speed Limit: 30 km/h",
      "output": "#include <zone_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float RESIDENTIAL_ZONE_SPEED_LIMIT = 30.0f; // Speed limit for residential area\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool residential_zone = getZoneType() == RESIDENTIAL; // Check if the car is in a residential area\n\n    if (residential_zone && car_speed > RESIDENTIAL_ZONE_SPEED_LIMIT) {\n        std::cout << \"FCW: Over-speeding in residential area! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, zone_type = Residential, speed_limit = 30 km/h\n// Expected Output: \"FCW: Over-speeding in residential area! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an emergency vehicle is approaching with sirens on.",
      "input": "Car Speed: 70 km/h, Emergency Vehicle Detected: True, Siren Status: On, Distance: 50 meters",
      "output": "#include <emergency_vehicle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float EMERGENCY_VEHICLE_ALERT_DISTANCE = 100.0f; // Distance threshold for emergency vehicle warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool emergency_vehicle_detected = getEmergencyVehicleStatus(); // Check if emergency vehicle detected\n    bool siren_on = getSirenStatus(); // Check if siren is on\n\n    if (emergency_vehicle_detected && siren_on && car_speed > EMERGENCY_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Emergency vehicle approaching! Yield and slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, emergency_vehicle_detected = true, siren_on = true, emergency_vehicle_distance = 50 m\n// Expected Output: \"FCW: Emergency vehicle approaching! Yield and slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when approaching a speed bump at high speed.",
      "input": "Car Speed: 45 km/h, Speed Bump Detected: True, Distance: 30 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_BUMP_ALERT_SPEED = 20.0f; // Speed threshold for speed bump warning\nconst float SPEED_BUMP_ALERT_DISTANCE = 40.0f; // Distance threshold for speed bump warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool speed_bump_detected = getRoadFeature() == SPEED_BUMP; // Check if speed bump detected\n    float speed_bump_distance = getRoadFeatureDistance(); // Distance to the speed bump\n\n    if (speed_bump_detected && car_speed > SPEED_BUMP_ALERT_SPEED && speed_bump_distance < SPEED_BUMP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Approaching speed bump at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, speed_bump_detected = true, speed_bump_distance = 30 m\n// Expected Output: \"FCW: Approaching speed bump at high speed! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when approaching a crosswalk with pedestrians on it.",
      "input": "Car Speed: 60 km/h, Pedestrians Detected: True, Distance: 15 meters",
      "output": "#include <crosswalk_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float CROSSWALK_ALERT_SPEED = 50.0f; // Speed threshold for crosswalk alert\nconst float CROSSWALK_ALERT_DISTANCE = 20.0f; // Distance threshold for crosswalk alert\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool pedestrians_detected = getPedestrianStatus(); // Check if pedestrians detected\n    float crosswalk_distance = getCrosswalkDistance(); // Distance to crosswalk\n\n    if (pedestrians_detected && car_speed > CROSSWALK_ALERT_SPEED && crosswalk_distance < CROSS\n\nWALK_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrians ahead at crosswalk! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, pedestrians_detected = true, crosswalk_distance = 15 m\n// Expected Output: \"FCW: Pedestrians ahead at crosswalk! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver of a sharp turn ahead at high speed.",
      "input": "Car Speed: 80 km/h, Sharp Turn Detected: True, Distance: 100 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SHARP_TURN_SPEED_THRESHOLD = 60.0f; // Speed threshold for sharp turn warning\nconst float SHARP_TURN_ALERT_DISTANCE = 150.0f; // Distance threshold for sharp turn warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool sharp_turn_detected = getRoadFeature() == SHARP_TURN; // Check if sharp turn detected\n    float sharp_turn_distance = getRoadFeatureDistance(); // Distance to the sharp turn\n\n    if (sharp_turn_detected && car_speed > SHARP_TURN_SPEED_THRESHOLD && sharp_turn_distance < SHARP_TURN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Sharp turn ahead! Slow down and prepare.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, sharp_turn_detected = true, sharp_turn_distance = 100 m\n// Expected Output: \"FCW: Sharp turn ahead! Slow down and prepare.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are too close to the car ahead.",
      "input": "Car Speed: 50 km/h, Distance to Vehicle Ahead: 5 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float TAILGATING_ALERT_DISTANCE = 8.0f; // Minimum distance for tailgating warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float distance_to_ahead_vehicle = getDistanceToObject(); // Distance to the vehicle ahead\n\n    if (distance_to_ahead_vehicle < TAILGATING_ALERT_DISTANCE) {\n        std::cout << \"FCW: You are too close to the car ahead! Increase the distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, distance_to_ahead_vehicle = 5 m\n// Expected Output: \"FCW: You are too close to the car ahead! Increase the distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if there is an obstacle in front that could cause a collision.",
      "input": "Car Speed: 30 km/h, Obstacle Detected: True, Distance: 10 meters",
      "output": "#include <obstacle_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float OBSTACLE_ALERT_DISTANCE = 10.0f; // Minimum distance for obstacle warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool obstacle_detected = getObstacleStatus(); // Check if obstacle detected\n    float obstacle_distance = getObstacleDistance(); // Distance to the obstacle\n\n    if (obstacle_detected && obstacle_distance < OBSTACLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Obstacle detected ahead! Stop or steer clear.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 30 km/h, obstacle_detected = true, obstacle_distance = 10 m\n// Expected Output: \"FCW: Obstacle detected ahead! Stop or steer clear.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected in the vehicle's path.",
      "input": "Car Speed: 40 km/h, Pedestrian Detected: True, Distance: 12 meters",
      "output": "#include <pedestrian_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 15.0f; // Minimum distance to pedestrian for warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool pedestrian_detected = getPedestrianStatus(); // Check if pedestrian detected\n    float pedestrian_distance = getPedestrianDistance(); // Distance to the pedestrian\n\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian in the path! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, pedestrian_detected = true, pedestrian_distance = 12 m\n// Expected Output: \"FCW: Pedestrian in the path! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle ahead suddenly slows down.",
      "input": "Car Speed: 60 km/h, Leading Vehicle Speed: 20 km/h, Distance: 30 meters",
      "output": "#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SUDDEN_SLOWDOWN_THRESHOLD = 30.0f; // Speed difference threshold for slowdown warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float leading_vehicle_speed = getLeadingVehicleSpeed(); // Speed of the leading vehicle\n    float distance_to_lead_vehicle = getDistanceToLeadingVehicle(); // Distance to leading vehicle\n\n    if (car_speed - leading_vehicle_speed > SUDDEN_SLOWDOWN_THRESHOLD && distance_to_lead_vehicle < SUDDEN_SLOWDOWN_THRESHOLD) {\n        std::cout << \"FCW: Sudden slowdown detected ahead! Prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, leading_vehicle_speed = 20 km/h, distance_to_lead_vehicle = 30 m\n// Expected Output: \"FCW: Sudden slowdown detected ahead! Prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if there is a stationary object ahead and a collision is imminent.",
      "input": "Car Speed: 20 km/h, Stationary Object Detected: True, Distance: 5 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float COLLISION_ALERT_DISTANCE = 10.0f; // Minimum distance to stationary object for collision warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool stationary_object_detected = getObjectStatus() == STATIONARY_OBJECT; // Check if stationary object detected\n    float object_distance = getObjectDistance(); // Distance to the object\n\n    if (stationary_object_detected && object_distance < COLLISION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Imminent collision with stationary object! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 20 km/h, stationary_object_detected = true, object_distance = 5 m\n// Expected Output: \"FCW: Imminent collision with stationary object! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are approaching a red traffic light at high speed.",
      "input": "Car Speed: 50 km/h, Traffic Light Status: Red, Distance: 150 meters",
      "output": "#include <traffic_light_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float RED_LIGHT_SPEED_THRESHOLD = 40.0f; // Speed threshold for red light warning\nconst float RED_LIGHT_ALERT_DISTANCE = 100.0f; // Distance threshold for red light warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool red_light_detected = getTrafficLightStatus() == RED; // Check if red light is detected\n\n    float distance_to_traffic_light = getTrafficLightDistance(); // Distance to the traffic light\n\n    if (red_light_detected && car_speed > RED_LIGHT_SPEED_THRESHOLD && distance_to_traffic_light < RED_LIGHT_ALERT_DISTANCE) {\n        std::cout << \"FCW: Red light ahead! Slow down and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, red_light_detected = true, traffic_light_distance = 150 m\n// Expected Output: \"FCW: Red light ahead! Slow down and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver when they are approaching a highway exit ramp at high speed.",
      "input": "Car Speed: 80 km/h, Exit Ramp Detected: True, Distance: 200 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float EXIT_RAMP_SPEED_THRESHOLD = 60.0f; // Speed threshold for highway exit ramp warning\nconst float EXIT_RAMP_ALERT_DISTANCE = 250.0f; // Distance threshold for exit ramp warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool exit_ramp_detected = getRoadFeature() == EXIT_RAMP; // Check if exit ramp is detected\n\n    float exit_ramp_distance = getRoadFeatureDistance(); // Distance to exit ramp\n\n    if (exit_ramp_detected && car_speed > EXIT_RAMP_SPEED_THRESHOLD && exit_ramp_distance < EXIT_RAMP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Approaching exit ramp at high speed! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, exit_ramp_detected = true, exit_ramp_distance = 200 m\n// Expected Output: \"FCW: Approaching exit ramp at high speed! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are approaching a U-turn ahead at high speed.",
      "input": "Car Speed: 40 km/h, U-Turn Detected: True, Distance: 50 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float U_TURN_ALERT_SPEED = 30.0f; // Speed threshold for U-turn warning\nconst float U_TURN_ALERT_DISTANCE = 60.0f; // Distance threshold for U-turn warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool u_turn_detected = getRoadFeature() == U_TURN; // Check if U-turn detected\n\n    float u_turn_distance = getRoadFeatureDistance(); // Distance to U-turn\n\n    if (u_turn_detected && car_speed > U_TURN_ALERT_SPEED && u_turn_distance < U_TURN_ALERT_DISTANCE) {\n        std::cout << \"FCW: U-turn ahead! Slow down and prepare.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, u_turn_detected = true, u_turn_distance = 50 m\n// Expected Output: \"FCW: U-turn ahead! Slow down and prepare.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the vehicle is too close to the car ahead, risking a rear-end collision.",
      "input": "Car Speed: 25 km/h, Distance to Vehicle Ahead: 3 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float REAR_END_COLLISION_THRESHOLD = 5.0f; // Minimum distance for rear-end collision warning\n\nint main() {\n    float car_speed =\n\n getCarSpeed(); // Retrieve the car's speed\n    float distance_to_ahead_vehicle = getDistanceToObject(); // Distance to the vehicle ahead\n\n    if (distance_to_ahead_vehicle < REAR_END_COLLISION_THRESHOLD) {\n        std::cout << \"FCW: Rear-end collision risk! Increase distance immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 25 km/h, distance_to_ahead_vehicle = 3 m\n// Expected Output: \"FCW: Rear-end collision risk! Increase distance immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a speed bump is detected ahead and the vehicle is going too fast.",
      "input": "Car Speed: 45 km/h, Speed Bump Detected: True, Distance: 30 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SPEED_BUMP_SPEED_THRESHOLD = 20.0f; // Speed threshold for speed bump warning\nconst float SPEED_BUMP_ALERT_DISTANCE = 50.0f; // Distance threshold for speed bump warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool speed_bump_detected = getRoadFeature() == SPEED_BUMP; // Check if speed bump is detected\n\n    float speed_bump_distance = getRoadFeatureDistance(); // Distance to speed bump\n\n    if (speed_bump_detected && car_speed > SPEED_BUMP_SPEED_THRESHOLD && speed_bump_distance < SPEED_BUMP_ALERT_DISTANCE) {\n        std::cout << \"FCW: Speed bump ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, speed_bump_detected = true, speed_bump_distance = 30 m\n// Expected Output: \"FCW: Speed bump ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are approaching a T-junction ahead at high speed.",
      "input": "Car Speed: 60 km/h, T-Junction Detected: True, Distance: 100 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float T_JUNCTION_ALERT_SPEED = 50.0f; // Speed threshold for T-junction warning\nconst float T_JUNCTION_ALERT_DISTANCE = 150.0f; // Distance threshold for T-junction warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool t_junction_detected = getRoadFeature() == T_JUNCTION; // Check if T-junction is detected\n\n    float t_junction_distance = getRoadFeatureDistance(); // Distance to T-junction\n\n    if (t_junction_detected && car_speed > T_JUNCTION_ALERT_SPEED && t_junction_distance < T_JUNCTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: T-junction ahead! Slow down and prepare to turn.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, t_junction_detected = true, t_junction_distance = 100 m\n// Expected Output: \"FCW: T-junction ahead! Slow down and prepare to turn.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if foggy conditions ahead require slowing down.",
      "input": "Car Speed: 40 km/h, Fog Detected: True, Visibility: 50 meters",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float FOG_ALERT_THRESHOLD = 100.0f; // Visibility threshold for fog warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool fog_detected = getWeatherStatus() == FOG; // Check if fog is detected\n\n    float visibility = getVisibility(); // Visibility due to fog\n\n    if (fog_detected && visibility < FOG_ALERT_THRESHOLD) {\n        std::cout << \"FCW: Foggy conditions ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, fog_detected = true, visibility = 50 m\n// Expected Output: \"FCW: Foggy conditions ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a motorcycle is detected in the lane ahead at a close distance.",
      "input": "Car Speed: 60 km/h, Motorcycle Detected: True, Distance: 10 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float MOTORCYCLE_ALERT_DISTANCE = 15.0f; // Minimum distance for motorcycle warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool motorcycle_detected = getObjectStatus() == MOTORCYCLE; // Check if motorcycle detected\n    float motorcycle_distance = getObjectDistance(); // Distance to the motorcycle\n\n    if (motorcycle_detected && motorcycle_distance < MOTORCYCLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Motorcycle ahead! Slow down and increase distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, motorcycle_detected = true, motorcycle_distance = 10 m\n// Expected Output: \"FCW: Motorcycle ahead! Slow down and increase distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an obstruction is detected in the roadway ahead.",
      "input": "Car Speed: 50 km/h, Obstruction Detected: True, Distance: 8 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float OBSTRUCTION_ALERT_DISTANCE = 10.0f; // Minimum distance to obstruction for warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool obstruction_detected = getObjectStatus() == OBSTRUCTION; // Check if obstruction detected\n    float obstruction_distance = getObjectDistance(); // Distance to the obstruction\n\n    if (obstruction_detected && obstruction_distance < OBSTRUCTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Obstruction detected ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, obstruction_detected = true, obstruction_distance = 8 m\n// Expected Output: \"FCW: Obstruction detected ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are tailgating the vehicle ahead at a close distance.",
      "input": "Car Speed: 70 km/h, Distance to Leading Vehicle: 2 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float TAILGATING_THRESHOLD = 3.0f; // Minimum distance for tailgating warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float distance_to_lead_vehicle = getDistanceToObject(); // Distance to the vehicle ahead\n\n    if (distance_to_lead_vehicle < TAILGATING_THRESHOLD) {\n        std::cout << \"FCW: Tailgating detected! Increase following distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, distance_to_lead_vehicle = 2 m\n// Expected Output: \"FCW: Tailgating detected! Increase following distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are approaching a sharp curve at high speed.",
      "input": "Car Speed: 80 km/h, Sharp Curve Detected: True, Distance: 100 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float SHARP_CURVE_ALERT_SPEED = 60.0f; // Speed threshold for sharp curve warning\nconst float SHARP_CURVE_ALERT_DISTANCE = 150.0f; // Distance threshold for sharp curve warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool sharp_curve_detected = getRoadFeature() == SHARP_CURVE; // Check if sharp curve is detected\n\n    float sharp_curve_distance = getRoadFeatureDistance(); // Distance to sharp curve\n\n    if (sharp_curve_detected && car_speed > SHARP_CURVE_ALERT_SPEED && sharp_curve_distance < SHARP_CURVE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Sharp curve ahead! Slow down and prepare.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, sharp_curve_detected = true, sharp_curve_distance = 100 m\n// Expected Output: \"FCW: Sharp curve ahead! Slow down and prepare.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are driving in the wrong direction on a one-way street.",
      "input": "Car Speed: 30 km/h, Wrong Way Detected: True",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float WRONG_WAY_ALERT_SPEED = 30.0f; // Speed threshold for wrong way warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool wrong_way_detected = getRoadFeature() == WRONG_WAY; // Check if wrong way is detected\n\n    if (wrong_way_detected && car_speed > WRONG_WAY_ALERT_SPEED) {\n        std::cout << \"FCW: Wrong way detected! Reverse immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 30 km/h, wrong_way_detected = true\n// Expected Output: \"FCW: Wrong way detected! Reverse immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the road is slippery and they are driving too fast.",
      "input": "Car Speed: 50 km/h, Slippery Road Detected: True, Road Condition: Wet",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float SLIPPERY_ROAD_ALERT_SPEED = 40.0f; // Speed threshold for slippery road warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool slippery_road_detected = getRoadCondition() == SLIPPERY; // Check if slippery road is detected\n\n    if (slippery_road_detected && car_speed > SLIPPERY_ROAD_ALERT_SPEED) {\n        std::cout << \"FCW: Slippery road ahead! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, slippery_road_detected = true, road_condition = wet\n// Expected Output: \"FCW: Slippery road ahead! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are approaching an intersection at high speed.",
      "input": "Car Speed: 70 km/h, Intersection Detected: True, Distance: 150 meters",
      "output": "#include <road_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_SPEED = 60.0f; // Speed threshold for intersection warning\nconst float INTERSECTION_ALERT_DISTANCE = 200.0f; // Distance threshold for intersection warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool intersection_detected = getRoadFeature() == INTERSECTION; // Check if intersection is detected\n\n    float intersection_distance = getRoadFeatureDistance(); // Distance to intersection\n\n    if (intersection_detected && car_speed > INTERSECTION_ALERT_SPEED && intersection_distance < INTERSECTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Intersection ahead! Slow down and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 70 km/h, intersection_detected = true, intersection_distance = 150 m\n// Expected Output: \"FCW: Intersection ahead! Slow down and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C\\n\\n++ code to warn the driver if a bus is in their lane ahead and they are approaching too quickly.",
      "input": "Car Speed: 40 km/h, Bus Detected: True, Distance: 20 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float BUS_ALERT_DISTANCE = 25.0f; // Minimum distance for bus warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool bus_detected = getObjectStatus() == BUS; // Check if bus detected\n    float bus_distance = getObjectDistance(); // Distance to the bus\n\n    if (bus_detected && bus_distance < BUS_ALERT_DISTANCE) {\n        std::cout << \"FCW: Bus ahead! Slow down and maintain distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 40 km/h, bus_detected = true, bus_distance = 20 m\n// Expected Output: \"FCW: Bus ahead! Slow down and maintain distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected crossing the road ahead.",
      "input": "Car Speed: 30 km/h, Pedestrian Detected: True, Distance: 5 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 7.0f; // Minimum distance for pedestrian warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool pedestrian_detected = getObjectStatus() == PEDESTRIAN; // Check if pedestrian detected\n    float pedestrian_distance = getObjectDistance(); // Distance to the pedestrian\n\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 30 km/h, pedestrian_detected = true, pedestrian_distance = 5 m\n// Expected Output: \"FCW: Pedestrian ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a red light is detected ahead and they are approaching too quickly.",
      "input": "Car Speed: 50 km/h, Red Light Detected: True, Distance: 80 meters",
      "output": "#include <traffic_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float RED_LIGHT_ALERT_SPEED = 40.0f; // Speed threshold for red light warning\nconst float RED_LIGHT_ALERT_DISTANCE = 100.0f; // Distance threshold for red light warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool red_light_detected = getTrafficLightStatus() == RED; // Check if red light is detected\n\n    float red_light_distance = getTrafficLightDistance(); // Distance to red light\n\n    if (red_light_detected && car_speed > RED_LIGHT_ALERT_SPEED && red_light_distance < RED_LIGHT_ALERT_DISTANCE) {\n        std::cout << \"FCW: Red light ahead! Slow down and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, red_light_detected = true, red_light_distance = 80 m\n// Expected Output: \"FCW: Red light ahead! Slow down and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a pedestrian is detected at a crosswalk ahead.",
      "input": "Car Speed: 45 km/h, Pedestrian Detected: True, Distance: 12 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float PEDESTRIAN_ALERT_DISTANCE = 15.0f; // Minimum distance for pedestrian warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool pedestrian_detected = getObjectStatus() == PEDESTRIAN; // Check if pedestrian detected\n    float pedestrian_distance = getObjectDistance(); // Distance to the pedestrian\n\n    if (pedestrian_detected && pedestrian_distance < PEDESTRIAN_ALERT_DISTANCE) {\n        std::cout << \"FCW: Pedestrian ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 45 km/h, pedestrian_detected = true, pedestrian_distance = 12 m\n// Expected Output: \"FCW: Pedestrian ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a child is detected in the road ahead.",
      "input": "Car Speed: 30 km/h, Child Detected: True, Distance: 7 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float CHILD_ALERT_DISTANCE = 10.0f; // Minimum distance for child warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool child_detected = getObjectStatus() == CHILD; // Check if child detected\n    float child_distance = getObjectDistance(); // Distance to the child\n\n    if (child_detected && child_distance < CHILD_ALERT_DISTANCE) {\n        std::cout << \"FCW: Child detected ahead! Stop immediately.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 30 km/h, child_detected = true, child_distance = 7 m\n// Expected Output: \"FCW: Child detected ahead! Stop immediately.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if an animal is detected in the road ahead.",
      "input": "Car Speed: 60 km/h, Animal Detected: True, Distance: 15 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float ANIMAL_ALERT_DISTANCE = 20.0f; // Minimum distance for animal warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool animal_detected = getObjectStatus() == ANIMAL; // Check if animal detected\n    float animal_distance = getObjectDistance(); // Distance to the animal\n\n    if (animal_detected && animal_distance < ANIMAL_ALERT_DISTANCE) {\n        std::cout << \"FCW: Animal ahead! Slow down and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 60 km/h, animal_detected = true, animal_distance = 15 m\n// Expected Output: \"FCW: Animal ahead! Slow down and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle ahead is suddenly braking.",
      "input": "Car Speed: 50 km/h, Lead Vehicle Braking: True, Distance: 20 meters",
      "output": "#include <braking_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float BRAKING_ALERT_DISTANCE = 30.0f; // Minimum distance for braking warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool lead_vehicle_braking = isLeadVehicleBraking(); // Check if lead vehicle is braking\n    float lead_vehicle_distance = getDistanceToLeadVehicle(); // Distance to the lead vehicle\n\n    if (lead_vehicle_braking && lead_vehicle_distance < BRAKING_ALERT_DISTANCE) {\n        std::cout << \"FCW: Lead vehicle is braking suddenly! Slow down.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, lead_vehicle_braking = true, lead_vehicle_distance = 20 m\n// Expected Output: \"FCW: Lead vehicle is braking suddenly! Slow down.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle is changing lanes into their path.",
      "input": "Car Speed: 80 km/h, Vehicle Lane Change Detected: True, Distance: 50 meters",
      "output": "#include <object_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <lane_sensor.hpp>\n#include <iostream>\n\nconst float LANE_CHANGE_ALERT_DISTANCE = 60.0f; // Minimum distance for lane change warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool lane_change_detected = isVehicleChangingLane(); // Check if vehicle is changing lane\n    float lane_change_distance = getObjectDistance(); // Distance to the vehicle changing lane\n\n    if (lane_change_detected && lane_change_distance < LANE_CHANGE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Vehicle changing lanes ahead! Slow down and be cautious.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 80 km/h, lane_change_detected = true, lane_change_distance = 50 m\n// Expected Output: \"FCW: Vehicle changing lanes ahead! Slow down and be cautious.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if a vehicle is too close in front of them at high speed.",
      "input": "Car Speed: 100 km/h, Distance to Lead Vehicle: 10 meters",
      "output": "#include <distance_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float CLOSE_VEHICLE_ALERT_DISTANCE = 15.0f; // Minimum distance for close vehicle warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    float distance_to_lead_vehicle = getDistanceToObject(); // Distance to the vehicle ahead\n\n    if (distance_to_lead_vehicle < CLOSE_VEHICLE_ALERT_DISTANCE) {\n        std::cout << \"FCW: Too close to the vehicle ahead! Increase following distance.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 100 km/h, distance_to_lead_vehicle = 10 m\n// Expected Output: \"FCW: Too close to the vehicle ahead! Increase following distance.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if the road is wet and they are driving at a high speed.",
      "input": "Car Speed: 90 km/h, Road Condition: Wet",
      "output": "#include <weather_sensor.hpp>\n#include <speed_sensor.hpp>\n#include <iostream>\n\nconst float WET_ROAD_ALERT_SPEED = 60.0f; // Speed threshold for wet road warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool wet_road_detected = getWeatherCondition() == WET; // Check if wet road is detected\n\n    if (wet_road_detected && car_speed > WET_ROAD_ALERT_SPEED) {\n        std::cout << \"FCW: Wet road detected! Slow down for safety.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 90 km/h, wet_road_detected = true\n// Expected Output: \"FCW: Wet road detected! Slow down for safety.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they exceed the speed limit in an area.",
      "input": "Car Speed: 120 km/h, Speed Limit: 100 km/h",
      "output": "#include <speed_sensor.hpp>\n#include <iostream>\nn\nconst float SPEED_LIMIT = 100.0f; // Speed limit for the area\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n\n    if (car_speed > SPEED_LIMIT) {\n        std::cout << \"FCW: Speeding! Slow down to the speed limit.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 120 km/h\n// Expected Output: \"FCW: Speeding! Slow down to the speed limit.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are approaching an intersection too quickly.",
      "input": "Car Speed: 50 km/h, Intersection Ahead: True, Distance: 100 meters",
      "output": "#include <speed_sensor.hpp>\n#include <traffic_sensor.hpp>\n#include <distance_sensor.hpp>\n#include <iostream>\n\nconst float INTERSECTION_ALERT_SPEED = 40.0f; // Speed threshold for intersection warning\nconst float INTERSECTION_ALERT_DISTANCE = 150.0f; // Distance threshold for intersection warning\n\nint main() {\n    float car_speed = getCarSpeed(); // Retrieve the car's speed\n    bool intersection_ahead = isIntersectionAhead(); // Check if intersection is ahead\n\n    float intersection_distance = getIntersectionDistance(); // Distance to intersection\n\n    if (intersection_ahead && car_speed > INTERSECTION_ALERT_SPEED && intersection_distance < INTERSECTION_ALERT_DISTANCE) {\n        std::cout << \"FCW: Intersection ahead! Slow down and prepare to stop.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: car_speed = 50 km/h, intersection_ahead = true, intersection_distance = 100 m\n// Expected Output: \"FCW: Intersection ahead! Slow down and prepare to stop.\""
    },
    {
      "instruction": "Write MISRA C++ code to warn the driver if they are showing signs of drowsiness while driving.",
      "input": "Driver Fatigue Detected: True",
      "output": "#include <driver_monitor.hpp>\n#include <iostream>\n\nconst float DROWSY_DRIVER_ALERT_THRESHOLD = 80.0f; // Fatigue threshold for alert\n\nint main() {\n    bool driver_fatigue_detected = isDriverFatigued(); // Check if the driver is showing signs of fatigue\n\n    if (driver_fatigue_detected) {\n        std::cout << \"FCW: Driver fatigue detected! Take a break.\" << std::endl;\n    }\n\n    return 0;\n}\n\n// Test Case\n// Input: driver_fatigue_detected = true\n// Expected Output: \"FCW: Driver fatigue detected! Take a break.\""
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning system using radar data. The system should analyze the relative velocity and distance between the vehicle and an object ahead, and issue a warning if the relative velocity is high and the distance is below a safety threshold.",
      "input": "Ensure proper error handling for radar data, prevent using namespaces, and provide comments for every critical operation.",
      "output": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stdexcept>\n\nconst float safe_distance = 10.0f; // meters\nconst float high_velocity_threshold = 30.0f; // m/s\n\n// Struct to hold radar data\nstruct RadarData {\n    float distance; // Distance to object in meters\n    float velocity; // Relative velocity in m/s\n};\n\n// Function to process radar data and trigger FCW warning\nvoid process_radar_data(const RadarData& data) {\n    if (data.distance < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n    if (data.velocity < 0) {\n        throw std::invalid_argument(\"Velocity cannot be negative\");\n    }\n\n    if (data.distance < safe_distance && data.velocity > high_velocity_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    RadarData data = {8.0f, 35.0f};  // Example data\n    try {\n        process_radar_data(data);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write C++ code for an FCW system based on camera data from a car. The system should estimate the relative speed and distance to the leading vehicle, triggering a warning if the vehicle is closing in too quickly.",
      "input": "Use only explicit type conversions, handle camera data correctly, and ensure the code is MISRA compliant.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n\nconst float critical_distance = 8.0f; // meters\nconst float speed_threshold = 25.0f; // km/h\n\n// Function to compute the speed based on image processing\nfloat compute_relative_speed(const cv::Point& prev_position, const cv::Point& current_position, float time_interval) {\n    float distance = std::sqrt(std::pow(current_position.x - prev_position.x, 2) + std::pow(current_position.y - prev_position.y, 2));\n    return distance / time_interval; // speed in m/s\n}\n\n// Function to trigger FCW if critical conditions are met\nvoid process_camera_data(const cv::Mat& image) {\n    // Assuming a method to detect the leading vehicle\n    cv::Point prev_position(100, 200);  // Example previous position\n    cv::Point current_position(120, 210);  // Example current position\n    float time_interval = 1.0f;  // Example time interval in seconds\n\n    float relative_speed = compute_relative_speed(prev_position, current_position, time_interval);\n\n    if (relative_speed > speed_threshold && relative_speed < critical_distance) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n}\n\nint main() {\n    cv::Mat frame;\n    // Assume frame is captured from camera\n    process_camera_data(frame);\n    return 0;\n}"
    },
    {
      "instruction": "Create C++ code for a Forward Collision Warning (FCW) system using Lidar data to estimate the distance to obstacles in the vehicle's path. If the obstacle is too close, the system should trigger an alert.",
      "input": "Ensure MISRA compliance, use proper error handling for Lidar sensor data, and include detailed comments.",
      "output": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nconst float danger_zone = 5.0f; // meters\n\n// Function to process Lidar data and trigger FCW if necessary\nvoid process_lidar_data(float distance_to_obstacle) {\n    if (distance_to_obstacle < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n\n    if (distance_to_obstacle < danger_zone) {\n        std::cout << \"WARNING: OBSTACLE AHEAD!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 4.5f;  // Example Lidar data\n    try {\n        process_lidar_data(lidar_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Develop C++ code for a Forward Collision Warning system based on ultrasonic sensors. The system should analyze the distance between the car and obstacles and activate the warning if the car is too close to an object.",
      "input": "Apply explicit error handling for sensor readings and ensure proper type conversion for distances.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float safe_distance = 2.0f; // meters\n\n// Function to process ultrasonic sensor data\nvoid process_ultrasonic_sensor_data(float distance_to_object) {\n    if (distance_to_object < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n\n    if (distance_to_object < safe_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_data = 1.5f;  // Example data\n    try {\n        process_ultrasonic_sensor_data(ultrasonic_data);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA-compliant C++ code for an FCW system using GPS data to determine the vehicle's speed and proximity to other objects on the road. If the vehicle is approaching an object too quickly, a warning should be issued.",
      "input": "Ensure that GPS data is processed with appropriate error checks and the code complies with MISRA standards.",
      "output": "#include <iostream>\n#include <stdexcept>\n#include <cmath>\n\nconst float critical_speed = 30.0f; // km/h\nconst float proximity_threshold = 5.0f; // meters\n\n// Function to process GPS data and issue an FCW warning if needed\nvoid process_gps_data(float vehicle_speed, float distance_to_object) {\n    if (vehicle_speed < 0 || distance_to_object < 0) {\n        throw std::invalid_argument(\"Speed and distance cannot be negative\");\n    }\n\n    if (vehicle_speed > critical_speed && distance_to_object < proximity_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float gps_speed = 35.0f;  // Example GPS speed in km/h\n    float gps_distance = 4.0f;  // Example GPS distance to object in meters\n    try {\n        process_gps_data(gps_speed, gps_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate C++ code for FCW using data from a combination of radar and camera sensors. The system should estimate the relative distance and speed, triggering an alert if the vehicle is approaching another object at a dangerous rate.",
      "input": "Ensure that sensor fusion is handled properly, avoid using 'using namespace', and ensure proper type conversions.",
      "output": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nconst float collision_threshold = 8.0f; // meters\nconst float speed_limit = 20.0f; // m/s\n\n// Function to compute relative speed and distance using sensor fusion\nvoid process_sensor_data(float radar_distance, float camera_speed) {\n    if (radar_distance < 0 || camera_speed < 0) {\n        throw std::invalid_argument(\"Distance and speed cannot be negative\");\n    }\n\n    if (radar_distance < collision_threshold && camera_speed > speed_limit) {\n        std::cout << \"WARNING: DANGER AHEAD!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.5f; \n\n // Example radar data\n    float camera_speed = 22.0f;  // Example camera speed data\n    try {\n        process_sensor_data(radar_distance, camera_speed);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create C++ code for a Forward Collision Warning system that processes sensor data from Lidar, radar, and camera. The system should trigger an alert if the vehicle is approaching another vehicle too quickly, considering both speed and distance.",
      "input": "Use proper exception handling and avoid using magic numbers.",
      "output": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nconst float safe_distance = 10.0f; // meters\nconst float speed_limit = 30.0f; // km/h\n\n// Function to compute relative speed and trigger FCW\nvoid process_sensors(float lidar_distance, float radar_speed, float camera_distance) {\n    if (lidar_distance < 0 || radar_speed < 0 || camera_distance < 0) {\n        throw std::invalid_argument(\"Sensor data cannot be negative\");\n    }\n\n    if (camera_distance < safe_distance && radar_speed > speed_limit) {\n        std::cout << \"WARNING: COLLISION WARNING!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 8.5f;  // Example Lidar data\n    float radar_speed = 32.0f;  // Example radar speed in km/h\n    float camera_distance = 7.0f;  // Example camera distance in meters\n    try {\n        process_sensors(lidar_distance, radar_speed, camera_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write C++ code for an FCW system using ultrasonic sensors. The system should analyze the distance to obstacles, and trigger a warning if the vehicle is too close to an object.",
      "input": "Include proper exception handling for sensor errors and avoid unsafe operations.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float warning_distance = 1.5f; // meters\n\n// Function to trigger FCW based on ultrasonic sensor data\nvoid process_ultrasonic_data(float distance_to_object) {\n    if (distance_to_object < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n\n    if (distance_to_object < warning_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_data = 1.2f;  // Example data\n    try {\n        process_ultrasonic_data(ultrasonic_data);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create C++ code for FCW based on GPS and radar data. The system should trigger a warning if the vehicle is moving too fast while being too close to an obstacle.",
      "input": "Ensure proper error handling for GPS and radar inputs, and avoid reliance on implicit type conversions.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float max_speed = 25.0f; // m/s\nconst float close_distance = 10.0f; // meters\n\n// Function to analyze GPS and radar data for FCW\nvoid process_gps_radar_data(float gps_speed, float radar_distance) {\n    if (gps_speed < 0 || radar_distance < 0) {\n        throw std::invalid_argument(\"Speed and distance cannot be negative\");\n    }\n\n    if (gps_speed > max_speed && radar_distance < close_distance) {\n        std::cout << \"WARNING: DANGER AHEAD!\" << std::endl;\n    }\n}\n\nint main() {\n    float gps_speed = 27.0f;  // Example GPS speed in m/s\n    float radar_distance = 8.0f;  // Example radar distance in meters\n    try {\n        process_gps_radar_data(gps_speed, radar_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate C++ code for an FCW system using data from both ultrasonic and radar sensors. The system should trigger a warning if the distance to an object is too close, considering both sensors' data.",
      "input": "Ensure that the data is correctly processed and no assumptions are made regarding the sensor's behavior.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float close_distance = 2.0f; // meters\n\n// Function to process ultrasonic and radar data\nvoid process_sensors(float ultrasonic_data, float radar_data) {\n    if (ultrasonic_data < 0 || radar_data < 0) {\n        throw std::invalid_argument(\"Sensor data cannot be negative\");\n    }\n\n    if (ultrasonic_data < close_distance && radar_data < close_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_sensor_data = 1.5f;  // Example ultrasonic data\n    float radar_sensor_data = 1.2f;  // Example radar data\n    try {\n        process_sensors(ultrasonic_sensor_data, radar_sensor_data);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write C++ code for a Forward Collision Warning system using sensor fusion from radar and ultrasonic sensors. The system should calculate the relative speed and proximity to an object and issue a warning if the object is too close and the relative speed is too high.",
      "input": "Ensure data from both sensors are properly validated, and avoid unsafe practices for sensor data handling.",
      "output": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nconst float proximity_threshold = 3.0f; // meters\nconst float speed_threshold = 20.0f; // m/s\n\n// Function to process radar and ultrasonic data for FCW\nvoid process_sensor_data(float radar_distance, float radar_speed, float ultrasonic_distance) {\n    if (radar_distance < 0 || radar_speed < 0 || ultrasonic_distance < 0) {\n        throw std::invalid_argument(\"Sensor data cannot be negative\");\n    }\n\n    if (radar_distance < proximity_threshold && radar_speed > speed_threshold) {\n        std::cout << \"WARNING: COLLISION RISK AHEAD!\" << std::endl;\n    }\n    else if (ultrasonic_distance < proximity_threshold) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5f;  // Example radar data\n    float radar_speed = 25.0f;  // Example radar speed in m/s\n    float ultrasonic_distance = 2.8f;  // Example ultrasonic distance\n    try {\n        process_sensor_data(radar_distance, radar_speed, ultrasonic_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create C++ code for an FCW system using Lidar data. The system should assess the distance between the vehicle and obstacles, triggering a warning if the distance is too small.",
      "input": "Ensure proper validation of Lidar data to ensure no erroneous values are processed.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float danger_distance = 5.0f; // meters\n\n// Function to process Lidar data for FCW\nvoid process_lidar_data(float distance_to_object) {\n    if (distance_to_object < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n\n    if (distance_to_object < danger_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 4.2f;  // Example Lidar data\n    try {\n        process_lidar_data(lidar_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write C++ code for an FCW system using a combination of camera and GPS data to estimate speed and distance to an object. The system should trigger an alert if the car is approaching an obstacle too quickly.",
      "input": "Validate GPS and camera data inputs properly, and use clear exception handling mechanisms.",
      "output": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nconst float speed_threshold = 30.0f; // m/s\nconst float proximity_threshold = 10.0f; // meters\n\n// Function to process GPS and camera data for FCW\nvoid process_gps_camera_data(float gps_speed, float distance_to_object) {\n    if (gps_speed < 0 || distance_to_object < 0) {\n        throw std::invalid_argument(\"Speed and distance cannot be negative\");\n    }\n\n    if (gps_speed > speed_threshold && distance_to_object < proximity_threshold) {\n        std::cout << \"WARNING: COLLISION RISK AHEAD!\" << std::endl;\n    }\n}\n\nint main() {\n    float gps_speed = 32.0f;  // Example GPS speed in m/s\n    float distance_to_object = 8.0f;  // Example distance to object in meters\n    try {\n        process_gps_camera_data(gps_speed, distance_to_object);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate C++ code for an FCW system based on radar data. The system should issue a warning if the vehicle is too close to another vehicle, using radar to measure the distance and relative velocity.",
      "input": "Ensure all radar inputs are validated and that no potential error scenarios are overlooked.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float safe_distance = 8.0f; // meters\nconst float velocity_threshold = 20.0f; // m/s\n\n// Function to process radar data for FCW\nvoid process_radar_data(float distance, float velocity) {\n    if (distance < 0 || velocity < 0) {\n        throw std::invalid_argument(\"Distance and velocity cannot be negative\");\n    }\n\n    if (distance < safe_distance && velocity > velocity_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 6.0f;  // Example radar distance in meters\n    float radar_velocity = 22.0f;  // Example radar relative velocity in m/s\n    try {\n        process_radar_data(radar_distance, radar_velocity);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write C++ code for an FCW system using ultrasonic sensors. The system should assess the proximity to obstacles and trigger an alert if the vehicle is too close to an object.",
      "input": "Make sure the sensor data is appropriately filtered and only valid readings are used in the system.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float warning_distance = 2.0f; // meters\n\n// Function to process ultrasonic sensor data for FCW\nvoid process_ultrasonic_data(float distance_to_object) {\n    if (distance_to_object < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n\n    if (distance_to_object < warning_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_data = 1.8f;  // Example ultrasonic data\n    try {\n        process_ultrasonic_data(ultrasonic_data);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create C++ code for a Forward Collision Warning system using camera and radar data. The system should calculate the relative speed and distance to obstacles, triggering a warning if both conditions indicate a potential collision.",
      "input": "Ensure the data processing for both camera and radar is done independently, and use type-safe conversions.",
      "output": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nconst float collision_threshold_distance = 5.0f; // meters\nconst float collision_threshold_speed = 15.0f; // m/s\n\n// Function to process camera and radar data for FCW\nvoid process_camera_radar_data(float camera_distance, float radar_speed) {\n    if (camera_distance < 0 || radar_speed < 0) {\n        throw std::invalid_argument(\"Distance and speed cannot be negative\");\n    }\n\n    if (camera_distance < collision_threshold_distance && radar_speed > collision_threshold_speed) {\n        std::cout << \"WARNING: COLLISION AHEAD!\" << std::endl;\n    }\n}\n\nint main() {\n    float camera_distance = 4.5f;  // Example camera data in meters\n    float radar_speed = 18.0f;  // Example radar speed in m/s\n    try {\n        process_camera_radar_data(camera_distance, radar_speed);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate C++ code for an FCW system based on\\n\\n GPS and camera data. The system should issue a warning if the vehicle is moving at a high speed and is too close to an object in front.",
      "input": "Make sure to validate GPS and camera data before processing.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float max_safe_speed = 25.0f; // m/s\nconst float min_safe_distance = 10.0f; // meters\n\n// Function to process GPS and camera data for FCW\nvoid process_gps_camera_data(float gps_speed, float camera_distance) {\n    if (gps_speed < 0 || camera_distance < 0) {\n        throw std::invalid_argument(\"Speed and distance cannot be negative\");\n    }\n\n    if (gps_speed > max_safe_speed && camera_distance < min_safe_distance) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n}\n\nint main() {\n    float gps_speed = 28.0f;  // Example GPS speed in m/s\n    float camera_distance = 9.0f;  // Example camera distance in meters\n    try {\n        process_gps_camera_data(gps_speed, camera_distance);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Create C++ code for an FCW system using radar and Lidar data. The system should trigger an alert if the vehicle is moving too fast while being too close to an object.",
      "input": "Ensure all sensor data is processed separately, and avoid assumptions about sensor accuracy.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float critical_distance = 7.0f; // meters\nconst float max_velocity = 18.0f; // m/s\n\n// Function to process radar and Lidar data for FCW\nvoid process_radar_lidar_data(float radar_distance, float lidar_velocity) {\n    if (radar_distance < 0 || lidar_velocity < 0) {\n        throw std::invalid_argument(\"Distance and velocity cannot be negative\");\n    }\n\n    if (radar_distance < critical_distance && lidar_velocity > max_velocity) {\n        std::cout << \"WARNING: DANGER AHEAD!\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 6.0f;  // Example radar distance\n    float lidar_velocity = 19.0f;  // Example Lidar velocity\n    try {\n        process_radar_lidar_data(radar_distance, lidar_velocity);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write C++ code for a Forward Collision Warning system based on ultrasonic sensors and radar. The system should trigger a warning if the vehicle is too close to an object in front while moving at a high speed.",
      "input": "Ensure that both sensors are properly calibrated and the data processing avoids errors.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float safe_distance = 2.5f; // meters\nconst float speed_threshold = 12.0f; // m/s\n\n// Function to process ultrasonic and radar data for FCW\nvoid process_ultrasonic_radar_data(float ultrasonic_distance, float radar_speed) {\n    if (ultrasonic_distance < 0 || radar_speed < 0) {\n        throw std::invalid_argument(\"Distance and speed cannot be negative\");\n    }\n\n    if (ultrasonic_distance < safe_distance && radar_speed > speed_threshold) {\n        std::cout << \"WARNING: COLLISION IMMINENT!\" << std::endl;\n    }\n}\n\nint main() {\n    float ultrasonic_data = 1.0f;  // Example ultrasonic data\n    float radar_speed = 14.0f;  // Example radar speed in m/s\n    try {\n        process_ultrasonic_radar_data(ultrasonic_data, radar_speed);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Generate C++ code for an FCW system based on Lidar and ultrasonic sensor data. The system should detect whether the vehicle is too close to an object, considering both sensors' data, and trigger a warning.",
      "input": "Ensure proper sensor calibration and error handling to avoid data inaccuracies.",
      "output": "#include <iostream>\n#include <stdexcept>\n\nconst float danger_distance = 1.5f; // meters\n\n// Function to process Lidar and ultrasonic data for FCW\nvoid process_lidar_ultrasonic_data(float lidar_distance, float ultrasonic_distance) {\n    if (lidar_distance < 0 || ultrasonic_distance < 0) {\n        throw std::invalid_argument(\"Distance cannot be negative\");\n    }\n\n    if (lidar_distance < danger_distance || ultrasonic_distance < danger_distance) {\n        std::cout << \"WARNING: OBJECT TOO CLOSE!\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_data = 1.0f;  // Example Lidar data\n    float ultrasonic_data = 1.3f;  // Example ultrasonic data\n    try {\n        process_lidar_ultrasonic_data(lidar_data, ultrasonic_data);\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA 2023-compliant C++ program for a Forward Collision Warning system. The system should simulate detecting an object in a video feed, calculate the distance based on bounding box size, and display a warning if the distance is too small.",
      "input": "Ensure the code adheres to MISRA standards: use explicit constants, avoid 'using namespace', handle exceptions properly, and include comments for all operations.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float CAR_WIDTH_METERS = 1.7f;\nconst float CAMERA_FOCAL_LENGTH_PIXELS = 800.0f;\nconst float WARNING_DISTANCE_METERS = 6.0f;\n\nstruct Object {\n    cv::Rect bounding_box;\n    float distance_meters;\n};\n\nfloat calculate_distance(int bbox_width_pixels) {\n    return (CAR_WIDTH_METERS * CAMERA_FOCAL_LENGTH_PIXELS) / static_cast<float>(bbox_width_pixels);\n}\n\nvoid detect_collision(cv::Mat &frame) {\n    cv::Rect detected_object(200, 150, 120, 60);\n    Object obj;\n    obj.bounding_box = detected_object;\n    obj.distance_meters = calculate_distance(detected_object.width);\n\n    cv::rectangle(frame, detected_object, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance_meters) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n\n    if (obj.distance_meters < WARNING_DISTANCE_METERS) {\n        cv::putText(frame, \"COLLISION ALERT!\", cv::Point(100, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture video_capture(0);\n    if (!video_capture.isOpened()) {\n        std::cerr << \"Error: Unable to open camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        video_capture >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        detect_collision(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    video_capture.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA-compliant C++ code for a Forward Collision Warning system. The program should estimate object distance using a simplified geometry formula and display warnings for imminent collisions.",
      "input": "The implementation must use OpenCV for visualization, avoid 'using namespace', and use constants and error handling as per MISRA 2023 guidelines.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float VEHICLE_WIDTH = 1.9f;\nconst float FOCAL_LENGTH = 950.0f;\nconst float COLLISION_THRESHOLD = 5.0f;\n\nstruct Detection {\n    cv::Rect bbox;\n    float distance;\n};\n\nfloat compute_distance(int width_in_px) {\n    return (VEHICLE_WIDTH * FOCAL_LENGTH) / static_cast<float>(width_in_px);\n}\n\nvoid analyze_frame(cv::Mat &frame) {\n    cv::Rect target(250, 200, 100, 50);\n    Detection detected_object;\n    detected_object.bbox = target;\n    detected_object.distance = compute_distance(target.width);\n\n    cv::rectangle(frame, target, cv::Scalar(255, 255, 0), 2);\n    std::string display_text = \"Distance: \" + std::to_string(detected_object.distance) + \" m\";\n    cv::putText(frame, display_text, cv::Point(target.x, target.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);\n\n    if (detected_object.distance < COLLISION_THRESHOLD) {\n        cv::putText(frame, \"WARNING! COLLISION RISK\", cv::Point(100, 100), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Camera access error.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        analyze_frame(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA 2023-compliant C++ code to implement a Forward Collision Warning (FCW) system that uses bounding boxes from detected objects to calculate distances and warn the driver of potential collisions.",
      "input": "The system must use OpenCV, avoid 'using namespace std', handle all type conversions explicitly, and adhere to MISRA guidelines for constants and error handling.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float VEHICLE_WIDTH = 1.9f;\nconst float CAMERA_FOCAL_LENGTH = 900.0f;\nconst float MIN_SAFE_DISTANCE = 8.0f;\n\nstruct DetectedObject {\n    cv::Rect box;\n    float distance;\n};\n\nfloat calculate_distance(int bbox_width) {\n    return (VEHICLE_WIDTH * CAMERA_FOCAL_LENGTH) / static_cast<float>(bbox_width);\n}\n\nvoid detect_and_warn(cv::Mat &frame) {\n    cv::Rect car_bbox(400, 250, 150, 75);\n    DetectedObject obj;\n    obj.box = car_bbox;\n    obj.distance = calculate_distance(car_bbox.width);\n\n    cv::rectangle(frame, car_bbox, cv::Scalar(255, 0, 0), 2);\n    std::string text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, text, cv::Point(car_bbox.x, car_bbox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);\n\n    if (obj.distance < MIN_SAFE_DISTANCE) {\n        cv::putText(frame, \"COLLISION WARNING!\", cv::Point(150, 50), cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Could not access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        detect_and_warn(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate C++ code for an FCW system that reads video frames, detects objects using bounding boxes, estimates their distances, and warns when objects are too close.",
      "input": "Ensure MISRA 2023 compliance by using explicit constants, avoiding global variables, and including detailed comments for all operations.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n#define SAFE_DISTANCE 7.0f\n#define FOCAL_LENGTH 850.0f\n#define VEHICLE_WIDTH 1.85f\n\nstruct BoundingBox {\n    cv::Rect box;\n    float distance;\n};\n\nfloat estimate_distance(int bbox_width_px) {\n    return (VEHICLE_WIDTH * FOCAL_LENGTH) / static_cast<float>(bbox_width_px);\n}\n\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_box(300, 250, 160, 80);\n    BoundingBox object;\n    object.box = detected_box;\n    object.distance = estimate_distance(detected_box.width);\n\n    cv::rectangle(frame, detected_box, cv::Scalar(0, 255, 0), 2);\n    std::string dist_text = \"Dist: \" + std::to_string(object.distance) + \" m\";\n    cv::putText(frame, dist_text, cv::Point(detected_box.x, detected_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n\n    if (object.distance < SAFE_DISTANCE) {\n        cv::putText(frame, \"WARNING: COLLISION!\", cv::Point(150, 50), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Camera error.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_frame(frame);\n        cv::imshow(\"FCW\", frame);\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for a Forward Collision Warning system using OpenCV. The system should process video frames, estimate the distance to detected objects, and issue a warning if the object is too close.",
      "input": "Follow MISRA standards: avoid global variables, handle all type conversions explicitly, and add comments to explain all steps.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nconst float car_width_m = 1.8f;\nconst float focal_length_px = 850.0f;\nconst float collision_threshold_m = 5.0f;\n\nstruct DetectedObject {\n    cv::Rect bounding_box;\n    float distance;\n};\n\nfloat calculate_distance(int bbox_width_px) {\n    return (car_width_m * focal_length_px) / static_cast<float>(bbox_width_px);\n}\n\nvoid detect_collision(cv::Mat &frame) {\n    cv::Rect bbox(300, 200, 150, 75);\n    DetectedObject obj;\n    obj.bounding_box = bbox;\n    obj.distance = calculate_distance(bbox.width);\n\n    cv::rectangle(frame, obj.bounding_box, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n\n    if (obj.distance < collision_threshold_m) {\n        cv::putText(frame, \"WARNING: TOO CLOSE!\", cv::Point(150, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Camera could not be opened.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        detect_collision(frame);\n        cv::imshow(\"Forward Collision Warning\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ code that complies with MISRA 2023 guidelines to detect objects in video, estimate their distance, and issue warnings for close objects.",
      "input": "Ensure compliance with MISRA 2023: avoid implicit type casting, do not use namespace shortcuts, and include detailed error handling.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n\nconst float car_width = 2.0f;\nconst float focal_length = 860.0f;\nconst float safe_distance = 6.0f;\n\nstruct Object {\n    cv::Rect bbox;\n    float distance;\n};\n\nfloat estimate_distance(int bbox_width) {\n    return (car_width * focal_length) / static_cast<float>(bbox_width);\n}\n\nvoid process_frame(cv::Mat &frame) {\n    cv::Rect detected_bbox(400, 300, 120, 60);\n    Object obj;\n    obj.bbox = detected_bbox;\n    obj.distance = estimate_distance(detected_bbox.width);\n\n    cv::rectangle(frame, detected_bbox, cv::Scalar(0, 255, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(detected_bbox.x, detected_bbox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);\n\n    if (obj.distance < safe_distance) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Failed to open video capture device.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        process_frame(frame);\n        cv::imshow(\"Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop a MISRA 2023-compliant C++ code for a Forward Collision Warning (FCW) system. The system should capture video frames, detect objects, calculate distances based on bounding box sizes, and issue warnings when the distance is below the defined threshold.",
      "input": "Ensure strict MISRA compliance: avoid implicit type conversions, provide robust error handling, and document each step of the process with comments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n\nconst float focal_length_x = 880.0f;\nconst float car_width = 1.8f;\nconst float collision_distance = 5.0f;\n\nstruct Object {\n    cv::Rect bbox;\n    float distance;\n};\n\nfloat compute_distance(const int width) {\n    return (car_width * focal_length_x) / static_cast<float>(width);\n}\n\nvoid analyze_frame(cv::Mat &frame) {\n    cv::Rect bbox(400, 300, 130, 70);\n    Object obj;\n    obj.bbox = bbox;\n    obj.distance = compute_distance(obj.bbox.width);\n\n    cv::rectangle(frame, obj.bbox, cv::Scalar(255, 0, 0), 2);\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, distance_text, cv::Point(obj.bbox.x, obj.bbox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);\n\n    if (obj.distance < collision_distance) {\n        cv::putText(frame, \"Collision Warning!\", cv::Point(200, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Failed to open video capture device.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        analyze_frame(frame);\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA-compliant C++ code to implement a Forward Collision Warning (FCW) system. It should detect objects in a video feed, estimate their distance, and provide a warning when objects come too close.",
      "input": "Follow MISRA guidelines: avoid global variables, provide clear function prototypes, and ensure robust handling of errors and edge cases.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n\nconst float focal_length = 850.0f;\nconst float car_width = 2.0f;\nconst float warning_threshold = 6.0f;\n\nstruct ObjectData {\n    cv::Rect bbox;\n    float distance;\n};\n\nfloat estimate_distance(int bbox_width) {\n    return (car_width * focal_length) / static_cast<float>(bbox_width);\n}\n\nvoid detect_and_warn(cv::Mat &frame) {\n    cv::Rect detected_bbox(320, 240, 100, 50);\n    ObjectData obj;\n    obj.bbox = detected_bbox;\n    obj.distance = estimate_distance(detected_bbox.width);\n\n    cv::rectangle(frame, detected_bbox, cv::Scalar(0, 255, 0), 2);\n    std::string text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(frame, text, cv::Point(obj.bbox.x, obj.bbox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n\n    if (obj.distance < warning_threshold) {\n        cv::putText(frame, \"WARNING: TOO CLOSE!\", cv::Point(150, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Unable to access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n        detect_and_warn(frame);\n        cv::imshow(\"Collision Warning\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA-compliant C++ code for a FCW system. The system should calculate the Time-to-Collision (TTC) based on object distance and velocity, and display a warning when TTC is below a threshold.",
      "input": "Ensure adherence to MISRA rules: explicit type conversions, meaningful comments, and avoidance of 'using namespace'.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float WARNING_TTC = 2.0f; // Time-to-Collision threshold in seconds\n\nstruct ObjectDetection {\n    float distance;\n    float velocity;\n    float ttc;\n};\n\nfloat calculate_ttc(float distance, float velocity) {\n    if (velocity > 0.0f) {\n        return distance / velocity;\n    } else {\n        return -1.0f; // Indicate invalid TTC\n    }\n}\n\nvoid process_frame(cv::Mat &frame, ObjectDetection &object) {\n    object.ttc = calculate_ttc(object.distance, object.velocity);\n\n    std::string ttc_text = \"TTC: \" + (object.ttc > 0.0f ? std::to_string(object.ttc) : \"N/A\") + \" s\";\n    cv::putText(frame, ttc_text, cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(255, 255, 255), 2);\n\n    if (object.ttc > 0.0f && object.ttc < WARNING_TTC) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Unable to open camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    ObjectDetection object = {15.0f, 7.5f, 0.0f};\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        process_frame(frame, object);\n        cv::imshow(\"FCW System\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ program that detects stationary objects using a bounding box area and alerts if the car gets too close. Include MISRA compliance with detailed comments.",
      "input": "Follow MISRA 2023 guidelines. Avoid dynamic memory allocations, ensure explicit constants, and provide detailed comments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst int SAFE_DISTANCE_PIXELS = 150; // Distance in pixels for safety\n\nstruct StationaryObject {\n    cv::Rect bounding_box;\n    bool is_close;\n};\n\nvoid analyze_frame(cv::Mat &frame, StationaryObject &object) {\n    object.is_close = object.bounding_box.height > SAFE_DISTANCE_PIXELS;\n\n    cv::rectangle(frame, object.bounding_box, cv::Scalar(0, 255, 0), 2);\n    if (object.is_close) {\n        cv::putText(frame, \"WARNING: OBJECT TOO CLOSE!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Unable to access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    StationaryObject object = {cv::Rect(200, 200, 100, 160), false};\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        analyze_frame(frame, object);\n        cv::imshow(\"Stationary Object Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Create MISRA-compliant C++ code for a FCW system. The system should calculate the Time-to-Collision (TTC) based on object distance and velocity, and display a warning when TTC is below a threshold.",
      "input": "Ensure adherence to MISRA rules: explicit type conversions, meaningful comments, and avoidance of 'using namespace'.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst float WARNING_TTC = 2.0f; // Time-to-Collision threshold in seconds\n\nstruct ObjectDetection {\n    float distance;\n    float velocity;\n    float ttc;\n};\n\nfloat calculate_ttc(float distance, float velocity) {\n    if (velocity > 0.0f) {\n        return distance / velocity;\n    } else {\n        return -1.0f; // Indicate invalid TTC\n    }\n}\n\nvoid process_frame(cv::Mat &frame, ObjectDetection &object) {\n    object.ttc = calculate_ttc(object.distance, object.velocity);\n\n    std::string ttc_text = \"TTC: \" + (object.ttc > 0.0f ? std::to_string(object.ttc) : \"N/A\") + \" s\";\n    cv::putText(frame, ttc_text, cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(255, 255, 255), 2);\n\n    if (object.ttc > 0.0f && object.ttc < WARNING_TTC) {\n        cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Unable to open camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    ObjectDetection object = {15.0f, 7.5f, 0.0f};\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        process_frame(frame, object);\n        cv::imshow(\"FCW System\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ program that detects stationary objects using a bounding box area and alerts if the car gets too close. Include MISRA compliance with detailed comments.",
      "input": "Follow MISRA 2023 guidelines. Avoid dynamic memory allocations, ensure explicit constants, and provide detailed comments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst int SAFE_DISTANCE_PIXELS = 150; // Distance in pixels for safety\n\nstruct StationaryObject {\n    cv::Rect bounding_box;\n    bool is_close;\n};\n\nvoid analyze_frame(cv::Mat &frame, StationaryObject &object) {\n    object.is_close = object.bounding_box.height > SAFE_DISTANCE_PIXELS;\n\n    cv::rectangle(frame, object.bounding_box, cv::Scalar(0, 255, 0), 2);\n    if (object.is_close) {\n        cv::putText(frame, \"WARNING: OBJECT TOO CLOSE!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Unable to access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    StationaryObject object = {cv::Rect(200, 200, 100, 160), false};\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        analyze_frame(frame, object);\n        cv::imshow(\"Stationary Object Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop a C++ program that detects stationary objects using a bounding box area and alerts if the car gets too close. Include MISRA compliance with detailed comments.",
      "input": "Follow MISRA 2023 guidelines. Avoid dynamic memory allocations, ensure explicit constants, and provide detailed comments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <cstdlib>\n\nconst int SAFE_DISTANCE_PIXELS = 150; // Distance in pixels for safety\n\nstruct StationaryObject {\n    cv::Rect bounding_box;\n    bool is_close;\n};\n\nvoid analyze_frame(cv::Mat &frame, StationaryObject &object) {\n    object.is_close = object.bounding_box.height > SAFE_DISTANCE_PIXELS;\n\n    cv::rectangle(frame, object.bounding_box, cv::Scalar(0, 255, 0), 2);\n    if (object.is_close) {\n        cv::putText(frame, \"WARNING: OBJECT TOO CLOSE!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n    }\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error: Unable to access the camera.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    cv::Mat frame;\n    StationaryObject object = {cv::Rect(200, 200, 100, 160), false};\n\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        analyze_frame(frame, object);\n        cv::imshow(\"Stationary Object Warning\", frame);\n\n        if (cv::waitKey(10) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Generate MISRA 2023-compliant C++ code for implementing a Forward Collision Warning (FCW) system using OpenCV. The system should detect objects, estimate the distance, and trigger a collision warning when the distance is below a specified threshold. Proper error handling and detailed comments should be included to explain each key operation in the code.",
      "input": "Ensure compliance with MISRA standards: avoid 'using namespace', handle all type conversions explicitly, and include comments for each key operation in the code.",
      "output": "#include <opencv2/opencv.hpp>  // For image processing\n#include <iostream>  // For input-output operations\n#include <cmath>  // For mathematical operations (e.g., sin, cos, atan)\n#include <cstdlib>  // For system operations like EXIT_FAILURE\n#include <vector>  // For vector container to hold bounding box data\n#include <string>  // For string manipulation\n\n// Camera parameters\nconst float focal_length_x = 874.0f;   // Focal length in X direction\nconst float focal_length_y = 995.0f;   // Focal length in Y direction\nconst float optical_center_x = 960.0f; // Optical center in X\nconst float optical_center_y = 536.0f; // Optical center in Y\nconst float car_width = 1.8f;  // Assumed average width of a car (meters)\n\n// Threshold for triggering collision warning (in meters)\nconst float collision_threshold = 10.0f;\n\n// Define a structure to represent a detected object\nstruct DetectedObject {\n    cv::Rect bounding_box;  // Bounding box for detected object\n    float distance;         // Estimated distance to object\n    std::string label;      // Label of the object (e.g., \"car\", \"truck\", etc.)\n};\n\n// Function to calculate the distance to an object based on its width in the image\n// Uses a simplified version of the camera calibration formula\nfloat calculate_distance(int object_width_in_image, int image_width) {\n    // Formula to estimate distance from the object width in the image\n    // Based on the known car width and camera focal length\n    return (car_width * focal_length_x * image_width) / (object_width_in_image * focal_length_x);\n}\n\n// Function to process an image, detect objects, and compute distances\nvoid process_image(cv::Mat &image) {\n    // Dummy object detection (simulated with a fixed bounding box for simplicity)\n    cv::Rect detected_object(600, 400, 200, 100);  // Example bounding box of a car\n    DetectedObject obj;\n    obj.bounding_box = detected_object;\n\n    // Calculate the object width in the image\n    int object_width_in_image = obj.bounding_box.width;\n\n    // Estimate the distance to the object\n    obj.distance = calculate_distance(object_width_in_image, image.cols);\n\n    // Draw the bounding box and distance on the image\n    cv::rectangle(image, obj.bounding_box, cv::Scalar(0, 255, 0), 2);  // Draw bounding box\n    std::string distance_text = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n    cv::putText(image, distance_text, cv::Point(obj.bounding_box.x, obj.bounding_box.y - 10), \n                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 2);  // Draw distance text\n\n    // Check for collision risk (if distance < threshold)\n    if (obj.distance < collision_threshold) {\n        cv::putText(image, \"WARNING: COLLISION IMMINENT\", cv::Point(300, 50), cv::FONT_HERSHEY_SIMPLEX, \n                    1, cv::Scalar(0, 0, 255), 2);  // Show warning message\n    }\n}\n\n// Main function to handle video or image capture and process each frame\nint main() {\n    // Open video capture device (use 0 for the default camera, or provide a video file path)\n    cv::VideoCapture cap(0);  // Open default camera\n    if (!cap.isOpened()) {\n        std::cout << \"ERROR: Could not open the camera or video!\" << std::endl;\n        return EXIT_FAILURE;  // Return failure if camera/video cannot be opened\n    }\n\n    cv::Mat frame;  // Frame for capturing images\n    while (true) {\n        cap >> frame;  // Capture a frame from the video\n\n        if (frame.empty()) {\n            break;  // Exit loop if the frame is empty (end of video)\n        }\n\n        // Process the captured frame to detect objects and calculate distance\n        process_image(frame);\n\n        // Display the processed frame\n        cv::imshow(\"FCW - Forward Collision Warning\", frame);\n\n        // Exit on pressing 'q'\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();  // Release the camera or video file\n    cv::destroyAllWindows();  // Close all OpenCV windows\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects objects in a video feed and calculates their distances using bounding box dimensions.",
      "input": "Ensure compliance by avoiding implicit conversions, providing constant thresholds, and including comments for every key operation.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\n// Constants for distance calculation\nconst float KNOWN_WIDTH = 1.8f;  // Average car width in meters\nconst float FOCAL_LENGTH = 1000.0f; // Focal length in pixels\nconst float COLLISION_THRESHOLD = 5.0f; // Collision warning threshold in meters\n\nfloat calculateDistance(int widthInPixels) {\n    return (KNOWN_WIDTH * FOCAL_LENGTH) / static_cast<float>(widthInPixels);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n    \n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150); // Simulated detection\n        float distance = calculateDistance(detectedObject.width);\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string distanceText = \"Distance: \" + std::to_string(distance) + \" m\";\n        cv::putText(frame, distanceText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (distance < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that logs detected objects and their distances into a file.",
      "input": "Ensure compliance by explicitly managing file streams and providing detailed comments for all operations.",
      "output": "#include <opencv2/opencv.hpp>\n#include <fstream>\n#include <iostream>\n\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float COLLISION_THRESHOLD = 5.0f;\n\nfloat calculateDistance(int widthInPixels) {\n    return (KNOWN_WIDTH * FOCAL_LENGTH) / static_cast<float>(widthInPixels);\n}\n\nint main() {\n    std::ofstream logFile(\"fcw_log.txt\", std::ios::out);\n    if (!logFile.is_open()) {\n        std::cerr << \"ERROR: Unable to open log file!\\n\";\n        return -1;\n    }\n\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = calculateDistance(detectedObject.width);\n\n        logFile << \"Object detected at distance: \" << distance << \" meters\\n\";\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string distanceText = \"Distance: \" + std::to_string(distance) + \" m\";\n        cv::putText(frame, distanceText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (distance < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    logFile.close();\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold dynamically based on the vehicle's speed.",
      "input": "Ensure compliance by explicitly managing speed inputs, defining constants for speed-to-threshold scaling, and providing detailed comments for dynamic adjustments.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\n// Constants for distance calculation\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float MIN_THRESHOLD = 5.0f;\nconst float MAX_THRESHOLD = 15.0f;\n\nfloat calculateDistance(int widthInPixels) {\n    return (KNOWN_WIDTH * FOCAL_LENGTH) / static_cast<float>(widthInPixels);\n}\n\nfloat adjustThreshold(float speed) {\n    if (speed < 30.0f) {\n        return MIN_THRESHOLD;\n    } else if (speed > 90.0f) {\n        return MAX_THRESHOLD;\n    }\n    return MIN_THRESHOLD + ((speed - 30.0f) / 60.0f) * (MAX_THRESHOLD - MIN_THRESHOLD);\n}\n\nint main() {\n    float vehicleSpeed = 50.0f; // Example speed (in km/h)\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        float collisionThreshold = adjustThreshold(vehicleSpeed);\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = calculateDistance(detectedObject.width);\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string distanceText = \"Distance: \" + std::to_string(distance) + \" m\";\n        cv::putText(frame, distanceText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (distance < collisionThreshold) {\n            cv::putText(frame, \"WARNING: COLLISION RISK\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA C++ 2023-compliant code for an FCW system that tracks multiple objects and triggers a warning for the closest object.",
      "input": "Ensure compliance by using structured programming, avoiding implicit type promotions, and providing comments for object prioritization logic.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <vector>\n\n// Constants\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float COLLISION_THRESHOLD = 5.0f;\n\nstruct DetectedObject {\n    cv::Rect boundingBox;\n    float distance;\n};\n\nfloat calculateDistance(int widthInPixels) {\n    return (KNOWN_WIDTH * FOCAL_LENGTH) / static_cast<float>(widthInPixels);\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        std::vector<DetectedObject> detectedObjects = {\n            {cv::Rect(300, 200, 80, 100), 0.0f},\n            {cv::Rect(500, 250, 100, 120), 0.0f},\n            {cv::Rect(700, 300, 120, 140), 0.0f}\n        };\n\n        DetectedObject closestObject;\n        closestObject.distance = std::numeric_limits<float>::max();\n\n        for (auto &obj : detectedObjects) {\n            obj.distance = calculateDistance(obj.boundingBox.width);\n            if (obj.distance < closestObject.distance) {\n                closestObject = obj;\n            }\n\n            cv::rectangle(frame, obj.boundingBox, cv::Scalar(0, 255, 0), 2);\n            std::string distanceText = \"Distance: \" + std::to_string(obj.distance) + \" m\";\n            cv::putText(frame, distanceText, cv::Point(obj.boundingBox.x, obj.boundingBox.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n        }\n\n        if (closestObject.distance < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION IMMINENT\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses a radar sensor to detect objects and calculates the time to collision (TTC).",
      "input": "Ensure compliance by explicitly handling radar data inputs, avoiding implicit type conversions, and including comments for the TTC calculation logic.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float RADAR_SENSOR_WIDTH = 1.8f;\nconst float RADAR_FOCAL_LENGTH = 1000.0f;\nconst float COLLISION_THRESHOLD = 3.0f;\n\nfloat calculateTTC(float relativeSpeed, float distance) {\n    if (relativeSpeed == 0.0f) {\n        return -1.0f; // No collision risk if speed is zero\n    }\n    return distance / relativeSpeed;\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    float relativeSpeed = 10.0f; // Relative speed of the object in km/h\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);  // Simulated object detection\n        float distance = RADAR_SENSOR_WIDTH * RADAR_FOCAL_LENGTH / static_cast<float>(detectedObject.width);\n        float ttc = calculateTTC(relativeSpeed, distance);\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string ttcText = \"TTC: \" + std::to_string(ttc) + \" sec\";\n        cv::putText(frame, ttcText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (ttc < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Develop MISRA C++ 2023-compliant code for an FCW system that integrates stereo camera images for depth estimation and collision detection.",
      "input": "Ensure compliance by handling stereo images correctly, avoiding unsafe type conversions, and adding comments explaining the depth estimation process.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float KNOWN_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float BASELINE = 0.2f;  // Distance between the two cameras in meters\nconst float COLLISION_THRESHOLD = 5.0f;\n\nfloat calculateDepth(int disparity) {\n    return (FOCAL_LENGTH * BASELINE) / static_cast<float>(disparity);\n}\n\nint main() {\n    cv::VideoCapture leftCam(0), rightCam(1);\n    if (!leftCam.isOpened() || !rightCam.isOpened()) {\n        std::cerr << \"ERROR: Unable to open camera streams!\\n\";\n        return -1;\n    }\n\n    cv::Mat leftFrame, rightFrame, disparityMap;\n    while (true) {\n        leftCam >> leftFrame;\n        rightCam >> rightFrame;\n        if (leftFrame.empty() || rightFrame.empty()) {\n            break;\n        }\n\n        // Compute disparity between the two images\n        cv::StereoBM stereoBM;\n        stereoBM(leftFrame, rightFrame, disparityMap);\n\n        // Simulated object detection: using a fixed region for simplicity\n        int disparity = disparityMap.at<uchar>(200, 300);  // Sample pixel value\n        float depth = calculateDepth(disparity);\n\n        cv::Rect detectedObject(300, 200, 100, 150);  // Simulated detection\n        cv::rectangle(leftFrame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string depthText = \"Depth: \" + std::to_string(depth) + \" m\";\n        cv::putText(leftFrame, depthText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (depth < COLLISION_THRESHOLD) {\n            cv::putText(leftFrame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", leftFrame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    leftCam.release();\n    rightCam.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that estimates the closing speed of a detected vehicle and triggers a warning when the speed exceeds a threshold.",
      "input": "Ensure compliance by calculating relative speed safely, avoiding unsafe type casting, and adding comments for each key computation.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nconst float VEHICLE_WIDTH = 1.8f;\nconst float FOCAL_LENGTH = 1000.0f;\nconst float MAX_SPEED_THRESHOLD = 40.0f;  // km/h\n\nfloat calculateSpeed(float distance, float time) {\n    return distance / time;\n}\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = VEHICLE_WIDTH * FOCAL_LENGTH / static_cast<float>(detectedObject.width);\n        float closingSpeed = calculateSpeed(distance, 1.0f); // Assume 1 second time frame for simplicity\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        std::string speedText = \"Closing Speed: \" + std::to_string(closingSpeed) + \" km/h\";\n        cv::putText(frame, speedText, cv::Point(300, 180), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 2);\n\n        if (closingSpeed > MAX_SPEED_THRESHOLD) {\n            cv::putText(frame, \"WARNING: HIGH CLOSING SPEED!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that provides visual and audio alerts for imminent collisions.",
      "input": "Ensure compliance by managing audio outputs safely, defining constants for alerting thresholds, and providing detailed comments for both visual and audio alerts.",
      "output": "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD = 3.0f;\nconst std::string ALERT_AUDIO_FILE = \"alert.wav\";  // Path to the audio file\n\nint main() {\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"ERROR: Unable to open video stream!\\n\";\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (true) {\n        cap >> frame;\n        if (frame.empty()) {\n            break;\n        }\n\n        cv::Rect detectedObject(300, 200, 100, 150);\n        float distance = 5.0f;  // Simulated constant distance for now\n\n        cv::rectangle(frame, detectedObject, cv::Scalar(0, 255, 0), 2);\n        if (distance < COLLISION_THRESHOLD) {\n            cv::putText(frame, \"WARNING: COLLISION RISK!\", cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 255), 2);\n            std::system(ALERT_AUDIO_FILE.c_str());  // Play alert sound\n        }\n\n        cv::imshow(\"FCW System\", frame);\n        if (cv::waitKey(1) == 'q') {\n            break;\n        }\n    }\n\n    cap.release();\n    cv::destroyAllWindows();\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using LiDAR data for object detection and collision prediction.",
      "input": "Ensure the code safely handles LiDAR data inputs, computes distances from point cloud data, and includes detailed comments for the collision prediction logic.",
      "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision distance threshold in meters\n\n// Structure to hold a LiDAR point\nstruct LidarPoint {\n    float x;\n    float y;\n    float z;\n};\n\n// Function to compute distance from the LiDAR point to the origin\nfloat calculateDistance(const LidarPoint &point) {\n    return std::sqrt(point.x * point.x + point.y * point.y + point.z * point.z);\n}\n\n// Function to predict collision based on distance\nbool isCollisionRisk(float distance) {\n    return (distance < COLLISION_THRESHOLD);\n}\n\nint main() {\n    std::vector<LidarPoint> lidarData = {\n        {1.0f, 2.0f, 0.0f},\n        {2.5f, 1.0f, 0.0f},\n        {4.0f, 4.0f, 0.0f},\n        {3.5f, 3.0f, 0.0f}\n    };  // Simulated LiDAR points\n\n    for (const auto &point : lidarData) {\n        float distance = calculateDistance(point);\n        std::cout << \"Detected Object at Distance: \" << distance << \" meters\" << std::endl;\n        if (isCollisionRisk(distance)) {\n            std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system where the collision threshold dynamically adjusts based on the road curvature.",
      "input": "Ensure safe handling of the road curvature data, and adjust the collision threshold appropriately for different curve radii.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BASE_COLLISION_THRESHOLD = 10.0f;  // Base collision threshold in meters\nconst float CURVE_ADJUSTMENT_FACTOR = 1.5f;  // Adjustment factor for road curves\n\n// Function to adjust the collision threshold based on road curvature\nfloat adjustThreshold(float curvatureRadius) {\n    if (curvatureRadius <= 0.0f) {\n        return BASE_COLLISION_THRESHOLD;  // No adjustment for straight roads\n    }\n    return BASE_COLLISION_THRESHOLD - (CURVE_ADJUSTMENT_FACTOR * (1.0f / curvatureRadius));\n}\n\nint main() {\n    float roadCurvatureRadius = 50.0f;  // Example curvature radius (in meters)\n    float collisionThreshold = adjustThreshold(roadCurvatureRadius);\n\n    std::cout << \"Adjusted Collision Threshold: \" << collisionThreshold << \" meters\" << std::endl;\n\n    float detectedObjectDistance = 7.0f;  // Example distance to detected object\n    if (detectedObjectDistance < collisionThreshold) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system integrated with adaptive cruise control to automatically adjust vehicle speed to avoid collisions.",
      "input": "Ensure compliance by explicitly controlling the vehicle's speed using adaptive cruise control, and include comments explaining the control logic.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float MAX_SPEED = 120.0f;  // Max speed in km/h\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision distance threshold in meters\nconst float SAFE_FOLLOW_DISTANCE = 2.0f;  // Safe following distance in meters\n\n// Function to calculate the desired vehicle speed\nfloat adjustSpeed(float currentDistance) {\n    if (currentDistance < SAFE_FOLLOW_DISTANCE) {\n        return 0.0f;  // Stop the vehicle if too close\n    }\n    return MAX_SPEED * (currentDistance / SAFE_FOLLOW_DISTANCE);  // Adjust speed proportionally\n}\n\nint main() {\n    float objectDistance = 4.0f;  // Example distance to detected object\n    float currentSpeed = 100.0f;  // Current speed in km/h\n\n    std::cout << \"Current Speed: \" << currentSpeed << \" km/h\" << std::endl;\n\n    // Adjust speed based on object distance\n    float adjustedSpeed = adjustSpeed(objectDistance);\n    std::cout << \"Adjusted Speed: \" << adjustedSpeed << \" km/h\" << std::endl;\n\n    if (objectDistance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK! Automatically reducing speed...\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers warnings with varying urgency based on both vehicle speed and the distance to the detected object.",
      "input": "Ensure the warning urgency changes dynamically depending on both the speed and distance to the detected object, with clear comments on the logic behind this decision.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float HIGH_SPEED_THRESHOLD = 80.0f;  // Speed in km/h for high urgency\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision distance threshold in meters\n\n// Function to determine the warning urgency\nstd::string determineUrgency(float speed, float distance) {\n    if (distance < COLLISION_THRESHOLD) {\n        if (speed > HIGH_SPEED_THRESHOLD) {\n            return \"URGENT: STOP IMMEDIATELY!\";\n        }\n        return \"WARNING: SLOW DOWN!\";\n    }\n    return \"SAFE: KEEP DRIVING.\";\n}\n\nint main() {\n    float objectDistance = 4.0f;  // Example distance to detected object\n    float vehicleSpeed = 100.0f;  // Vehicle speed in km/h\n\n    std::cout << \"Current Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Distance to Object: \" << objectDistance << \" meters\" << std::endl;\n\n    std::string urgencyMessage = determineUrgency(vehicleSpeed, objectDistance);\n    std::cout << urgencyMessage << std::endl;\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts potential obstacles based on the vehicle's trajectory.",
      "input": "Ensure the code simulates vehicle trajectory calculations and predicts obstacle risks accordingly, with detailed comments explaining the trajectory modeling logic.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SAFE_DISTANCE = 5.0f;  // Safe distance in meters\nconst float TRAJECTORY_PREDICTION_TIME = 3.0f;  // Time in seconds for trajectory prediction\n\n// Function to simulate trajectory calculation\nfloat predictTrajectory(float currentSpeed, float time) {\n    return currentSpeed * time;  // Simple linear prediction\n}\n\nint main() {\n    float currentSpeed = 100.0f;  // Vehicle speed in km/h\n    float predictedDistance = predictTrajectory(currentSpeed, TRAJECTORY_PREDICTION_TIME);\n\n    std::cout << \"Predicted Distance after \" << TRAJECTORY_PREDICTION_TIME << \" seconds: \" << predictedDistance << \" meters\" << std::endl;\n\n    if (predictedDistance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Potential Obstacle Ahead!\" << std::endl;\n    } else {\n        std::cout << \"Trajectory Clear, Safe to Proceed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that integrates radar and camera data for multi-sensor fusion to improve collision prediction accuracy.",
      "input": "Ensure compliance by carefully handling both radar and camera data inputs, calculating distances from both sensors, and merging the data for improved prediction accuracy.",
      "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst float RADAR_COLLISION_THRESHOLD = 6.0f;  // Radar collision threshold\nconst float CAMERA_COLLISION_THRESHOLD = 5.0f;  // Camera collision threshold\n\n// Structure to hold radar data\nstruct RadarData {\n    float distance;\n    float angle;\n};\n\n// Structure to hold camera data\nstruct CameraData {\n    float distance;\n    float objectType;\n};\n\n// Function to combine radar and camera data for collision prediction\nbool isCollisionRisk(float radarDistance, float cameraDistance) {\n    return (radarDistance < RADAR_COLLISION_THRESHOLD || cameraDistance < CAMERA_COLLISION_THRESHOLD);\n}\n\nint main() {\n    RadarData radar = {4.5f, 30.0f};  // Simulated radar data\n    CameraData camera = {5.0f, 1.0f};  // Simulated camera data (e.g., detected car)\n\n    std::cout << \"Radar Distance: \" << radar.distance << \" meters\" << std::endl;\n    std::cout << \"Camera Distance: \" << camera.distance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(radar.distance, camera.distance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using GPS data along with radar and camera data to predict collisions.",
      "input": "Ensure the integration of GPS data, and process it along with radar and camera data for improved collision prediction, with clear comments on each step.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float GPS_COLLISION_THRESHOLD = 10.0f;  // GPS-based collision threshold in meters\nconst float RADAR_COLLISION_THRESHOLD = 6.0f;  // Radar-based threshold\nconst float CAMERA_COLLISION_THRESHOLD = 5.0f;  // Camera-based threshold\n\n// Structure to hold GPS data\nstruct GPSData {\n    float latitude;\n    float longitude;\n    float speed;\n};\n\n// Function to check collision risk based on sensor data\nbool isCollisionRisk(float gpsDistance, float radarDistance, float cameraDistance) {\n    return (gpsDistance < GPS_COLLISION_THRESHOLD || radarDistance < RADAR_COLLISION_THRESHOLD || cameraDistance < CAMERA_COLLISION_THRESHOLD);\n}\n\nint main() {\n    GPSData gps = {34.0522f, -118.2437f, 40.0f};  // Simulated GPS data (latitude, longitude, speed)\n    float radarDistance = 7.0f;  // Simulated radar distance\n    float cameraDistance = 4.0f;  // Simulated camera distance\n\n    std::cout << \"GPS Speed: \" << gps.speed << \" km/h\" << std::endl;\n    std::cout << \"Radar Distance: \" << radarDistance << \" meters\" << std::endl;\n    std::cout << \"Camera Distance: \" << cameraDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(gps.speed, radarDistance, cameraDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision risk prediction based on vehicle velocity.",
      "input": "Use vehicle velocity (speed) to adjust the collision prediction logic, ensuring that higher speeds trigger a more urgent warning when close to objects.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Distance threshold for collision risk in meters\nconst float HIGH_SPEED_THRESHOLD = 80.0f;  // Speed threshold in km/h for more urgent warnings\n\n// Function to check for collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    if (vehicleSpeed > HIGH_SPEED_THRESHOLD) {\n        return objectDistance < COLLISION_THRESHOLD / 2;  // More urgent warning for high speed\n    }\n    return objectDistance < COLLISION_THRESHOLD;  // Regular threshold for normal speed\n}\n\nint main() {\n    float vehicleSpeed = 90.0f;  // Vehicle speed in km/h\n    float objectDistance = 3.0f;  // Distance to detected object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts the behavior of obstacles based on their speed and direction relative to the vehicle.",
      "input": "Include logic to estimate the movement direction and speed of detected obstacles and use that data to predict future collision risks.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Distance threshold for collision risk\n\n// Structure to represent an obstacle with speed and direction\nstruct Obstacle {\n    float distance;\n    float speed;\n    float direction;  // Angle in degrees relative to the vehicle's direction\n};\n\n// Function to predict future position of an obstacle\nfloat predictObstaclePosition(const Obstacle &obstacle, float time) {\n    return obstacle.distance + obstacle.speed * time;  // Simple prediction based on speed and direction\n}\n\nint main() {\n    Obstacle obstacle = {10.0f, 20.0f, 45.0f};  // Example obstacle (10 meters away, 20 km/h speed, 45 degrees angle)\n    float predictionTime = 5.0f;  // Time in seconds for prediction\n\n    float predictedPosition = predictObstaclePosition(obstacle, predictionTime);\n\n    std::cout << \"Predicted Position of Obstacle after \" << predictionTime << \" seconds: \" << predictedPosition << \" meters\" << std::endl;\n\n    if (predictedPosition < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that includes pedestrian detection with vehicle speed.",
      "input": "Process pedestrian detection results alongside vehicle speed to calculate and trigger collision warnings if pedestrians are detected too close.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float PEDESTRIAN_COLLISION_THRESHOLD = 3.0f;  // Collision threshold for pedestrians in meters\nconst float VEHICLE_SPEED_THRESHOLD = 60.0f;  // Speed threshold in km/h for pedestrian collision warnings\n\n// Function to check pedestrian collision risk based on speed and distance\nbool isPedestrianCollisionRisk(float vehicleSpeed, float pedestrianDistance) {\n    if (vehicleSpeed > VEHICLE_SPEED_THRESHOLD) {\n        return pedestrianDistance < PEDESTRIAN_COLLISION_THRESHOLD / 2;  // Urgent warning at high speeds\n    }\n    return pedestrianDistance < PEDESTRIAN_COLLISION_THRESHOLD;  // Normal threshold for slower speeds\n}\n\nint main() {\n    float vehicleSpeed = 70.0f;  // Vehicle speed in km/h\n    float pedestrianDistance = 2.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(vehicleSpeed, pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses steering angle and object distance to trigger collision warnings.",
      "input": "Use the steering angle of the vehicle along with the object distance to predict the likelihood of a collision and trigger warnings accordingly.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Threshold for collision in meters\nconst float STEERING_ANGLE_THRESHOLD = 45.0f;  // Steering angle threshold in degrees\n\n// Function to calculate collision risk based on steering angle and distance\nbool isCollisionRisk(float steeringAngle, float objectDistance) {\n    if (std::abs(steeringAngle) > STEERING_ANGLE_THRESHOLD) {\n        return objectDistance < COLLISION_THRESHOLD / 2;  // More risky if steering sharply\n    }\n    return objectDistance < COLLISION_THRESHOLD;  // Regular collision risk check\n}\n\nint main() {\n    float steeringAngle = 50.0f;  // Steering angle in degrees\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Steering Angle: \" << steeringAngle << \" degrees\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(steeringAngle, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system using data from multiple sensors (radar, camera, LIDAR) with weighted contribution for collision prediction.",
      "input": "Ensure that radar, camera, and LIDAR data contribute differently to the collision risk assessment based on their reliability and distance accuracy.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float RADAR_WEIGHT = 0.4f;  // Weight for radar data\nconst float CAMERA_WEIGHT = 0.3f;  // Weight for camera data\nconst float LIDAR_WEIGHT = 0.3f;  // Weight for LIDAR data\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision threshold in meters\n\n// Function to check collision risk with weighted sensor data\nbool isCollisionRisk(float radarDistance, float cameraDistance, float lidarDistance) {\n    float weightedDistance = (radarDistance * RADAR_WEIGHT + cameraDistance * CAMERA_WEIGHT + lidarDistance * LIDAR_WEIGHT);\n    return weightedDistance < COLLISION_THRESHOLD;  // Check if combined weighted distance is below threshold\n}\n\nint main() {\n    float radarDistance = 4.0f;  // Radar distance in meters\n    float cameraDistance = 5.0f;  // Camera distance in meters\n    float lidarDistance = 6.0f;  // LIDAR distance in meters\n\n    std::cout << \"Radar Distance: \" << radarDistance << \" meters\" << std::endl;\n    std::cout << \"Camera Distance: \" << cameraDistance << \" meters\" << std::endl;\n    std::cout << \"LIDAR Distance: \" << lidarDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(radarDistance, cameraDistance, lidarDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that estimates the future trajectory of an object and predicts collisions based on vehicle movement.",
      "input": "Implement a predictive model that estimates the trajectory of obstacles and predicts potential collisions considering vehicle motion.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Threshold for collision in meters\n\n// Function to estimate future position of an object based on velocity\nfloat predictObjectPosition(float currentDistance, float velocity, float time) {\n    return currentDistance + velocity * time;  // Simple trajectory prediction based on velocity\n}\n\nint main() {\n    float currentDistance = 10.0f;  // Current distance to object in meters\n    float objectVelocity = 2.0f;  // Object velocity in meters per second\n    float predictionTime = 5.0f;  // Time in seconds for prediction\n\n    float predictedPosition = predictObjectPosition(currentDistance, objectVelocity, predictionTime);\n\n    std::cout << \"Predicted Position of Object after \" << predictionTime << \" seconds: \" << predictedPosition << \" meters\" << std::endl;\n\n    if (predictedPosition < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses night vision camera data to detect obstacles and predict collision risks.",
      "input": "Process night vision data to detect obstacles and trigger collision warnings when detected obstacles are within a specified distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float NIGHT_VISION_COLLISION_THRESHOLD = 10.0f;  // Threshold for collision in meters based on night vision\n\n// Function to check collision risk based on night vision data\nbool isCollisionRisk(float objectDistance) {\n    return objectDistance < NIGHT_VISION_COLLISION_THRESHOLD;  // Check if object is too close based on night vision data\n}\n\nint main() {\n    float objectDistance = 8.0f;  // Object distance in meters based on night vision camera\n\n    std::cout << \"Object Distance (Night Vision): \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on rain sensor input.",
      "input": "Integrate a rain sensor to adjust the collision warning threshold, increasing the warning distance in wet conditions.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_DRY = 5.0f;  // Collision threshold for dry conditions in meters\nconst float COLLISION_THRESHOLD_WET = 8.0f;  // Collision threshold for wet conditions in meters\n\n// Function to check collision risk based on weather conditions\nbool isCollisionRisk(bool isWetWeather, float objectDistance) {\n    float threshold = isWetWeather ? COLLISION_THRESHOLD_WET : COLLISION_THRESHOLD_DRY;\n    return objectDistance < threshold;  // Check if object distance is less than adjusted threshold\n}\n\nint main() {\n    bool isWetWeather = true;  // Simulate wet weather condition based on rain sensor input\n    float objectDistance = 6.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isWetWeather, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts collisions at intersections based on vehicle position and angle.",
      "input": "Estimate the collision risk when a vehicle is approaching an intersection, considering its position and heading angle.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 10.0f;  // Collision threshold in meters\nconst float INTERSECTION_SAFE_DISTANCE = 5.0f;  // Safe distance at intersection\n\n// Function to check intersection collision risk\nbool isIntersectionCollisionRisk(float vehiclePosition, float vehicleHeading, float objectDistance) {\n    // If vehicle is within the intersection zone and heading towards it\n    if (vehiclePosition < INTERSECTION_SAFE_DISTANCE && std::abs(vehicleHeading) < 45.0f) {\n        return objectDistance < COLLISION_THRESHOLD;  // Check if object is within threshold distance\n    }\n    return false;  // No risk if not at intersection or not heading towards it\n}\n\nint main() {\n    float vehiclePosition = 4.0f;  // Vehicle's distance from intersection in meters\n    float vehicleHeading = 30.0f;  // Vehicle heading in degrees\n    float objectDistance = 8.0f;  // Distance to detected object in meters\n\n    std::cout << \"Vehicle Position: \" << vehiclePosition << \" meters from intersection\" << std::endl;\n    std::cout << \"Vehicle Heading: \" << vehicleHeading << \" degrees\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isIntersectionCollisionRisk(vehiclePosition, vehicleHeading, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK AT INTERSECTION!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the warning threshold based on vehicle speed in dense traffic conditions.",
      "input": "Adjust the threshold for collision warning in dense traffic by reducing the warning distance based on the vehicle speed.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 5.0f;  // Threshold at high speed in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 3.0f;  // Threshold at low speed in meters\nconst float TRAFFIC_DENSITY = 0.7f;  // Simulated traffic density (0 to 1)\n\n// Function to check collision risk based on speed and traffic density\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    // Adjust threshold based on speed and traffic density\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    if (TRAFFIC_DENSITY > 0.6f) {\n        threshold = COLLISION_THRESHOLD_LOW_SPEED;  // Tighter threshold in dense traffic\n    }\n    return objectDistance < threshold;  // Check if object is too close based on adjusted threshold\n}\n\nint main() {\n    float vehicleSpeed = 40.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses vehicle headlights and fog detection to adjust the collision warning threshold.",
      "input": "Consider the effect of headlights and fog detection data to adjust the warning threshold for better collision prediction in low-visibility conditions.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CLEAR = 10.0f;  // Collision threshold in clear conditions\nconst float COLLISION_THRESHOLD_FOG = 6.0f;  // Collision threshold in foggy conditions\n\n// Function to check collision risk based on fog and headlights\nbool isCollisionRisk(bool isFoggy, bool headlightsOn, float objectDistance) {\n    float threshold = isFoggy ? COLLISION_THRESHOLD_FOG : COLLISION_THRESHOLD_CLEAR;\n    if (headlightsOn) {\n        threshold = threshold * 1.5f;  // Increased threshold with headlights on\n    }\n    return objectDistance < threshold;  // Check if object distance is below threshold\n}\n\nint main() {\n    bool isFoggy = true;  // Simulated fog condition\n    bool headlightsOn = true;  // Simulated headlights on\n    float objectDistance = 7.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isFoggy, headlightsOn, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that incorporates lane departure detection to adjust collision warning behavior.",
      "input": "Integrate lane departure detection data to adjust the threshold and urgency of collision warnings, increasing the risk when the vehicle is leaving its lane.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_DEPARTURE = 4.0f;  // Threshold when lane departure is detected\nconst float COLLISION_THRESHOLD_NORMAL = 5.0f;  // Normal threshold\n\n// Function to check collision risk with lane departure data\nbool isCollisionRisk(bool isLaneDepartureDetected, float objectDistance) {\n    float threshold = isLaneDepartureDetected ? COLLISION_THRESHOLD_LANE_DEPARTURE : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if object distance is less than adjusted threshold\n}\n\nint main() {\n    bool isLaneDepartureDetected = true;  // Simulate lane departure detection\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isLaneDepartureDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO LANE DEPARTURE!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that predicts pedestrian collisions by detecting pedestrians and predicting their path relative to the vehicle.",
      "input": "Use pedestrian detection data and predict their future path, adjusting the collision warning if the predicted path intersects with the vehicle\\u2019s trajectory.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 2.5f;  // Collision threshold in meters\n\n// Function to predict pedestrian's future position\nfloat predictPedestrianPosition(float pedestrianDistance, float pedestrianVelocity, float time) {\n    return pedestrianDistance + pedestrianVelocity * time;  // Predict future position based on velocity\n}\n\nint main() {\n    float pedestrianDistance = 10.0f;  // Distance to pedestrian in meters\n    float pedestrianVelocity = 1.5f;  // Pedestrian velocity in meters per second\n    float predictionTime = 3.0f;  // Time to predict in seconds\n\n    float predictedPedestrianPosition = predictPedestrianPosition(pedestrianDistance, pedestrianVelocity, predictionTime);\n\n    std::cout << \"Predicted Pedestrian Position after \" << predictionTime << \" seconds: \" << predictedPedestrianPosition << \" meters\" << std::endl;\n\n    if (predictedPedestrianPosition < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on vehicle weight and cargo.",
      "input": "Consider the weight and cargo data to adjust the threshold for collision warning, increasing the warning distance for heavier vehicles with more cargo.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BASE_COLLISION_THRESHOLD = 5.0f;  // Base collision threshold in meters\nconst float WEIGHT_THRESHOLD = 2000.0f;  // Weight threshold for heavier vehicles in kg\nconst float CARGO_THRESHOLD = 500.0f;  // Cargo threshold in kg\n\n// Function to check collision risk based on vehicle weight and cargo\nbool isCollisionRisk(float vehicleWeight, float cargoWeight, float objectDistance) {\n    float threshold = BASE_COLLISION_THRESHOLD;\n    if (vehicleWeight > WEIGHT_THRESHOLD || cargoWeight > CARGO_THRESHOLD) {\n        threshold += 2.0f;  // Increase threshold for heavier vehicles and cargo\n    }\n    return objectDistance < threshold;  // Check if object is within threshold\n}\n\nint main() {\n    float vehicleWeight = 2500.0f;  // Vehicle weight in kg\n    float cargoWeight = 600.0f;  // Cargo weight in kg\n    float objectDistance = 6.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Weight: \" << vehicleWeight << \" kg\" << std::endl;\n    std::cout << \"Cargo Weight: \" << cargoWeight << \" kg\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleWeight, cargoWeight, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO VEHICLE WEIGHT AND CARGO!\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on pedestrian detection and vehicle speed.",
      "input": "Adjust the collision warning threshold when a pedestrian is detected, considering the vehicle's speed to trigger earlier warnings at higher speeds.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN_SLOW = 5.0f;  // Threshold for slow speed in meters\nconst float COLLISION_THRESHOLD_PEDESTRIAN_FAST = 3.0f;  // Threshold for fast speed in meters\n\n// Function to check collision risk based on pedestrian detection and vehicle speed\nbool isPedestrianCollisionRisk(bool isPedestrianDetected, float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_PEDESTRIAN_FAST : COLLISION_THRESHOLD_PEDESTRIAN_SLOW;\n    return isPedestrianDetected && objectDistance < threshold;  // Check if pedestrian is detected and object is too close\n}\n\n// Test case\nint main() {\n    bool isPedestrianDetected = true;  // Simulated pedestrian detection\n    float vehicleSpeed = 60.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to detected pedestrian in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(isPedestrianDetected, vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the night mode sensor input.",
      "input": "Consider the night mode sensor to decrease the collision warning threshold at night for better visibility and reaction time.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_DAY = 10.0f;  // Threshold during day in meters\nconst float COLLISION_THRESHOLD_NIGHT = 5.0f;  // Threshold during night in meters\n\n// Function to check collision risk based on night mode detection\nbool isCollisionRisk(bool isNightMode, float objectDistance) {\n    float threshold = isNightMode ? COLLISION_THRESHOLD_NIGHT : COLLISION_THRESHOLD_DAY;\n    return objectDistance < threshold;  // Check if object is too close for night mode\n}\n\n// Test case\nint main() {\n    bool isNightMode = true;  // Simulate night mode based on sensor input\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isNightMode, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers an alert if a lane change is detected and a vehicle is too close.",
      "input": "Detect lane changes and trigger a collision warning if a vehicle is detected in the adjacent lane and the distance is too close.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 3.0f;  // Threshold for lane change in meters\n\n// Function to check collision risk during lane change\nbool isLaneChangeCollisionRisk(bool isLaneChangeDetected, float objectDistance) {\n    return isLaneChangeDetected && objectDistance < COLLISION_THRESHOLD_LANE_CHANGE;  // Check if lane change is detected and object is too close\n}\n\n// Test case\nint main() {\n    bool isLaneChangeDetected = true;  // Simulate lane change detection\n    float objectDistance = 2.5f;  // Distance to object in adjacent lane in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeCollisionRisk(isLaneChangeDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DURING LANE CHANGE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that integrates with automatic emergency braking to stop the car when collision risk is detected.",
      "input": "Trigger the automatic emergency braking system when the collision risk exceeds the threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // Collision threshold in meters\n\n// Function to simulate automatic emergency braking\nvoid applyEmergencyBraking() {\n    std::cout << \"Automatic Emergency Braking Activated!\" << std::endl;\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        applyEmergencyBraking();  // Trigger emergency braking\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning based on detected speed limits.",
      "input": "Integrate speed limit detection to modify the collision warning threshold when approaching a zone with reduced speed limits.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_NORMAL = 10.0f;  // Normal collision threshold in meters\nconst float COLLISION_THRESHOLD_SPEED_LIMIT = 6.0f;  // Adjusted threshold in reduced speed zones\n\n// Function to check collision risk based on speed limit zone\nbool isCollisionRisk(bool isSpeedLimitDetected, float objectDistance) {\n    float threshold = isSpeedLimitDetected ? COLLISION_THRESHOLD_SPEED_LIMIT : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if object is too close based on adjusted threshold\n}\n\n// Test case\nint main() {\n    bool isSpeedLimitDetected = true;  // Simulate speed limit detection\n    float objectDistance = 5.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isSpeedLimitDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO SPEED LIMIT!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold based on the detected vehicle type (e.g., truck, car).",
      "input": "Adjust the collision warning threshold when detecting different types of vehicles (truck vs. car) for better risk assessment.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CAR = 5.0f;  // Threshold for cars in meters\nconst float COLLISION_THRESHOLD_TRUCK = 8.0f;  // Threshold for trucks in meters\n\n// Function to check collision risk based on vehicle type\nbool isCollisionRisk(std::string vehicleType, float objectDistance) {\n    float threshold = (vehicleType == \"truck\") ? COLLISION_THRESHOLD_TRUCK : COLLISION_THRESHOLD_CAR;\n    return objectDistance < threshold;  // Check if object distance is less than threshold\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"truck\";  // Simulate detection of a truck\n    float objectDistance = 6.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH VEHICLE TYPE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on weather conditions.",
      "input": "Adjust the collision warning threshold during adverse weather conditions (e.g., rain, fog) to trigger warnings at a closer distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_NORMAL = 10.0f;  // Normal threshold in meters\nconst float COLLISION_THRESHOLD_WEATHER = 5.0f;  // Reduced threshold in adverse weather\n\n// Function to check collision risk based on weather condition\nbool isCollisionRisk(bool isAdverseWeather, float objectDistance) {\n    float threshold = isAdverseWeather ? COLLISION_THRESHOLD_WEATHER : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if object is too close in adverse weather\n}\n\n// Test case\nint main() {\n    bool isAdverseWeather = true;  // Simulate adverse weather (rain or fog)\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isAdverseWeather, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DUE TO WEATHER!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the threshold for pedestrian and vehicle collision risk based on distance to the object.",
      "input": "Decrease the collision warning threshold as the vehicle approaches an object (pedestrian or other vehicle).",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_NEAR = 3.0f;  // Threshold for close objects in meters\nconst float COLLISION_THRESHOLD_FAR = 8.0f;  // Threshold for farther objects in meters\n\n// Function to check collision risk based on distance\nbool isCollisionRisk(float objectDistance) {\n    float threshold = (objectDistance < 5.0f) ? COLLISION_THRESHOLD_NEAR : COLLISION_THRESHOLD_FAR;\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that dynamically adjusts the collision warning threshold based on the vehicle's speed.",
      "input": "If the vehicle's speed exceeds 80 km/h, reduce the collision warning threshold to account for faster closing rates.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_SLOW = 15.0f;  // Threshold for slow speeds in meters\nconst float COLLISION_THRESHOLD_FAST = 5.0f;  // Threshold for fast speeds in meters\n\n// Function to check collision risk based on speed\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 80.0f) ? COLLISION_THRESHOLD_FAST : COLLISION_THRESHOLD_SLOW;\n    return objectDistance < threshold;  // Check if object is too close based on vehicle speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 90.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold depending on the type of object (pedestrian, vehicle, cyclist).",
      "input": "Set a higher warning threshold for pedestrians and cyclists, while using a lower threshold for vehicles to allow quicker responses.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_CYCLIST = 5.0f;  // Threshold for cyclists in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 2.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk based on object type\nbool isCollisionRisk(std::string objectType, float objectDistance) {\n    float threshold;\n    if (objectType == \"pedestrian\") {\n        threshold = COLLISION_THRESHOLD_PEDESTRIAN;\n    } else if (objectType == \"cyclist\") {\n        threshold = COLLISION_THRESHOLD_CYCLIST;\n    } else {\n        threshold = COLLISION_THRESHOLD_VEHICLE;\n    }\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Object type (e.g., vehicle, pedestrian, cyclist)\n    float objectDistance = 1.5f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the warning threshold based on road curvature.",
      "input": "If road curvature is detected, reduce the collision threshold to account for reduced stopping distances.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_STRAIGHT = 10.0f;  // Threshold for straight road in meters\nconst float COLLISION_THRESHOLD_CURVED = 5.0f;  // Threshold for curved road in meters\n\n// Function to check collision risk based on road curvature\nbool isCollisionRisk(bool isCurvedRoad, float objectDistance) {\n    float threshold = isCurvedRoad ? COLLISION_THRESHOLD_CURVED : COLLISION_THRESHOLD_STRAIGHT;\n    return objectDistance < threshold;  // Check if object is too close based on road curvature\n}\n\n// Test case\nint main() {\n    bool isCurvedRoad = true;  // Simulate road curvature detection\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Road Curvature: \" << (isCurvedRoad ? \"Curved\" : \"Straight\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isCurvedRoad, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on fog detection.",
      "input": "When fog is detected, reduce the collision threshold to allow quicker response times due to limited visibility.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CLEAR = 15.0f;  // Threshold for clear visibility in meters\nconst float COLLISION_THRESHOLD_FOG = 5.0f;  // Reduced threshold in foggy conditions\n\n// Function to check collision risk based on fog detection\nbool isCollisionRisk(bool isFogDetected, float objectDistance) {\n    float threshold = isFogDetected ? COLLISION_THRESHOLD_FOG : COLLISION_THRESHOLD_CLEAR;\n    return objectDistance < threshold;  // Check if object is too close in fog\n}\n\n// Test case\nint main() {\n    bool isFogDetected = true;  // Simulate fog detection\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Fog Detected: \" << (isFogDetected ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(isFogDetected, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK IN FOG!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that prioritizes pedestrians when multiple objects are detected.",
      "input": "If both a vehicle and pedestrian are detected, prioritize the pedestrian for collision warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk, prioritizing pedestrians\nbool isCollisionRisk(std::string objectType, float objectDistance) {\n    if (objectType == \"pedestrian\" && objectDistance < COLLISION_THRESHOLD_PEDESTRIAN) {\n        return true;  // Prioritize pedestrian if close\n    } else if (objectType == \"vehicle\" && objectDistance < COLLISION_THRESHOLD_VEHICLE) {\n        return true;  // Vehicle warning if too close\n    }\n    return false;  // No risk\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Simulate vehicle detection\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the size of the detected object.",
      "input": "Use a larger threshold for smaller objects and a smaller threshold for larger objects to account for different stopping distances.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 5.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 3.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk based on object size\nbool isCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 3.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on size\n}\n\n// Test case\nint main() {\n    float objectSize = 2.5f;  // Size of object in meters\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that differentiates collision risks based on vehicle type.",
      "input": "Trigger a more urgent warning for trucks, while using a more lenient warning for sedans.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_TRUCK = 2.0f;  // Threshold for trucks in meters\nconst float COLLISION_THRESHOLD_SEDAN = 5.0f;  // Threshold for sedans in meters\n\n// Function to check collision risk based on vehicle type\nbool isCollisionRisk(std::string vehicleType, float objectDistance) {\n    float threshold;\n    if (vehicleType == \"truck\") {\n        threshold = COLLISION_THRESHOLD_TRUCK;\n    } else {\n        threshold = COLLISION_THRESHOLD_SEDAN;\n    }\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"truck\";  // Simulate vehicle type detection\n    float objectDistance = 1.8f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH VEHICLE TYPE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that handles multiple objects and triggers individual warnings based on their risk levels.",
      "input": "Detect both a vehicle and pedestrian and trigger different warnings for each object based on their distance.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk for multiple objects\nbool isCollisionRisk(std::string objectType, float objectDistance) {\n    if (objectType == \"pedestrian\" && objectDistance < COLLISION_THRESHOLD_PEDESTRIAN) {\n        return true;  // Collision risk for pedestrians\n    } else if (objectType == \"vehicle\" && objectDistance < COLLISION_THRESHOLD_VEHICLE) {\n        return true;  // Collision risk for vehicles\n    }\n    return false;  // No risk\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Simulate vehicle detection\n    float objectDistance = 4.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision warning based on the speed of a detected object.",
      "input": "If an object is approaching at a high speed, reduce the collision threshold to trigger an earlier warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_SLOW_OBJECT = 10.0f;  // Threshold for slow objects in meters\nconst float COLLISION_THRESHOLD_FAST_OBJECT = 3.0f;  // Threshold for fast objects in meters\n\n// Function to check collision risk based on object speed\nbool isCollisionRisk(float objectSpeed, float objectDistance) {\n    float threshold = (objectSpeed > 20.0f) ? COLLISION_THRESHOLD_FAST_OBJECT : COLLISION_THRESHOLD_SLOW_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on its speed\n}\n\n// Test case\nint main() {\n    float objectSpeed = 25.0f;  // Object speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that combines object type and speed to adjust the collision warning threshold.",
      "input": "For fast-moving vehicles, use a shorter threshold; for pedestrians, use a longer threshold regardless of speed.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\nconst float COLLISION_THRESHOLD_VEHICLE_FAST = 2.0f;  // Threshold for fast vehicles in meters\nconst float COLLISION_THRESHOLD_VEHICLE_SLOW = 5.0f;  // Threshold for slow vehicles in meters\n\n// Function to check collision risk based on object type and speed\nbool isCollisionRisk(std::string objectType, float objectSpeed, float objectDistance) {\n    float threshold;\n    if (objectType == \"pedestrian\") {\n        threshold = COLLISION_THRESHOLD_PEDESTRIAN;\n    } else if (objectSpeed > 20.0f) {\n        threshold = COLLISION_THRESHOLD_VEHICLE_FAST;\n    } else {\n        threshold = COLLISION_THRESHOLD_VEHICLE_SLOW;\n    }\n    return objectDistance < threshold;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    std::string objectType = \"vehicle\";  // Object type (pedestrian or vehicle)\n    float objectSpeed = 25.0f;  // Speed of the object in km/h\n    float objectDistance = 1.5f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectType, objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold based on the size of the detected object.",
      "input": "For larger objects, decrease the threshold to trigger the collision warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 4.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 7.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk based on object size\nbool isCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 2.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on size\n}\n\n// Test case\nint main() {\n    float objectSize = 2.5f;  // Object size in meters\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that calculates the collision risk based on vehicle detection logic and distance.",
      "input": "Trigger the warning when the vehicle is within a certain distance and moving towards the system at a high speed.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_VEHICLE = 3.0f;  // Threshold for vehicles in meters\n\n// Function to check collision risk based on vehicle detection logic\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return (vehicleSpeed > 15.0f) && (objectDistance < COLLISION_THRESHOLD_VEHICLE);  // Vehicle approaching fast\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 20.0f;  // Vehicle speed in km/h\n    float objectDistance = 2.5f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that dynamically adjusts the collision warning threshold based on the relative speed of the vehicle and the detected object.",
      "input": "If the relative speed exceeds a threshold, reduce the collision threshold to trigger the warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_SLOW_RELATIVE_SPEED = 8.0f;  // Threshold for slow relative speed in meters\nconst float COLLISION_THRESHOLD_FAST_RELATIVE_SPEED = 4.0f;  // Threshold for fast relative speed in meters\n\n// Function to check collision risk based on relative speed\nbool isCollisionRisk(float relativeSpeed, float objectDistance) {\n    float threshold = (relativeSpeed > 25.0f) ? COLLISION_THRESHOLD_FAST_RELATIVE_SPEED : COLLISION_THRESHOLD_SLOW_RELATIVE_SPEED;\n    return objectDistance < threshold;  // Check if object is too close based on relative speed\n}\n\n// Test case\nint main() {\n    float relativeSpeed = 30.0f;  // Relative speed between vehicle and object in km/h\n    float objectDistance = 3.5f;  // Distance to object in meters\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(relativeSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that specifically checks for pedestrians in the detection zone and triggers a warning accordingly.",
      "input": "Use a smaller threshold for pedestrians due to their smaller size and faster response time required.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 2.0f;  // Threshold for pedestrians in meters\n\n// Function to check collision risk for pedestrians\nbool isPedestrianCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Pedestrian risk detection\n}\n\n// Test case\nint main() {\n    float objectDistance = 1.8f;  // Distance to pedestrian in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that calculates the time to collision and adjusts the warning level accordingly.",
      "input": "If the time to collision is less than 2 seconds, trigger an urgent warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_URGENT = 2.0f;  // Urgent warning threshold in seconds\nconst float COLLISION_THRESHOLD_NORMAL = 5.0f;  // Normal warning threshold in seconds\n\n// Function to check collision risk based on time to collision\nbool isUrgentCollisionRisk(float timeToCollision) {\n    return timeToCollision < COLLISION_THRESHOLD_URGENT;  // Urgent warning if time to collision is less than threshold\n}\n\n// Test case\nint main() {\n    float timeToCollision = 1.5f;  // Time to collision in seconds\n\n    std::cout << \"Time to Collision: \" << timeToCollision << \" seconds\" << std::endl;\n\n    if (isUrgentCollisionRisk(timeToCollision)) {\n        std::cout << \"WARNING: URGENT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Urgent Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high-speed vehicles and triggers a warning based on their relative velocity.",
      "input": "If the vehicle is approaching at a high relative speed, trigger an earlier warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 2.0f;  // Threshold for high-speed vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL_SPEED = 5.0f;  // Threshold for normal-speed vehicles in meters\n\n// Function to check collision risk based on relative speed\nbool isHighSpeedVehicleRisk(float relativeSpeed, float objectDistance) {\n    float threshold = (relativeSpeed > 25.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_NORMAL_SPEED;\n    return objectDistance < threshold;  // Check if vehicle is too close at high speed\n}\n\n// Test case\nint main() {\n    float relativeSpeed = 30.0f;  // Relative speed in km/h\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isHighSpeedVehicleRisk(relativeSpeed, objectDistance)) {\n        std::cout << \"WARNING: HIGH SPEED VEHICLE COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No High-Speed Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if the detected vehicle is braking while approaching.",
      "input": "If the vehicle is braking, trigger a collision warning with a reduced distance threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_BRAKING_VEHICLE = 2.0f;  // Threshold for braking vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL = 5.0f;  // Normal threshold for non-braking vehicles\n\n// Function to check collision risk for braking vehicles\nbool isBrakingVehicleRisk(bool isBraking, float objectDistance) {\n    float threshold = (isBraking) ? COLLISION_THRESHOLD_BRAKING_VEHICLE : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if vehicle is too close when braking\n}\n\n// Test case\nint main() {\n    bool isBraking = true;  // Vehicle is braking\n    float objectDistance = 2.5f;  // Distance to braking vehicle in meters\n\n    std::cout << \"Is Vehicle Braking: \" << (isBraking ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isBrakingVehicleRisk(isBraking, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH BRAKING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Braking Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses time to collision to determine the urgency of the warning.",
      "input": "If the time to collision is less than 3 seconds, trigger a high-priority warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_PRIORITY = 3.0f;  // Time threshold for high priority warning in seconds\nconst float COLLISION_THRESHOLD_LOW_PRIORITY = 5.0f;  // Time threshold for low priority warning in seconds\n\n// Function to check collision risk based on time to collision\nbool isUrgentCollisionRisk(float timeToCollision) {\n    return timeToCollision < COLLISION_THRESHOLD_HIGH_PRIORITY;  // Urgent risk if time to collision is less than threshold\n}\n\n// Test case\nint main() {\n    float timeToCollision = 2.5f;  // Time to collision in seconds\n\n    std::cout << \"Time to Collision: \" << timeToCollision << \" seconds\" << std::endl;\n\n    if (isUrgentCollisionRisk(timeToCollision)) {\n        std::cout << \"WARNING: URGENT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Urgent Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision warning based on vehicle type (e.g., truck vs. car).",
      "input": "If the detected vehicle is a truck, set a longer warning threshold.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_CAR = 5.0f;  // Threshold for cars in meters\nconst float COLLISION_THRESHOLD_TRUCK = 10.0f;  // Threshold for trucks in meters\n\n// Function to check collision risk based on vehicle type\nbool isCollisionRisk(std::string vehicleType, float objectDistance) {\n    float threshold = (vehicleType == \"truck\") ? COLLISION_THRESHOLD_TRUCK : COLLISION_THRESHOLD_CAR;\n    return objectDistance < threshold;  // Check if vehicle is too close based on type\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"truck\";  // Vehicle type (car or truck)\n    float objectDistance = 8.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the size of the detected object.",
      "input": "If the object is large, trigger the collision warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 4.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 6.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk based on object size\nbool isCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 2.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if object is too close based on size\n}\n\n// Test case\nint main() {\n    float objectSize = 3.0f;  // Object size in meters\n    float objectDistance = 3.5f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers an early warning when the relative speed between vehicles is high.",
      "input": "If the relative speed between the own vehicle and a detected object exceeds 30 km/h, trigger a warning earlier.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed collisions in meters\nconst float COLLISION_THRESHOLD_NORMAL_SPEED = 6.0f;  // Threshold for normal-speed collisions in meters\n\n// Function to check collision risk based on relative speed\nbool isHighSpeedCollisionRisk(float relativeSpeed, float objectDistance) {\n    float threshold = (relativeSpeed > 30.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_NORMAL_SPEED;\n    return objectDistance < threshold;  // Check if object is too close at high relative speed\n}\n\n// Test case\nint main() {\n    float relativeSpeed = 35.0f;  // Relative speed in km/h\n    float objectDistance = 2.5f;  // Distance to object in meters\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isHighSpeedCollisionRisk(relativeSpeed, objectDistance)) {\n        std::cout << \"WARNING: HIGH SPEED COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No High-Speed Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that specifically detects pedestrians and triggers a collision warning accordingly.",
      "input": "If a pedestrian is detected and within a distance of 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrians in meters\n\n// Function to check collision risk for pedestrians\nbool isPedestrianCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Pedestrian risk detection\n}\n\n// Test case\nint main() {\n    float objectDistance = 2.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks if a detected vehicle is braking and adjusts the collision threshold accordingly.",
      "input": "If the detected vehicle is braking, use a shorter collision threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_BRAKING = 3.0f;  // Threshold for braking vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL = 6.0f;  // Normal threshold for non-braking vehicles in meters\n\n// Function to check collision risk based on braking\nbool isBrakingCollisionRisk(bool isBraking, float objectDistance) {\n    float threshold = (isBraking) ? COLLISION_THRESHOLD_BRAKING : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if vehicle is too close when braking\n}\n\n// Test case\nint main() {\n    bool isBraking = true;  // Braking condition\n    float objectDistance = 3.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Is Vehicle Braking: \" << (isBraking ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isBrakingCollisionRisk(isBraking, objectDistance)) {\n        std::cout << \"WARNING: VEHICLE IS BRAKING! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Braking Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if the vehicle in the adjacent lane is changing lanes.",
      "input": "If the adjacent vehicle is detected as changing lanes, check if it's within a critical distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 4.0f;  // Threshold for lane-change collision in meters\n\n// Function to check collision risk with lane-changing vehicle\nbool isLaneChangeCollisionRisk(bool isChangingLane, float objectDistance) {\n    return (isChangingLane && objectDistance < COLLISION_THRESHOLD_LANE_CHANGE);  // Check if vehicle is changing lanes and too close\n}\n\n// Test case\nint main() {\n    bool isChangingLane = true;  // Lane change condition\n    float objectDistance = 3.5f;  // Distance to lane-changing vehicle in meters\n\n    std::cout << \"Is Vehicle Changing Lane: \" << (isChangingLane ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeCollisionRisk(isChangingLane, objectDistance)) {\n        std::cout << \"WARNING: VEHICLE IS CHANGING LANE! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision detection based on the speed of the object detected.",
      "input": "If the object is moving at high speed, trigger a warning if it is within a closer distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_FAST_OBJECT = 3.0f;  // Threshold for fast-moving objects in meters\nconst float COLLISION_THRESHOLD_SLOW_OBJECT = 6.0f;  // Threshold for slow-moving objects in meters\n\n// Function to check collision risk based on object speed\nbool isFastObjectCollisionRisk(float objectSpeed, float objectDistance) {\n    float threshold = (objectSpeed > 20.0f) ? COLLISION_THRESHOLD_FAST_OBJECT : COLLISION_THRESHOLD_SLOW_OBJECT;\n    return objectDistance < threshold;  // Check if fast object is too close\n}\n\n// Test case\nint main() {\n    float objectSpeed = 25.0f;  // Object speed in km/h\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isFastObjectCollisionRisk(objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: FAST OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Fast Object Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a collision warning if the detected vehicle is turning and within a certain distance.",
      "input": "If the detected vehicle is turning, reduce the threshold distance for collision detection.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_TURNING = 3.0f;  // Threshold for turning vehicles in meters\nconst float COLLISION_THRESHOLD_NORMAL = 6.0f;  // Normal threshold for non-turning vehicles\n\n// Function to check collision risk for turning vehicles\nbool isTurningVehicleRisk(bool isTurning, float objectDistance) {\n    float threshold = (isTurning) ? COLLISION_THRESHOLD_TURNING : COLLISION_THRESHOLD_NORMAL;\n    return objectDistance < threshold;  // Check if vehicle is turning and too close\n}\n\n// Test case\nint main() {\n    bool isTurning = true;  // Vehicle is turning\n    float objectDistance = 2.5f;  // Distance to turning vehicle in meters\n\n    std::cout << \"Is Vehicle Turning: \" << (isTurning ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isTurningVehicleRisk(isTurning, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH TURNING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Turning Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning based on the direction of a detected object (e.g., moving towards or away from the vehicle).",
      "input": "If the detected object is moving toward the vehicle and within a specific distance, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_APPROACHING = 3.0f;  // Threshold for objects approaching the vehicle in meters\nconst float COLLISION_THRESHOLD_RECEDING = 6.0f;  // Threshold for receding objects in meters\n\n// Function to check collision risk based on object direction\nbool isApproachingCollisionRisk(std::string objectDirection, float objectDistance) {\n    float threshold = (objectDirection == \"approaching\") ? COLLISION_THRESHOLD_APPROACHING : COLLISION_THRESHOLD_RECEDING;\n    return objectDistance < threshold;  // Check if object is too close based on direction\n}\n\n// Test case\nint main() {\n    std::string objectDirection = \"approaching\";  // Object's direction\n    float objectDistance = 2.5f;  // Distance to object in meters\n\n    std::cout << \"Object Direction: \" << objectDirection << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isApproachingCollisionRisk(objectDirection, objectDistance)) {\n        std::cout << \"WARNING: APPROACHING OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if a detected vehicle is too close and changing lanes towards your vehicle.",
      "input": "If a vehicle is in the adjacent lane and moving towards your lane, trigger a warning when it is within a specific threshold.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 4.0f;  // Threshold for lane change collision risk in meters\n\n// Function to check lane change collision risk\nbool isLaneChangeRisk(bool isMovingTowards, float objectDistance) {\n    return isMovingTowards && objectDistance < COLLISION_THRESHOLD_LANE_CHANGE;  // Check if object is too close while moving towards the lane\n}\n\n// Test case\nint main() {\n    bool isMovingTowards = true;  // Vehicle moving towards own lane\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Is Vehicle Moving Towards Lane: \" << (isMovingTowards ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeRisk(isMovingTowards, objectDistance)) {\n        std::cout << \"WARNING: VEHICLE CHANGING LANES TOWARDS YOU! COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks the movement speed of pedestrians and triggers a warning based on their speed and proximity.",
      "input": "If the pedestrian is moving fast and within 2 meters, trigger a collision warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN_FAST = 2.0f;  // Threshold for fast-moving pedestrians in meters\nconst float COLLISION_THRESHOLD_PEDESTRIAN_SLOW = 4.0f;  // Threshold for slow-moving pedestrians in meters\n\n// Function to check collision risk with pedestrian\nbool isPedestrianCollisionRisk(float pedestrianSpeed, float objectDistance) {\n    float threshold = (pedestrianSpeed > 3.0f) ? COLLISION_THRESHOLD_PEDESTRIAN_FAST : COLLISION_THRESHOLD_PEDESTRIAN_SLOW;\n    return objectDistance < threshold;  // Check if pedestrian is too close\n}\n\n// Test case\nint main() {\n    float pedestrianSpeed = 4.5f;  // Pedestrian speed in meters/second\n    float objectDistance = 1.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Pedestrian Speed: \" << pedestrianSpeed << \" m/s\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning based on the speed of the own vehicle.",
      "input": "If the vehicle speed exceeds 50 km/h, use a shorter collision threshold.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed own vehicle in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;  // Threshold for low-speed own vehicle in meters\n\n// Function to check collision risk based on own vehicle speed\nbool isOwnVehicleSpeedRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return objectDistance < threshold;  // Check if vehicle is too close based on speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 55.0f;  // Own vehicle speed in km/h\n    float objectDistance = 2.5f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isOwnVehicleSpeedRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects large objects and triggers a warning if they are within a short distance.",
      "input": "If the detected object is larger than 2 meters and within 5 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_OBJECT = 5.0f;  // Threshold for large objects in meters\nconst float COLLISION_THRESHOLD_SMALL_OBJECT = 8.0f;  // Threshold for small objects in meters\n\n// Function to check collision risk with large object\nbool isLargeObjectCollisionRisk(float objectSize, float objectDistance) {\n    float threshold = (objectSize > 2.0f) ? COLLISION_THRESHOLD_LARGE_OBJECT : COLLISION_THRESHOLD_SMALL_OBJECT;\n    return objectDistance < threshold;  // Check if large object is too close\n}\n\n// Test case\nint main() {\n    float objectSize = 3.0f;  // Object size in meters\n    float objectDistance = 4.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLargeObjectCollisionRisk(objectSize, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH LARGE OBJECT!\" << std::endl;\n    } else {\n        std::cout << \"No Large Object Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks if two vehicles in adjacent lanes are getting too close, triggering a warning.",
      "input": "If both vehicles are within a critical distance and moving towards each other, trigger a collision warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_ADJACENT_VEHICLES = 3.5f;  // Threshold for adjacent vehicles in meters\n\n// Function to check collision risk with two adjacent vehicles\nbool isAdjacentVehicleCollisionRisk(float vehicle1Distance, float vehicle2Distance) {\n    return (vehicle1Distance < COLLISION_THRESHOLD_ADJACENT_VEHICLES && vehicle2Distance < COLLISION_THRESHOLD_ADJACENT_VEHICLES);  // Check if both vehicles are too close\n}\n\n// Test case\nint main() {\n    float vehicle1Distance = 3.0f;  // Distance to first vehicle in meters\n    float vehicle2Distance = 2.5f;  // Distance to second vehicle in meters\n\n    std::cout << \"Vehicle 1 Distance: \" << vehicle1Distance << \" meters\" << std::endl;\n    std::cout << \"Vehicle 2 Distance: \" << vehicle2Distance << \" meters\" << std::endl;\n\n    if (isAdjacentVehicleCollisionRisk(vehicle1Distance, vehicle2Distance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH ADJACENT VEHICLES!\" << std::endl;\n    } else {\n        std::cout << \"No Adjacent Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a collision warning when multiple objects are detected within a short distance.",
      "input": "If two or more objects are within a certain threshold distance, trigger a warning.",
      "output": "#include <iostream>\n#include <vector>\n\nconst float COLLISION_THRESHOLD_MULTIPLE_OBJECTS = 3.0f;  // Threshold for multiple objects in meters\n\n// Function to check collision risk with multiple objects\nbool areMultipleObjectsCollisionRisk(std::vector<float> objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD_MULTIPLE_OBJECTS) {\n            return true;  // If any object is too close\n        }\n    }\n    return false;\n}\n\n// Test case\nint main() {\n    std::vector<float> objectDistances = {3.0f, 2.5f, 4.0f};  // Distances to multiple objects in meters\n\n    if (areMultipleObjectsCollisionRisk(objectDistances)) {\n        std::cout << \"WARNING: MULTIPLE OBJECTS COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Multiple Objects Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that takes into account traffic light status for collision risk.",
      "input": "If the traffic light is red and an object is approaching within a short distance, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_RED_LIGHT = 2.0f;  // Threshold for objects approaching with red light in meters\n\n// Function to check collision risk with traffic light status\nbool isRedLightCollisionRisk(bool isRedLight, float objectDistance) {\n    return (isRedLight && objectDistance < COLLISION_THRESHOLD_RED_LIGHT);  // Check if traffic light is red and object is too close\n}\n\n// Test case\nint main() {\n    bool isRedLight = true;  // Traffic light status\n    float objectDistance = 1.5f;  // Distance to object in meters\n\n    std::cout << \"Traffic Light Status: \" << (isRedLight ? \"Red\" : \"Green\") << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isRedLightCollisionRisk(isRedLight, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH OBJECT AT RED LIGHT!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision detection based on object size and speed.",
      "input": "For larger and faster objects, trigger a warning if they are within a shorter distance.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LARGE_FAST_OBJECT = 3.0f;  // Threshold for large and fast objects in meters\nconst float COLLISION_THRESHOLD_NORMAL_OBJECT = 6.0f;  // Threshold for normal objects in meters\n\n// Function to check collision risk based on object size and speed\nbool isLargeFastObjectCollisionRisk(float objectSize, float objectSpeed, float objectDistance) {\n    float threshold = (objectSize > 2.0f && objectSpeed > 20.0f) ? COLLISION_THRESHOLD_LARGE_FAST_OBJECT : COLLISION_THRESHOLD_NORMAL_OBJECT;\n    return objectDistance < threshold;  // Check if large and fast object is too close\n}\n\n// Test case\nint main() {\n    float objectSize = 3.5f;  // Object size in meters\n    float objectSpeed = 25.0f;  // Object speed in km/h\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Size: \" << objectSize << \" meters\" << std::endl;\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isLargeFastObjectCollisionRisk(objectSize, objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: LARGE AND FAST OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning based on the speed of an approaching object. If the object is approaching at high speed and within a certain distance, trigger a warning.",
      "input": "If the object's speed is greater than 30 km/h and the object is within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed objects in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 5.0f;  // Threshold for low-speed objects in meters\n\n// Function to check collision risk based on object speed\nbool isObjectSpeedRisk(float objectSpeed, float objectDistance) {\n    float threshold = (objectSpeed > 30.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return objectDistance < threshold;  // Check if object is too close based on speed\n}\n\n// Test case\nint main() {\n    float objectSpeed = 35.0f;  // Object speed in km/h\n    float objectDistance = 2.0f;  // Distance to object in meters\n\n    std::cout << \"Object Speed: \" << objectSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isObjectSpeedRisk(objectSpeed, objectDistance)) {\n        std::cout << \"WARNING: HIGH-SPEED OBJECT COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a vehicle in front that has come to a stop and triggers a warning if the vehicle is too close.",
      "input": "If the vehicle in front has stopped and the distance is less than 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_STOPPED_VEHICLE = 3.0f;  // Threshold for stopped vehicle in meters\n\n// Function to check collision risk with stopped vehicle\nbool isStoppedVehicleCollisionRisk(bool isStopped, float vehicleDistance) {\n    return isStopped && vehicleDistance < COLLISION_THRESHOLD_STOPPED_VEHICLE;  // Check if stopped vehicle is too close\n}\n\n// Test case\nint main() {\n    bool isStopped = true;  // Vehicle status (stopped)\n    float vehicleDistance = 2.5f;  // Distance to stopped vehicle in meters\n\n    std::cout << \"Is Vehicle Stopped: \" << (isStopped ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isStoppedVehicleCollisionRisk(isStopped, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH STOPPED VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks pedestrian collision risk when a pedestrian is near a crosswalk and within a specific distance.",
      "input": "If a pedestrian is near the crosswalk and within 2 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 2.0f;  // Threshold for pedestrian in meters\n\n// Function to check pedestrian collision risk near crosswalk\nbool isPedestrianCollisionRisk(bool isNearCrosswalk, float pedestrianDistance) {\n    return isNearCrosswalk && pedestrianDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Check if pedestrian is too close near crosswalk\n}\n\n// Test case\nint main() {\n    bool isNearCrosswalk = true;  // Pedestrian near crosswalk\n    float pedestrianDistance = 1.5f;  // Distance to pedestrian in meters\n\n    std::cout << \"Pedestrian Near Crosswalk: \" << (isNearCrosswalk ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(isNearCrosswalk, pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN NEAR CROSSWALK!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if objects in a traffic jam are too close.",
      "input": "If multiple objects are within 2 meters in a traffic jam, trigger a collision warning.",
      "output": "#include <iostream>\n#include <vector>\n\nconst float COLLISION_THRESHOLD_TRAFFIC_JAM = 2.0f;  // Threshold for objects in traffic jam in meters\n\n// Function to check collision risk with multiple objects in traffic jam\nbool isTrafficJamCollisionRisk(std::vector<float> objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD_TRAFFIC_JAM) {\n            return true;  // If any object is too close\n        }\n    }\n    return false;\n}\n\n// Test case\nint main() {\n    std::vector<float> objectDistances = {1.5f, 3.0f, 1.8f};  // Distances to objects in meters\n\n    if (isTrafficJamCollisionRisk(objectDistances)) {\n        std::cout << \"WARNING: COLLISION RISK IN TRAFFIC JAM!\" << std::endl;\n    } else {\n        std::cout << \"No Traffic Jam Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that checks collision risk based on object type (e.g., vehicle, motorcycle).",
      "input": "If the object is a motorcycle and is within 2 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_MOTORCYCLE = 2.0f;  // Threshold for motorcycle collision risk in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicle collision risk in meters\n\n// Function to check collision risk based on object type\nbool isObjectCollisionRisk(std::string objectType, float objectDistance) {\n    float threshold = (objectType == \"motorcycle\") ? COLLISION_THRESHOLD_MOTORCYCLE : COLLISION_THRESHOLD_VEHICLE;\n    return objectDistance < threshold;  // Check if object is too close based on type\n}\n\n// Test case\nint main() {\n    std::string objectType = \"motorcycle\";  // Object type\n    float objectDistance = 1.8f;  // Distance to object in meters\n\n    std::cout << \"Object Type: \" << objectType << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isObjectCollisionRisk(objectType, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH MOTORCYCLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a cyclist and triggers a warning if the cyclist is within a short distance.",
      "input": "If the cyclist is within 1.5 meters, trigger a collision warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_CYCLIST = 1.5f;  // Threshold for cyclist collision risk in meters\n\n// Function to check collision risk with cyclist\nbool isCyclistCollisionRisk(float cyclistDistance) {\n    return cyclistDistance < COLLISION_THRESHOLD_CYCLIST;  // Check if cyclist is too close\n}\n\n// Test case\nint main() {\n    float cyclistDistance = 1.2f;  // Distance to cyclist in meters\n\n    std::cout << \"Cyclist Distance: \" << cyclistDistance << \" meters\" << std::endl;\n\n    if (isCyclistCollisionRisk(cyclistDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH CYCLIST!\" << std::endl;\n    } else {\n        std::cout << \"No Cyclist Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that considers lane changes and triggers a warning if a collision risk arises during a lane change.",
      "input": "If the vehicle is changing lanes and the other vehicle is within 3 meters in the adjacent lane, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LANE_CHANGE = 3.0f;  // Threshold for lane change collision risk in meters\n\n// Function to check collision risk during lane change\nbool isLaneChangeCollisionRisk(bool isLaneChange, float adjacentVehicleDistance) {\n    return isLaneChange && adjacentVehicleDistance < COLLISION_THRESHOLD_LANE_CHANGE;  // Check if lane change creates collision risk\n}\n\n// Test case\nint main() {\n    bool isLaneChange = true;  // Lane change status\n    float adjacentVehicleDistance = 2.8f;  // Distance to vehicle in adjacent lane in meters\n\n    std::cout << \"Is Lane Change: \" << (isLaneChange ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Adjacent Vehicle Distance: \" << adjacentVehicleDistance << \" meters\" << std::endl;\n\n    if (isLaneChangeCollisionRisk(isLaneChange, adjacentVehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK DURING LANE CHANGE!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts collision detection based on the type of vehicle (e.g., SUV, sedan).",
      "input": "For SUVs, trigger a warning if they are within 5 meters. For sedans, trigger a warning if within 3 meters.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_SUV = 5.0f;  // Threshold for SUV collision risk in meters\nconst float COLLISION_THRESHOLD_SEDAN = 3.0f;  // Threshold for sedan collision risk in meters\n\n// Function to check collision risk based on vehicle type\nbool isVehicleCollisionRisk(std::string vehicleType, float vehicleDistance) {\n    float threshold = (vehicleType == \"SUV\") ? COLLISION_THRESHOLD_SUV : COLLISION_THRESHOLD_SEDAN;\n    return vehicleDistance < threshold;  // Check if vehicle is too close based on type\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"SUV\";  // Vehicle type\n    float vehicleDistance = 4.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isVehicleCollisionRisk(vehicleType, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH SUV!\" << std::endl;\n    } else {\n        std::cout << \"No Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that activates the emergency braking system when an object is detected within 1 meter.",
      "input": "If the distance to an object is less than 1 meter, trigger emergency braking.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float EMERGENCY_BRAKING_THRESHOLD = 1.0f;  // Threshold for emergency braking in meters\n\n// Function to check if emergency braking is needed\nbool isEmergencyBrakingNeeded(float objectDistance) {\n    return objectDistance < EMERGENCY_BRAKING_THRESHOLD;  // Trigger braking if distance is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 0.8f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isEmergencyBrakingNeeded(objectDistance)) {\n        std::cout << \"WARNING: EMERGENCY BRAKING ACTIVATED!\" << std::endl;\n    } else {\n        std::cout << \"No Emergency Braking Needed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a collision warning based on the speed of the vehicle ahead. The system should adjust the warning threshold based on the speed of the vehicle.",
      "input": "If the vehicle ahead is traveling at a speed greater than 50 km/h and the distance is less than 5 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_LOW_SPEED = 10.0f;  // Threshold for low-speed objects in meters\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 5.0f;  // Threshold for high-speed objects in meters\n\n// Function to calculate the collision risk based on speed\nbool isSpeedAdjustedRisk(float vehicleSpeed, float vehicleDistance) {\n    float threshold = (vehicleSpeed > 50.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return vehicleDistance < threshold;  // Adjust risk based on speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 60.0f;  // Speed of the vehicle ahead in km/h\n    float vehicleDistance = 4.0f;  // Distance to the vehicle ahead in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isSpeedAdjustedRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH FAST VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects moving pedestrians and triggers a collision warning if they are within a specified threshold distance.",
      "input": "If the pedestrian is moving and within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_PEDESTRIAN = 3.0f;  // Threshold for pedestrian collision risk in meters\n\n// Function to check if a pedestrian poses a collision risk\nbool isPedestrianMovingCollisionRisk(bool isMoving, float pedestrianDistance) {\n    return isMoving && pedestrianDistance < COLLISION_THRESHOLD_PEDESTRIAN;  // Check if moving pedestrian is too close\n}\n\n// Test case\nint main() {\n    bool isMoving = true;  // Pedestrian is moving\n    float pedestrianDistance = 2.0f;  // Distance to pedestrian in meters\n\n    std::cout << \"Pedestrian Moving: \" << (isMoving ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianMovingCollisionRisk(isMoving, pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH MOVING PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects both motorcycles and vehicles and triggers a collision warning based on their distance.",
      "input": "If the motorcycle is within 2 meters or the vehicle is within 5 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <string>\n\nconst float COLLISION_THRESHOLD_MOTORCYCLE = 2.0f;  // Threshold for motorcycle collision risk in meters\nconst float COLLISION_THRESHOLD_VEHICLE = 5.0f;  // Threshold for vehicle collision risk in meters\n\n// Function to check collision risk based on vehicle type\nbool isVehicleCollisionRisk(std::string vehicleType, float vehicleDistance) {\n    float threshold = (vehicleType == \"motorcycle\") ? COLLISION_THRESHOLD_MOTORCYCLE : COLLISION_THRESHOLD_VEHICLE;\n    return vehicleDistance < threshold;  // Check if vehicle is too close based on type\n}\n\n// Test case\nint main() {\n    std::string vehicleType = \"motorcycle\";  // Vehicle type\n    float vehicleDistance = 1.5f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Type: \" << vehicleType << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isVehicleCollisionRisk(vehicleType, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH MOTORCYCLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that updates collision risk as the distance to the object changes. If the distance is below the threshold, trigger a warning.",
      "input": "If the distance to the object falls below 4 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Threshold for collision risk in meters\n\n// Function to check collision risk based on dynamic distance\nbool isDynamicCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD;  // Check if object is too close\n}\n\n// Test case\nint main() {\n    float objectDistance = 3.5f;  // Distance to object in meters\n\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isDynamicCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision threshold based on the speed of the vehicle and objects in front.",
      "input": "If the vehicle speed is greater than 60 km/h and the object is within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD_HIGH_SPEED = 3.0f;  // Threshold for high-speed vehicle collision risk in meters\nconst float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;  // Threshold for low-speed vehicle collision risk in meters\n\n// Function to calculate the collision risk based on vehicle speed\nbool isSpeedBasedRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = (vehicleSpeed > 60.0f) ? COLLISION_THRESHOLD_HIGH_SPEED : COLLISION_THRESHOLD_LOW_SPEED;\n    return objectDistance < threshold;  // Adjust risk based on vehicle speed\n}\n\n// Test case\nint main() {\n    float vehicleSpeed = 70.0f;  // Speed of the vehicle in km/h\n    float objectDistance = 2.5f;  // Distance to the object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isSpeedBasedRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that calculates collision risk based on the distance to multiple objects in front of the vehicle.",
      "input": "If any of the objects are within 4 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Threshold for collision risk in meters\n\n// Function to check collision risk for multiple objects\nbool isMultipleObjectCollisionRisk(const std::vector<float>& objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD) {\n            return true;  // If any object is too close\n        }\n    }\n    return false;  // No collision risk\n}\n\n// Test case\nint main() {\n    std::vector<float> objectDistances = {5.0f, 3.0f, 6.0f};  // Distances to multiple objects\n\n    if (isMultipleObjectCollisionRisk(objectDistances)) {\n        std::cout << \"WARNING: COLLISION RISK WITH OBJECTS!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle behind is too close and triggers a warning if it is within 2 meters.",
      "input": "If the distance to the rear vehicle is within 2 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float REAR_VEHICLE_COLLISION_THRESHOLD = 2.0f;  // Threshold for rear vehicle collision risk in meters\n\n// Function to check rear vehicle collision risk\nbool isRearVehicleCollisionRisk(float rearVehicleDistance) {\n    return rearVehicleDistance < REAR_VEHICLE_COLLISION_THRESHOLD;  // Check if rear vehicle is too close\n}\n\n// Test case\nint main() {\n    float rearVehicleDistance = 1.5f;  // Distance to rear vehicle in meters\n\n    std::cout << \"Rear Vehicle Distance: \" << rearVehicleDistance << \" meters\" << std::endl;\n\n    if (isRearVehicleCollisionRisk(rearVehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH REAR VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Rear Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a stationary vehicle and triggers a warning if it is too close.",
      "input": "If the vehicle ahead is stationary and within 3 meters, trigger a warning.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float STATIONARY_VEHICLE_THRESHOLD = 3.0f;  // Threshold for stationary vehicle collision risk in meters\n\n// Function to check collision risk with a stationary vehicle\nbool isStationaryVehicleCollisionRisk(bool isStationary, float vehicleDistance) {\n    return isStationary && vehicleDistance < STATIONARY_VEHICLE_THRESHOLD;  // Check if stationary vehicle is too close\n}\n\n// Test case\nint main() {\n    bool isStationary = true;  // Vehicle is stationary\n    float vehicleDistance = 2.0f;  // Distance to vehicle in meters\n\n    std::cout << \"Vehicle Stationary: \" << (isStationary ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isStationaryVehicleCollisionRisk(isStationary, vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH STATIONARY VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Stationary Vehicle Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses real-time data from a camera and speed sensor to trigger a collision warning. If an object is within 5 meters and the vehicle's speed exceeds 60 km/h, trigger a warning.",
      "input": "Real-time data input includes the camera feed for object detection and speed data from a speed sensor.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision threshold in meters\nconst float SPEED_THRESHOLD = 60.0f;  // Speed threshold for warning in km/h\n\n// Function to detect objects in a frame and return the closest object's distance\nfloat detectObjectDistance(cv::Mat &frame) {\n    // Simulate object detection (replace with actual object detection code)\n    return 3.0f;  // Simulate detected object distance of 3 meters\n}\n\n// Function to check collision risk based on speed and object distance\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return vehicleSpeed > SPEED_THRESHOLD && objectDistance < COLLISION_THRESHOLD;\n}\n\n// Test case for real-time data\nint main() {\n    float vehicleSpeed = 75.0f;  // Vehicle speed in km/h\n    cv::Mat frame;  // Capture frame from camera (not implemented here)\n    float objectDistance = detectObjectDistance(frame);  // Get object distance from camera feed\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians in real-time using camera data. If a pedestrian is within 3 meters, trigger a warning.",
      "input": "Real-time camera feed data for pedestrian detection.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float PEDESTRIAN_THRESHOLD = 3.0f;  // Pedestrian collision threshold in meters\n\n// Function to simulate pedestrian detection in the camera feed\nfloat detectPedestrianDistance(cv::Mat &frame) {\n    // Simulate pedestrian detection (replace with actual detection)\n    return 2.5f;  // Simulate detected pedestrian distance of 2.5 meters\n}\n\n// Function to check if there is a collision risk with a pedestrian\nbool isPedestrianCollisionRisk(float pedestrianDistance) {\n    return pedestrianDistance < PEDESTRIAN_THRESHOLD;\n}\n\n// Test case for real-time pedestrian detection\nint main() {\n    cv::Mat frame;  // Capture frame from camera (not implemented here)\n    float pedestrianDistance = detectPedestrianDistance(frame);  // Detect pedestrian in frame\n\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that uses real-time vehicle speed and distance data from radar to determine collision risk.",
      "input": "Real-time speed and radar data for detecting objects in front of the vehicle.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Threshold for collision risk in meters\n\n// Function to simulate radar object detection\nfloat getRadarObjectDistance() {\n    return 3.5f;  // Simulate object detection at 3.5 meters\n}\n\n// Function to get real-time vehicle speed (simulated)\nfloat getVehicleSpeed() {\n    return 65.0f;  // Simulate vehicle speed of 65 km/h\n}\n\n// Function to determine collision risk based on speed and distance\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return vehicleSpeed > 60.0f && objectDistance < COLLISION_THRESHOLD;  // Collision risk if speed > 60 km/h\n}\n\n// Test case for speed and radar data\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float objectDistance = getRadarObjectDistance();  // Get object distance from radar\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that processes real-time object data (from radar and cameras) to check if any object is within 4 meters.",
      "input": "Real-time data of multiple objects detected by radar and cameras.",
      "output": "#include <iostream>\n#include <vector>\n#include <opencv2/opencv.hpp>\n\nconst float COLLISION_THRESHOLD = 4.0f;  // Collision threshold in meters\n\n// Function to simulate object detection (from radar and cameras)\nstd::vector<float> getObjectDistances() {\n    return {3.0f, 6.0f, 2.5f};  // Simulate distances to multiple objects\n}\n\n// Function to check if any object is within collision threshold\nbool isAnyObjectWithinCollisionThreshold(const std::vector<float>& objectDistances) {\n    for (float distance : objectDistances) {\n        if (distance < COLLISION_THRESHOLD) {\n            return true;  // Return true if any object is within threshold\n        }\n    }\n    return false;  // No object within threshold\n}\n\n// Test case for real-time data processing\nint main() {\n    std::vector<float> objectDistances = getObjectDistances();  // Get object distances from radar and camera\n\n    std::cout << \"Object Distances: \";\n    for (float distance : objectDistances) {\n        std::cout << distance << \" meters \" << std::endl;\n    }\n\n    if (isAnyObjectWithinCollisionThreshold(objectDistances)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if a pedestrian or object is detected within 3 meters.",
      "input": "Real-time object and pedestrian detection data.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float COLLISION_THRESHOLD = 3.0f;  // Threshold for collision risk in meters\n\n// Function to simulate object and pedestrian detection in camera feed\nfloat detectObjectOrPedestrian(cv::Mat &frame) {\n    return 2.5f;  // Simulate object/pedestrian detection at 2.5 meters\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float objectDistance) {\n    return objectDistance < COLLISION_THRESHOLD;  // Collision risk if distance is too small\n}\n\n// Test case for real-time object/pedestrian detection\nint main() {\n    cv::Mat frame;  // Capture frame from camera (not implemented)\n    float objectDistance = detectObjectOrPedestrian(frame);  // Get distance to detected object or pedestrian\n\n    std::cout << \"Object/Pedestrian Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if an object is within 5 meters and the vehicle speed exceeds 50 km/h.",
      "input": "Real-time speed and radar object detection data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 5.0f;  // Collision threshold in meters\nconst float SPEED_THRESHOLD = 50.0f;  // Speed threshold for warning in km/h\n\n// Function to simulate radar object detection\nfloat getRadarObjectDistance() {\n    return 4.5f;  // Simulate object detection at 4.5 meters\n}\n\n// Function to simulate real-time vehicle speed\nfloat getVehicleSpeed() {\n    return 55.0f;  // Simulate vehicle speed of 55 km/h\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    return vehicleSpeed > SPEED_THRESHOLD && objectDistance < COLLISION_THRESHOLD;  // Collision if conditions met\n}\n\n// Test case for real-time vehicle and object detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get real-time vehicle speed\n    float objectDistance = getRadarObjectDistance();  // Get radar object distance\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that triggers a warning if a vehicle is detected in front of the car and is stationary within 2 meters.",
      "input": "Real-time vehicle detection and speed data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float COLLISION_THRESHOLD = 2.0f;  // Threshold for collision risk with stationary vehicle in meters\n\n// Function to simulate detection of a stationary vehicle\nfloat detectStationaryVehicleDistance() {\n    return 1.5f;  // Simulate detected stationary vehicle at 1.5 meters\n}\n\n// Function to check collision risk with a stationary vehicle\nbool isStationaryVehicleRisk(float vehicleDistance) {\n    return vehicleDistance < COLLISION_THRESHOLD;  // Risk if stationary vehicle is too close\n}\n\n// Test case for stationary vehicle detection\nint main() {\n    float vehicleDistance = detectStationaryVehicleDistance();  // Get distance to stationary vehicle\n\n    std::cout << \"Stationary Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isStationaryVehicleRisk(vehicleDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH STATIONARY VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk with Stationary Vehicle.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision risk threshold based on vehicle speed. Higher speed should lower the threshold for collision warning.",
      "input": "Real-time vehicle speed and object distance data.",
      "output": "#include <iostream>\n#include <cmath>\n\n// Function to calculate collision threshold based on speed\nfloat calculateThreshold(float vehicleSpeed) {\n    return 5.0f - (vehicleSpeed / 100.0f);  // Threshold decreases as speed increases\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = calculateThreshold(vehicleSpeed);  // Calculate dynamic threshold\n    return objectDistance < threshold;  // Risk if object distance is less than threshold\n}\n\n// Test case for dynamic threshold\nint main() {\n    float vehicleSpeed = 80.0f;  // Vehicle speed in km/h\n    float objectDistance = 3.0f;  // Object distance in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects tailgating vehicles. If the vehicle behind is within 2 meters and traveling faster, trigger a warning.",
      "input": "Real-time data from rear radar and vehicle speed sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float TAILGATING_THRESHOLD = 2.0f;  // Tailgating threshold in meters\n\n// Function to simulate the detection of a vehicle behind using radar\nfloat getRearVehicleDistance() {\n    return 1.5f;  // Simulate a vehicle 1.5 meters behind\n}\n\n// Function to simulate the vehicle speed\nfloat getVehicleSpeed() {\n    return 70.0f;  // Simulate vehicle speed of 70 km/h\n}\n\n// Function to simulate rear vehicle speed\nfloat getRearVehicleSpeed() {\n    return 80.0f;  // Simulate the rear vehicle speed of 80 km/h\n}\n\n// Function to check tailgating risk\nbool isTailgatingRisk(float vehicleSpeed, float rearVehicleDistance, float rearVehicleSpeed) {\n    return rearVehicleDistance < TAILGATING_THRESHOLD && rearVehicleSpeed > vehicleSpeed;\n}\n\n// Test case for tailgating detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float rearVehicleDistance = getRearVehicleDistance();  // Get distance to vehicle behind\n    float rearVehicleSpeed = getRearVehicleSpeed();  // Get speed of vehicle behind\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Rear Vehicle Distance: \" << rearVehicleDistance << \" meters\" << std::endl;\n    std::cout << \"Rear Vehicle Speed: \" << rearVehicleSpeed << \" km/h\" << std::endl;\n\n    if (isTailgatingRisk(vehicleSpeed, rearVehicleDistance, rearVehicleSpeed)) {\n        std::cout << \"WARNING: TAILGATING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Tailgating Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if a vehicle is stopped in front. If a vehicle in front is stationary within 3 meters, trigger a collision warning.",
      "input": "Real-time data from front radar and vehicle detection cameras.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float STOPPED_VEHICLE_THRESHOLD = 3.0f;  // Threshold in meters for stopped vehicle detection\n\n// Function to simulate front radar detecting a stopped vehicle\nfloat getFrontVehicleDistance() {\n    return 2.5f;  // Simulate stopped vehicle at 2.5 meters\n}\n\n// Function to simulate front vehicle speed\nfloat getFrontVehicleSpeed() {\n    return 0.0f;  // Simulate stationary vehicle (speed 0 km/h)\n}\n\n// Function to check collision risk with a stopped vehicle\nbool isStoppedVehicleRisk(float frontVehicleDistance, float frontVehicleSpeed) {\n    return frontVehicleDistance < STOPPED_VEHICLE_THRESHOLD && frontVehicleSpeed == 0.0f;\n}\n\n// Test case for stopped vehicle detection\nint main() {\n    float frontVehicleDistance = getFrontVehicleDistance();  // Get distance to vehicle in front\n    float frontVehicleSpeed = getFrontVehicleSpeed();  // Get speed of vehicle in front\n\n    std::cout << \"Front Vehicle Distance: \" << frontVehicleDistance << \" meters\" << std::endl;\n    std::cout << \"Front Vehicle Speed: \" << frontVehicleSpeed << \" km/h\" << std::endl;\n\n    if (isStoppedVehicleRisk(frontVehicleDistance, frontVehicleSpeed)) {\n        std::cout << \"WARNING: STOPPED VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Stopped Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians crossing the road. If a pedestrian is within 2 meters, trigger a warning.",
      "input": "Real-time camera feed and pedestrian detection system.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f;  // Pedestrian collision threshold in meters\n\n// Function to simulate pedestrian detection using camera feed\nfloat detectPedestrianDistance(cv::Mat &frame) {\n    return 1.5f;  // Simulate pedestrian detected 1.5 meters ahead\n}\n\n// Function to check pedestrian collision risk\nbool isPedestrianCollisionRisk(float pedestrianDistance) {\n    return pedestrianDistance < PEDESTRIAN_THRESHOLD;  // Collision risk if distance is too small\n}\n\n// Test case for pedestrian detection\nint main() {\n    cv::Mat frame;  // Capture frame from camera (not implemented here)\n    float pedestrianDistance = detectPedestrianDistance(frame);  // Get distance to pedestrian from camera feed\n\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianDistance)) {\n        std::cout << \"WARNING: COLLISION RISK WITH PEDESTRIAN!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that adjusts the collision warning threshold based on the vehicle's speed. The faster the vehicle, the shorter the collision threshold.",
      "input": "Real-time speed and object distance data.",
      "output": "#include <iostream>\n#include <cmath>\n\n// Function to adjust collision threshold based on vehicle speed\nfloat calculateCollisionThreshold(float vehicleSpeed) {\n    return 5.0f - (vehicleSpeed / 100.0f);  // Adjust threshold: higher speed, shorter threshold\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance) {\n    float threshold = calculateCollisionThreshold(vehicleSpeed);  // Adjust threshold based on speed\n    return objectDistance < threshold;  // Collision risk if object is too close\n}\n\n// Test case for speed-adjusted collision risk\nint main() {\n    float vehicleSpeed = 90.0f;  // Vehicle speed in km/h\n    float objectDistance = 3.0f;  // Distance to object in meters\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects vehicles in the blind spot. If a vehicle is detected within 1.5 meters and approaching, trigger a warning.",
      "input": "Real-time data from side radar and vehicle position sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BLIND_SPOT_THRESHOLD = 1.5f;  // Blind spot detection threshold in meters\n\n// Function to simulate side radar detecting a vehicle in the blind spot\nfloat getBlindSpotVehicleDistance() {\n    return 1.2f;  // Simulate vehicle detected at 1.2 meters in the blind spot\n}\n\n// Function to simulate the vehicle's speed\nfloat getVehicleSpeed() {\n    return 50.0f;  // Simulate vehicle speed of 50 km/h\n}\n\n// Function to check collision risk with vehicle in the blind spot\nbool isBlindSpotRisk(float vehicleSpeed, float vehicleDistance) {\n    return vehicleDistance < BLIND_SPOT_THRESHOLD && vehicleSpeed > 40.0f;  // Risk if vehicle is too close and approaching\n}\n\n// Test case for blind spot detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getBlindSpotVehicleDistance();  // Get distance to vehicle in blind spot\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Blind Spot Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isBlindSpotRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Blind Spot Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians near the sidewalk. If a pedestrian crosses within 2 meters and the vehicle is traveling over 30 km/h, trigger a warning.",
      "input": "Real-time pedestrian detection data and vehicle speed data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f;  // Threshold for pedestrian detection in meters\nconst float VEHICLE_SPEED_THRESHOLD = 30.0f;  // Minimum speed for triggering the warning\n\n// Function to simulate pedestrian distance detection\nfloat detectPedestrianDistance() {\n    return 1.8f;  // Simulate pedestrian at 1.8 meters\n}\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 35.0f;  // Simulate vehicle speed of 35 km/h\n}\n\n// Function to check pedestrian collision risk\nbool isPedestrianCollisionRisk(float vehicleSpeed, float pedestrianDistance) {\n    return vehicleSpeed > VEHICLE_SPEED_THRESHOLD && pedestrianDistance < PEDESTRIAN_THRESHOLD;\n}\n\n// Test case for pedestrian detection near the sidewalk\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get real-time vehicle speed\n    float pedestrianDistance = detectPedestrianDistance();  // Get distance to pedestrian\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(vehicleSpeed, pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN CROSSING!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that dynamically adjusts the collision detection threshold based on the environment (day or night).",
      "input": "Real-time sensor data, vehicle speed, and environmental condition.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float DAY_THRESHOLD = 5.0f;  // Daytime collision threshold in meters\nconst float NIGHT_THRESHOLD = 3.0f;  // Nighttime collision threshold in meters\n\n// Function to simulate environment condition (day or night)\nstd::string getEnvironmentCondition() {\n    return \"day\";  // Simulate daytime condition\n}\n\n// Function to calculate collision threshold based on environment\nfloat calculateDynamicThreshold(std::string environment) {\n    if (environment == \"night\") {\n        return NIGHT_THRESHOLD;  // Shorter threshold at night\n    } else {\n        return DAY_THRESHOLD;  // Longer threshold during the day\n}\n}\n\n// Function to check collision risk\nbool isCollisionRisk(float vehicleSpeed, float objectDistance, std::string environment) {\n    float threshold = calculateDynamicThreshold(environment);  // Calculate dynamic threshold\n    return objectDistance < threshold;  // Collision risk if object is too close\n}\n\n// Test case for dynamic threshold based on environment\nint main() {\n    float vehicleSpeed = 60.0f;  // Vehicle speed in km/h\n    float objectDistance = 4.0f;  // Distance to object in meters\n    std::string environment = getEnvironmentCondition();  // Get environment condition (day or night)\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n    std::cout << \"Environment: \" << environment << std::endl;\n\n    if (isCollisionRisk(vehicleSpeed, objectDistance, environment)) {\n        std::cout << \"WARNING: COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects obstructions in front of the vehicle. If an obstacle is within 3 meters, trigger a warning.",
      "input": "Real-time data from front radar and LIDAR sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float OBSTRUCTION_THRESHOLD = 3.0f;  // Obstruction detection threshold in meters\n\n// Function to simulate front radar detecting an obstruction\nfloat getFrontObstructionDistance() {\n    return 2.5f;  // Simulate obstruction detected 2.5 meters in front\n}\n\n// Function to check for obstruction risk\nbool isObstructionRisk(float obstructionDistance) {\n    return obstructionDistance < OBSTRUCTION_THRESHOLD;\n}\n\n// Test case for obstruction detection\nint main() {\n    float obstructionDistance = getFrontObstructionDistance();  // Get distance to obstruction\n\n    std::cout << \"Obstruction Distance: \" << obstructionDistance << \" meters\" << std::endl;\n\n    if (isObstructionRisk(obstructionDistance)) {\n        std::cout << \"WARNING: FRONT OBSTRUCTION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Obstruction Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden lane departure. If the vehicle drifts more than 0.5 meters outside the lane without signaling, trigger a warning.",
      "input": "Real-time data from lane detection cameras and steering sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f;  // Lane departure threshold in meters\n\n// Function to simulate lane departure detection\nfloat getLaneDeparture() {\n    return 0.6f;  // Simulate lane departure of 0.6 meters\n}\n\n// Function to check lane departure risk\nbool isLaneDepartureRisk(float laneDeparture) {\n    return laneDeparture > LANE_DEPARTURE_THRESHOLD;\n}\n\n// Test case for lane departure detection\nint main() {\n    float laneDeparture = getLaneDeparture();  // Get lane departure distance\n\n    std::cout << \"Lane Departure: \" << laneDeparture << \" meters\" << std::endl;\n\n    if (isLaneDepartureRisk(laneDeparture)) {\n        std::cout << \"WARNING: LANE DEPARTURE!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects driver fatigue based on head movement patterns. If the driver's head remains still for more than 5 seconds, trigger a warning.",
      "input": "Real-time data from in-vehicle camera (for head movement) and time tracking.",
      "output": "#include <iostream>\n#include <ctime>\n\nconst int FATIGUE_THRESHOLD = 5;  // Threshold in seconds for detecting fatigue\n\n// Function to simulate head movement tracking\nbool isDriverAlert() {\n    return false;  // Simulate a still head position for 6 seconds\n}\n\n// Function to check driver fatigue\nbool isDriverFatigued(int elapsedTime) {\n    return elapsedTime > FATIGUE_THRESHOLD;\n}\n\n// Test case for driver fatigue detection\nint main() {\n    int elapsedTime = 6;  // Simulate 6 seconds of no head movement\n\n    std::cout << \"Elapsed Time: \" << elapsedTime << \" seconds\" << std::endl;\n\n    if (isDriverFatigued(elapsedTime)) {\n        std::cout << \"WARNING: DRIVER FATIGUE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"Driver is Alert.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians in front of the vehicle. If a pedestrian is detected within 2 meters, trigger a warning.",
      "input": "Real-time pedestrian detection data from front camera.",
      "output": "#include <iostream>\n#include <opencv2/opencv.hpp>\n\nconst float PEDESTRIAN_THRESHOLD = 2.0f;  // Threshold for pedestrian detection in meters\n\n// Function to simulate pedestrian detection using camera feed\nfloat detectPedestrianDistance(cv::Mat &frame) {\n    return 1.8f;  // Simulate pedestrian at 1.8 meters\n}\n\n// Function to check for pedestrian collision risk\nbool isPedestrianCollisionRisk(float pedestrianDistance) {\n    return pedestrianDistance < PEDESTRIAN_THRESHOLD;\n}\n\n// Test case for pedestrian detection in front of the vehicle\nint main() {\n    cv::Mat frame;  // Simulate frame capture from camera\n    float pedestrianDistance = detectPedestrianDistance(frame);  // Get distance to pedestrian\n\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianCollisionRisk(pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN IN FRONT!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden braking by the vehicle ahead. If the vehicle in front suddenly brakes and the vehicle is within 3 meters, trigger a warning.",
      "input": "Real-time brake pressure sensor data and vehicle distance sensor data.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BRAKE_THRESHOLD = 3.0f;  // Threshold for sudden braking detection in meters\n\n// Function to simulate vehicle brake pressure sensor data\nbool isBrakingSuddenly() {\n    return true;  // Simulate sudden braking event\n}\n\n// Function to simulate distance to the vehicle ahead\nfloat getDistanceToFrontVehicle() {\n    return 2.5f;  // Simulate distance to the vehicle in front\n}\n\n// Function to check for sudden braking risk\nbool isSuddenBrakeRisk(float distance) {\n    return distance < BRAKE_THRESHOLD && isBrakingSuddenly();\n}\n\n// Test case for sudden braking detection\nint main() {\n    float distance = getDistanceToFrontVehicle();  // Get distance to vehicle in front\n\n    std::cout << \"Distance to Front Vehicle: \" << distance << \" meters\" << std::endl;\n\n    if (isSuddenBrakeRisk(distance)) {\n        std::cout << \"WARNING: SUDDEN BRAKING AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Braking Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high-speed vehicles in front. If a vehicle is within 5 meters and traveling faster than 100 km/h, trigger a warning.",
      "input": "Real-time data from radar, vehicle speed sensors, and front vehicle distance sensor.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SPEED_THRESHOLD = 100.0f;  // Speed threshold for triggering warning\nconst float DISTANCE_THRESHOLD = 5.0f;  // Distance threshold in meters\n\n// Function to simulate the speed of a vehicle in front\nfloat getFrontVehicleSpeed() {\n    return 110.0f;  // Simulate speed of 110 km/h\n}\n\n// Function to simulate the distance to the vehicle in front\nfloat getFrontVehicleDistance() {\n    return 4.0f;  // Simulate distance to vehicle in front\n}\n\n// Function to check for high-speed vehicle risk\nbool isHighSpeedVehicleRisk(float speed, float distance) {\n    return speed > SPEED_THRESHOLD && distance < DISTANCE_THRESHOLD;\n}\n\n// Test case for high-speed vehicle detection\nint main() {\n    float vehicleSpeed = getFrontVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getFrontVehicleDistance();  // Get distance to front vehicle\n\n    std::cout << \"Front Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Front Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isHighSpeedVehicleRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: HIGH-SPEED VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No High-Speed Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects tailgating. If a vehicle is within 2 meters of the car and traveling at a higher speed, trigger a warning.",
      "input": "Real-time radar and camera data for vehicle distance and speed.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float TAILGATING_THRESHOLD = 2.0f;  // Distance threshold for tailgating detection in meters\nconst float TAILGATING_SPEED_DIFFERENCE = 10.0f;  // Speed difference threshold for tailgating\n\n// Function to simulate vehicle distance\nfloat getVehicleDistance() {\n    return 1.8f;  // Simulate vehicle at 1.8 meters distance\n}\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 70.0f;  // Simulate vehicle speed of 70 km/h\n}\n\n// Function to check for tailgating risk\nbool isTailgatingRisk(float vehicleDistance, float vehicleSpeed) {\n    return vehicleDistance < TAILGATING_THRESHOLD && vehicleSpeed > TAILGATING_SPEED_DIFFERENCE;\n}\n\n// Test case for tailgating detection\nint main() {\n    float vehicleDistance = getVehicleDistance();  // Get vehicle distance\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isTailgatingRisk(vehicleDistance, vehicleSpeed)) {\n        std::cout << \"WARNING: TAILGATING DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Tailgating Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects over-speeding in a residential area. If the vehicle speed exceeds 40 km/h, trigger a warning.",
      "input": "Real-time vehicle speed data and GPS data for detecting residential areas.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SPEED_LIMIT = 40.0f;  // Speed limit for residential areas in km/h\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 45.0f;  // Simulate vehicle speed of 45 km/h\n}\n\n// Function to check for over-speeding in a residential area\nbool isOverSpeeding(float speed) {\n    return speed > SPEED_LIMIT;\n}\n\n// Test case for over-speeding in residential area\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isOverSpeeding(vehicleSpeed)) {\n        std::cout << \"WARNING: OVER-SPEEDING IN RESIDENTIAL AREA!\" << std::endl;\n    } else {\n        std::cout << \"No Over-Speeding Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high traffic density ahead. If the vehicle speed drops below 10 km/h and the distance to the vehicle ahead is less than 3 meters, trigger a warning.",
      "input": "Real-time vehicle speed and distance to the vehicle ahead.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float SPEED_THRESHOLD = 10.0f;  // Speed threshold for detecting high traffic density in km/h\nconst float DISTANCE_THRESHOLD = 3.0f;  // Distance threshold in meters for detecting high traffic density\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 8.0f;  // Simulate vehicle speed of 8 km/h (slow traffic)\n}\n\n// Function to simulate distance to the vehicle ahead\nfloat getVehicleDistance() {\n    return 2.5f;  // Simulate distance to the vehicle ahead\n}\n\n// Function to check for high traffic density risk\nbool isHighTrafficDensityRisk(float vehicleSpeed, float vehicleDistance) {\n    return vehicleSpeed < SPEED_THRESHOLD && vehicleDistance < DISTANCE_THRESHOLD;\n}\n\n// Test case for high traffic density detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getVehicleDistance();  // Get distance to vehicle ahead\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Distance to Vehicle Ahead: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isHighTrafficDensityRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: HIGH TRAFFIC DENSITY AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No High Traffic Density Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects when rain affects the braking distance. If rain is detected and the vehicle's speed exceeds 50 km/h, increase the distance threshold by 1.5 meters.",
      "input": "Real-time data from the rain sensor, vehicle speed, and braking distance sensor.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float BASE_BRAKE_DISTANCE = 3.0f;  // Base braking distance in meters\nconst float RAIN_ADJUSTMENT = 1.5f;  // Additional distance for braking in rain\nconst float RAIN_DETECTED = 1.0f;  // Simulate rain detected\nconst float RAIN_NOT_DETECTED = 0.0f;  // No rain detected\n\n// Function to simulate rain detection\nfloat isRainDetected() {\n    return RAIN_DETECTED;  // Simulate rain detected\n}\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 55.0f;  // Simulate vehicle speed of 55 km/h\n}\n\n// Function to calculate braking distance based on rain\nfloat getBrakingDistance(float speed, float rainStatus) {\n    if (rainStatus == RAIN_DETECTED) {\n        return BASE_BRAKE_DISTANCE + RAIN_ADJUSTMENT;  // Increase braking distance due to rain\n    }\n    return BASE_BRAKE_DISTANCE;  // No adjustment if no rain\n}\n\n// Test case for braking distance in rain\nint main() {\n    float rainStatus = isRainDetected();  // Check if rain is detected\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    float brakeDistance = getBrakingDistance(vehicleSpeed, rainStatus);  // Calculate braking distance\n    std::cout << \"Braking Distance: \" << brakeDistance << \" meters\" << std::endl;\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects low tire pressure. If the tire pressure is below 25 psi, trigger a warning.",
      "input": "Real-time data from the tire pressure sensors.",
      "output": "#include <iostream>\n\nconst float LOW_TIRE_PRESSURE = 25.0f;  // Low tire pressure threshold in psi\n\n// Function to simulate tire pressure reading\nfloat getTirePressure() {\n    return 24.5f;  // Simulate low tire pressure (24.5 psi)\n}\n\n// Function to check for low tire pressure\nbool isLowTirePressure(float tirePressure) {\n    return tirePressure < LOW_TIRE_PRESSURE;  // Return true if pressure is below threshold\n}\n\n// Test case for tire pressure detection\nint main() {\n    float tirePressure = getTirePressure();  // Get tire pressure\n    std::cout << \"Tire Pressure: \" << tirePressure << \" psi\" << std::endl;\n\n    if (isLowTirePressure(tirePressure)) {\n        std::cout << \"WARNING: LOW TIRE PRESSURE!\" << std::endl;\n    } else {\n        std::cout << \"Tire Pressure is Normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high pedestrian traffic ahead. If more than 5 pedestrians are detected within a 10-meter range, trigger a warning.",
      "input": "Real-time data from pedestrian detection cameras and sensors.",
      "output": "#include <iostream>\n\nconst int PEDESTRIAN_COUNT_THRESHOLD = 5;  // Threshold for high pedestrian traffic\nconst float PEDESTRIAN_RANGE = 10.0f;  // Range in meters to detect pedestrians\n\n// Function to simulate the number of pedestrians detected in range\nint detectPedestriansInRange() {\n    return 6;  // Simulate detection of 6 pedestrians within the range\n}\n\n// Function to check for high pedestrian traffic\nbool isHighPedestrianTraffic(int pedestrianCount) {\n    return pedestrianCount > PEDESTRIAN_COUNT_THRESHOLD;  // Trigger warning if more than 5 pedestrians\n}\n\n// Test case for high pedestrian traffic detection\nint main() {\n    int pedestrianCount = detectPedestriansInRange();  // Get pedestrian count\n    std::cout << \"Number of Pedestrians: \" << pedestrianCount << std::endl;\n\n    if (isHighPedestrianTraffic(pedestrianCount)) {\n        std::cout << \"WARNING: HIGH PEDESTRIAN TRAFFIC AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"Pedestrian Traffic is Normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden acceleration by a vehicle ahead. If the vehicle ahead accelerates more than 10 km/h within 1 second, trigger a warning.",
      "input": "Real-time data from vehicle speed sensors and relative speed sensors.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float ACCELERATION_THRESHOLD = 10.0f;  // Acceleration threshold in km/h per second\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 50.0f;  // Speed of front vehicle\n}\n\n// Function to calculate speed change in the past second\nfloat getSpeedChange() {\n    return 12.0f;  // Simulate sudden acceleration of 12 km/h in 1 second\n}\n\n// Function to check for sudden acceleration\nbool isSuddenAccelerationRisk(float speedChange) {\n    return speedChange > ACCELERATION_THRESHOLD;  // Trigger warning if speed change exceeds threshold\n}\n\n// Test case for sudden acceleration detection\nint main() {\n    float speedChange = getSpeedChange();  // Get speed change in last second\n    std::cout << \"Speed Change in Last Second: \" << speedChange << \" km/h\" << std::endl;\n\n    if (isSuddenAccelerationRisk(speedChange)) {\n        std::cout << \"WARNING: SUDDEN ACCELERATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Acceleration Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a child crossing the road. If a child is detected in front of the vehicle within 3 meters, trigger a warning.",
      "input": "Real-time data from pedestrian detection camera and sensor.",
      "output": "#include <iostream>\n\nconst float CHILD_DETECTION_THRESHOLD = 3.0f;  // Threshold for child detection in meters\n\n// Function to simulate child detection\nfloat detectChildInFront() {\n    return 2.5f;  // Simulate child detected 2.5 meters in front\n}\n\n// Function to check for collision risk with detected child\nbool isChildCollisionRisk(float distance) {\n    return distance < CHILD_DETECTION_THRESHOLD;  // Trigger warning if child is within threshold\n}\n\n// Test case for child detection\nint main() {\n    float childDistance = detectChildInFront();  // Get distance to child\n    std::cout << \"Child Distance: \" << childDistance << \" meters\" << std::endl;\n\n    if (isChildCollisionRisk(childDistance)) {\n        std::cout << \"WARNING: CHILD CROSSING THE ROAD!\" << std::endl;\n    } else {\n        std::cout << \"No Child Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle drifts to the shoulder. If the vehicle crosses 1.5 meters from the center lane without signaling, trigger a warning.",
      "input": "Real-time data from lane detection cameras and steering angle sensor.",
      "output": "#include <iostream>\n#include <cmath>\n\nconst float LANE_DEPARTURE_THRESHOLD = 1.5f;  // Threshold for lane departure in meters\n\n// Function to simulate lane departure detection\nfloat detectLaneDeparture() {\n    return 1.8f;  // Simulate drifting 1.8 meters from lane center\n}\n\n// Function to check if vehicle is drifting out of lane\nbool isLaneDepartureRisk(float departureDistance) {\n    return departureDistance > LANE_DEPARTURE_THRESHOLD;  // Trigger warning if departure exceeds threshold\n}\n\n// Test case for lane departure detection\nint main() {\n    float departureDistance = detectLaneDeparture();  // Get lane departure distance\n    std::cout << \"Lane Departure Distance: \" << departureDistance << \" meters\" << std::endl;\n\n    if (isLaneDepartureRisk(departureDistance)) {\n        std::cout << \"WARNING: LANE DEPARTURE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects when a vehicle ahead is stopping suddenly. If the vehicle ahead slows down by more than 15 km/h within 2 seconds, trigger a warning.",
      "input": "Real-time vehicle speed data and relative speed data.",
      "output": "#include <iostream>\n\nconst float SPEED_CHANGE_THRESHOLD = 15.0f;  // Threshold for sudden deceleration in km/h\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 30.0f;  // Front vehicle speed of 30 km/h\n}\n\n// Function to calculate speed change in the past 2 seconds\nfloat getSpeedChange() {\n    return 20.0f;  // Simulate sudden deceleration of 20 km/h in 2 seconds\n}\n\n// Function to check for sudden deceleration\nbool isSuddenDecelerationRisk(float speedChange) {\n    return speedChange > SPEED_CHANGE_THRESHOLD;  // Trigger warning if speed change exceeds threshold\n}\n\n// Test case for sudden deceleration detection\nint main() {\n    float speedChange = getSpeedChange();  // Get speed change in last 2 seconds\n    std::cout << \"Speed Change in Last 2 Seconds: \" << speedChange << \" km/h\" << std::endl;\n\n    if (isSuddenDecelerationRisk(speedChange)) {\n        std::cout << \"WARNING: SUDDEN DECELERATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Deceleration Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a vehicle in the blind spot. If a vehicle is detected in the blind spot while the driver is signaling for a lane change, trigger a warning.",
      "input": "Real-time data from blind spot sensors and turn signal indicator.",
      "output": "#include <iostream>\n\nconst float BLIND_SPOT_THRESHOLD = 3.0f;  // Threshold for detecting vehicle in blind spot in meters\n\n// Function to simulate vehicle detection in blind spot\nfloat detectBlindSpotVehicle() {\n    return 2.5f;  // Simulate vehicle detected 2.5 meters in blind spot\n}\n\n// Function to check for vehicle in blind spot while signaling\nbool isBlindSpotRisk(float vehicleDistance) {\n    return vehicleDistance < BLIND_SPOT_THRESHOLD;  // Trigger warning if vehicle is in blind spot\n}\n\n// Test case for blind spot detection\nint main() {\n    float vehicleDistance = detectBlindSpotVehicle();  // Get distance to vehicle in blind spot\n    std::cout << \"Distance to Blind Spot Vehicle: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isBlindSpotRisk(vehicleDistance)) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Blind Spot Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects road rage behavior. If the vehicle speed exceeds 100 km/h and the distance to the vehicle ahead is less than 3 meters, trigger a warning.",
      "input": "Real-time vehicle speed and distance data.",
      "output": "#include <iostream>\n\nconst float SPEED_THRESHOLD = 100.0f;  // Road rage speed threshold in km/h\nconst float DISTANCE_THRESHOLD = 3.0f;  // Distance threshold in meters\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 110.0f;  // Simulate vehicle speed of 110 km/h\n}\n\n// Function to simulate distance to vehicle ahead\nfloat getVehicleDistance() {\n    return 2.5f;  // Simulate distance to the vehicle ahead\n}\n\n// Function to check for road rage risk\nbool isRoadRageRisk(float vehicleSpeed, float vehicleDistance) {\n    return vehicleSpeed > SPEED_THRESHOLD && vehicleDistance < DISTANCE_THRESHOLD;\n}\n\n// Test case for road rage detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float vehicleDistance = getVehicleDistance();  // Get distance to vehicle ahead\n\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Vehicle Distance: \" << vehicleDistance << \" meters\" << std::endl;\n\n    if (isRoadRageRisk(vehicleSpeed, vehicleDistance)) {\n        std::cout << \"WARNING: ROAD RAGE BEHAVIOR DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Road Rage Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a slow-moving vehicle ahead. If the vehicle ahead is moving slower than 20 km/h and the relative speed between the two vehicles is more than 10 km/h, trigger a warning.",
      "input": "Real-time data from vehicle speed and relative speed sensors.",
      "output": "#include <iostream>\n\nconst float SLOW_VEHICLE_SPEED_THRESHOLD = 20.0f;  // Slow-moving vehicle speed threshold\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // Relative speed threshold\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 18.0f;  // Simulate front vehicle speed of 18 km/h\n}\n\n// Function to simulate vehicle's speed\nfloat getVehicleSpeed() {\n    return 30.0f;  // Simulate vehicle speed of 30 km/h\n}\n\n// Function to calculate relative speed\nfloat getRelativeSpeed(float frontVehicleSpeed, float vehicleSpeed) {\n    return vehicleSpeed - frontVehicleSpeed;  // Relative speed between two vehicles\n}\n\n// Function to check for slow-moving vehicle ahead\nbool isSlowVehicleAhead(float frontVehicleSpeed, float relativeSpeed) {\n    return frontVehicleSpeed < SLOW_VEHICLE_SPEED_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD;  // Trigger warning if vehicle is moving slowly\n}\n\n// Test case for slow vehicle detection\nint main() {\n    float frontVehicleSpeed = getFrontVehicleSpeed();  // Get front vehicle speed\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float relativeSpeed = getRelativeSpeed(frontVehicleSpeed, vehicleSpeed);  // Get relative speed\n\n    std::cout << \"Front Vehicle Speed: \" << frontVehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n\n    if (isSlowVehicleAhead(frontVehicleSpeed, relativeSpeed)) {\n        std::cout << \"WARNING: SLOW MOVING VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Slow Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a pedestrian at a crosswalk. If a pedestrian is detected within 5 meters of the vehicle's path, trigger a warning.",
      "input": "Real-time data from pedestrian detection camera and proximity sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 5.0f;  // Pedestrian detection threshold in meters\n\n// Function to simulate pedestrian detection distance\nfloat detectPedestrian() {\n    return 4.0f;  // Simulate pedestrian detected 4 meters ahead\n}\n\n// Function to check for pedestrian in path\nbool isPedestrianInPath(float distance) {\n    return distance < PEDESTRIAN_DETECTION_THRESHOLD;  // Trigger warning if pedestrian is within threshold\n}\n\n// Test case for pedestrian detection\nint main() {\n    float pedestrianDistance = detectPedestrian();  // Get distance to pedestrian\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianInPath(pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN AT CROSSWALK!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian in Path.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden lane departure. If the vehicle crosses the lane markings without signaling, trigger a warning.",
      "input": "Real-time data from lane detection camera and steering angle sensor.",
      "output": "#include <iostream>\n\nconst float LANE_DEPARTURE_THRESHOLD = 1.0f;  // Lane departure threshold in meters\n\n// Function to simulate lane departure distance\nfloat detectLaneDeparture() {\n    return 1.2f;  // Simulate lane departure of 1.2 meters\n}\n\n// Function to check for lane departure risk\nbool isLaneDepartureRisk(float laneDepartureDistance) {\n    return laneDepartureDistance > LANE_DEPARTURE_THRESHOLD;  // Trigger warning if lane departure exceeds threshold\n}\n\n// Test case for lane departure detection\nint main() {\n    float laneDepartureDistance = detectLaneDeparture();  // Get lane departure distance\n    std::cout << \"Lane Departure Distance: \" << laneDepartureDistance << \" meters\" << std::endl;\n\n    if (isLaneDepartureRisk(laneDepartureDistance)) {\n        std::cout << \"WARNING: LANE DEPARTURE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects stopped traffic ahead. If the vehicle ahead has a speed of 0 km/h and the vehicle's relative speed is greater than 10 km/h, trigger a warning.",
      "input": "Real-time data from vehicle speed sensors and relative speed sensors.",
      "output": "#include <iostream>\n\nconst float STOPPED_VEHICLE_SPEED_THRESHOLD = 0.0f;  // Stopped vehicle speed threshold\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // Relative speed threshold\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 0.0f;  // Simulate stopped vehicle ahead\n}\n\n// Function to simulate vehicle's speed\nfloat getVehicleSpeed() {\n    return 20.0f;  // Simulate vehicle speed of 20 km/h\n}\n\n// Function to calculate relative speed\nfloat getRelativeSpeed(float frontVehicleSpeed, float vehicleSpeed) {\n    return vehicleSpeed - frontVehicleSpeed;  // Relative speed between two vehicles\n}\n\n// Function to check for stopped traffic ahead\nbool isStoppedTrafficAhead(float frontVehicleSpeed, float relativeSpeed) {\n    return frontVehicleSpeed == STOPPED_VEHICLE_SPEED_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD;  // Trigger warning if stopped traffic ahead\n}\n\n// Test case for stopped traffic detection\nint main() {\n    float frontVehicleSpeed = getFrontVehicleSpeed();  // Get front vehicle speed\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    float relativeSpeed = getRelativeSpeed(frontVehicleSpeed, vehicleSpeed);  // Get relative speed\n\n    std::cout << \"Front Vehicle Speed: \" << frontVehicleSpeed << \" km/h\" << std::endl;\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n\n    if (isStoppedTrafficAhead(frontVehicleSpeed, relativeSpeed)) {\n        std::cout << \"WARNING: STOPPED TRAFFIC AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Stopped Traffic Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is going too fast on a curve. If the vehicle's speed exceeds 60 km/h while turning, trigger a warning.",
      "input": "Real-time data from vehicle speed sensor and GPS curve data.",
      "output": "#include <iostream>\n\nconst float CURVE_SPEED_THRESHOLD = 60.0f;  // Speed threshold for curves in km/h\n\n// Function to simulate vehicle speed\nfloat getVehicleSpeed() {\n    return 65.0f;  // Simulate vehicle speed of 65 km/h\n}\n\n// Function to simulate curve detection\nbool isOnCurve() {\n    return true;  // Simulate vehicle on a curve\n}\n\n// Function to check for speed on curve risk\nbool isSpeedingOnCurve(float vehicleSpeed) {\n    return isOnCurve() && vehicleSpeed > CURVE_SPEED_THRESHOLD;  // Trigger warning if speed exceeds threshold while on a curve\n}\n\n// Test case for speed on curve detection\nint main() {\n    float vehicleSpeed = getVehicleSpeed();  // Get vehicle speed\n    std::cout << \"Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isSpeedingOnCurve(vehicleSpeed)) {\n        std::cout << \"WARNING: EXCESSIVE SPEED ON CURVE!\" << std::endl;\n    } else {\n        std::cout << \"No Speeding Risk on Curve.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects the risk of a rear-end collision. If the relative speed between vehicles is greater than 20 km/h and the distance is less than 5 meters, trigger a warning.",
      "input": "Real-time data from vehicle speed sensor and rear-facing radar.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0f;  // Distance threshold for rear-end collision risk\nconst float COLLISION_SPEED_THRESHOLD = 20.0f;  // Speed threshold for rear-end collision risk\n\n// Function to simulate relative speed to vehicle behind\nfloat getRelativeSpeed() {\n    return 25.0f;  // Simulate relative speed of 25 km/h\n}\n\n// Function to simulate distance to vehicle behind\nfloat getDistanceToRearVehicle() {\n    return 3.0f;  // Simulate distance to rear vehicle of 3 meters\n}\n\n// Function to check for rear-end collision risk\nbool isRearEndCollisionRisk(float relativeSpeed, float distanceToRearVehicle) {\n    return relativeSpeed > COLLISION_SPEED_THRESHOLD && distanceToRearVehicle < COLLISION_DISTANCE_THRESHOLD;  // Trigger warning if collision risk is detected\n}\n\n// Test case for rear-end collision detection\nint main() {\n    float relativeSpeed = getRelativeSpeed();  // Get relative speed to vehicle behind\n    float distanceToRearVehicle = getDistanceToRearVehicle();  // Get distance to rear vehicle\n\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n    std::cout << \"Distance to Rear Vehicle: \" << distanceToRearVehicle << \" meters\" << std::endl;\n\n    if (isRearEndCollisionRisk(relativeSpeed, distanceToRearVehicle)) {\n        std::cout << \"WARNING: REAR-END COLLISION RISK!\" << std::endl;\n    } else {\n        std::cout << \"No Rear-End Collision Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects high traffic density ahead. If the vehicle density in front exceeds 30 vehicles per kilometer, trigger a warning.",
      "input": "Real-time data from traffic density sensors.",
      "output": "#include <iostream>\n\nconst int DENSITY_THRESHOLD = 30;  // Vehicle density threshold\n\n// Function to simulate traffic density\nint getTrafficDensity() {\n    return 35;  // Simulate high traffic density of 35 vehicles per kilometer\n}\n\n// Function to check for high traffic density\nbool isHighTrafficDensity(int trafficDensity) {\n    return trafficDensity > DENSITY_THRESHOLD;  // Trigger warning if density exceeds threshold\n}\n\n// Test case for traffic density detection\nint main() {\n    int trafficDensity = getTrafficDensity();  // Get traffic density\n    std::cout << \"Traffic Density: \" << trafficDensity << \" vehicles per km\" << std::endl;\n\n    if (isHighTrafficDensity(trafficDensity)) {\n        std::cout << \"WARNING: HIGH TRAFFIC DENSITY AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No High Traffic Density Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects hard braking by the vehicle ahead. If the deceleration rate exceeds 5 m/s^2, trigger a warning.",
      "input": "Real-time data from vehicle deceleration sensors.",
      "output": "#include <iostream>\n\nconst float DECELERATION_THRESHOLD = 5.0f;  // Hard braking deceleration threshold in m/s^2\n\n// Function to simulate vehicle deceleration rate\nfloat getVehicleDeceleration() {\n    return 6.0f;  // Simulate hard braking with deceleration of 6 m/s^2\n}\n\n// Function to check for hard braking risk\nbool isHardBrakingRisk(float deceleration) {\n    return deceleration > DECELERATION_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for hard braking detection\nint main() {\n    float deceleration = getVehicleDeceleration();  // Get vehicle deceleration rate\n    std::cout << \"Deceleration Rate: \" << deceleration << \" m/s^2\" << std::endl;\n\n    if (isHardBrakingRisk(deceleration)) {\n        std::cout << \"WARNING: HARD BRAKING AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Hard Braking Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a pedestrian crossing in front of the vehicle. If a pedestrian is detected within 3 meters of the vehicle's path, trigger a warning.",
      "input": "Real-time data from pedestrian detection sensors and proximity sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DISTANCE_THRESHOLD = 3.0f;  // Pedestrian detection threshold in meters\n\n// Function to simulate pedestrian detection distance\nfloat detectPedestrian() {\n    return 2.5f;  // Simulate pedestrian detected 2.5 meters ahead\n}\n\n// Function to check for pedestrian in the vehicle's path\nbool isPedestrianInPath(float distance) {\n    return distance < PEDESTRIAN_DISTANCE_THRESHOLD;  // Trigger warning if pedestrian is within threshold\n}\n\n// Test case for pedestrian detection\nint main() {\n    float pedestrianDistance = detectPedestrian();  // Get pedestrian distance\n    std::cout << \"Pedestrian Distance: \" << pedestrianDistance << \" meters\" << std::endl;\n\n    if (isPedestrianInPath(pedestrianDistance)) {\n        std::cout << \"WARNING: PEDESTRIAN CROSSING!\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is following too closely behind another vehicle. If the distance to the vehicle ahead is less than 2 meters and the relative speed is greater than 10 km/h, trigger a warning.",
      "input": "Real-time data from vehicle sensors (distance and speed).",
      "output": "#include <iostream>\n\nconst float CLOSE_FOLLOWING_THRESHOLD = 2.0f;  // Distance threshold in meters\nconst float RELATIVE_SPEED_THRESHOLD = 10.0f;  // Relative speed threshold in km/h\n\n// Function to simulate distance to the vehicle ahead\nfloat getDistanceToVehicleAhead() {\n    return 1.5f;  // Simulate close following vehicle 1.5 meters away\n}\n\n// Function to simulate relative speed\nfloat getRelativeSpeed() {\n    return 15.0f;  // Simulate relative speed of 15 km/h\n}\n\n// Function to check for close following risk\nbool isCloseFollowing(float distanceToVehicle, float relativeSpeed) {\n    return distanceToVehicle < CLOSE_FOLLOWING_THRESHOLD && relativeSpeed > RELATIVE_SPEED_THRESHOLD;  // Trigger warning if too close\n}\n\n// Test case for close following detection\nint main() {\n    float distanceToVehicle = getDistanceToVehicleAhead();  // Get distance to vehicle ahead\n    float relativeSpeed = getRelativeSpeed();  // Get relative speed\n\n    std::cout << \"Distance to Vehicle Ahead: \" << distanceToVehicle << \" meters\" << std::endl;\n    std::cout << \"Relative Speed: \" << relativeSpeed << \" km/h\" << std::endl;\n\n    if (isCloseFollowing(distanceToVehicle, relativeSpeed)) {\n        std::cout << \"WARNING: CLOSE FOLLOWING VEHICLE!\" << std::endl;\n    } else {\n        std::cout << \"No Close Following Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle ahead is suddenly stopping. If the vehicle ahead decelerates rapidly (greater than 4 m/s\\u00b2), trigger a warning.",
      "input": "Real-time data from vehicle deceleration sensors and front-facing radar.",
      "output": "#include <iostream>\n\nconst float SUDDEN_STOP_THRESHOLD = 4.0f;  // Deceleration threshold in m/s^2\n\n// Function to simulate front vehicle deceleration rate\nfloat getFrontVehicleDeceleration() {\n    return 5.0f;  // Simulate sudden stop with 5 m/s^2 deceleration\n}\n\n// Function to check for sudden stop risk\nbool isSuddenStopAhead(float deceleration) {\n    return deceleration > SUDDEN_STOP_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for sudden stop detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get front vehicle deceleration\n    std::cout << \"Front Vehicle Deceleration: \" << deceleration << \" m/s^2\" << std::endl;\n\n    if (isSuddenStopAhead(deceleration)) {\n        std::cout << \"WARNING: SUDDEN STOP AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Stop Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects an incorrect lane change. If the vehicle crosses lane markings without a signal, trigger a warning.",
      "input": "Real-time data from lane detection sensors and steering angle sensor.",
      "output": "#include <iostream>\n\nconst float LANE_DEPARTURE_THRESHOLD = 0.5f;  // Lane departure threshold in meters\n\n// Function to simulate lane detection status\nbool isLaneDepartureDetected() {\n    return true;  // Simulate lane departure\n}\n\n// Function to simulate whether the turn signal is on\nbool isTurnSignalOn() {\n    return false;  // Simulate no turn signal active\n}\n\n// Function to check for incorrect lane change\nbool isIncorrectLaneChange() {\n    return isLaneDepartureDetected() && !isTurnSignalOn();  // Trigger warning if lane departure occurs without signal\n}\n\n// Test case for lane change detection\nint main() {\n    if (isIncorrectLaneChange()) {\n        std::cout << \"WARNING: INCORRECT LANE CHANGE!\" << std::endl;\n    } else {\n        std::cout << \"No Lane Change Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a vehicle in the blind spot. If another vehicle is detected in the blind spot zone and the driver attempts to change lanes, trigger a warning.",
      "input": "Real-time data from blind spot monitoring sensors and steering angle sensor.",
      "output": "#include <iostream>\n\nconst float BLIND_SPOT_ZONE_THRESHOLD = 3.0f;  // Blind spot zone threshold in meters\n\n// Function to simulate vehicle detection in the blind spot\nbool isVehicleInBlindSpot() {\n    return true;  // Simulate a vehicle detected in the blind spot\n}\n\n// Function to simulate steering angle (change lane attempt)\nfloat getSteeringAngle() {\n    return 30.0f;  // Simulate a lane change attempt with 30-degree steering angle\n}\n\n// Function to check for blind spot collision risk\nbool isBlindSpotRisk() {\n    return isVehicleInBlindSpot() && getSteeringAngle() > 20.0f;  // Trigger warning if vehicle is in blind spot during lane change\n}\n\n// Test case for blind spot detection\nint main() {\n    if (isBlindSpotRisk()) {\n        std::cout << \"WARNING: VEHICLE IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Blind Spot Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects an object (e.g., vehicle or obstruction) in front of the vehicle at an intersection. If an object is detected within 10 meters, trigger a warning.",
      "input": "Real-time data from front-facing camera and proximity sensors.",
      "output": "#include <iostream>\n\nconst float OBJECT_DETECTION_THRESHOLD = 10.0f;  // Object detection threshold in meters\n\n// Function to simulate object detection distance\nfloat detectObjectAtIntersection() {\n    return 8.0f;  // Simulate an object detected 8 meters ahead\n}\n\n// Function to check for object in path\nbool isObjectInPath(float distance) {\n    return distance < OBJECT_DETECTION_THRESHOLD;  // Trigger warning if object is within threshold\n}\n\n// Test case for object detection at intersection\nint main() {\n    float objectDistance = detectObjectAtIntersection();  // Get object distance\n    std::cout << \"Object Distance: \" << objectDistance << \" meters\" << std::endl;\n\n    if (isObjectInPath(objectDistance)) {\n        std::cout << \"WARNING: OBJECT AHEAD AT INTERSECTION!\" << std::endl;\n    } else {\n        std::cout << \"No Object Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects reduced visibility due to weather conditions (e.g., fog, rain). If visibility drops below a certain threshold (100 meters), trigger a warning.",
      "input": "Real-time data from visibility sensors (e.g., camera, radar).",
      "output": "#include <iostream>\n\nconst float VISIBILITY_THRESHOLD = 100.0f;  // Visibility threshold in meters\n\n// Function to simulate current visibility\nfloat getCurrentVisibility() {\n    return 80.0f;  // Simulate reduced visibility (80 meters)\n}\n\n// Function to check for reduced visibility risk\nbool isReducedVisibility(float visibility) {\n    return visibility < VISIBILITY_THRESHOLD;  // Trigger warning if visibility is below threshold\n}\n\n// Test case for visibility detection\nint main() {\n    float visibility = getCurrentVisibility();  // Get current visibility\n    std::cout << \"Current Visibility: \" << visibility << \" meters\" << std::endl;\n\n    if (isReducedVisibility(visibility)) {\n        std::cout << \"WARNING: REDUCED VISIBILITY AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Reduced Visibility Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects slippery road conditions. If the road surface friction drops below a threshold, trigger a warning.",
      "input": "Real-time data from road surface friction sensors and weather sensors.",
      "output": "#include <iostream>\n\nconst float ROAD_FRICTION_THRESHOLD = 0.3f;  // Road surface friction threshold\n\n// Function to simulate road surface friction\nfloat getRoadSurfaceFriction() {\n    return 0.2f;  // Simulate slippery road condition with low friction\n}\n\n// Function to check for slippery road risk\nbool isSlipperyRoad(float friction) {\n    return friction < ROAD_FRICTION_THRESHOLD;  // Trigger warning if friction is below threshold\n}\n\n// Test case for slippery road detection\nint main() {\n    float friction = getRoadSurfaceFriction();  // Get road surface friction\n    std::cout << \"Road Surface Friction: \" << friction << std::endl;\n\n    if (isSlipperyRoad(friction)) {\n        std::cout << \"WARNING: SLIPPERY ROAD CONDITIONS!\" << std::endl;\n    } else {\n        std::cout << \"No Slippery Road Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects an obstacle in the vehicle's path. If an obstacle is detected within 5 meters, trigger a warning.",
      "input": "Real-time data from front-facing radar and ultrasonic sensors.",
      "output": "#include <iostream>\n\nconst float OBSTACLE_DISTANCE_THRESHOLD = 5.0f;  // Obstacle detection threshold in meters\n\n// Function to simulate obstacle detection distance\nfloat detectObstacleInPath() {\n    return 3.0f;  // Simulate obstacle detected 3 meters ahead\n}\n\n// Function to check for obstacle in path\nbool isObstacleInPath(float distance) {\n    return distance < OBSTACLE_DISTANCE_THRESHOLD;  // Trigger warning if obstacle is within threshold\n}\n\n// Test case for obstacle detection\nint main() {\n    float obstacleDistance = detectObstacleInPath();  // Get obstacle distance\n    std::cout << \"Obstacle Distance: \" << obstacleDistance << \" meters\" << std::endl;\n\n    if (isObstacleInPath(obstacleDistance)) {\n        std::cout << \"WARNING: OBSTACLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Obstacle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects the risk of collision while reversing. If the vehicle is reversing and detects an object within 2 meters, trigger a warning.",
      "input": "Real-time data from rear sensors and reverse gear status.",
      "output": "#include <iostream>\n\nconst float REVERSE_COLLISION_THRESHOLD = 2.0f;  // Collision threshold for reversing in meters\n\n// Function to simulate rear object detection distance\nfloat detectRearObject() {\n    return 1.5f;  // Simulate an object detected 1.5 meters behind\n}\n\n// Function to check for collision risk while reversing\nbool isReverseCollisionRisk(float distance) {\n    return distance < REVERSE_COLLISION_THRESHOLD;  // Trigger warning if object is within threshold\n}\n\n// Test case for reverse collision risk detection\nint main() {\n    bool isReversing = true;  // Assume vehicle is in reverse\n    if (isReversing) {\n        float rearObjectDistance = detectRearObject();  // Get distance to rear object\n        std::cout << \"Rear Object Distance: \" << rearObjectDistance << \" meters\" << std::endl;\n\n        if (isReverseCollisionRisk(rearObjectDistance)) {\n            std::cout << \"WARNING: COLLISION RISK WHILE REVERSING!\" << std::endl;\n        } else {\n            std::cout << \"No Collision Risk While Reversing.\" << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a slow-moving vehicle ahead. If the vehicle ahead is moving at less than 20 km/h, trigger a warning.",
      "input": "Real-time data from front radar and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float SLOW_MOVING_THRESHOLD = 20.0f;  // Slow-moving vehicle speed threshold in km/h\n\n// Function to simulate speed of vehicle ahead\nfloat getFrontVehicleSpeed() {\n    return 15.0f;  // Simulate a slow-moving vehicle ahead at 15 km/h\n}\n\n// Function to check if vehicle ahead is moving too slowly\nbool isSlowMovingAhead(float speed) {\n    return speed < SLOW_MOVING_THRESHOLD;  // Trigger warning if vehicle ahead is too slow\n}\n\n// Test case for slow-moving vehicle detection\nint main() {\n    float vehicleSpeed = getFrontVehicleSpeed();  // Get speed of vehicle ahead\n    std::cout << \"Front Vehicle Speed: \" << vehicleSpeed << \" km/h\" << std::endl;\n\n    if (isSlowMovingAhead(vehicleSpeed)) {\n        std::cout << \"WARNING: SLOW MOVING VEHICLE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Slow Moving Vehicle Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects uneven road surfaces. If the vehicle detects a significant bump or uneven terrain (greater than 5 cm variation), trigger a warning.",
      "input": "Real-time data from road surface monitoring sensors (e.g., accelerometers).",
      "output": "#include <iostream>\n\nconst float ROAD_SURFACE_VARIATION_THRESHOLD = 0.05f;  // Road surface variation threshold in meters\n\n// Function to simulate road surface bump variation\nfloat getRoadSurfaceVariation() {\n    return 0.06f;  // Simulate a road bump with 6 cm variation\n}\n\n// Function to check for uneven road surface\nbool isUnevenRoadSurface(float variation) {\n    return variation > ROAD_SURFACE_VARIATION_THRESHOLD;  // Trigger warning if variation exceeds threshold\n}\n\n// Test case for uneven road surface detection\nint main() {\n    float surfaceVariation = getRoadSurfaceVariation();  // Get road surface variation\n    std::cout << \"Road Surface Variation: \" << surfaceVariation << \" meters\" << std::endl;\n\n    if (isUnevenRoadSurface(surfaceVariation)) {\n        std::cout << \"WARNING: UNEVEN ROAD SURFACE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Uneven Road Surface Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is approaching a traffic signal with insufficient time to stop. If the signal is about to turn red within 5 seconds, trigger a warning.",
      "input": "Real-time data from traffic signal detection cameras and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst int TRAFFIC_SIGNAL_WARNING_TIME = 5;  // Time to red light warning threshold in seconds\n\n// Function to simulate traffic signal status\nbool isTrafficLightRed() {\n    return true;  // Simulate red light\n}\n\n// Function to simulate time to red light turning on\nint timeToRedLight() {\n    return 4;  // Simulate 4 seconds to red light\n}\n\n// Function to check if there's insufficient time to stop at a red light\nbool isTrafficSignalViolation(int timeToRed) {\n    return isTrafficLightRed() && timeToRed < TRAFFIC_SIGNAL_WARNING_TIME;  // Trigger warning if time to red light is less than threshold\n}\n\n// Test case for traffic signal violation detection\nint main() {\n    int redLightTime = timeToRedLight();  // Get time to red light\n    std::cout << \"Time to Red Light: \" << redLightTime << \" seconds\" << std::endl;\n\n    if (isTrafficSignalViolation(redLightTime)) {\n        std::cout << \"WARNING: TRAFFIC SIGNAL VIOLATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Traffic Signal Violation Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle ahead has malfunctioning brake lights. If the brake lights of the vehicle ahead are not detected when decelerating, trigger a warning.",
      "input": "Real-time data from brake light monitoring sensors and front vehicle speed sensors.",
      "output": "#include <iostream>\n\n// Function to simulate detection of brake lights in the vehicle ahead\nbool areBrakeLightsFunctional() {\n    return false;  // Simulate malfunctioning brake lights\n}\n\n// Function to simulate front vehicle deceleration\nfloat getFrontVehicleDeceleration() {\n    return 3.0f;  // Simulate deceleration at 3 m/s^2\n}\n\n// Function to check for malfunctioning brake lights\nbool isMalfunctioningBrakeLights(float deceleration) {\n    return !areBrakeLightsFunctional() && deceleration > 2.0f;  // Trigger warning if brake lights are malfunctioning and decelerating\n}\n\n// Test case for malfunctioning brake lights detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get front vehicle deceleration\n    std::cout << \"Front Vehicle Deceleration: \" << deceleration << \" m/s^2\" << std::endl;\n\n    if (isMalfunctioningBrakeLights(deceleration)) {\n        std::cout << \"WARNING: MALFUNCTIONING BRAKE LIGHTS AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Brake Light Malfunction Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a rapid lane departure. If the vehicle crosses lane markings at a speed greater than 60 km/h without turn signals, trigger a warning.",
      "input": "Real-time data from lane departure sensors and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float LANE_DEPARTURE_SPEED_THRESHOLD = 60.0f;  // Speed threshold for lane departure in km/h\n\n// Function to simulate current vehicle speed\nfloat getCurrentSpeed() {\n    return 65.0f;  // Simulate vehicle moving at 65 km/h\n}\n\n// Function to simulate lane departure detection\nbool isLaneDepartureDetected() {\n    return true;  // Simulate lane departure detected\n}\n\n// Function to check for rapid lane departure\nbool isRapidLaneDeparture(float speed) {\n    return isLaneDepartureDetected() && speed > LANE_DEPARTURE_SPEED_THRESHOLD;  // Trigger warning if lane departure is detected at high speed\n}\n\n// Test case for rapid lane departure detection\nint main() {\n    float speed = getCurrentSpeed();  // Get current vehicle speed\n    std::cout << \"Current Vehicle Speed: \" << speed << \" km/h\" << std::endl;\n\n    if (isRapidLaneDeparture(speed)) {\n        std::cout << \"WARNING: RAPID LANE DEPARTURE AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Rapid Lane Departure Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians in the vehicle's path. If a pedestrian is detected within 3 meters, trigger a warning.",
      "input": "Real-time data from front-facing cameras and lidar sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 3.0f;  // Pedestrian detection threshold in meters\n\n// Function to simulate pedestrian detection distance\nfloat detectPedestrianInPath() {\n    return 2.5f;  // Simulate pedestrian detected 2.5 meters ahead\n}\n\n// Function to check for pedestrian in path\nbool isPedestrianIn\nYou said:\ngive me another 10 examples like this with real time data for fcw in cars\nChatGPT said:\nChatGPT\nHere are 10 more examples of Forward Collision Warning (FCW) systems in cars using real-time data:\n\n{"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects heavy rainfall. If rainfall is detected at a rate greater than 20 mm/h, trigger a warning to reduce speed.",
      "input": "Real-time data from rainfall sensors and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float RAINFALL_THRESHOLD = 20.0f;  // Heavy rainfall threshold in mm/h\n\n// Function to simulate rainfall intensity\nfloat getRainfallIntensity() {\n    return 25.0f;  // Simulate rainfall intensity of 25 mm/h\n}\n\n// Function to check for heavy rainfall\nbool isHeavyRainfall(float intensity) {\n    return intensity > RAINFALL_THRESHOLD;  // Trigger warning if rainfall exceeds threshold\n}\n\n// Test case for heavy rainfall detection\nint main() {\n    float rainfallIntensity = getRainfallIntensity();  // Get rainfall intensity\n    std::cout << \"Rainfall Intensity: \" << rainfallIntensity << \" mm/h\" << std::endl;\n\n    if (isHeavyRainfall(rainfallIntensity)) {\n        std::cout << \"WARNING: HEAVY RAINFALL AHEAD! REDUCE SPEED.\" << std::endl;\n    } else {\n        std::cout << \"No Heavy Rainfall Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if there is a crosswalk ahead. If a crosswalk is detected within 30 meters and there is a pedestrian nearby, trigger a warning.",
      "input": "Real-time data from camera and pedestrian detection sensors.",
      "output": "#include <iostream>\n\nconst float CROSSWALK_DETECTION_THRESHOLD = 30.0f;  // Crosswalk detection threshold in meters\nconst float PEDESTRIAN_PROXIMITY_THRESHOLD = 5.0f;  // Proximity threshold for pedestrian in meters\n\n// Function to simulate crosswalk detection distance\nfloat getCrosswalkDistance() {\n    return 20.0f;  // Simulate crosswalk detected 20 meters ahead\n}\n\n// Function to simulate pedestrian proximity\nfloat getPedestrianProximity() {\n    return 3.0f;  // Simulate a pedestrian 3 meters away\n}\n\n// Function to check for crosswalk and pedestrian risk\nbool isCrosswalkRisk(float crosswalkDistance, float pedestrianProximity) {\n    return crosswalkDistance < CROSSWALK_DETECTION_THRESHOLD && pedestrianProximity < PEDESTRIAN_PROXIMITY_THRESHOLD;  // Trigger warning if both conditions met\n}\n\n// Test case for crosswalk detection\nint main() {\n    float crosswalkDistance = getCrosswalkDistance();  // Get distance to crosswalk\n    float pedestrianProximity = getPedestrianProximity();  // Get pedestrian proximity\n\n    if (isCrosswalkRisk(crosswalkDistance, pedestrianProximity)) {\n        std::cout << \"WARNING: PEDESTRIAN ON CROSSWALK AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Crosswalk Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects a sudden lane change. If the vehicle suddenly changes lanes without signaling, trigger a warning.",
      "input": "Real-time data from lane change sensors and turn signal status.",
      "output": "#include <iostream>\n\nconst bool TURN_SIGNAL_STATUS = false;  // Assume the turn signal is off\n\n// Function to simulate lane change detection\nbool isLaneChangeDetected() {\n    return true;  // Simulate sudden lane change detection\n}\n\n// Function to check for sudden lane change without signaling\nbool isSuddenLaneChange() {\n    return isLaneChangeDetected() && !TURN_SIGNAL_STATUS;  // Trigger warning if lane change is detected without signaling\n}\n\n// Test case for sudden lane change detection\nint main() {\n    if (isSuddenLaneChange()) {\n        std::cout << \"WARNING: SUDDEN LANE CHANGE DETECTED!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Lane Change Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects obstructions in the blind spot. If an obstruction is detected in the blind spot while attempting a lane change, trigger a warning.",
      "input": "Real-time data from blind spot sensors and lane change signals.",
      "output": "#include <iostream>\n\nconst float BLIND_SPOT_DETECTION_THRESHOLD = 3.0f;  // Blind spot obstruction detection threshold in meters\n\n// Function to simulate blind spot detection distance\nfloat getBlindSpotDistance() {\n    return 2.5f;  // Simulate an obstruction in the blind spot 2.5 meters away\n}\n\n// Function to simulate lane change signal status\nbool isLaneChangeSignalOn() {\n    return true;  // Simulate lane change signal on\n}\n\n// Function to check for obstruction in blind spot during lane change\nbool isBlindSpotObstruction(float blindSpotDistance) {\n    return blindSpotDistance < BLIND_SPOT_DETECTION_THRESHOLD && isLaneChangeSignalOn();  // Trigger warning if obstruction is in the blind spot while signaling lane change\n}\n\n// Test case for blind spot obstruction detection\nint main() {\n    float blindSpotDistance = getBlindSpotDistance();  // Get distance to blind spot obstruction\n\n    if (isBlindSpotObstruction(blindSpotDistance)) {\n        std::cout << \"WARNING: OBSTRUCTION IN BLIND SPOT!\" << std::endl;\n    } else {\n        std::cout << \"No Obstruction in Blind Spot.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects stop sign violation. If the vehicle approaches a stop sign at a speed greater than 5 km/h, trigger a warning.",
      "input": "Real-time data from traffic sign recognition cameras and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float STOP_SIGN_VIOLATION_THRESHOLD_SPEED = 5.0f;  // Speed threshold for stop sign violation in km/h\n\n// Function to simulate stop sign detection\nbool isStopSignDetected() {\n    return true;  // Simulate stop sign detected\n}\n\n// Function to simulate vehicle speed\nfloat getCurrentSpeed() {\n    return 6.0f;  // Simulate vehicle moving at 6 km/h\n}\n\n// Function to check for stop sign violation\nbool isStopSignViolation(float speed) {\n    return isStopSignDetected() && speed > STOP_SIGN_VIOLATION_THRESHOLD_SPEED;  // Trigger warning if vehicle violates stop sign\n}\n\n// Test case for stop sign violation detection\nint main() {\n    float speed = getCurrentSpeed();  // Get current vehicle speed\n\n    if (isStopSignViolation(speed)) {\n        std::cout << \"WARNING: STOP SIGN VIOLATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Stop Sign Violation Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden braking by the vehicle ahead. If the vehicle ahead decelerates faster than 3 m/s\\u00b2, trigger a warning.",
      "input": "Real-time data from front radar and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float SUDDEN_BRAKING_THRESHOLD = 3.0f;  // Sudden braking threshold in m/s\u00c2\u00b2\n\n// Function to simulate deceleration of the vehicle ahead\nfloat getFrontVehicleDeceleration() {\n    return 3.5f;  // Simulate a deceleration of 3.5 m/s\u00c2\u00b2\n}\n\n// Function to check for sudden braking\nbool isSuddenBraking(float deceleration) {\n    return deceleration > SUDDEN_BRAKING_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for sudden braking detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get deceleration of vehicle ahead\n\n    if (isSuddenBraking(deceleration)) {\n        std::cout << \"WARNING: SUDDEN BRAKING AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Braking Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects foggy weather conditions. If fog is detected with visibility below 100 meters, trigger a warning.",
      "input": "Real-time data from weather sensors and visibility measurement systems.",
      "output": "#include <iostream>\n\nconst float FOG_VISIBILITY_THRESHOLD = 100.0f;  // Visibility threshold for foggy weather in meters\n\n// Function to simulate foggy weather condition\nfloat getVisibility() {\n    return 90.0f;  // Simulate visibility of 90 meters in foggy weather\n}\n\n// Function to check for foggy weather\nbool isFoggyWeather(float visibility) {\n    return visibility < FOG_VISIBILITY_THRESHOLD;  // Trigger warning if visibility is less than threshold\n}\n\n// Test case for foggy weather detection\nint main() {\n    float visibility = getVisibility();  // Get visibility in foggy weather\n\n    if (isFoggyWeather(visibility)) {\n        std::cout << \"WARNING: FOGGY WEATHER AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Foggy Weather Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects pedestrians crossing in front of the vehicle. If a pedestrian is detected within 5 meters of the vehicle and moving toward it, trigger a collision warning.",
      "input": "Real-time data from pedestrian detection sensors and vehicle proximity sensors.",
      "output": "#include <iostream>\n\nconst float PEDESTRIAN_DETECTION_THRESHOLD = 5.0f;  // Pedestrian proximity threshold in meters\nconst float PEDESTRIAN_SPEED_THRESHOLD = 1.0f;  // Pedestrian speed threshold in m/s\n\n// Function to simulate pedestrian detection distance\nfloat getPedestrianDistance() {\n    return 4.0f;  // Simulate a pedestrian 4 meters away\n}\n\n// Function to simulate pedestrian speed\nfloat getPedestrianSpeed() {\n    return 1.5f;  // Simulate a pedestrian moving at 1.5 m/s towards the vehicle\n}\n\n// Function to check for pedestrian collision risk\nbool isPedestrianRisk(float distance, float speed) {\n    return distance < PEDESTRIAN_DETECTION_THRESHOLD && speed > PEDESTRIAN_SPEED_THRESHOLD;  // Trigger warning if pedestrian is too close and moving towards vehicle\n}\n\n// Test case for pedestrian collision detection\nint main() {\n    float distance = getPedestrianDistance();  // Get distance to pedestrian\n    float speed = getPedestrianSpeed();  // Get speed of pedestrian\n\n    if (isPedestrianRisk(distance, speed)) {\n        std::cout << \"WARNING: PEDESTRIAN AHEAD! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Pedestrian Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects animals crossing the road. If an animal is detected within 10 meters of the vehicle, trigger a collision warning.",
      "input": "Real-time data from camera and motion sensors.",
      "output": "#include <iostream>\n\nconst float ANIMAL_DETECTION_THRESHOLD = 10.0f;  // Animal proximity threshold in meters\n\n// Function to simulate animal detection distance\nfloat getAnimalDistance() {\n    return 8.0f;  // Simulate an animal 8 meters away from the vehicle\n}\n\n// Function to check for animal collision risk\nbool isAnimalRisk(float distance) {\n    return distance < ANIMAL_DETECTION_THRESHOLD;  // Trigger warning if animal is within proximity threshold\n}\n\n// Test case for animal collision detection\nint main() {\n    float distance = getAnimalDistance();  // Get distance to detected animal\n\n    if (isAnimalRisk(distance)) {\n        std::cout << \"WARNING: ANIMAL CROSSING! COLLISION RISK.\" << std::endl;\n    } else {\n        std::cout << \"No Animal Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects if the vehicle is approaching a red light at high speed. If the vehicle is within 50 meters of the red light and moving faster than 10 km/h, trigger a warning.",
      "input": "Real-time data from traffic light cameras and vehicle speed sensors.",
      "output": "#include <iostream>\n\nconst float RED_LIGHT_THRESHOLD_DISTANCE = 50.0f;  // Distance threshold for red light detection in meters\nconst float RED_LIGHT_THRESHOLD_SPEED = 10.0f;  // Speed threshold in km/h\n\n// Function to simulate distance to red light\nfloat getRedLightDistance() {\n    return 40.0f;  // Simulate distance of 40 meters to red light\n}\n\n// Function to simulate vehicle speed\nfloat getCurrentSpeed() {\n    return 12.0f;  // Simulate vehicle moving at 12 km/h\n}\n\n// Function to check for red light violation\nbool isRedLightViolation(float distance, float speed) {\n    return distance < RED_LIGHT_THRESHOLD_DISTANCE && speed > RED_LIGHT_THRESHOLD_SPEED;  // Trigger warning if red light detected and speed is high\n}\n\n// Test case for red light violation detection\nint main() {\n    float distance = getRedLightDistance();  // Get distance to red light\n    float speed = getCurrentSpeed();  // Get current vehicle speed\n\n    if (isRedLightViolation(distance, speed)) {\n        std::cout << \"WARNING: RED LIGHT VIOLATION AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Red Light Violation Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects slippery road conditions. If road traction is low (e.g., due to ice or rain), trigger a warning.",
      "input": "Real-time data from road condition sensors.",
      "output": "#include <iostream>\n\nconst float SLIPPERY_ROAD_THRESHOLD = 0.5f;  // Traction threshold for slippery roads\n\n// Function to simulate road traction condition\nfloat getRoadTraction() {\n    return 0.3f;  // Simulate slippery road with low traction\n}\n\n// Function to check for slippery road condition\nbool isSlipperyRoad(float traction) {\n    return traction < SLIPPERY_ROAD_THRESHOLD;  // Trigger warning if traction is below threshold\n}\n\n// Test case for slippery road condition detection\nint main() {\n    float traction = getRoadTraction();  // Get current road traction\n\n    if (isSlipperyRoad(traction)) {\n        std::cout << \"WARNING: SLIPPERY ROAD CONDITIONS AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Slippery Road Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for an FCW system that detects sudden stops by vehicles ahead. If the vehicle ahead decelerates abruptly, trigger a collision warning.",
      "input": "Real-time data from front radar and vehicle deceleration sensors.",
      "output": "#include <iostream>\n\nconst float SUDDEN_STOP_DECELERATION_THRESHOLD = 4.0f;  // Deceleration threshold for sudden stop in m/s\u00c2\u00b2\n\n// Function to simulate deceleration of the vehicle ahead\nfloat getFrontVehicleDeceleration() {\n    return 5.0f;  // Simulate deceleration of 5 m/s\u00c2\u00b2\n}\n\n// Function to check for sudden stop ahead\nbool isSuddenStop(float deceleration) {\n    return deceleration > SUDDEN_STOP_DECELERATION_THRESHOLD;  // Trigger warning if deceleration exceeds threshold\n}\n\n// Test case for sudden stop detection\nint main() {\n    float deceleration = getFrontVehicleDeceleration();  // Get deceleration of vehicle ahead\n\n    if (isSuddenStop(deceleration)) {\n        std::cout << \"WARNING: SUDDEN STOP AHEAD!\" << std::endl;\n    } else {\n        std::cout << \"No Sudden Stop Risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting tailgating. If the distance between your car and the vehicle ahead is less than 2 seconds of headway, trigger a warning.",
      "input": "Real-time data from radar sensors to measure distance and speed.",
      "output": "#include <iostream>\n\nconst float SAFE_HEADWAY_TIME = 2.0f; // Minimum safe time headway in seconds\n\n// Function to get distance to the vehicle ahead\nfloat getVehicleDistance() {\n    return 15.0f; // Simulated distance in meters\n}\n\n// Function to get the speed of the vehicle\nfloat getVehicleSpeed() {\n    return 10.0f; // Simulated speed in m/s\n}\n\n// Function to check for tailgating\nbool isTailgating(float distance, float speed) {\n    float time_headway = distance / speed;\n    return time_headway < SAFE_HEADWAY_TIME;\n}\n\nint main() {\n    float distance = getVehicleDistance();\n    float speed = getVehicleSpeed();\n\n    if (isTailgating(distance, speed)) {\n        std::cout << \"WARNING: Tailgating detected! Maintain a safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting lane departure when an obstacle is present in the adjacent lane. Trigger a warning if the vehicle drifts into a lane with an obstacle within 5 meters.",
      "input": "Real-time data from lane sensors and proximity sensors.",
      "output": "#include <iostream>\n\nconst float OBSTACLE_DETECTION_THRESHOLD = 5.0f; // Obstacle proximity threshold in meters\n\nbool isLaneDepartureDetected() {\n    return true; // Simulate lane departure detection\n}\n\nfloat getObstacleDistance() {\n    return 3.0f; // Simulate obstacle 3 meters away in adjacent lane\n}\n\nbool isLaneDepartureRisk(float obstacle_distance) {\n    return isLaneDepartureDetected() && obstacle_distance < OBSTACLE_DETECTION_THRESHOLD;\n}\n\nint main() {\n    float obstacle_distance = getObstacleDistance();\n\n    if (isLaneDepartureRisk(obstacle_distance)) {\n        std::cout << \"WARNING: Lane departure into an obstacle detected!\" << std::endl;\n    } else {\n        std::cout << \"No lane departure risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting a risk of rear-end collision. If the vehicle ahead decelerates at more than 4 m/s\\u00b2 and the distance is less than 10 meters, trigger a warning.",
      "input": "Real-time data from radar and deceleration sensors.",
      "output": "#include <iostream>\n\nconst float SAFE_DECELERATION_THRESHOLD = 4.0f; // Deceleration threshold in m/s\u00c2\u00b2\nconst float SAFE_DISTANCE_THRESHOLD = 10.0f;   // Distance threshold in meters\n\nfloat getFrontVehicleDeceleration() {\n    return 5.0f; // Simulated deceleration\n}\n\nfloat getVehicleDistance() {\n    return 8.0f; // Simulated distance\n}\n\nbool isRearEndCollisionRisk(float deceleration, float distance) {\n    return deceleration > SAFE_DECELERATION_THRESHOLD && distance < SAFE_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float deceleration = getFrontVehicleDeceleration();\n    float distance = getVehicleDistance();\n\n    if (isRearEndCollisionRisk(deceleration, distance)) {\n        std::cout << \"WARNING: Risk of rear-end collision!\" << std::endl;\n    } else {\n        std::cout << \"No rear-end collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting potential intersection collisions. Trigger a warning if an incoming vehicle is detected within 15 meters at an intersection.",
      "input": "Real-time data from intersection cameras and radar.",
      "output": "#include <iostream>\n\nconst float INTERSECTION_PROXIMITY_THRESHOLD = 15.0f; // Proximity threshold for intersection collision\n\nfloat getIncomingVehicleDistance() {\n    return 10.0f; // Simulated incoming vehicle distance\n}\n\nbool isIntersectionCollisionRisk(float distance) {\n    return distance < INTERSECTION_PROXIMITY_THRESHOLD;\n}\n\nint main() {\n    float distance = getIncomingVehicleDistance();\n\n    if (isIntersectionCollisionRisk(distance)) {\n        std::cout << \"WARNING: Risk of collision at intersection!\" << std::endl;\n    } else {\n        std::cout << \"No intersection collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting collision risks in stop-and-go traffic. If the vehicle ahead is within 2 meters and decelerating, trigger a warning.",
      "input": "Real-time data from proximity sensors and deceleration sensors.",
      "output": "#include <iostream>\n\nconst float STOP_AND_GO_DISTANCE_THRESHOLD = 2.0f; // Distance threshold in meters\n\nfloat getVehicleDistance() {\n    return 1.5f; // Simulated distance\n}\n\nbool isForwardCollisionRisk(float distance) {\n    return distance < STOP_AND_GO_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float distance = getVehicleDistance();\n\n    if (isForwardCollisionRisk(distance)) {\n        std::cout << \"WARNING: Risk of forward collision in stop-and-go traffic!\" << std::endl;\n    } else {\n        std::cout << \"No forward collision risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect stationary objects ahead. If the vehicle is moving at over 5 m/s and an object is detected within 5 meters, trigger a warning.",
      "input": "Real-time data from LiDAR sensors.",
      "output": "#include <iostream>\n\nconst float STATIONARY_OBJECT_DISTANCE_THRESHOLD = 5.0f;\nconst float VEHICLE_SPEED_THRESHOLD = 5.0f;\n\nfloat getVehicleSpeed() {\n    return 6.0f;\n}\n\nfloat getStationaryObjectDistance() {\n    return 4.0f;\n}\n\nbool isStationaryObjectRisk(float speed, float distance) {\n    return speed > VEHICLE_SPEED_THRESHOLD && distance < STATIONARY_OBJECT_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getStationaryObjectDistance();\n\n    if (isStationaryObjectRisk(speed, distance)) {\n        std::cout << \"WARNING: Stationary object ahead!\" << std::endl;\n    } else {\n        std::cout << \"No stationary object risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn drivers of foggy conditions reducing visibility below 50 meters.",
      "input": "Real-time data from visibility sensors.",
      "output": "#include <iostream>\n\nconst float VISIBILITY_THRESHOLD = 50.0f;\n\nfloat getVisibility() {\n    return 30.0f; // Simulated visibility\n}\n\nbool isFogRisk(float visibility) {\n    return visibility < VISIBILITY_THRESHOLD;\n}\n\nint main() {\n    float visibility = getVisibility();\n\n    if (isFogRisk(visibility)) {\n        std::cout << \"WARNING: Reduced visibility due to fog!\" << std::endl;\n    } else {\n        std::cout << \"Visibility is clear.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for detecting a risk in adaptive cruise control. Trigger a warning if the vehicle ahead slows down and the following distance becomes less than 1 second of headway.",
      "input": "Real-time data from radar for speed and distance measurements.",
      "output": "#include <iostream>\n\nconst float MIN_HEADWAY_TIME = 1.0f; // Minimum acceptable headway time in seconds\n\nfloat getFrontVehicleSpeed() {\n    return 15.0f; // Simulated front vehicle speed in m/s\n}\n\nfloat getFrontVehicleDistance() {\n    return 10.0f; // Simulated front vehicle distance in meters\n}\n\nbool isACCWarningTriggered(float speed, float distance) {\n    float headway_time = distance / speed;\n    return headway_time < MIN_HEADWAY_TIME;\n}\n\nint main() {\n    float speed = getFrontVehicleSpeed();\n    float distance = getFrontVehicleDistance();\n\n    if (isACCWarningTriggered(speed, distance)) {\n        std::cout << \"WARNING: Adaptive Cruise Control - Follow distance too short!\" << std::endl;\n    } else {\n        std::cout << \"ACC: Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn drivers if they are exceeding the speed limit in a designated zone.",
      "input": "Real-time data from GPS and speedometer sensors.",
      "output": "#include <iostream>\n\nconst float SPEED_LIMIT = 60.0f; // Speed limit in km/h\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed in km/h\n}\n\nbool isSpeeding(float speed) {\n    return speed > SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isSpeeding(speed)) {\n        std::cout << \"WARNING: Speeding! Reduce your speed immediately.\" << std::endl;\n    } else {\n        std::cout << \"Speed within limits.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect emergency braking scenarios and alert the driver.",
      "input": "Real-time data from brake sensors and proximity sensors.",
      "output": "#include <iostream>\n\nconst float BRAKE_FORCE_THRESHOLD = 6.0f; // Brake force threshold in m/s\u00c2\u00b2\nconst float DISTANCE_THRESHOLD = 5.0f;   // Safe distance threshold in meters\n\nfloat getBrakeForce() {\n    return 7.0f; // Simulated brake force\n}\n\nfloat getVehicleDistance() {\n    return 4.0f; // Simulated vehicle distance\n}\n\nbool isEmergencyBrakingRisk(float brake_force, float distance) {\n    return brake_force > BRAKE_FORCE_THRESHOLD && distance < DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float brake_force = getBrakeForce();\n    float distance = getVehicleDistance();\n\n    if (isEmergencyBrakingRisk(brake_force, distance)) {\n        std::cout << \"WARNING: Emergency braking detected!\" << std::endl;\n    } else {\n        std::cout << \"No emergency braking risk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if a pedestrian is detected within a crosswalk.",
      "input": "Real-time data from vision sensors and object detection algorithms.",
      "output": "#include <iostream>\n\nconst float CROSSWALK_DISTANCE_THRESHOLD = 2.0f; // Threshold for pedestrian distance in meters\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getPedestrianDistance() {\n    return 1.5f; // Simulated pedestrian distance\n}\n\nbool isPedestrianCrossingRisk(float distance) {\n    return isPedestrianDetected() && distance < CROSSWALK_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float pedestrian_distance = getPedestrianDistance();\n\n    if (isPedestrianCrossingRisk(pedestrian_distance)) {\n        std::cout << \"WARNING: Pedestrian detected on crosswalk!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn the driver if the road is slippery based on traction control system data.",
      "input": "Real-time data from traction control system.",
      "output": "#include <iostream>\n\nconst float TRACTION_LOSS_THRESHOLD = 0.5f; // Simulated threshold for traction loss\n\nfloat getTractionLevel() {\n    return 0.3f; // Simulated traction level\n}\n\nbool isSlipperyRoadRisk(float traction_level) {\n    return traction_level < TRACTION_LOSS_THRESHOLD;\n}\n\nint main() {\n    float traction_level = getTractionLevel();\n\n    if (isSlipperyRoadRisk(traction_level)) {\n        std::cout << \"WARNING: Slippery road ahead! Drive carefully.\" << std::endl;\n    } else {\n        std::cout << \"Road conditions normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect low visibility in tunnels and alert the driver to reduce speed.",
      "input": "Real-time data from visibility and light sensors.",
      "output": "#include <iostream>\n\nconst float TUNNEL_VISIBILITY_THRESHOLD = 20.0f; // Visibility threshold in meters\n\nfloat getTunnelVisibility() {\n    return 15.0f; // Simulated visibility\n}\n\nbool isTunnelVisibilityRisk(float visibility) {\n    return visibility < TUNNEL_VISIBILITY_THRESHOLD;\n}\n\nint main() {\n    float visibility = getTunnelVisibility();\n\n    if (isTunnelVisibilityRisk(visibility)) {\n        std::cout << \"WARNING: Low visibility in tunnel! Reduce speed.\" << std::endl;\n    } else {\n        std::cout << \"Tunnel visibility is clear.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if another vehicle is detected in their blind spot.",
      "input": "Real-time data from blind spot sensors.",
      "output": "#include <iostream>\n\nbool isVehicleInBlindSpot() {\n    return true; // Simulated detection of a vehicle in the blind spot\n}\n\nint main() {\n    if (isVehicleInBlindSpot()) {\n        std::cout << \"WARNING: Vehicle detected in blind spot!\" << std::endl;\n    } else {\n        std::cout << \"No vehicle in blind spot.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn the driver if the vehicle speed exceeds safe limits during hill descent.",
      "input": "Real-time data from slope sensors and speedometer.",
      "output": "#include <iostream>\n\nconst float HILL_DESCENT_SPEED_LIMIT = 20.0f; // Speed limit for hill descent in km/h\n\nfloat getVehicleSpeed() {\n    return 25.0f; // Simulated vehicle speed\n}\n\nbool isHillDescentSpeedRisk(float speed) {\n    return speed > HILL_DESCENT_SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isHillDescentSpeedRisk(speed)) {\n        std::cout << \"WARNING: Reduce speed during hill descent!\" << std::endl;\n    } else {\n        std::cout << \"Speed within safe limits for hill descent.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect speed bumps ahead and alert the driver if the vehicle speed is too high.",
      "input": "Real-time data from road profile sensors and speedometer.",
      "output": "#include <iostream>\n\nconst float SPEED_BUMP_SPEED_LIMIT = 10.0f; // Speed limit for speed bump in km/h\n\nbool isSpeedBumpDetected() {\n    return true; // Simulated detection of a speed bump\n}\n\nfloat getVehicleSpeed() {\n    return 15.0f; // Simulated vehicle speed\n}\n\nbool isSpeedBumpRisk(float speed) {\n    return isSpeedBumpDetected() && speed > SPEED_BUMP_SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isSpeedBumpRisk(speed)) {\n        std::cout << \"WARNING: Reduce speed for speed bump!\" << std::endl;\n    } else {\n        std::cout << \"Safe approach to speed bump.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect stop signs and alert the driver if the vehicle fails to slow down.",
      "input": "Real-time data from vision sensors and speedometer.",
      "output": "#include <iostream>\n\nconst float STOP_SPEED_LIMIT = 5.0f; // Speed limit when approaching a stop sign in km/h\n\nbool isStopSignDetected() {\n    return true; // Simulated detection of a stop sign\n}\n\nfloat getVehicleSpeed() {\n    return 20.0f; // Simulated vehicle speed in km/h\n}\n\nbool isStopWarningTriggered(float speed) {\n    return isStopSignDetected() && speed > STOP_SPEED_LIMIT;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isStopWarningTriggered(speed)) {\n        std::cout << \"WARNING: Approaching stop sign too fast!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle slowing appropriately for stop sign.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if the vehicle is drifting out of its lane.",
      "input": "Real-time data from lane detection algorithms.",
      "output": "#include <iostream>\n\nbool isVehicleDrifting() {\n    return true; // Simulated detection of lane departure\n}\n\nint main() {\n    if (isVehicleDrifting()) {\n        std::cout << \"WARNING: Lane departure detected! Correct your steering.\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is within the lane.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect collision risks at intersections based on vehicle positions and speeds.",
      "input": "Real-time data from radar sensors and GPS.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 10.0f; // Collision threshold in meters\n\nfloat getDistanceToCrossingVehicle() {\n    return 8.0f; // Simulated distance to another vehicle\n}\n\nfloat getCrossingVehicleSpeed() {\n    return 5.0f; // Simulated speed of the other vehicle\n}\n\nbool isCrossingCollisionRisk(float distance, float speed) {\n    return distance < COLLISION_DISTANCE_THRESHOLD && speed > 0.0f;\n}\n\nint main() {\n    float distance = getDistanceToCrossingVehicle();\n    float speed = getCrossingVehicleSpeed();\n\n    if (isCrossingCollisionRisk(distance, speed)) {\n        std::cout << \"WARNING: Collision risk at intersection!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk at intersection.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to warn the driver if vehicle speed is too high for a curve ahead.",
      "input": "Real-time data from GPS and gyroscope sensors.",
      "output": "#include <iostream>\n\nconst float CURVE_SAFE_SPEED = 30.0f; // Safe speed limit for curve in km/h\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Simulated vehicle speed\n}\n\nbool isCurveSpeedRisk(float speed) {\n    return speed > CURVE_SAFE_SPEED;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n\n    if (isCurveSpeedRisk(speed)) {\n        std::cout << \"WARNING: Reduce speed for the curve!\" << std::endl;\n    } else {\n        std::cout << \"Safe speed for the curve.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to assist parking by detecting nearby obstacles.",
      "input": "Real-time data from ultrasonic sensors.",
      "output": "#include <iostream>\n\nconst float PARKING_OBSTACLE_DISTANCE = 0.5f; // Distance threshold for parking in meters\n\nfloat getObstacleDistance() {\n    return 0.3f; // Simulated distance to obstacle\n}\n\nbool isParkingObstacleRisk(float distance) {\n    return distance < PARKING_OBSTACLE_DISTANCE;\n}\n\nint main() {\n    float distance = getObstacleDistance();\n\n    if (isParkingObstacleRisk(distance)) {\n        std::cout << \"WARNING: Obstacle too close during parking!\" << std::endl;\n    } else {\n        std::cout << \"Safe parking distance.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if they are tailgating another vehicle.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nconst float MIN_FOLLOW_DISTANCE = 2.0f; // Minimum safe distance in meters\n\nfloat getFollowingDistance() {\n    return 1.5f; // Simulated following distance\n}\n\nbool isTailgatingRisk(float distance) {\n    return distance < MIN_FOLLOW_DISTANCE;\n}\n\nint main() {\n    float distance = getFollowingDistance();\n\n    if (isTailgatingRisk(distance)) {\n        std::cout << \"WARNING: Too close to the vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to alert the driver if visibility is too low during night driving.",
      "input": "Real-time data from light sensors.",
      "output": "#include <iostream>\n\nconst float NIGHT_VISIBILITY_THRESHOLD = 30.0f; // Visibility threshold in meters\n\nfloat getVisibilityDistance() {\n    return 25.0f; // Simulated visibility distance\n}\n\nbool isLowVisibilityRisk(float visibility) {\n    return visibility < NIGHT_VISIBILITY_THRESHOLD;\n}\n\nint main() {\n    float visibility = getVisibilityDistance();\n\n    if (isLowVisibilityRisk(visibility)) {\n        std::cout << \"WARNING: Low visibility! Drive cautiously.\" << std::endl;\n    } else {\n        std::cout << \"Visibility is clear for night driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to monitor engine temperature and alert the driver if overheating occurs.",
      "input": "Real-time data from temperature sensors.",
      "output": "#include <iostream>\n\nconst float MAX_ENGINE_TEMP = 100.0f; // Maximum safe engine temperature in Celsius\n\nfloat getEngineTemperature() {\n    return 105.0f; // Simulated engine temperature\n}\n\nbool isEngineOverheating(float temperature) {\n    return temperature > MAX_ENGINE_TEMP;\n}\n\nint main() {\n    float temperature = getEngineTemperature();\n\n    if (isEngineOverheating(temperature)) {\n        std::cout << \"WARNING: Engine overheating! Stop the vehicle immediately.\" << std::endl;\n    } else {\n        std::cout << \"Engine temperature is normal.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a collision warning if the distance to the vehicle ahead is below a critical threshold.",
      "input": "Real-time data from LiDAR sensors.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 5.0f; // Minimum safe distance in meters\n\nfloat getDistanceToVehicleAhead() {\n    return 4.5f; // Simulated distance to the vehicle ahead\n}\n\nbool isCollisionWarningTriggered(float distance) {\n    return distance < COLLISION_DISTANCE_THRESHOLD;\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionWarningTriggered(distance)) {\n        std::cout << \"WARNING: Risk of collision with the vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance to the vehicle ahead.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a collision warning based on vehicle speed and the distance to the vehicle ahead.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nconst float COLLISION_DISTANCE_THRESHOLD = 10.0f; // Safe distance threshold in meters\nconst float MAX_SAFE_SPEED = 50.0f; // Maximum safe speed in km/h\n\nfloat getDistanceToVehicleAhead() {\n    return 8.0\nYou said:\n give me another 10 examples like this with real time data for fcw in cars\nChatGPT said:\nChatGPT\nHere are 10 Forward Collision Warning (FCW) examples specifically for real-time car scenarios, using detailed MISRA C++ 2023-compliant code:\n\nDataset Example 1: FCW with Dynamic Distance Threshold\njson\nCopy code\n{"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to include braking reaction time in collision warning calculations.",
      "input": "Real-time data from radar sensors, speedometer, and braking system.",
      "output": "#include <iostream>\n\nconst float BRAKING_REACTION_TIME = 1.5f; // Reaction time in seconds\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 15.0f; // Simulated distance to vehicle ahead in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    float reaction_distance = (speed * 1000.0f / 3600.0f) * BRAKING_REACTION_TIME; // Convert speed to m/s\n    return distance < reaction_distance;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision imminent! Apply brakes.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to integrate radar and LiDAR data for improved collision warning.",
      "input": "Real-time data from radar and LiDAR sensors.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance in meters\n}\n\nfloat getLidarDistance() {\n    return 9.5f; // Simulated LiDAR distance in meters\n}\n\nfloat calculateAverageDistance(float radar_distance, float lidar_distance) {\n    return (radar_distance + lidar_distance) / 2.0f;\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 8.0f; // Threshold in meters\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float radar_distance = getRadarDistance();\n    float lidar_distance = getLidarDistance();\n\n    float average_distance = calculateAverageDistance(radar_distance, lidar_distance);\n\n    if (isCollisionRisk(average_distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to adjust the collision threshold based on weather conditions.",
      "input": "Real-time data from weather sensors and radar.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 15.0f; // Simulated distance in meters\n}\n\nbool isRainyWeather() {\n    return true; // Simulated weather condition\n}\n\nbool isCollisionRisk(float distance, bool rainy_weather) {\n    const float DRY_THRESHOLD = 10.0f;\n    const float WET_THRESHOLD = 15.0f;\n    float threshold = rainy_weather ? WET_THRESHOLD : DRY_THRESHOLD;\n    return distance < threshold;\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n    bool rainy_weather = isRainyWeather();\n\n    if (isCollisionRisk(distance, rainy_weather)) {\n        std::cout << \"WARNING: Collision risk in current weather!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to recommend a speed adjustment if collision risk is detected.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 10.0f; // Simulated distance in meters\n}\n\nfloat recommendSafeSpeed(float distance) {\n    return (distance * 3.6f) / 2.0f; // Convert distance to a safe speed in km/h\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (distance < 15.0f) {\n        float recommended_speed = recommendSafeSpeed(distance);\n        std::cout << \"WARNING: Reduce speed to \" << recommended_speed << \" km/h!\" << std::endl;\n    } else {\n        std::cout << \"Current speed is safe.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect collision risk in stop-and-go traffic.",
      "input": "Real-time data from radar sensors.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 3.0f; // Simulated distance in meters\n}\n\nbool isCollisionRiskInTraffic(float distance) {\n    const float TRAFFIC_THRESHOLD = 2.5f; // Safe distance for heavy traffic\n    return distance < TRAFFIC_THRESHOLD;\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n\n    if (isCollisionRiskInTraffic(distance)) {\n        std::cout << \"WARNING: Collision risk in traffic! Maintain gap.\" << std::endl;\n    } else {\n        std::cout << \"Safe gap in traffic maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to trigger an emergency braking alert if collision risk is imminent.",
      "input": "Real-time data from radar sensors and speedometer.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 2.0f; // Simulated distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed in km/h\n}\n\nbool isEmergencyBrakingRequired(float speed, float distance) {\n    const float EMERGENCY_THRESHOLD = 2.5f; // Threshold for emergency braking\n    return distance < EMERGENCY_THRESHOLD && speed > 0.0f;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n\n    if (isEmergencyBrakingRequired(speed, distance)) {\n        std::cout << \"WARNING: Apply emergency brakes immediately!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a collision warning if the radar-measured distance falls below a safe threshold.",
      "input": "Real-time radar distance data.",
      "output": "#include <iostream>\n\nconst float SAFE_DISTANCE_THRESHOLD = 10.0f; // Safe distance in meters\n\nfloat getRadarDistance() {\n    return 8.5f; // Simulated radar distance (real-time input)\n}\n\nint main() {\n    float distance = getRadarDistance();\n\n    if (distance < SAFE_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to calculate collision risk using speed and radar distance data.",
      "input": "Real-time speed from the speedometer and radar distance.",
      "output": "#include <iostream>\n\nconst float SAFE_SPEED_DISTANCE_FACTOR = 0.5f; // Safe factor (speed * factor)\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Speed in km/h (real-time input)\n}\n\nfloat getRadarDistance() {\n    return 20.0f; // Distance in meters (real-time input)\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float safe_distance = speed * SAFE_SPEED_DISTANCE_FACTOR / 3.6f; // Convert speed to m/s\n\n    if (distance < safe_distance) {\n        std::cout << \"WARNING: Collision risk detected! Reduce speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to fuse radar and LiDAR distances to assess collision risk.",
      "input": "Real-time data from radar and LiDAR sensors.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 9.0f; // Radar distance (real-time input)\n}\n\nfloat getLidarDistance() {\n    return 9.5f; // LiDAR distance (real-time input)\n}\n\nfloat calculateFusedDistance(float radar, float lidar) {\n    return (radar + lidar) / 2.0f; // Average fusion of distances\n}\n\nint main() {\n    const float COLLISION_THRESHOLD = 10.0f; // Safe threshold\n    float radar_distance = getRadarDistance();\n    float lidar_distance = getLidarDistance();\n    float fused_distance = calculateFusedDistance(radar_distance, lidar_distance);\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to dynamically adjust the collision threshold based on weather conditions.",
      "input": "Real-time radar distance and weather conditions (rainy or dry).",
      "output": "#include <iostream>\n\nbool isRainyWeather() {\n    return true; // Simulated weather input\n}\n\nfloat getRadarDistance() {\n    return 12.0f; // Radar-measured distance\n}\n\nint main() {\n    const float DRY_THRESHOLD = 10.0f;\n    const float WET_THRESHOLD = 15.0f;\n\n    bool rainy = isRainyWeather();\n    float distance = getRadarDistance();\n    float threshold = rainy ? WET_THRESHOLD : DRY_THRESHOLD;\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk in current weather!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to detect collision risk in stop-and-go traffic.",
      "input": "Real-time data from radar sensors.",
      "output": "#include <iostream>\n\nconst float TRAFFIC_DISTANCE_THRESHOLD = 2.0f; // Safe distance for traffic in meters\n\nfloat getDistanceToVehicleAhead() {\n    return 1.8f; // Radar-measured distance (real-time input)\n}\n\nint main() {\n    float distance = getDistanceToVehicleAhead();\n\n    if (distance < TRAFFIC_DISTANCE_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk in traffic! Maintain gap.\" << std::endl;\n    } else {\n        std::cout << \"Safe traffic gap maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue a warning if the vehicle ahead brakes suddenly.",
      "input": "Real-time data from radar and speed sensors.",
      "output": "#include <iostream>\n\nconst float SUDDEN_BRAKING_THRESHOLD = 2.0f; // Acceleration threshold in m/s^2\n\nfloat getVehicleAcceleration() {\n    return -3.0f; // Simulated acceleration (negative for braking)\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 7.0f; // Radar distance in meters\n}\n\nint main() {\n    float acceleration = getVehicleAcceleration();\n    float distance = getDistanceToVehicleAhead();\n\n    if (acceleration < -SUDDEN_BRAKING_THRESHOLD && distance < 10.0f) {\n        std::cout << \"WARNING: Sudden braking detected! Maintain safe distance.\" << std::endl;\n    } else {\n        std::cout << \"Normal driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to adjust warning timing based on the vehicle's speed.",
      "input": "Real-time radar distance and speedometer readings.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Speed in km/h\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 20.0f; // Distance in meters\n}\n\nint main() {\n    const float TIME_TO_COLLISION = 2.0f; // Time in seconds\n    float speed = getVehicleSpeed() / 3.6f; // Convert to m/s\n    float distance = getDistanceToVehicleAhead();\n\n    if (distance / speed < TIME_TO_COLLISION) {\n        std::cout << \"WARNING: Collision risk detected! Adjust speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to issue collision warnings based on distance on curved roads.",
      "input": "Real-time radar distance and GPS-curvature data.",
      "output": "#include <iostream>\n\nfloat getDistanceToVehicleAhead() {\n    return 18.0f; // Distance in meters\n}\n\nbool isOnCurvedRoad() {\n    return true; // Simulated road curvature status\n}\n\nint main() {\n    const float CURVED_THRESHOLD = 20.0f;\n    const float STRAIGHT_THRESHOLD = 10.0f;\n\n    float distance = getDistanceToVehicleAhead();\n    bool curved_road = isOnCurvedRoad();\n    float threshold = curved_road ? CURVED_THRESHOLD : STRAIGHT_THRESHOLD;\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected! Adjust speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning if radar detects an object within 10 meters.",
      "input": "Radar detected distance: 8.5 meters. Collision threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid detectCollision(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.5F;\n    float collision_threshold = 10.0F;\n\n    detectCollision(radar_distance, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn the driver when a LiDAR sensor detects a vehicle closer than the threshold during urban driving.",
      "input": "LiDAR data: 7.2 meters. Threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid processUrbanFCW(float lidar_distance, float threshold) {\n    if (lidar_distance < threshold) {\n        std::cout << \"WARNING: Vehicle detected at \" << lidar_distance << \" meters. Slow down!\" << std::endl;\n    } else {\n        std::cout << \"Safe urban driving. Distance: \" << lidar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 7.2F;\n    float threshold = 8.0F;\n\n    processUrbanFCW(lidar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Use radar data to detect multiple objects and alert if any is below the danger threshold.",
      "input": "Object distances: 15 meters, 12 meters, and 9 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjects(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {15.0F, 12.0F, 9.0F};\n    float collision_threshold = 10.0F;\n\n    checkMultipleObjects(object_distances, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide a warning based on a dynamic threshold calculated from vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicCollisionWarning(float speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Distance to object \" << distance << \" meters below threshold \" << threshold << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at \" << speed << \" km/h.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;  // km/h\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicCollisionWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Combine radar and camera data to warn if the detected object is confirmed as a car within the threshold.",
      "input": "Radar distance: 9 meters. Camera confirmation: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid radarCameraFCW(float distance, bool isCar, float threshold) {\n    if (isCar && distance < threshold) {\n        std::cout << \"WARNING: Car detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 9.0F;\n    bool camera_confirmation = true;\n    float collision_threshold = 10.0F;\n\n    radarCameraFCW(radar_distance, camera_confirmation, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn the driver of a collision if an object is detected during reverse parking.",
      "input": "Reverse radar distance: 1.2 meters. Parking mode: Enabled. Threshold: 2 meters.",
      "output": "#include <iostream>\n\nvoid reverseParkingWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during reverse parking!\" << std::endl;\n    } else {\n        std::cout << \"Reverse parking clear. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float reverse_distance = 1.2F;\n    float parking_threshold = 2.0F;\n\n    reverseParkingWarning(reverse_distance, parking_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Evaluate real-time radar data to warn if objects are detected in low visibility conditions.",
      "input": "Radar distance: 12 meters. Low visibility mode: Enabled. Adjusted threshold: 14 meters.",
      "output": "#include <iostream>\n\nvoid lowVisibilityWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Low visibility collision risk! Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Low visibility safe. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;\n    float adjusted_threshold = 14.0F;\n\n    lowVisibilityWarning(radar_distance, adjusted_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Alert the driver during stop-and-go traffic if the radar detects an object within 3 meters.",
      "input": "Stop-and-go radar distance: 2.5 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoFCW(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Close object detected at \" << distance << \" meters in stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Stop-and-go distance clear.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;\n    float collision_threshold = 3.0F;\n\n    stopAndGoFCW(radar_distance, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn of a stationary object detected ahead at night by radar.",
      "input": "Night mode active. Radar distance: 16 meters. Threshold: 20 meters.",
      "output": "#include <iostream>\n\nvoid nightModeFCW(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Stationary object detected at \" << distance << \" meters. Reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at night.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 16.0F;\n    float night_threshold = 20.0F;\n\n    nightModeFCW(radar_distance, night_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger FCW for pedestrians detected within a crosswalk during rainy conditions.",
      "input": "Pedestrian distance: 6 meters. Rainy mode threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianRainFCW(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters in rainy conditions.\" << std::endl;\n    } else {\n\nYou said:\ngive me 10 examples like this for fcw with real time data\nChatGPT said:\nChatGPT\nHere are 10 examples of Forward Collision Warning (FCW) with real-time data, using C++ code for each scenario.\n\nExample 1\njson\nCopy code\n{"
    },
    {
      "instruction": "Use LiDAR data to detect objects within a threshold and alert if an object is within range.",
      "input": "LiDAR distance: 7.2 meters. Threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid checkDistanceWithLiDAR(float lidar_distance, float threshold) {\n    if (lidar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << lidar_distance << \" meters. Maintain a safe distance!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << lidar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float lidar_distance = 7.2F;\n    float threshold = 8.0F;\n\n    checkDistanceWithLiDAR(lidar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Evaluate multiple objects and warn if any of them is too close.",
      "input": "Object distances: 15 meters, 12 meters, 9 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjects(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {15.0F, 12.0F, 9.0F};\n    float collision_threshold = 10.0F;\n\n    checkMultipleObjects(object_distances, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Adjust the collision warning threshold based on vehicle speed, and trigger a warning if the distance is below the dynamic threshold.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicThresholdWarning(float speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h, Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;  // km/h\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicThresholdWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Combine radar and camera data to detect a vehicle and warn if it\\u2019s too close.",
      "input": "Radar distance: 9 meters. Camera confirmation: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid radarCameraCollisionWarning(float distance, bool isCar, float threshold) {\n    if (isCar && distance < threshold) {\n        std::cout << \"WARNING: Car detected at \" << distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 9.0F;\n    bool camera_confirmation = true;\n    float collision_threshold = 10.0F;\n\n    radarCameraCollisionWarning(radar_distance, camera_confirmation, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger an alert if the radar detects an object too close during reverse parking.",
      "input": "Reverse radar distance: 1.2 meters. Threshold: 2 meters.",
      "output": "#include <iostream>\n\nvoid reverseParkingAlert(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during reverse parking!\" << std::endl;\n    } else {\n        std::cout << \"Reverse parking clear. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float reverse_distance = 1.2F;\n    float parking_threshold = 2.0F;\n\n    reverseParkingAlert(reverse_distance, parking_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Evaluate radar data and issue a warning in low visibility conditions if the detected object is within the threshold.",
      "input": "Radar distance: 12 meters. Low visibility mode: Enabled. Threshold: 14 meters.",
      "output": "#include <iostream>\n\nvoid lowVisibilityWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Low visibility hazard!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at low visibility.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;\n    float low_visibility_threshold = 14.0F;\n\n    lowVisibilityWarning(radar_distance, low_visibility_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide a collision warning if an object is detected in stop-and-go traffic.",
      "input": "Radar distance: 2.5 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters in stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Clear in stop-and-go traffic. Distance: \" << distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;\n    float stop_and_go_threshold = 3.0F;\n\n    stopAndGoCollisionWarning(radar_distance, stop_and_go_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Warn if an object is detected at night and is within the danger zone.",
      "input": "Radar distance: 16 meters. Threshold: 20 meters.",
      "output": "#include <iostream>\n\nvoid nightModeCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Stationary object detected at \" << distance << \" meters. Reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe night driving.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 16.0F;\n    float night_threshold = 20.0F;\n\n    nightModeCollisionWarning(radar_distance, night_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide an alert if a pedestrian is detected too close while driving in rainy conditions.",
      "input": "Pedestrian distance: 6 meters. Threshold for rainy conditions: 8 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianRainCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters in rainy conditions.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving in rainy conditions.\" << std::endl;\n    }\n}\n\nint main() {\n    float pedestrian_distance = 6.0F;\n    float rainy_threshold = 8.0F;\n\n    pedestrianRainCollisionWarning(pedestrian_distance, rainy_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning when an object is detected within 10 meters using radar data.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F;\n    float threshold = 10.0F;\n\n    checkCollisionWarning(radar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Check if any object is too close from multiple objects detected using radar.",
      "input": "Object distances: 18 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {18.0F, 5.0F, 12.0F};\n    float collision_threshold = 10.0F;\n\n    checkMultipleObjectsDistance(object_distances, collision_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Use both camera and radar data to issue a collision warning.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected by camera at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.0F;\n    bool camera_detection = true;\n    float threshold = 10.0F;\n\n    combinedCollisionWarning(radar_distance, camera_detection, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Change the collision warning threshold based on vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicSpeedThresholdWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger an alert if a pedestrian is detected within 5 meters using radar data.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 4.0F;\n    float pedestrian_threshold = 5.0F;\n\n    pedestrianCollisionWarning(radar_distance, pedestrian_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide collision warning if an object is too close during stop-and-go traffic.",
      "input": "Radar distance: 2.5 meters. Threshold for stop-and-go traffic: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Clear in stop-and-go traffic.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 2.5F;\n    float stop_and_go_threshold = 3.0F;\n\n    stopAndGoCollisionWarning(radar_distance, stop_and_go_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Activate collision warning if an object is detected within the threshold while driving at night.",
      "input": "Radar distance: 12 meters. Threshold: 15 meters.",
      "output": "#include <iostream>\n\nvoid nightTimeCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters at night.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at night.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 12.0F;\n    float night_threshold = 15.0F;\n\n    nightTimeCollisionWarning(radar_distance, night_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Issue a collision warning if an object is detected during low visibility conditions, even at a larger distance.",
      "input": "Radar distance: 25 meters. Threshold for low visibility: 30 meters.",
      "output": "#include <iostream>\n\nvoid lowVisibilityCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters. Low visibility hazard!\" << std::endl;\n    } else {\n        std::cout << \"Clear visibility.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 25.0F;\n    float low_visibility_threshold = 30.0F;\n\n    lowVisibilityCollisionWarning(radar_distance, low_visibility_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide an alert if an object is detected too close while reversing.",
      "input": "Reverse radar distance: 1.8 meters. Threshold: 2 meters.",
      "output": "#include <iostream>\n\nvoid reverseParkingAlert(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters during reverse parking.\" << std::endl;\n    } else {\n        std::cout << \"Clear for reverse parking.\" << std::endl;\n    }\n}\n\nint main() {\n    float reverse_distance = 1.8F;\n    float parking_threshold = 2.0F;\n\n    reverseParkingAlert(reverse_distance, parking_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Detect sudden obstacles at high speed and trigger a warning if too close.",
      "input": "Vehicle speed: 100 km/h. Radar distance: 5 meters. Threshold: 6 meters.",
      "output": "#include <iostream>\n\nvoid suddenObstacleWarning(float vehicle_speed, float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Sudden obstacle detected at \" << distance << \" meters. Slow down!\" << std::endl;\n    } else {\n        std::cout << \"Obstacle at a safe distance.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 100.0F;\n    float radar_distance = 5.0F;\n    float obstacle_threshold = 6.0F;\n\n    suddenObstacleWarning(vehicle_speed, radar_distance, obstacle_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Generate a forward collision warning if an object is detected within 10 meters using radar.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    /* Check if radar distance is less than the threshold */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters. Collision imminent!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 8.0F;\n    float threshold = 10.0F;\n\n    checkCollisionWarning(radar_distance, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Detect multiple objects and trigger a collision warning if any of them are too close.",
      "input": "Object distances: 18 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    /* Loop through all object distances to check if any object is too close */\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}\n\nint main() {\n    std::vector<float> object_distances = {18.0F, 5.0F, 12.0F};\n    float threshold = 10.0F;\n\n    checkMultipleObjectsDistance(object_distances, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Generate a forward collision warning when both radar and camera detect objects.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    /* Trigger warning if both radar and camera detect an object within the threshold distance */\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 7.0F;\n    bool camera_detection = true;\n    float threshold = 10.0F;\n\n    combinedCollisionWarning(radar_distance, camera_detection, threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Change the collision warning threshold based on the vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    /* Warn if object is too close based on speed-adjusted threshold */\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}\n\nint main() {\n    float vehicle_speed = 60.0F;\n    float radar_distance = 15.0F;\n    float dynamic_threshold = 18.0F;\n\n    dynamicSpeedThresholdWarning(vehicle_speed, radar_distance, dynamic_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Trigger a collision warning if a pedestrian is detected within 5 meters.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    /* Detect pedestrian and trigger warning if too close */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}\n\nint main() {\n    float radar_distance = 4.0F;\n    float pedestrian_threshold = 5.0F;\n\n    pedestrianCollisionWarning(radar_distance, pedestrian_threshold);\n    return 0;\n}"
    },
    {
      "instruction": "Provide collision warning if an object is too close during stop-and-go traffic.",
      "input": "Radar distance: 2.5 meters. Threshold for stop-and-go traffic: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold\nYou said:\ngive me only the logic of fcw and make sure to add instruction so that the model im training understand what it is\nChatGPT said:\nChatGPT\nHere are 10 examples of Forward Collision Warning (FCW) logic written in C++ with MISRA 2023 compliance and dataset entry format, focusing only on the FCW logic.\n\nExample 1: Basic Collision Warning Logic\njson\nCopy code\n{"
    },
    {
      "instruction": "Develop a system that checks the distance of multiple objects and triggers a collision warning if any object is too close.",
      "input": "Object distances: 18 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    /* Check each object distance to see if any is below the threshold */\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}"
    },
    {
      "instruction": "Combine radar and camera data to trigger a forward collision warning when both detect an object within the threshold distance.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    /* Trigger warning if both radar and camera detect object within threshold */\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Create a forward collision warning system that adjusts the threshold distance dynamically based on vehicle speed.",
      "input": "Vehicle speed: 60 km/h. Radar distance: 15 meters. Dynamic threshold: 18 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    /* Adjust collision warning threshold based on vehicle speed */\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a forward collision warning when a pedestrian is detected within a critical distance.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    /* Check if the distance to the pedestrian is below the critical threshold */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Provide a collision warning when an object is detected too close during stop-and-go traffic conditions.",
      "input": "Radar distance: 2.5 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    /* Trigger a warning if an object is too close in stop-and-go traffic */\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters in stop-and-go traffic.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance in stop-and-go traffic.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a forward collision warning if the radar detects an object within a certain distance when the vehicle is traveling at high speed.",
      "input": "Vehicle speed: 120 km/h. Radar distance: 30 meters. Threshold: 25 meters.",
      "output": "#include <iostream>\n\nvoid highSpeedCollisionWarning(float speed, float radar_distance, float threshold) {\n    /* Trigger a warning if the vehicle is moving fast and the object is too close */\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a collision warning based on the size of detected objects and their distance.",
      "input": "Object size: 3 meters. Radar distance: 10 meters. Threshold: 8 meters.",
      "output": "#include <iostream>\n\nvoid objectSizeBasedCollisionWarning(float object_size, float radar_distance, float threshold) {\n    /* Trigger warning based on object size and distance to vehicle */\n    if (object_size > 2.0F && radar_distance < threshold) {\n        std::cout << \"WARNING: Large object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from object.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Generate a warning if the car ahead makes a sudden stop within a short distance.",
      "input": "Radar distance: 6 meters. Relative speed: 30 km/h. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid suddenStopCollisionWarning(float radar_distance, float relative_speed, float threshold) {\n    /* Trigger warning if a sudden stop is detected and object is too close */\n    if (radar_distance < threshold && relative_speed > 20.0F) {\n        std::cout << \"WARNING: Sudden stop detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Provide a collision warning system during nighttime driving if an object is detected within a specified distance.",
      "input": "Radar distance: 10 meters. Nighttime driving detected: True. Threshold: 12 meters.",
      "output": "#include <iostream>\n\nvoid nighttimeCollisionWarning(float radar_distance, bool nighttime, float threshold) {\n    /* Trigger a warning if object is too close during nighttime driving */\n    if (nighttime && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters during nighttime.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a simple forward collision warning system that triggers a warning if the object is within a defined threshold distance.",
      "input": "Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid checkCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance: \" << radar_distance << \" meters.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a logic to check multiple objects' distances and trigger a warning if any object is too close.",
      "input": "Object distances: 15 meters, 5 meters, 12 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n#include <vector>\n\nvoid checkMultipleObjectsDistance(const std::vector<float>& distances, float threshold) {\n    for (float distance : distances) {\n        if (distance < threshold) {\n            std::cout << \"WARNING: Object detected at \" << distance << \" meters. Collision risk!\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"All objects are at a safe distance.\" << std::endl;\n}"
    },
    {
      "instruction": "Combine radar and camera data for collision warning, where both must detect an object within a threshold distance to trigger a warning.",
      "input": "Radar distance: 7 meters. Camera detection: True. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid combinedCollisionWarning(float radar_distance, bool camera_detected, float threshold) {\n    if (camera_detected && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Adjust the collision warning threshold dynamically based on vehicle speed. The threshold decreases as the vehicle's speed increases.",
      "input": "Vehicle speed: 80 km/h. Radar distance: 10 meters. Threshold: 15 meters.",
      "output": "#include <iostream>\n\nvoid dynamicSpeedThresholdWarning(float speed, float distance, float threshold) {\n    if (speed > 60.0F) {\n        threshold = 10.0F; // Decrease threshold at high speed\n    }\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a forward collision warning system for detecting pedestrians within a threshold distance.",
      "input": "Radar distance: 4 meters. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid pedestrianCollisionWarning(float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Pedestrian detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Create a forward collision warning system for stop-and-go traffic where objects are detected close to the vehicle.",
      "input": "Radar distance: 3 meters. Threshold: 3 meters.",
      "output": "#include <iostream>\n\nvoid stopAndGoCollisionWarning(float distance, float threshold) {\n    if (distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance in stop-and-go traffic.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Implement a forward collision warning system for high-speed driving where the warning triggers if an object is too close at high speed.",
      "input": "Vehicle speed: 120 km/h. Radar distance: 30 meters. Threshold: 25 meters.",
      "output": "#include <iostream>\n\nvoid highSpeedCollisionWarning(float speed, float radar_distance, float threshold) {\n    if (radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters at speed \" << speed << \" km/h.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance at speed: \" << speed << \" km/h.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Create a system that triggers a collision warning if a large object is detected within a specified distance.",
      "input": "Object size: 3 meters. Radar distance: 8 meters. Threshold: 10 meters.",
      "output": "#include <iostream>\n\nvoid objectSizeBasedWarning(float object_size, float radar_distance, float threshold) {\n    if (object_size > 2.0F && radar_distance < threshold) {\n        std::cout << \"WARNING: Large object detected at \" << radar_distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from object.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Develop a system that triggers a warning if an object ahead of the vehicle makes a sudden stop.",
      "input": "Radar distance: 6 meters. Relative speed: 30 km/h. Threshold: 5 meters.",
      "output": "#include <iostream>\n\nvoid suddenStopWarning(float radar_distance, float relative_speed, float threshold) {\n    if (radar_distance < threshold && relative_speed > 20.0F) {\n        std::cout << \"WARNING: Sudden stop detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Trigger a collision warning during nighttime driving if an object is detected within the threshold.",
      "input": "Radar distance: 10 meters. Nighttime driving detected: True. Threshold: 12 meters.",
      "output": "#include <iostream>\n\nvoid nighttimeCollisionWarning(float radar_distance, bool nighttime, float threshold) {\n    if (nighttime && radar_distance < threshold) {\n        std::cout << \"WARNING: Object detected at \" << radar_distance << \" meters during nighttime.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance.\" << std::endl;\n    }\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using radar distance data.",
      "input": "Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar data\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on vehicle speed.",
      "input": "Vehicle speed: 50 km/h, Radar distance: 9.5 meters.",
      "output": "#include <iostream>\n\nconst float BASE_THRESHOLD = 8.0f;\nconst float SPEED_ADJUSTMENT = 0.1f;\n\nfloat getSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 9.5f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getSpeed();\n    float distance = getRadarDistance();\n    float threshold = BASE_THRESHOLD + (speed * SPEED_ADJUSTMENT);\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using LiDAR distance data.",
      "input": "LiDAR distance: 6.8 meters.",
      "output": "#include <iostream>\n\nfloat getLiDARDistance() {\n    return 6.8f; // Simulated LiDAR data\n}\n\nint main() {\n    float distance = getLiDARDistance();\n    const float COLLISION_THRESHOLD = 7.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that uses radar and camera data fusion for distance calculation.",
      "input": "Radar distance: 7.2 meters, Camera distance: 6.0 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 7.2f; // Simulated radar data\n}\n\nfloat getCameraDistance() {\n    return 6.0f; // Simulated camera data\n}\n\nfloat calculateFusionDistance(float radar, float camera) {\n    return (radar + camera) / 2.0f; // Fusion of radar and camera data\n}\n\nint main() {\n    float radar = getRadarDistance();\n    float camera = getCameraDistance();\n\n    float fused_distance = calculateFusionDistance(radar, camera);\n    const float COLLISION_THRESHOLD = 7.0f;\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW based on object detection with radar and camera.",
      "input": "Object type: Vehicle, Radar distance: 6.0 meters, Camera distance: 5.5 meters.",
      "output": "#include <iostream>\n#include <string>\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nfloat getCameraDistance() {\n    return 5.5f; // Simulated camera data\n}\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nint main() {\n    float radar = getRadarDistance();\n    float camera = getCameraDistance();\n    std::string objectType = getObjectType();\n    const float VEHICLE_THRESHOLD = 8.0f;\n    const float PEDESTRIAN_THRESHOLD = 5.0f;\n    float threshold = (objectType == \"Vehicle\") ? VEHICLE_THRESHOLD : PEDESTRIAN_THRESHOLD;\n\n    if ((radar + camera) / 2.0f < threshold) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic collision threshold based on vehicle speed.",
      "input": "Speed: 80 km/h, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n\nconst float BASE_THRESHOLD = 6.0f;\nconst float SPEED_ADJUSTMENT = 0.1f;\n\nfloat getSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getSpeed();\n    float distance = getRadarDistance();\n    float threshold = BASE_THRESHOLD + (speed * SPEED_ADJUSTMENT);\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using LiDAR distance data for collision detection.",
      "input": "LiDAR distance: 5.0 meters.",
      "output": "#include <iostream>\n\nfloat getLiDARDistance() {\n    return 5.0f; // Simulated LiDAR data\n}\n\nint main() {\n    float distance = getLiDARDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using multi-sensor fusion from radar, camera, and LiDAR data.",
      "input": "Radar distance: 6.0 meters, Camera distance: 5.5 meters, LiDAR distance: 7.0 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nfloat getCameraDistance() {\n    return 5.5f; // Simulated camera data\n}\n\nfloat getLiDARDistance() {\n    return 7.0f; // Simulated LiDAR data\n}\n\nfloat calculateFusionDistance(float radar, float camera, float lidar) {\n    return (radar + camera + lidar) / 3.0f; // Average distance from all sensors\n}\n\nint main() {\n    float radar = getRadarDistance();\n    float camera = getCameraDistance();\n    float lidar = getLiDARDistance();\n\n    float fused_distance = calculateFusionDistance(radar, camera, lidar);\n    const float COLLISION_THRESHOLD = 6.5f;\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that specifically detects pedestrians and triggers a warning.",
      "input": "Pedestrian detected, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar data\n}\n\nint main() {\n    bool pedestrian_detected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    const float PEDESTRIAN_THRESHOLD = 5.0f;\n\n    if (pedestrian_detected && distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance from pedestrian.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts collision threshold dynamically at high speed.",
      "input": "Speed: 120 km/h, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nconst float BASE_THRESHOLD = 6.0f;\nconst float SPEED_ADJUSTMENT = 0.2f;\n\nfloat getSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getSpeed();\n    float distance = getRadarDistance();\n    float threshold = BASE_THRESHOLD + (speed * SPEED_ADJUSTMENT);\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected at high speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained at high speed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code to implement a simple radar-based FCW with a fixed threshold.",
      "input": "Radar distance: 4.8 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 4.8f; // Simulated radar distance\n}\n\nint main() {\n    const float COLLISION_THRESHOLD = 5.0f;\n    float distance = getRadarDistance();\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the threshold based on weather conditions.",
      "input": "Weather condition: Rainy, Radar distance: 6.2 meters.",
      "output": "#include <iostream>\n\nenum Weather { SUNNY, RAINY, SNOWY }; \n\nfloat getRadarDistance() {\n    return 6.2f; // Simulated radar data\n}\n\nWeather getWeatherCondition() {\n    return RAINY; // Simulated weather condition\n}\n\nint main() {\n    Weather weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = 5.0f;\n\n    if (weather == RAINY) {\n        COLLISION_THRESHOLD = 4.5f; // Adjust threshold in rainy conditions\n    }\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the threshold based on the object type (e.g., vehicle, pedestrian).",
      "input": "Object type: Vehicle, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n#include <string>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = (objectType == \"Vehicle\") ? 6.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained from \" << objectType << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the threshold is adjusted based on the vehicle speed.",
      "input": "Vehicle speed: 40 km/h, Radar distance: 7.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 7.5f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = 6.0f + (speed / 10.0f); // Dynamic threshold based on speed\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with pedestrian detection using radar data.",
      "input": "Pedestrian detected, Radar distance: 4.2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 4.2f; // Simulated radar data\n}\n\nint main() {\n    bool pedestrian_detected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    const float PEDESTRIAN_THRESHOLD = 4.5f;\n\n    if (pedestrian_detected && distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected or safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW using camera data integrated with radar.",
      "input": "Camera distance: 5.0 meters, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nfloat getCameraDistance() {\n    return 5.0f; // Simulated camera data\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nint main() {\n    float camera = getCameraDistance();\n    float radar = getRadarDistance();\n    float fused_distance = (camera + radar) / 2.0f; // Fusion of camera and radar data\n    const float COLLISION_THRESHOLD = 5.5f;\n\n    if (fused_distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with a high-speed collision warning that triggers above a certain speed.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float SPEED_THRESHOLD = 100.0f;\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (speed > SPEED_THRESHOLD && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on road curvature.",
      "input": "Road curvature: 15 degrees, Radar distance: 6.3 meters.",
      "output": "#include <iostream>\n\nfloat getRoadCurvature() {\n    return 15.0f; // Simulated road curvature\n}\n\nfloat getRadarDistance() {\n    return 6.3f; // Simulated radar data\n}\n\nint main() {\n    float curvature = getRoadCurvature();\n    float distance = getRadarDistance();\n    const float BASE_THRESHOLD = 6.0f;\n    float threshold = (curvature > 10.0f) ? BASE_THRESHOLD * 1.1f : BASE_THRESHOLD;\n\n    if (distance < threshold) {\n        std::cout << \"WARNING: Collision risk detected due to road curvature!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that differentiates between pedestrians and vehicles.",
      "input": "Object type: Pedestrian, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float VEHICLE_THRESHOLD = 6.0f;\n    const float PEDESTRIAN_THRESHOLD = 4.0f;\n\n    if (objectType == \"Pedestrian\" && distance < PEDESTRIAN_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected at \" << distance << \" meters.\" << std::endl;\n    } else if (objectType == \"Vehicle\" && distance < VEHICLE_THRESHOLD) {\n        std::cout << \"WARNING: Vehicle detected at \" << distance << \" meters.\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that activates emergency braking when a collision is imminent.",
      "input": "Radar distance: 2.5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.5f; // Simulated radar data\n}\n\nbool isEmergencyBrakingRequired(float distance) {\n    const float EMERGENCY_THRESHOLD = 3.0f;\n    return distance < EMERGENCY_THRESHOLD; // Trigger emergency braking if below threshold\n}\n\nint main() {\n    float distance = getRadarDistance();\n\n    if (isEmergencyBrakingRequired(distance)) {\n        std::cout << \"WARNING: Collision imminent, emergency braking activated!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the threshold based on the vehicle's current speed.",
      "input": "Vehicle speed: 80 km/h, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float BASE_THRESHOLD = 6.0f;\n    float COLLISION_THRESHOLD = BASE_THRESHOLD - (speed / 100.0f);\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that considers the velocity of the vehicle and calculates the time-to-collision.",
      "input": "Vehicle speed: 60 km/h, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar data\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / speed; // Time to collision calculation\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float time_to_collision = calculateTimeToCollision(speed, distance);\n\n    if (time_to_collision < 3.0f) {\n        std::cout << \"WARNING: High collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that automatically adjusts the distance threshold based on road type.",
      "input": "Road type: Highway, Radar distance: 7.0 meters.",
      "output": "#include <iostream>\n\nenum RoadType { CITY, HIGHWAY, RURAL };\n\nRoadType getRoadType() {\n    return HIGHWAY; // Simulated road type\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Simulated radar data\n}\n\nint main() {\n    RoadType road_type = getRoadType();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = (road_type == HIGHWAY) ? 8.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that also incorporates lane departure warning into the decision-making process.",
      "input": "Lane departure: Yes, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulated lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar data\n}\n\nint main() {\n    bool lane_departure = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 5.0f;\n\n    if (lane_departure && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Lane departure and collision risk detected!\" << std::endl;\n    } else if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that only activates when a vehicle ahead is detected.",
      "input": "Vehicle ahead: Detected, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nbool isVehicleAheadDetected() {\n    return true; // Simulated vehicle ahead detection\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar data\n}\n\nint main() {\n    bool vehicle_ahead = isVehicleAheadDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (vehicle_ahead && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates time-to-collision with pedestrians and triggers a warning if necessary.",
      "input": "Object type: Pedestrian, Radar distance: 3.0 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / (speed / 3.6f); // Time to collision (km/h to m/s conversion)\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    std::string objectType = getObjectType();\n    float time_to_collision = calculateTimeToCollision(speed, distance);\n\n    if (objectType == \"Pedestrian\" && time_to_collision < 2.0f) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dual thresholds based on the vehicle's speed: one for city speed and one for highway speed.",
      "input": "Vehicle speed: 110 km/h, Radar distance: 8.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 110.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Simulated radar data\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float CITY_SPEED_THRESHOLD = 5.0f;\n    const float HIGHWAY_SPEED_THRESHOLD = 8.0f;\n    float COLLISION_THRESHOLD = (speed < 50.0f) ? CITY_SPEED_THRESHOLD : HIGHWAY_SPEED_THRESHOLD;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision threshold based on whether it is day or night.",
      "input": "Time of day: Night, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nbool isNightTime() {\n    return true; // Simulated night-time condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar data\n}\n\nint main() {\n    bool night_time = isNightTime();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = night_time ? 5.0f : 7.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the weather condition (rain/sunny).",
      "input": "Weather condition: Rain, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAIN, FOGGY };\n\nWeatherCondition getWeatherCondition() {\n    return RAIN; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar data\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAIN) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects multiple objects and provides warnings for each detected object.",
      "input": "Object 1: Vehicle, Radar distance: 4.5 meters, Object 2: Pedestrian, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType(int objectId) {\n    if (objectId == 1) {\n        return \"Vehicle\";\n    } else if (objectId == 2) {\n        return \"Pedestrian\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\nfloat getRadarDistance(int objectId) {\n    if (objectId == 1) {\n        return 4.5f;\n    } else if (objectId == 2) {\n        return 2.0f;\n    } else {\n        return 0.0f;\n    }\n}\n\nint main() {\n    for (int i = 1; i <= 2; ++i) {\n        std::string objectType = getObjectType(i);\n        float distance = getRadarDistance(i);\n        const float COLLISION_THRESHOLD = (objectType == \"Pedestrian\") ? 3.0f : 6.0f;\n\n        if (distance < COLLISION_THRESHOLD) {\n            std::cout << \"WARNING: \" << objectType << \" detected at \" << distance << \" meters.\" << std::endl;\n        } else {\n            std::cout << \"Safe distance maintained for \" << objectType << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the collision warning threshold adjusts based on the vehicle's speed.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (speed > 80.0f) ? 5.0f : 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that compares distances of multiple objects and triggers a warning for the closest object.",
      "input": "Object 1: Car, Radar distance: 7.5 meters, Object 2: Pedestrian, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance(int objectId) {\n    if (objectId == 1) {\n        return 7.5f; // Distance to Car\n    } else if (objectId == 2) {\n        return 3.5f; // Distance to Pedestrian\n    } else {\n        return 0.0f; // Invalid Object\n    }\n}\n\nint main() {\n    float carDistance = getRadarDistance(1);\n    float pedestrianDistance = getRadarDistance(2);\n    float closestDistance = (carDistance < pedestrianDistance) ? carDistance : pedestrianDistance;\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (closestDistance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with the closest object!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision detection threshold based on whether it is day or night.",
      "input": "Time of day: Day, Vehicle speed: 60 km/h, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nbool isDayTime() {\n    return true; // Simulated time of day\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar data\n}\n\nint main() {\n    bool daytime = isDayTime();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float DAYTIME_THRESHOLD = (daytime) ? 5.5f : 4.5f;\n\n    if (distance < DAYTIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with pedestrian detection and a stricter collision threshold if the vehicle is moving slowly.",
      "input": "Object type: Pedestrian, Vehicle speed: 30 km/h, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (speed < 40.0f) ? 1.5f : 3.0f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates the following distance based on the vehicle's speed and triggers a warning if the distance is too short.",
      "input": "Vehicle speed: 80 km/h, Radar distance: 4.5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.5f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float followingDistance = speed / 2.0f; // Following distance = speed / 2 (for simplicity)\n\n    if (distance < followingDistance) {\n        std::cout << \"WARNING: Following distance too short!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic threshold adjustment based on weather conditions.",
      "input": "Weather condition: Rain, Radar distance: 5.5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAIN, SNOW };\n\nWeatherCondition getWeatherCondition() {\n    return RAIN; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.5f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAIN) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the vehicle's speed dynamically if a collision risk is detected.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 3.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid adjustVehicleSpeed(float& speed) {\n    speed = 80.0f; // Reduce speed to avoid collision\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.5f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected! Reducing speed...\" << std::endl;\n        adjustVehicleSpeed(speed);\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects the object type (vehicle or pedestrian) and adjusts the collision threshold accordingly.",
      "input": "Object type: Vehicle, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float VEHICLE_THRESHOLD = 5.0f;\n    const float PEDESTRIAN_THRESHOLD = 2.0f;\n    const float COLLISION_THRESHOLD = (objectType == \"Vehicle\") ? VEHICLE_THRESHOLD : PEDESTRIAN_THRESHOLD;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that tracks the vehicle's distance over time to ensure long-term safety.",
      "input": "Radar distance: 3.0 meters, Time elapsed: 5 seconds.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n    const int TIME_ELAPSED = 5; // Time in seconds\n\n    if (distance < COLLISION_THRESHOLD && TIME_ELAPSED > 3) {\n        std::cout << \"WARNING: Collision risk detected after long-term monitoring!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a reactive warning system when a collision risk is detected.",
      "input": "Radar distance: 3.0 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar data\n}\n\nvoid triggerWarning() {\n    std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.5f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        triggerWarning();\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision threshold based on road type.",
      "input": "Road type: Highway, Vehicle speed: 100 km/h, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nenum RoadType { HIGHWAY, CITY, COUNTRY };\n\nRoadType getRoadType() {\n    return HIGHWAY; // Simulated road type\n}\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar distance\n}\n\nint main() {\n    RoadType road = getRoadType();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float COLLISION_THRESHOLD = (road == HIGHWAY) ? 5.0f : 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts object detection sensitivity based on the distance to the object.",
      "input": "Object distance: 1.0 meters, Object type: Vehicle.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getObjectDistance() {\n    return 1.0f; // Simulated object distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getObjectDistance();\n    const float COLLISION_THRESHOLD = (distance < 2.0f) ? 1.0f : 2.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians and triggers a warning if the distance is too short.",
      "input": "Object type: Pedestrian, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 2.5f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates the following distance based on vehicle speed.",
      "input": "Vehicle speed: 70 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float followingDistance = (speed / 2.0f); // Following distance = speed / 2\n\n    std::cout << \"Following distance: \" << followingDistance << \" meters.\" << std::endl;\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning based on the type of object detected.",
      "input": "Object type: Vehicle, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that calculates time to collision and triggers a warning if the time to collision is below a threshold.",
      "input": "Vehicle speed: 60 km/h, Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / speed; // Time to collision formula\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float timeToCollision = calculateTimeToCollision(speed, distance);\n    const float COLLISION_TIME_THRESHOLD = 3.0f;\n\n    if (timeToCollision < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe time to collision.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that includes traffic light detection and adjusts collision detection based on the state of the light.",
      "input": "Traffic light state: Red, Radar distance: 3.5 meters.",
      "output": "#include <iostream>\n\nenum TrafficLightState { RED, YELLOW, GREEN };\n\nTrafficLightState getTrafficLightState() {\n    return RED; // Simulated traffic light state\n}\n\nfloat getRadarDistance() {\n    return 3.5f; // Simulated radar distance\n}\n\nint main() {\n    TrafficLightState lightState = getTrafficLightState();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (lightState == RED) ? 2.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with specific detection and alert for pedestrians.",
      "input": "Object type: Pedestrian, Radar distance: 1.5 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 1.5f; // Simulated radar data\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 2.0f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with time-to-collision calculation and alert if the time is less than a threshold.",
      "input": "Vehicle speed: 80 km/h, Radar distance: 10.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nfloat calculateTimeToCollision(float speed, float distance) {\n    return distance / speed; // Time to collision formula\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    float timeToCollision = calculateTimeToCollision(speed, distance);\n    const float COLLISION_TIME_THRESHOLD = 3.5f;\n\n    if (timeToCollision < COLLISION_TIME_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe time to collision.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision threshold based on weather conditions.",
      "input": "Weather condition: Rainy, Radar distance: 4.0 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { SUNNY, RAINY, SNOWY };\n\nWeatherCondition getWeatherCondition() {\n    return RAINY; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAINY) ? 3.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with dynamic collision threshold based on the vehicle speed.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 10.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (speed > 100.0f) ? 8.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW with intersection detection, triggering a warning if the vehicle is approaching an intersection.",
      "input": "Intersection detected: Yes, Radar distance: 15.0 meters.",
      "output": "#include <iostream>\n\nbool isIntersectionDetected() {\n    return true; // Simulated intersection detection\n}\n\nfloat getRadarDistance() {\n    return 15.0f; // Simulated radar distance\n}\n\nint main() {\n    bool intersection = isIntersectionDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (intersection) ? 5.0f : 10.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk at intersection!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW where the collision threshold is adjusted based on the size of the detected object.",
      "input": "Object size: Large (Truck), Radar distance: 6.0 meters.",
      "output": "#include <iostream>\n\nenum ObjectSize { SMALL, MEDIUM, LARGE };\n\nObjectSize getObjectSize() {\n    return LARGE; // Simulated object size\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    ObjectSize size = getObjectSize();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (size == LARGE) ? 8.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with object!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers automatic braking if the distance to the object is less than the threshold.",
      "input": "Radar distance: 2.0 meters, Object type: Vehicle.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Vehicle\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar data\n}\n\nvoid applyBrakes() {\n    std::cout << \"Automatic brakes applied!\" << std::endl;\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        applyBrakes();\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that distinguishes between vehicle and pedestrian and triggers a warning accordingly.",
      "input": "Object type: Pedestrian, Radar distance: 1.8 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 1.8f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (objectType == \"Pedestrian\") ? 2.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with \" << objectType << \"!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers an emergency alert when the radar distance is below a threshold and the vehicle speed is high.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 3.0 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid triggerEmergencyAlert() {\n    std::cout << \"EMERGENCY ALERT: Immediate action required!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float SPEED_THRESHOLD = 90.0f;\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (speed > SPEED_THRESHOLD && distance < COLLISION_THRESHOLD) {\n        triggerEmergencyAlert();\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that checks if the vehicle speed is too high given the distance to the detected object.",
      "input": "Vehicle speed: 150 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 150.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float SPEED_THRESHOLD = 120.0f;\n    const float COLLISION_THRESHOLD = 8.0f;\n\n    if (speed > SPEED_THRESHOLD && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected at high speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects lane departure and triggers a collision warning if there is a risk of lane departure combined with close proximity to an object.",
      "input": "Lane departure detected: Yes, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulated lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    bool laneDeparture = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (laneDeparture && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to lane departure!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that considers the type of vehicle ahead and adjusts the collision threshold accordingly.",
      "input": "Vehicle type ahead: Motorcycle, Radar distance: 2.5 meters.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getVehicleTypeAhead() {\n    return MOTORCYCLE; // Simulated vehicle type ahead\n}\n\nfloat getRadarDistance() {\n    return 2.5f; // Simulated radar distance\n}\n\nint main() {\n    VehicleType vehicle = getVehicleTypeAhead();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (vehicle == MOTORCYCLE) ? 2.0f : 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk with vehicle ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the curvature of the road ahead.",
      "input": "Road curvature: High, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nenum RoadCurvature { FLAT, LOW, HIGH };\n\nRoadCurvature getRoadCurvature() {\n    return HIGH; // Simulated road curvature\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    RoadCurvature curvature = getRoadCurvature();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (curvature == HIGH) ? 5.0f : 8.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected due to road curvature!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the vehicle's braking ability.",
      "input": "Vehicle speed: 60 km/h, Brake response time: 2 seconds.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getBrakeResponseTime() {\n    return 2.0f; // Simulated brake response time\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float brakeResponseTime = getBrakeResponseTime();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (brakeResponseTime > 1.5f) ? 3.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on fog conditions.",
      "input": "Fog condition: Heavy, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, LIGHT_FOG, HEAVY_FOG };\n\nWeatherCondition getWeatherCondition() {\n    return HEAVY_FOG; // Simulated fog condition\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == HEAVY_FOG) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected in foggy conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning if the vehicle is changing lanes and there is an object in the new lane.",
      "input": "Lane change detected: Yes, Radar distance: 5.0 meters.",
      "output": "#include <iostream>\n\nbool isLaneChangeDetected() {\n    return true; // Simulated lane change detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    bool laneChange = isLaneChangeDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 6.0f;\n\n    if (laneChange && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected during lane change!\" << std::endl;\n    } else {\n        std::cout << \"Safe lane change.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers automatic emergency braking when the distance is below a certain threshold.",
      "input": "Radar distance: 1.5 meters, Emergency braking status: False.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 1.5f; // Simulated radar distance\n}\n\nbool isEmergencyBrakingActive() {\n    return false; // Simulated emergency braking status\n}\n\nvoid applyBrakes() {\n    std::cout << \"Applying emergency brakes!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    bool braking = isEmergencyBrakingActive();\n    const float COLLISION_THRESHOLD = 2.0f;\n\n    if (distance < COLLISION_THRESHOLD && !braking) {\n        applyBrakes();\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians and triggers an automatic alert if within a specific range.",
      "input": "Object type: Pedestrian, Radar distance: 2.0 meters.",
      "output": "#include <iostream>\n\nstd::string getObjectType() {\n    return \"Pedestrian\"; // Simulated object type\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string objectType = getObjectType();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (objectType == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected!\" << std::endl;\n    } else {\n        std::cout << \"No immediate threat.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning if there is a cross traffic risk when pulling out of a parking spot.",
      "input": "Cross traffic detected: Yes, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isCrossTrafficDetected() {\n    return true; // Simulated cross traffic detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    bool crossTraffic = isCrossTrafficDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (crossTraffic && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Cross traffic risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to proceed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that checks if the vehicle's stopping distance exceeds the available road space.",
      "input": "Vehicle speed: 50 km/h, Road length available: 15 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Simulated vehicle speed\n}\n\nfloat getAvailableRoadLength() {\n    return 15.0f; // Simulated road length available\n}\n\nfloat calculateStoppingDistance(float speed) {\n    const float DECELERATION = 5.0f; // Simulated deceleration\n    return (speed * speed) / (2 * DECELERATION); // Simplified stopping distance formula\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float roadLength = getAvailableRoadLength();\n    float stoppingDistance = calculateStoppingDistance(speed);\n\n    if (stoppingDistance > roadLength) {\n        std::cout << \"WARNING: Insufficient road length to stop safely!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that dynamically adjusts the warning threshold based on the road's speed limit.",
      "input": "Vehicle speed: 80 km/h, Road speed limit: 60 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed\n}\n\nfloat getRoadSpeedLimit() {\n    return 60.0f; // Simulated road speed limit\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    float vehicleSpeed = getVehicleSpeed();\n    float speedLimit = getRoadSpeedLimit();\n    float distance = getRadarDistance();\n\n    if (vehicleSpeed > speedLimit && distance < 15.0f) {\n        std::cout << \"WARNING: Over-speeding! Slow down.\" << std::endl;\n    } else if (vehicleSpeed > speedLimit) {\n        std::cout << \"WARNING: Over-speeding! Reduce speed.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects if the vehicle is approaching heavy traffic and adjusts the collision risk threshold.",
      "input": "Traffic congestion: Heavy, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isTrafficHeavy() {\n    return true; // Simulated traffic congestion\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    bool traffic = isTrafficHeavy();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (traffic) ? 2.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: High collision risk due to traffic!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision risk based on the size of the detected object ahead.",
      "input": "Object detected: Small vehicle, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nenum ObjectType { CAR, TRUCK, MOTORCYCLE, SMALL_VEHICLE };\n\nObjectType getDetectedObject() {\n    return SMALL_VEHICLE; // Simulated object detection\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Simulated radar distance\n}\n\nint main() {\n    ObjectType detectedObject = getDetectedObject();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (detectedObject == SMALL_VEHICLE) ? 4.0f : 8.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected with small vehicle!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that integrates with adaptive cruise control to maintain a safe distance based on the vehicle's speed.",
      "input": "Vehicle speed: 100 km/h, Distance to vehicle ahead: 5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getDistanceToVehicleAhead() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    float vehicleSpeed = getVehicleSpeed();\n    float distance = getDistanceToVehicleAhead();\n    const float SAFE_DISTANCE = vehicleSpeed * 0.5f; // Simple rule for safe distance\n\n    if (distance < SAFE_DISTANCE) {\n        std::cout << \"WARNING: Too close to vehicle ahead, activating cruise control adjustment.\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians crossing the road and triggers a warning.",
      "input": "Object type: Pedestrian, Radar distance: 1.8 meters.",
      "output": "#include <iostream>\n\nstd::string getDetectedObject() {\n    return \"Pedestrian\"; // Simulated object detection\n}\n\nfloat getRadarDistance() {\n    return 1.8f; // Simulated radar distance\n}\n\nint main() {\n    std::string object = getDetectedObject();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 2.0f;\n\n    if (object == \"Pedestrian\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision warning threshold based on poor visibility conditions.",
      "input": "Visibility: Poor, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nenum VisibilityCondition { CLEAR, POOR };\n\nVisibilityCondition getVisibilityCondition() {\n    return POOR; // Simulated poor visibility\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nint main() {\n    VisibilityCondition visibility = getVisibilityCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (visibility == POOR) ? 2.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Collision risk detected in poor visibility conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers a warning when a pedestrian is detected in a crosswalk.",
      "input": "Object type: Pedestrian, Crosswalk detected: Yes, Radar distance: 1.0 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianInCrosswalk() {\n    return true; // Simulated pedestrian in crosswalk detection\n}\n\nfloat getRadarDistance() {\n    return 1.0f; // Simulated radar distance\n}\n\nint main() {\n    bool pedestrianInCrosswalk = isPedestrianInCrosswalk();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 1.5f;\n\n    if (pedestrianInCrosswalk && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian in crosswalk!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected in crosswalk.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that warns the driver when the car is too close to a stop sign.",
      "input": "Object detected: Stop sign, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nstd::string getDetectedObject() {\n    return \"Stop sign\"; // Simulated object detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    std::string object = getDetectedObject();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (object == \"Stop sign\" && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Too close to stop sign!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on the vehicle's headlights being in night mode.",
      "input": "Headlights: Night mode, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nbool areHeadlightsInNightMode() {\n    return true; // Simulated night mode\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Simulated radar distance\n}\n\nint main() {\n    bool nightMode = areHeadlightsInNightMode();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (nightMode) ? 6.0f : 10.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Low visibility due to night mode!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects rapid deceleration and warns if the car is approaching a dangerous situation.",
      "input": "Vehicle speed: 80 km/h, Deceleration rate: 8 m/s\\u00b2.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Simulated vehicle speed in km/h\n}\n\nfloat getDecelerationRate() {\n    return 8.0f; // Simulated deceleration rate in m/s\u00c2\u00b2\n}\n\nbool isRapidDeceleration(float decelerationRate) {\n    return decelerationRate > 7.0f; // Threshold for rapid deceleration\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float deceleration = getDecelerationRate();\n\n    if (isRapidDeceleration(deceleration)) {\n        std::cout << \"WARNING: Rapid deceleration detected!\" << std::endl;\n    } else {\n        std::cout << \"Normal deceleration.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects obstacles at intersections and issues a warning when a collision risk is detected.",
      "input": "Obstacle detected at intersection, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nbool isObstacleDetectedAtIntersection() {\n    return true; // Simulated obstacle detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    bool obstacle = isObstacleDetectedAtIntersection();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (obstacle && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Obstacle detected at intersection!\" << std::endl;\n    } else {\n        std::cout << \"Safe to proceed.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the warning threshold based on whether it's night time, considering lower visibility.",
      "input": "Vehicle speed: 60 km/h, Night time: True, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isNightTime() {\n    return true; // Simulated night time detection\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Simulated radar distance\n}\n\nint main() {\n    bool nightTime = isNightTime();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = nightTime ? 8.0f : 12.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Low visibility due to night time driving.\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects if a sudden lane change is made and issues a warning.",
      "input": "Vehicle speed: 90 km/h, Lane change detected: Yes, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nbool isLaneChangeDetected() {\n    return true; // Simulated lane change detection\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Simulated radar distance\n}\n\nint main() {\n    bool laneChange = isLaneChangeDetected();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 5.0f;\n\n    if (laneChange && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Sudden lane change detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe lane change detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that detects pedestrians and assesses collision risk based on their distance from the vehicle.",
      "input": "Pedestrian detected: Yes, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulated pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar distance\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (pedestrianDetected && distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Pedestrian detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that adjusts the collision warning threshold based on weather conditions.",
      "input": "Weather: Rainy, Vehicle speed: 70 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, RAINY, FOGGY };\n\nWeatherCondition getWeatherCondition() {\n    return RAINY; // Simulated weather condition\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Simulated radar distance\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == RAINY) ? 3.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Reduced visibility due to weather!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that triggers emergency braking when collision risk is high.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Simulated vehicle speed\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance\n}\n\nvoid activateEmergencyBraking() {\n    std::cout << \"Emergency Braking Activated!\" << std::endl;\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 4.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        activateEmergencyBraking();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that also triggers a warning when the car is detected to be drifting out of its lane.",
      "input": "Lane deviation detected: Yes, Vehicle speed: 70 km/h.",
      "output": "#include <iostream>\n\nbool isLaneDeviationDetected() {\n    return true; // Simulated lane deviation detection\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed\n}\n\nint main() {\n    bool laneDeviation = isLaneDeviationDetected();\n    float speed = getVehicleSpeed();\n\n    if (laneDeviation) {\n        std::cout << \"WARNING: Lane deviation detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle within lane.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that warns when the vehicle is too close to the vehicle ahead, i.e., tailgating.",
      "input": "Distance to vehicle ahead: 2 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.0f; // Simulated radar distance\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Simulated vehicle speed\n}\n\nint main() {\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = 3.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Tailgating detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write MISRA C++ 2023-compliant code for FCW that takes into account the vehicle's turn signal status when calculating collision risk.",
      "input": "Turn signal active: Yes, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nbool isTurnSignalActive() {\n    return true; // Simulated turn signal status\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Simulated radar distance\n}\n\nint main() {\n    bool turnSignal = isTurnSignalActive();\n    float distance = getRadarDistance();\n\n    if (turnSignal && distance < 10.0f) {\n        std::cout << \"WARNING: Turn signal active, be aware of vehicle maneuver!\" << std::endl;\n    } else {\n        std::cout << \"No turn signal detected.\" << std::endl;\n    }\n\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects collision risk based on the distance from a detected object ahead of the vehicle.",
      "input": "Radar distance: 3 meters, Vehicle speed: 70 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Simulated radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Simulated vehicle speed in km/h\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 5.0f; // 5 meters distance threshold\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW that adjusts the warning threshold based on the vehicle's speed.",
      "input": "Vehicle speed: 90 km/h, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float SPEED_THRESHOLD = 80.0f;\n    const float COLLISION_THRESHOLD_HIGH_SPEED = 4.0f;\n    const float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;\n    if (speed > SPEED_THRESHOLD) {\n        return distance < COLLISION_THRESHOLD_HIGH_SPEED;\n    } else {\n        return distance < COLLISION_THRESHOLD_LOW_SPEED;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Implement a MISRA C++ 2023-compliant FCW system that detects pedestrians and calculates collision risk based on proximity.",
      "input": "Pedestrian detected: Yes, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 3.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (pedestrianDetected && isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Pedestrian ahead!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that also checks if the vehicle is deviating from its lane and issues a warning.",
      "input": "Lane deviation detected: Yes, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isLaneDeviationDetected() {\n    return true; // Simulated lane deviation detection\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nint main() {\n    bool laneDeviation = isLaneDeviationDetected();\n    float distance = getRadarDistance();\n    if (laneDeviation) {\n        std::cout << \"WARNING: Lane deviation detected!\" << std::endl;\n    } else {\n        std::cout << \"Vehicle is within lane.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the warning threshold based on weather conditions (e.g., rainy or foggy).",
      "input": "Weather: Foggy, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, RAINY, FOGGY };\n\nWeatherCondition getWeatherCondition() {\n    return FOGGY; // Simulated weather condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nint main() {\n    WeatherCondition weather = getWeatherCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (weather == FOGGY) ? 4.0f : 6.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Reduced visibility due to foggy conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that warns if the car is following too closely behind another vehicle (tailgating).",
      "input": "Distance to vehicle ahead: 1.5 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 1.5f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isTailgating(float distance) {\n    const float MIN_SAFE_DISTANCE = 2.0f; // Safe distance in meters\n    return distance < MIN_SAFE_DISTANCE;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isTailgating(distance)) {\n        std::cout << \"WARNING: Tailgating detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe following distance.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that accounts for the vehicle's turn signal status when determining collision risk.",
      "input": "Turn signal active: Yes, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nbool isTurnSignalActive() {\n    return true; // Simulated turn signal status\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nint main() {\n    bool turnSignal = isTurnSignalActive();\n    float distance = getRadarDistance();\n    if (turnSignal && distance < 5.0f) {\n        std::cout << \"WARNING: Turn signal active, vehicle may change lane!\" << std::endl;\n    } else {\n        std::cout << \"No turn signal detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers emergency braking when a collision risk is detected and too close.",
      "input": "Radar distance: 2 meters, Vehicle speed: 80 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nvoid activateEmergencyBraking() {\n    std::cout << \"Emergency Braking Activated!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 3.0f) {\n        activateEmergencyBraking();\n    } else {\n        std::cout << \"No immediate collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts collision risk thresholds based on the vehicle's speed.",
      "input": "Vehicle speed: 100 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 100.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float COLLISION_THRESHOLD_HIGH_SPEED = 4.0f;\n    const float COLLISION_THRESHOLD_LOW_SPEED = 6.0f;\n    return (speed > 90.0f) ? (distance < COLLISION_THRESHOLD_HIGH_SPEED) : (distance < COLLISION_THRESHOLD_LOW_SPEED);\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that dynamically adjusts the collision warning threshold based on heavy traffic conditions.",
      "input": "Traffic conditions: Heavy, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nenum TrafficCondition { LIGHT, MODERATE, HEAVY };\n\nTrafficCondition getTrafficCondition() {\n    return HEAVY; // Simulate traffic condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nint main() {\n    TrafficCondition traffic = getTrafficCondition();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (traffic == HEAVY) ? 3.0f : 5.0f;\n\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Heavy traffic, reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that differentiates collision risk based on the type of vehicle ahead (e.g., car, truck).",
      "input": "Vehicle ahead: Truck, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getAheadVehicleType() {\n    return TRUCK; // Simulated vehicle ahead\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(VehicleType type, float distance) {\n    const float CAR_THRESHOLD = 5.0f;\n    const float TRUCK_THRESHOLD = 8.0f;\n    const float MOTORCYCLE_THRESHOLD = 4.0f;\n\n    switch(type) {\n        case CAR: return distance < CAR_THRESHOLD;\n        case TRUCK: return distance < TRUCK_THRESHOLD;\n        case MOTORCYCLE: return distance < MOTORCYCLE_THRESHOLD;\n        default: return false;\n    }\n}\n\nint main() {\n    VehicleType vehicle = getAheadVehicleType();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(vehicle, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision risk warning based on the vehicle's dynamic speed and distance to the object ahead.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 4.0f;\n    const float LOW_SPEED_THRESHOLD = 6.0f;\n    if (speed > 100.0f) {\n        return distance < HIGH_SPEED_THRESHOLD;\n    } else {\n        return distance < LOW_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that uses both forward camera and radar data for collision detection and warning.",
      "input": "Radar distance: 5 meters, Camera detects an object ahead.",
      "output": "#include <iostream>\n\nbool isObjectDetectedByCamera() {\n    return true; // Simulate object detection by camera\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance, bool cameraDetection) {\n    const float COLLISION_THRESHOLD = 4.0f;\n    return cameraDetection && distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool cameraDetection = isObjectDetectedByCamera();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance, cameraDetection)) {\n        std::cout << \"WARNING: Object ahead!\" << std::endl;\n    } else {\n        std::cout << \"No object detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the duration of the warning based on the distance to the object ahead.",
      "input": "Radar distance: 3 meters, Warning threshold: 5 seconds.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nvoid activateWarning(float duration) {\n    std::cout << \"WARNING: Collision risk! Warning duration: \" << duration << \" seconds.\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 5.0f) {\n        activateWarning(5.0f); // Trigger warning for 5 seconds\n    } else {\n        std::cout << \"No collision risk.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers automatic emergency braking when the radar detects an object within a critical distance.",
      "input": "Radar distance: 1.5 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 1.5f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nvoid activateAutomaticBraking() {\n    std::cout << \"Automatic emergency braking triggered!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 2.0f) {\n        activateAutomaticBraking();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects collision risk based on lane change signals from the vehicle ahead.",
      "input": "Lane change detected: Yes, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nbool isLaneChangeDetected() {\n    return true; // Simulate lane change detection\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nint main() {\n    bool laneChange = isLaneChangeDetected();\n    float distance = getRadarDistance();\n    if (laneChange && distance < 10.0f) {\n        std::cout << \"WARNING: Lane change detected, risk of collision!\" << std::endl;\n    } else {\n        std::cout << \"No lane change detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision risk based on pedestrian detection and vehicle speed.",
      "input": "Pedestrian detected: Yes, Vehicle speed: 20 km/h, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 20.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool pedestrianDetected, float speed, float distance) {\n    const float COLLISION_THRESHOLD = (speed < 30.0f) ? 3.0f : 2.0f;\n    return pedestrianDetected && distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(pedestrianDetected, speed, distance)) {\n        std::cout << \"WARNING: Pedestrian ahead!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects when the vehicle ahead stops and issues an appropriate warning.",
      "input": "Vehicle ahead speed: 0 km/h, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeedAhead() {\n    return 0.0f; // Speed of the vehicle ahead\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nvoid triggerFCW() {\n    std::cout << \"WARNING: Vehicle ahead has stopped!\" << std::endl;\n}\n\nint main() {\n    float speedAhead = getVehicleSpeedAhead();\n    float distance = getRadarDistance();\n    if (speedAhead == 0.0f && distance < 3.0f) {\n        triggerFCW();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning threshold based on road curvature.",
      "input": "Road curvature: Sharp turn, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nenum RoadCurvature { STRAIGHT, SLIGHT_TURN, SHARP_TURN };\n\nRoadCurvature getRoadCurvature() {\n    return SHARP_TURN; // Simulate sharp turn condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nint main() {\n    RoadCurvature curvature = getRoadCurvature();\n    float distance = getRadarDistance();\n    const float COLLISION_THRESHOLD = (curvature == SHARP_TURN) ? 3.0f : 5.0f;\n    if (distance < COLLISION_THRESHOLD) {\n        std::cout << \"WARNING: Sharp turn, reduce speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects cross-traffic and provides a warning when necessary.",
      "input": "Cross-traffic detected: Yes, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nbool isCrossTrafficDetected() {\n    return true; // Simulate cross-traffic detection\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nint main() {\n    bool crossTrafficDetected = isCrossTrafficDetected();\n    float distance = getRadarDistance();\n    if (crossTrafficDetected && distance < 6.0f) {\n        std::cout << \"WARNING: Cross-traffic detected, proceed with caution!\" << std::endl;\n    } else {\n        std::cout << \"No cross-traffic detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers a pedestrian avoidance warning if a pedestrian is detected and collision risk is high.",
      "input": "Pedestrian detected: Yes, Radar distance: 2 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(float distance, bool pedestrianDetected) {\n    const float PEDESTRIAN_THRESHOLD = 2.5f;\n    return pedestrianDetected && distance < PEDESTRIAN_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance, pedestrianDetected)) {\n        std::cout << \"WARNING: Pedestrian ahead, slow down or stop!\" << std::endl;\n    } else {\n        std::cout << \"No pedestrian detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates lane departure warnings when the vehicle is at risk of colliding with a vehicle ahead while exiting the lane.",
      "input": "Lane departure: Yes, Vehicle ahead speed: 30 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulate lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeedAhead() {\n    return 30.0f; // Vehicle speed ahead\n}\n\nint main() {\n    bool laneDeparture = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    float speedAhead = getVehicleSpeedAhead();\n    if (laneDeparture && distance < 15.0f && speedAhead < 50.0f) {\n        std::cout << \"WARNING: Lane departure detected, vehicle ahead, slow down!\" << std::endl;\n    } else {\n        std::cout << \"No lane departure detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the threshold for collision warning based on the dynamic speed of the vehicle.",
      "input": "Vehicle speed: 90 km/h, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 5.0f;\n    const float NORMAL_SPEED_THRESHOLD = 8.0f;\n    if (speed > 80.0f) {\n        return distance < HIGH_SPEED_THRESHOLD;\n    } else {\n        return distance < NORMAL_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers the emergency brake if a collision risk is detected based on radar data.",
      "input": "Radar distance: 2 meters, Vehicle speed: 30 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Vehicle speed in km/h\n}\n\nvoid activateEmergencyBrake() {\n    std::cout << \"Emergency brake activated!\" << std::endl;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (distance < 3.0f) {\n        activateEmergencyBrake();\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision risk threshold based on the type of vehicle ahead (car, truck, motorcycle).",
      "input": "Vehicle ahead: Truck, Radar distance: 12 meters, Speed: 80 km/h.",
      "output": "#include <iostream>\n\nenum VehicleType { CAR, TRUCK, MOTORCYCLE };\n\nVehicleType getVehicleTypeAhead() {\n    return TRUCK; // Vehicle type ahead\n}\n\nfloat getRadarDistance() {\n    return 12.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(VehicleType type, float distance, float speed) {\n    const float CAR_THRESHOLD = 10.0f;\n    const float TRUCK_THRESHOLD = 15.0f;\n    const float MOTORCYCLE_THRESHOLD = 8.0f;\n\n    if (type == CAR) {\n        return distance < CAR_THRESHOLD && speed > 60.0f;\n    } else if (type == TRUCK) {\n        return distance < TRUCK_THRESHOLD && speed > 70.0f;\n    } else {\n        return distance < MOTORCYCLE_THRESHOLD && speed > 50.0f;\n    }\n}\n\nint main() {\n    VehicleType vehicleType = getVehicleTypeAhead();\n    float distance = getRadarDistance();\n    float speed = getVehicleSpeed();\n    if (isCollisionRisk(vehicleType, distance, speed)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision threshold based on weather conditions.",
      "input": "Weather: Foggy, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nenum WeatherCondition { CLEAR, FOGGY, RAINY };\n\nWeatherCondition getCurrentWeather() {\n    return FOGGY; // Current weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(WeatherCondition weather, float distance) {\n    const float CLEAR_THRESHOLD = 8.0f;\n    const float FOGGY_THRESHOLD = 4.0f;\n    const float RAINY_THRESHOLD = 6.0f;\n\n    if (weather == CLEAR) {\n        return distance < CLEAR_THRESHOLD;\n    } else if (weather == FOGGY) {\n        return distance < FOGGY_THRESHOLD;\n    } else { // RAINY\n        return distance < RAINY_THRESHOLD;\n    }\n}\n\nint main() {\n    WeatherCondition weather = getCurrentWeather();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(weather, distance)) {\n        std::cout << \"WARNING: Collision risk detected due to weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"No collision risk detected.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects rear-end collision risks when a vehicle is too close behind.",
      "input": "Rear vehicle speed: 100 km/h, Radar distance: 3 meters.",
      "output": "#include <iostream>\n\nfloat getRearVehicleSpeed() {\n    return 100.0f; // Rear vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nbool isRearEndCollisionRisk(float rearSpeed, float distance) {\n    const float COLLISION_THRESHOLD = 5.0f;\n    return rearSpeed > 90.0f && distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float rearSpeed = getRearVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isRearEndCollisionRisk(rearSpeed, distance)) {\n        std::cout << \"WARNING: Rear-end collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe from rear-end collision.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers a warning based on vehicle speed and proximity to other vehicles.",
      "input": "Vehicle speed: 110 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 110.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 5.0f;\n    const float NORMAL_SPEED_THRESHOLD = 8.0f;\n    return (speed > 100.0f && distance < HIGH_SPEED_THRESHOLD) || (distance < NORMAL_SPEED_THRESHOLD);\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High speed collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the radar distance threshold based on the vehicle's speed.",
      "input": "Vehicle speed: 40 km/h, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float SLOW_SPEED_THRESHOLD = 10.0f;\n    const float NORMAL_SPEED_THRESHOLD = 7.0f;\n    if (speed < 50.0f) {\n        return distance < SLOW_SPEED_THRESHOLD;\n    } else {\n        return distance < NORMAL_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: Collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that provides an alert when the vehicle is driving on a narrow road with a vehicle ahead.",
      "input": "Road width: Narrow, Vehicle ahead speed: 20 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nbool isNarrowRoad() {\n    return true; // Simulate narrow road condition\n}\n\nfloat getVehicleSpeedAhead() {\n    return 20.0f; // Vehicle speed ahead\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nint main() {\n    bool narrowRoad = isNarrowRoad();\n    float speedAhead = getVehicleSpeedAhead();\n    float distance = getRadarDistance();\n    if (narrowRoad && distance < 8.0f && speedAhead < 30.0f) {\n        std::cout << \"WARNING: Narrow road ahead, vehicle approaching!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning system for night driving.",
      "input": "Time of day: Night, Radar distance: 8 meters, Vehicle speed: 40 km/h.",
      "output": "#include <iostream>\n\nbool isNightMode() {\n    return true; // Simulate night driving condition\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool nightMode, float distance) {\n    const float NIGHT_MODE_THRESHOLD = 6.0f;\n    const float NORMAL_MODE_THRESHOLD = 8.0f;\n\n    if (nightMode) {\n        return distance < NIGHT_MODE_THRESHOLD;\n    } else {\n        return distance < NORMAL_MODE_THRESHOLD;\n    }\n}\n\nint main() {\n    bool nightMode = isNightMode();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(nightMode, distance)) {\n        std::cout << \"WARNING: Collision risk detected in night mode!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects tailgating behavior and triggers an emergency alert.",
      "input": "Rear vehicle distance: 2 meters, Speed: 100 km/h.",
      "output": "#include <iostream>\n\nfloat getRearVehicleDistance() {\n    return 2.0f; // Rear vehicle distance in meters\n}\n\nfloat getRearVehicleSpeed() {\n    return 100.0f; // Rear vehicle speed in km/h\n}\n\nbool isTailgatingRisk(float rearDistance, float rearSpeed) {\n    const float TAILGATING_THRESHOLD = 3.0f;\n    return rearDistance < TAILGATING_THRESHOLD && rearSpeed > 90.0f;\n}\n\nint main() {\n    float rearDistance = getRearVehicleDistance();\n    float rearSpeed = getRearVehicleSpeed();\n    if (isTailgatingRisk(rearDistance, rearSpeed)) {\n        std::cout << \"WARNING: Tailgating risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe distance maintained.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the radar distance threshold based on vehicle speed.",
      "input": "Vehicle speed: 120 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float speed, float distance) {\n    const float SPEED_THRESHOLD = 100.0f;\n    const float HIGH_SPEED_THRESHOLD = 5.0f;\n    const float NORMAL_SPEED_THRESHOLD = 8.0f;\n\n    if (speed > SPEED_THRESHOLD) {\n        return distance < HIGH_SPEED_THRESHOLD;\n    } else {\n        return distance < NORMAL_SPEED_THRESHOLD;\n    }\n}\n\nint main() {\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(speed, distance)) {\n        std::cout << \"WARNING: High-speed collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers proximity alerts when driving in urban areas.",
      "input": "Location: Urban, Radar distance: 4 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nbool isUrbanArea() {\n    return true; // Simulate urban area condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool urbanArea, float distance) {\n    const float URBAN_AREA_THRESHOLD = 5.0f;\n    const float NORMAL_AREA_THRESHOLD = 8.0f;\n\n    if (urbanArea) {\n        return distance < URBAN_AREA_THRESHOLD;\n    } else {\n        return distance < NORMAL_AREA_THRESHOLD;\n    }\n}\n\nint main() {\n    bool urbanArea = isUrbanArea();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(urbanArea, distance)) {\n        std::cout << \"WARNING: Collision risk in urban area!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects long-distance vehicles and adjusts the alert accordingly.",
      "input": "Vehicle ahead distance: 50 meters, Speed: 80 km/h.",
      "output": "#include <iostream>\n\nfloat getVehicleAheadDistance() {\n    return 50.0f; // Vehicle ahead distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(float distance, float speed) {\n    const float LONG_DISTANCE_THRESHOLD = 45.0f;\n    const float COLLISION_SPEED_THRESHOLD = 60.0f;\n    return distance < LONG_DISTANCE_THRESHOLD && speed > COLLISION_SPEED_THRESHOLD;\n}\n\nint main() {\n    float distance = getVehicleAheadDistance();\n    float speed = getVehicleSpeed();\n    if (isCollisionRisk(distance, speed)) {\n        std::cout << \"WARNING: Long-distance vehicle detected, slow down!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving conditions.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers an alert when driving on hazardous road conditions such as icy roads.",
      "input": "Road condition: Icy, Radar distance: 6 meters, Vehicle speed: 30 km/h.",
      "output": "#include <iostream>\n\nenum RoadCondition { NORMAL, ICY, WET };\n\nRoadCondition getRoadCondition() {\n    return ICY; // Simulate icy road condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(RoadCondition condition, float distance) {\n    const float ICY_ROAD_THRESHOLD = 4.0f;\n    const float NORMAL_ROAD_THRESHOLD = 8.0f;\n\n    if (condition == ICY) {\n        return distance < ICY_ROAD_THRESHOLD;\n    } else {\n        return distance < NORMAL_ROAD_THRESHOLD;\n    }\n}\n\nint main() {\n    RoadCondition condition = getRoadCondition();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(condition, distance)) {\n        std::cout << \"WARNING: Hazardous road condition detected, slow down!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adapts the collision warning when detecting motorcycles ahead.",
      "input": "Vehicle ahead: Motorcycle, Radar distance: 6 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nbool isMotorcycleAhead() {\n    return true; // Simulate motorcycle ahead condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool motorcycleAhead, float distance) {\n    const float MOTORCYCLE_THRESHOLD = 5.0f;\n    const float NORMAL_THRESHOLD = 8.0f;\n\n    if (motorcycleAhead) {\n        return distance < MOTORCYCLE_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool motorcycleAhead = isMotorcycleAhead();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(motorcycleAhead, distance)) {\n        std::cout << \"WARNING: Motorcycle ahead, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates with an automated braking system to stop the vehicle in case of a detected collision risk.",
      "input": "Radar distance: 3 meters, Vehicle speed: 90 km/h.",
      "output": "#include <iostream>\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nvoid applyBrakes() {\n    std::cout << \"Automated braking system activated!\" << std::endl;\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 4.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance)) {\n        applyBrakes();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates lane departure warning with forward collision detection.",
      "input": "Vehicle in lane: True, Radar distance: 8 meters.",
      "output": "#include <iostream>\n\nbool isLaneDeparture() {\n    return false; // Simulate lane departure condition\n}\n\nfloat getRadarDistance() {\n    return 8.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 5.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool laneDeparture = isLaneDeparture();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(distance) || laneDeparture) {\n        std::cout << \"WARNING: Lane departure or collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning for foggy weather conditions.",
      "input": "Weather condition: Foggy, Radar distance: 4 meters, Vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nbool isFoggyWeather() {\n    return true; // Simulate foggy weather condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool foggyWeather, float distance) {\n    const float FOG_THRESHOLD = 3.0f;\n    const float NORMAL_THRESHOLD = 6.0f;\n\n    if (foggyWeather) {\n        return distance < FOG_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool foggyWeather = isFoggyWeather();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(foggyWeather, distance)) {\n        std::cout << \"WARNING: Foggy weather, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects if the vehicle in front is decelerating and triggers an alert.",
      "input": "Lead vehicle speed: 70 km/h, Following vehicle speed: 60 km/h.",
      "output": "#include <iostream>\n\nfloat getLeadVehicleSpeed() {\n    return 70.0f; // Lead vehicle speed in km/h\n}\n\nfloat getFollowingVehicleSpeed() {\n    return 60.0f; // Following vehicle speed in km/h\n}\n\nbool isDecelerating(float leadSpeed, float followSpeed) {\n    return followSpeed < leadSpeed;\n}\n\nint main() {\n    float leadSpeed = getLeadVehicleSpeed();\n    float followSpeed = getFollowingVehicleSpeed();\n    if (isDecelerating(leadSpeed, followSpeed)) {\n        std::cout << \"WARNING: Lead vehicle is decelerating, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers an adaptive alert when a pedestrian is detected in the vehicle's path.",
      "input": "Pedestrian detected: True, Radar distance: 3 meters, Vehicle speed: 20 km/h.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 3.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 20.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool pedestrianDetected, float distance) {\n    const float PEDESTRIAN_THRESHOLD = 4.0f;\n    return pedestrianDetected && distance < PEDESTRIAN_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(pedestrianDetected, distance)) {\n        std::cout << \"WARNING: Pedestrian detected, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the collision warning system based on the time of day (day or night).",
      "input": "Time of day: Day, Radar distance: 10 meters, Vehicle speed: 80 km/h.",
      "output": "#include <iostream>\n\nbool isDayTime() {\n    return true; // Simulate day time condition\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 80.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool dayTime, float distance) {\n    const float DAY_TIME_THRESHOLD = 12.0f;\n    const float NIGHT_TIME_THRESHOLD = 8.0f;\n\n    if (dayTime) {\n        return distance < DAY_TIME_THRESHOLD;\n    } else {\n        return distance < NIGHT_TIME_THRESHOLD;\n    }\n}\n\nint main() {\n    bool dayTime = isDayTime();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(dayTime, distance)) {\n        std::cout << \"WARNING: Collision risk detected in day mode!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects sharp curves ahead and adjusts collision warning thresholds.",
      "input": "Curve ahead: True, Radar distance: 6 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nbool isCurveAhead() {\n    return true; // Simulate curve ahead condition\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool curveAhead, float distance) {\n    const float CURVE_THRESHOLD = 5.0f;\n    const float NORMAL_THRESHOLD = 8.0f;\n\n    if (curveAhead) {\n        return distance < CURVE_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool curveAhead = isCurveAhead();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(curveAhead, distance)) {\n        std::cout << \"WARNING: Collision risk due to curve ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adapts the collision warning threshold based on the density of traffic.",
      "input": "Traffic flow: Dense, Radar distance: 4 meters, Vehicle speed: 30 km/h.",
      "output": "#include <iostream>\n\nbool isTrafficDense() {\n    return true; // Simulate dense traffic condition\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 30.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool denseTraffic, float distance) {\n    const float DENSE_TRAFFIC_THRESHOLD = 3.0f;\n    const float NORMAL_TRAFFIC_THRESHOLD = 6.0f;\n\n    if (denseTraffic) {\n        return distance < DENSE_TRAFFIC_THRESHOLD;\n    } else {\n        return distance < NORMAL_TRAFFIC_THRESHOLD;\n    }\n}\n\nint main() {\n    bool denseTraffic = isTrafficDense();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(denseTraffic, distance)) {\n        std::cout << \"WARNING: Collision risk due to dense traffic!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects fog and adjusts the vehicle speed and collision warning thresholds.",
      "input": "Weather: Foggy, Vehicle speed: 40 km/h, Radar distance: 5 meters.",
      "output": "#include <iostream>\n\nbool isFoggyWeather() {\n    return true; // Simulate foggy weather condition\n}\n\nfloat getRadarDistance() {\n    return 5.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 40.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool foggyWeather, float distance) {\n    const float FOG_THRESHOLD = 4.0f;\n    const float NORMAL_THRESHOLD = 6.0f;\n\n    if (foggyWeather) {\n        return distance < FOG_THRESHOLD;\n    } else {\n        return distance < NORMAL_THRESHOLD;\n    }\n}\n\nint main() {\n    bool foggyWeather = isFoggyWeather();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(foggyWeather, distance)) {\n        std::cout << \"WARNING: Collision risk in foggy conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects slow-moving traffic ahead and adjusts the warning system.",
      "input": "Lead vehicle speed: 20 km/h, Following vehicle speed: 25 km/h.",
      "output": "#include <iostream>\n\nfloat getLeadVehicleSpeed() {\n    return 20.0f; // Lead vehicle speed in km/h\n}\n\nfloat getFollowingVehicleSpeed() {\n    return 25.0f; // Following vehicle speed in km/h\n}\n\nbool isSlowMovingTraffic(float leadSpeed, float followSpeed) {\n    return followSpeed < leadSpeed;\n}\n\nint main() {\n    float leadSpeed = getLeadVehicleSpeed();\n    float followSpeed = getFollowingVehicleSpeed();\n    if (isSlowMovingTraffic(leadSpeed, followSpeed)) {\n        std::cout << \"WARNING: Slow-moving traffic detected ahead!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers an automatic lane change when a collision risk is detected.",
      "input": "Collision risk: True, Vehicle speed: 90 km/h.",
      "output": "#include <iostream>\n\nbool isCollisionRisk() {\n    return true; // Simulate collision risk detection\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nvoid triggerLaneChange() {\n    std::cout << \"WARNING: Collision risk detected. Triggering automatic lane change!\" << std::endl;\n}\n\nint main() {\n    if (isCollisionRisk()) {\n        triggerLaneChange();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that integrates blind spot detection with forward collision warning.",
      "input": "Blind spot detected: True, Radar distance: 7 meters.",
      "output": "#include <iostream>\n\nbool isBlindSpotDetected() {\n    return true; // Simulate blind spot detection\n}\n\nfloat getRadarDistance() {\n    return 7.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float COLLISION_THRESHOLD = 5.0f;\n    return distance < COLLISION_THRESHOLD;\n}\n\nint main() {\n    bool blindSpot = isBlindSpotDetected();\n    float distance = getRadarDistance();\n    if (blindSpot || isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Blind spot or collision risk detected!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects pedestrians at crosswalks and triggers a warning.",
      "input": "Pedestrian detected: True, Radar distance: 2 meters.",
      "output": "#include <iostream>\n\nbool isPedestrianDetected() {\n    return true; // Simulate pedestrian detection\n}\n\nfloat getRadarDistance() {\n    return 2.0f; // Radar distance in meters\n}\n\nbool isCollisionRisk(float distance) {\n    const float PEDESTRIAN_THRESHOLD = 3.0f;\n    return distance < PEDESTRIAN_THRESHOLD;\n}\n\nint main() {\n    bool pedestrianDetected = isPedestrianDetected();\n    float distance = getRadarDistance();\n    if (pedestrianDetected && isCollisionRisk(distance)) {\n        std::cout << \"WARNING: Pedestrian detected at crosswalk, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts the speed limit threshold based on weather conditions (clear, rainy, snowy).",
      "input": "Weather: Rainy, Vehicle speed: 60 km/h, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nenum Weather { CLEAR, RAINY, SNOWY }; // Weather conditions\n\nWeather currentWeather = RAINY;\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 60.0f; // Vehicle speed in km/h\n}\n\nbool isSpeedLimitExceeded(Weather weather, float distance, float speed) {\n    const float NORMAL_SPEED_LIMIT = 80.0f;\n    const float RAINY_SPEED_LIMIT = 60.0f;\n    const float SNOWY_SPEED_LIMIT = 50.0f;\n    if (weather == RAINY) {\n        return speed > RAINY_SPEED_LIMIT && distance < 12.0f;\n    } else if (weather == SNOWY) {\n        return speed > SNOWY_SPEED_LIMIT && distance < 8.0f;\n    } else {\n        return speed > NORMAL_SPEED_LIMIT && distance < 15.0f;\n    }\n}\n\nint main() {\n    float distance = getRadarDistance();\n    float speed = getVehicleSpeed();\n    if (isSpeedLimitExceeded(currentWeather, distance, speed)) {\n        std::cout << \"WARNING: Speed limit exceeded for current weather conditions!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects tailgating (following too closely) and triggers a warning.",
      "input": "Lead vehicle speed: 100 km/h, Following vehicle speed: 95 km/h, Radar distance: 4 meters.",
      "output": "#include <iostream>\n\nfloat getLeadVehicleSpeed() {\n    return 100.0f; // Lead vehicle speed in km/h\n}\n\nfloat getFollowingVehicleSpeed() {\n    return 95.0f; // Following vehicle speed in km/h\n}\n\nfloat getRadarDistance() {\n    return 4.0f; // Radar distance in meters\n}\n\nbool isTailgating(float leadSpeed, float followSpeed, float distance) {\n    const float MIN_DISTANCE = 5.0f;\n    return (followSpeed > leadSpeed) && (distance < MIN_DISTANCE);\n}\n\nint main() {\n    float leadSpeed = getLeadVehicleSpeed();\n    float followSpeed = getFollowingVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isTailgating(leadSpeed, followSpeed, distance)) {\n        std::cout << \"WARNING: Tailgating detected, increase following distance!\" << std::endl;\n    } else {\n        std::cout << \"Safe driving distance maintained.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects autonomous vehicles in the vicinity and adjusts collision warnings accordingly.",
      "input": "Lead vehicle type: Autonomous, Radar distance: 6 meters, Vehicle speed: 50 km/h.",
      "output": "#include <iostream>\n\nenum VehicleType { HUMAN_CONTROLLED, AUTONOMOUS }; // Vehicle types\n\nVehicleType leadVehicle = AUTONOMOUS;\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 50.0f; // Vehicle speed in km/h\n}\n\nbool isAutonomousVehicle(VehicleType vehicleType) {\n    return vehicleType == AUTONOMOUS;\n}\n\nint main() {\n    float distance = getRadarDistance();\n    if (isAutonomousVehicle(leadVehicle) && distance < 8.0f) {\n        std::cout << \"WARNING: Autonomous vehicle detected, adjust driving speed!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that adjusts collision warning when navigating a sharp curve at high speeds.",
      "input": "Vehicle speed: 120 km/h, Curve ahead: True, Radar distance: 10 meters.",
      "output": "#include <iostream>\n\nbool isCurveAhead() {\n    return true; // Simulate curve ahead condition\n}\n\nfloat getRadarDistance() {\n    return 10.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 120.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool curveAhead, float speed, float distance) {\n    const float HIGH_SPEED_THRESHOLD = 100.0f;\n    const float CURVE_THRESHOLD = 6.0f;\n    if (curveAhead && speed > HIGH_SPEED_THRESHOLD) {\n        return distance < CURVE_THRESHOLD;\n    } else {\n        return distance < 12.0f;\n    }\n}\n\nint main() {\n    bool curveAhead = isCurveAhead();\n    float speed = getVehicleSpeed();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(curveAhead, speed, distance)) {\n        std::cout << \"WARNING: Collision risk in high-speed curve!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that detects potential lane departures and adjusts collision warnings based on vehicle position.",
      "input": "Lane departure detected: True, Vehicle speed: 90 km/h, Radar distance: 15 meters.",
      "output": "#include <iostream>\n\nbool isLaneDepartureDetected() {\n    return true; // Simulate lane departure detection\n}\n\nfloat getRadarDistance() {\n    return 15.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 90.0f; // Vehicle speed in km/h\n}\n\nbool isCollisionRisk(bool laneDeparture, float distance) {\n    const float LANE_DEPARTURE_THRESHOLD = 10.0f;\n    return laneDeparture && distance < LANE_DEPARTURE_THRESHOLD;\n}\n\nint main() {\n    bool laneDeparture = isLaneDepartureDetected();\n    float distance = getRadarDistance();\n    if (isCollisionRisk(laneDeparture, distance)) {\n        std::cout << \"WARNING: Lane departure detected, collision risk!\" << std::endl;\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    },
    {
      "instruction": "Write a MISRA C++ 2023-compliant FCW system that triggers automatic emergency braking when a collision risk is detected.",
      "input": "Collision risk: True, Vehicle speed: 70 km/h, Radar distance: 6 meters.",
      "output": "#include <iostream>\n\nbool isCollisionRisk() {\n    return true; // Simulate collision risk detection\n}\n\nfloat getRadarDistance() {\n    return 6.0f; // Radar distance in meters\n}\n\nfloat getVehicleSpeed() {\n    return 70.0f; // Vehicle speed in km/h\n}\n\nvoid triggerEmergencyBraking() {\n    std::cout << \"WARNING: Collision risk detected, emergency braking triggered!\" << std::endl;\n}\n\nint main() {\n    if (isCollisionRisk()) {\n        triggerEmergencyBraking();\n    } else {\n        std::cout << \"Safe to continue driving.\" << std::endl;\n    }\n    return 0;\n}"
    }
  ]